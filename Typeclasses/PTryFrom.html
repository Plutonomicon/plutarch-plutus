<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PTryFrom</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">{-# LANGUAGE FlexibleInstances #-}
module Plutarch.Docs.PTryFrom (recoverListFromPData, theField, untrustedRecord, recoverListPartially, recoverAB) where 
import Plutarch.Prelude
import GHC.Generics (Generic)
</code></pre>
</p>
</details>
<h1 id="ptryfrom"><a class="header" href="#ptryfrom"><code>PTryFrom</code></a></h1>
<pre><code class="language-hs">class PTryFrom (a :: PType) (b :: PType) where
  type PTryFromExcess a b :: PType
  ptryFrom :: forall s r. Term s a -&gt; ((Term s b, Reduce (PTryFromExcess a b s)) -&gt; Term s r) -&gt; Term s r
</code></pre>
<p><code>PTryFrom</code> is a typeclass to prove equality between a type that in some way can't be trusted about its representation and another type that we want the untrusted type to be represented as.
<code>PTryFrom</code> proves the structure of the untrusted type and recovers it as the trusted, type which hence also carries more information.</p>
<p>A good example is getting a <code>PData</code> from a redeemer and wanting to prove that it is of a certain kind, e.g. a <code>PAsData (PBuiltinList (PAsData PInteger))</code>. We could do this with:</p>
<pre><code class="language-haskell">recoverListFromPData :: forall (s :: S). Term s PData -&gt; Term s (PAsData (PBuiltinList (PAsData PInteger)))
recoverListFromPData = unTermCont . fmap fst . tcont . ptryFrom @(PAsData (PBuiltinList (PAsData PInteger)))
</code></pre>
<blockquote>
<p>Note: You can find a specialized version of <code>ptryFrom</code> in <code>Plutarch.Extra</code> that is the same as <code>ptryFrom @PData @(PAsData a)</code></p>
</blockquote>
<h2 id="implementing-ptryfrom"><a class="header" href="#implementing-ptryfrom">Implementing <code>PTryFrom</code></a></h2>
<p>Implementing <code>PTryFrom</code> for your type should be easy as soon as you have a datatype deriving its Plutarch data representation
via <code>PlutusTypeData</code> as <code>PTryFrom</code> also has a generic <code>default</code> implementation.</p>
<pre><code class="language-haskell">-- your datatype
data PAB (s :: S)
  = PA (Term s (PDataRecord '["_0" ':= PInteger, "_1" ':= PByteString]))
  | PB (Term s (PDataRecord '["_0" ':= PBuiltinList (PAsData PInteger), "_1" ':= PByteString]))
  deriving stock (Generic)
  deriving anyclass (PlutusType, PIsData)

-- getting the generic `Data` representation for your type
instance DerivePlutusType PAB where type DPTStrat _ = PlutusTypeData
-- getting a generic `PTryFrom` instance that recovers your type 
-- from an opaque `PData`
instance PTryFrom PData (PAsData PAB)

-- a valid AB
sampleAB :: Term s (PAsData PAB)
sampleAB = pdata $ pcon $ PA (pdcons @"_0" # pdata (pconstant 4) #$ pdcons # pdata (pconstant "foo") # pdnil)

-- we forget the structure of our `sampleAB`
sampleABdata :: Term s PData
sampleABdata = pforgetData sampleAB

-- recovers an `AB` from an opaque `PData`
recoverAB :: Term s (PAsData PAB)
recoverAB = unTermCont $ fst &lt;$&gt; tcont (ptryFrom sampleABdata)

</code></pre>
<blockquote>
<p>Note: There are other valid implementations for recovering your datatype from <code>PData</code>, in some cases you might,
for example, want to include additional checks, think making sure that some <code>PNatural</code> is indeed positive.
In this case you will have to hand-roll the implementation of <code>PTryFrom</code>. For some examples, see <code>plutarch-test</code>'s
<code>PTryFromSpec.hs</code></p>
</blockquote>
<h2 id="laws"><a class="header" href="#laws">Laws</a></h2>
<ul>
<li>the operation <code>ptryFrom</code> mustn't change the representation of the underlying data</li>
<li>the operation <code>ptryFrom</code> must always prove the integrity of the whole target type
<ul>
<li>example:
<code>ptryFrom @PData @(PAsData (PBuiltinList PData))</code> ssucceeds iff the underlying representation is a <code>BuiltinList</code> containing any <code>PData</code></li>
</ul>
</li>
<li>all conversions are fallible, this happens if the representation doesn't match the expected type.</li>
<li>the operation <code>ptryFrom @a @b</code> proves equality between the less expressive <code>PType</code> <code>a</code> and the more expressive <code>PType</code> <code>b</code>, hence the first
element of the resulting Tuple must always be wrapped in <code>PAsData</code> if the origin type was <code>PData</code> (see law 1)</li>
<li>the result type <code>b</code> must always be safer than the origin type <code>a</code>, i.e. it must carry more information</li>
</ul>
<blockquote>
<p>Note: doing this in a manner that doesn't error would be really costly and hence we only offer a version that fails with <code>perror</code>.</p>
</blockquote>
<h2 id="ptryfromexcess"><a class="header" href="#ptryfromexcess"><code>PTryFromExcess</code></a></h2>
<p>An important note is, that <code>PTryFrom</code> carries a type <code>PTryFromExcess</code> which safes data that arose as "excess" during the act of verifying. For
<code>PData (PAsData PSomething)</code> instances this most times
carries a <code>PSomething</code>, i.e. the type that has been proven equality for but without <code>PAsData</code> wrapper. In cases where this type is not useful,
the excess type is just an empty <code>HRec</code>.</p>
<p>In case of the recovered type being a record or anything that contains a record, the excess type is more interesting:
It contains an <code>HRec</code>, that has all the fields that have been recoverd and all <em>their</em> excess stored. If you recover a <code>PAsData (PDataRecord xs)</code> from <code>PData</code>, there is another field under the accessor <code>"unwrapped"</code> that contains the unwrapped record, which representation wise is just a <code>PBuiltinList PData</code>, of course.</p>
<p>Generally, when recovering a <code>PDataRecord</code>, the procedure is as follows</p>
<pre><code class="language-haskell">untrustedRecord :: Term s PData
untrustedRecord =
  let r :: Term s (PAsData (PDataRecord '["_0" ':= (PDataRecord '["_1" ':= PInteger])]))
      r = pdata $ pdcons # (pdata $ pdcons # pdata (pconstant 42) # pdnil) # pdnil
   in pforgetData r

-- obviously, `untrustedRecord` would be what we get from our untrusted party

theField :: Term s PInteger
theField = unTermCont $ do
  (_, exc) &lt;- tcont (ptryFrom @(PAsData (PDataRecord '["_0" ':= (PDataRecord '["_1" ':= PInteger])])) untrustedRecord)
  pure $ snd (snd $ snd (snd exc)._0)._1
</code></pre>
<p>Because the record excess stores the field already in its unwrapped form, you don't have to <code>pfromData</code> it again.</p>
<p>If you don't use <code>OverloadedRecordDot</code>, there is an equivalent function <code>getField</code> (from <code>GHC.Records</code>) that does the same and works with type applications.</p>
<h2 id="recovering-only-partially"><a class="header" href="#recovering-only-partially">Recovering only partially</a></h2>
<p>In case we don't want to verify the whole structure but rather part of it (this can be a reasonable decision to lower the fees), we can just leave the part
of the data that is not to be verified a <code>PData</code> which serves as the base case:</p>
<pre><code class="language-haskell">recoverListPartially :: forall r s. Term s PData  -&gt; ((Term s (PAsData (PBuiltinList PData)), Term s (PBuiltinList PData)) -&gt; Term s r) -&gt; Term s r
recoverListPartially = ptryFrom @(PAsData (PBuiltinList PData)) @PData
</code></pre>
<p>This is especially important with something like <code>PDataSum</code> which simply cannot store the excess types over the barrier of <code>pmatch</code> because obviously,
you don't know the type of the excess before actually matching on it. The solution would be to recover an equivalent <code>PDataSum</code> whose constructors
contain <code>PData</code> and after having matched on those, recover the underlying record or whatever field you're interested in. If you're not interested
in the excess, you could of course also just recover the whole Sum without issue, in this case it won't be more expensive.</p>
<p>Please be aware, that nuances can already make a performance difference, e.g.</p>
<ul>
<li>recovering <code>ptryFromData @(PAsData (PBuiltinList PData))</code> is cheaper than <code>ptryFromData @(PAsData (PBuiltinList (PAsData PDAta)))</code> because the latter
maps over no-ops, whereas the former just asserts that the <code>PData</code> indeed contains a <code>PBuiltinList</code>.</li>
<li>If you only, say, need the head of a list, first recovering a <code>PAsData (PBuiltinList PData)</code> (don't forget to use the excess instead of using
<code>pfromData</code>), <em>then</em> using head and after that recovering the field in there will be cheaper than recovering the whole list with the target type and
using head on that.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Typeclasses/PlutusType,PCon,PMatch.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../Usage.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Typeclasses/PlutusType,PCon,PMatch.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../Usage.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
