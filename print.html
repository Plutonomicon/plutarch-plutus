<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>The Plutarch guide is your one-stop shop for getting up to speed on Plutarch!</p>
<blockquote>
<p>Note: If you spot any mistakes/have any related questions that this guide lacks the answer to, please don't hesitate to raise an issue. The goal is to have high quality documentation for Plutarch users!</p>
</blockquote>
<blockquote>
<p>Aside: Not interested in the details? Skip straight to <a href="Overview.html#examples">examples</a>!</p>
</blockquote>
<h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<h2 id="haddock"><a class="header" href="#haddock">Haddock</a></h2>
<p>Haddock documentation of <code>plutus-core</code>, <code>plutus-ledger-api</code>, <code>plutus-tx</code>, and few other upstream library with correctly matched version to latest Plutarch is available:</p>
<p><a href="https://plutonomicon.github.io/plutarch-plutus/haddock/">Go to Haddock</a></p>
<h2 id="compiling-and-running"><a class="header" href="#compiling-and-running">Compiling and Running</a></h2>
<ul>
<li><a href="./Run.html#common-extensions-and-ghc-options">Common Extensions and GHC options</a></li>
<li><a href="./Run.html#evaluation">Evaluation</a></li>
<li>Nix binary cache is recommended. Otherwise nix will build from GHC itself.</li>
</ul>
<p>Use Plutonomicon binary cache via cachix: https://plutonomicon.cachix.org</p>
<p>DO NOT add your user to <code>trusted-users</code> as <code>cachix use</code> suggests because this is
<a href="https://nixos.org/manual/nix/stable/command-ref/conf-file.html#conf-trusted-users">insecure</a>.</p>
<h2 id="introduction-and-basic-syntax"><a class="header" href="#introduction-and-basic-syntax">Introduction and Basic Syntax</a></h2>
<p>The <a href="./Introduction.html">Introduction section</a> serves as a introduction to Plutarch's basic concepts and core syntactic constructs. It will help build a mental model of Plutarch, but is insufficient to write production-ready code.</p>
<ul>
<li><a href="./Introduction.html#overview">Overview</a></li>
<li><a href="./Introduction/UntypedPlutusCore.html">Untyped Plutus Core (UPLC)</a></li>
<li><a href="./Introduction/PlutarchTypes.html">Plutarch Types</a></li>
<li><a href="./Introduction/PlutarchTerms.html">Plutarch <code>Term</code>s</a>
<ul>
<li><a href="./Introduction/PlutarchTerms/PlutarchConstants.html">Plutarch Constant <code>Term</code>s</a>
<ul>
<li><a href="./Introduction/PlutarchTerms/PlutarchConstants.html#static-building-of-constant-terms-with-pconstant">Static building of constant <code>Term</code>s with <code>pconstant</code></a></li>
<li><a href="./Introduction/PlutarchTerms/PlutarchConstants.html#dynamic-building-of-constant-terms-with-pcon">Dynamic building of constant <code>Term</code>s with <code>pcon</code></a></li>
<li><a href="./Introduction/PlutarchTerms/PlutarchConstants.html#overloaded-literals">Overloaded literals</a></li>
<li><a href="./Introduction/PlutarchTerms/PlutarchConstants.html#helper-functions">Helper functions</a></li>
</ul>
</li>
<li><a href="./Introduction/PlutarchTerms/PlutarchLambdas.html#lambdas-plutarch-level-function-terms">Lambdas; Plutarch-level Function <code>Term</code>s.</a>
<ul>
<li><a href="./Introduction/PlutarchTerms/PlutarchLambdas.html#function-application">Function Application</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="./Introduction/Patternmatching.html">Pattern matching constant <code>Term</code>s with <code>pmatch</code>.</a></li>
<li><a href="./Introduction/DelayAndForce.html">Strictness and Laziness; Delayed Terms and Forcing</a></li>
<li><a href="./Introduction.html#references">References</a></li>
</ul>
<h2 id="practical-usage"><a class="header" href="#practical-usage">Practical Usage</a></h2>
<p>The <a href="./Usage.html">Usage section</a> fills in the gaps left by the previous. It illustrates techniques that make Plutarch easier to work with.</p>
<ul>
<li><a href="./Usage/Conditionals.html">Conditionals</a></li>
<li><a href="./Usage/Recursion.html">Recursion</a></li>
<li><a href="./Usage/PreludeMixin.html">Using the Plutarch Prelude</a></li>
<li><a href="./Usage/DoSyntaxWithTermCont.html">Do syntax with <code>TermCont</code></a></li>
<li><a href="./Usage/DoSyntaxWithQualifiedDo.html">Do syntax with <code>QualifiedDo</code> and <code>Plutarch.Monadic</code></a></li>
<li><a href="./Usage/DerivingForNewtypes.html">Deriving typeclasses for <code>newtype</code>s</a></li>
<li><a href="./Usage/DerivingWithGenerics.html">Deriving typeclasses with generics</a></li>
<li><a href="./Usage/AvoidWorkDuplicationUsingPlet.html"><code>plet</code> to avoid work duplication</a></li>
<li><a href="./Usage/Tracing.html">Tracing</a></li>
<li><a href="./Usage/RaisingErrors.html">Raising errors</a></li>
<li><a href="./Usage/UnsafeFunctions.html">Unsafe functions</a></li>
</ul>
<h2 id="concepts"><a class="header" href="#concepts">Concepts</a></h2>
<p>The <a href="./Concepts.html">Concepts section</a> details additional concepts.</p>
<ul>
<li><a href="./Concepts/Hoisting.html">Hoisting, metaprogramming, and fundamentals</a>
<ul>
<li><a href="./Concepts/Hoisting.html#hoisting-operators">Hoisting Operators</a></li>
</ul>
</li>
<li><a href="./Concepts/WhatIsTheS.html#what-is-the-s">What is the <code>s</code>?</a></li>
<li><a href="./Concepts/DataAndScottEncoding.html">Data encoding and Scott encoding</a>
<ul>
<li><a href="./Concepts/DataAndScottEncoding.html#data-encoding">Data encoding</a></li>
<li><a href="./Concepts/DataAndScottEncoding.html#scott-encoding">Scott encoding</a></li>
</ul>
</li>
<li><a href="./Concepts/HaskellSynonym.html">Haskell synonym of Plutarch types</a></li>
</ul>
<h2 id="typeclasses"><a class="header" href="#typeclasses">Typeclasses</a></h2>
<p>The <a href="./Typeclasses.html">Typeclasses section</a> discusses the primary typeclasses related to Plutarch.</p>
<ul>
<li><a href="./Typeclasses/PEqAndPOrd.html"><code>PEq</code> &amp; <code>POrd</code></a></li>
<li><a href="./Typeclasses/PIntegral.html"><code>PIntegral</code></a></li>
<li><a href="./Typeclasses/PIsData.html"><code>PIsData</code></a></li>
<li><a href="./Typeclasses/PlutusType,PCon,PMatch.html"><code>PlutusType</code>, <code>PCon</code>, and <code>PMatch</code></a>
<ul>
<li><a href="./Typeclasses/PlutusType,PCon,PMatch.html#implementing-plutustype-for-your-own-types-scott-encoding">Implementing <code>PlutusType</code> for your own types (Scott Encoding)</a></li>
<li><a href="./Typeclasses/PlutusType,PCon,PMatch.html#implementing-plutustype-for-your-own-types-data-encoding">Implementing <code>PlutusType</code> for your own types (<code>Data</code> Encoding)</a></li>
<li><a href="./Typeclasses/PlutusType,PCon,PMatch.html#implementing-plutustype-for-your-own-types-newtype">Implementing <code>PlutusType</code> for your own types (<code>newtype</code>)</a></li>
</ul>
</li>
<li><a href="./Typeclasses/PListLike.html"><code>PListLike</code></a></li>
<li><a href="./Typeclasses/PIsDataReprAndPDataFields.html"><code>PIsDataRepr</code> &amp; <code>PDataFields</code></a>
<ul>
<li><a href="./Typeclasses/PIsDataReprAndPDataFields.html#all-about-extracting-fields">All about extracting fields</a>
<ul>
<li><a href="./Typeclasses/PIsDataReprAndPDataFields.html#alternatives-to-overloadedrecorddot">Alternatives to <code>OverloadedRecordDot</code></a></li>
</ul>
</li>
<li><a href="./Typeclasses/PIsDataReprAndPDataFields.html#all-about-constructing-data-values">All about constructing data values</a></li>
</ul>
</li>
<li><a href="./Typeclasses/PTryFrom.html"><code>PTryFrom</code></a>
<ul>
<li><a href="./Typeclasses/PTryFrom.html#laws">Laws</a></li>
<li><a href="./Typeclasses/PTryFrom.html#implementing-ptryfrom">Implementing <code>PTryFrom</code></a></li>
<li><a href="./Typeclasses/PTryFrom.html#ptryfromexcess"><code>PTryFromExcess</code></a></li>
<li><a href="./Typeclasses/PTryFrom.html#recovering-only-partially">Recovering only partially</a></li>
</ul>
</li>
</ul>
<h2 id="working-with-types"><a class="header" href="#working-with-types">Working with Types</a></h2>
<p>The <a href="./Types.html">Types section</a> discusses the core types of Plutarch.</p>
<ul>
<li><a href="./Types/PInteger.html"><code>PInteger</code></a></li>
<li><a href="./Types/PBool.html"><code>PBool</code></a></li>
<li><a href="./Types/PString.html"><code>PString</code></a></li>
<li><a href="./Types/PByteString.html"><code>PByteString</code></a></li>
<li><a href="./Types/PUnit.html"><code>PUnit</code></a></li>
<li><a href="./Types/PBuiltinList.html"><code>PBuiltinList</code></a></li>
<li><a href="./Types/PList.html"><code>PList</code></a></li>
<li><a href="./Types/PBuiltinPair.html"><code>PBuiltinPair</code></a></li>
<li><a href="./Types/PAsData.html"><code>PAsData</code></a></li>
<li><a href="./Types/PDataSumAndPDataRecord.html"><code>PDataSum</code> &amp; <code>PDataRecord</code></a></li>
<li><a href="./Types/PData.html"><code>PData</code></a></li>
</ul>
<h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<ul>
<li><a href="./examples/BASIC.html">Basic examples</a></li>
<li><a href="./examples/VALIDATOR.html">Validator &amp; Minting policies</a></li>
</ul>
<h1 id="rules-of-thumb-tips-and-tricks"><a class="header" href="#rules-of-thumb-tips-and-tricks">Rules of thumb, Tips, and Tricks</a></h1>
<p>Outside of the fundamental user guide, there are rules of thumb and general guidelines you can follow to improve your Plutarch experience. The <a href="./Tricks.html">Tricks section</a> discusses ways of writing efficient and high quality Plutarch code, as well as rules that can help auditing Plutarch easier.</p>
<ul>
<li><a href="./Tricks/PlutarchFunctionsStrict.html">Plutarch functions are strict</a></li>
<li><a href="./Tricks/DontDuplicateWork.html">Don't duplicate work</a>
<ul>
<li><a href="./Tricks/DontDuplicateWork.html#where-should-arguments-be-pleted">Where should arguments be <code>plet</code>ed?</a></li>
</ul>
</li>
<li><a href="./Tricks/PreferPlutarchfunctions.html">Prefer Plutarch level functions</a></li>
<li><a href="./Tricks/UsingHaskellLevelfunctions.html">When to use Haskell level functions?</a></li>
<li><a href="./Tricks/DifferenceBetweenPconAndPconstant.html">The difference between <code>PlutusType</code>/<code>PCon</code> and <code>PLift</code>'s <code>pconstant</code></a></li>
<li><a href="./Tricks/ResponsibilityOfEvaluationInHaskellFunctions.html">Let Haskell level functions take responsibility of evaluation</a></li>
<li><a href="./Tricks/makeIsDataIndexed,HaskellADTs,PIsDataRepr.html">The isomorphism between <code>makeIsDataIndexed</code>, Haskell ADTs, and <code>PIsDataRepr</code></a></li>
<li><a href="./Tricks/PreferStaticallyBuildingConstants.html">Prefer statically building constants whenever possible</a></li>
<li><a href="./Tricks/RepresentationOfPlutarchType.html">Figuring out the representation of a Plutarch type</a></li>
<li><a href="./Tricks/PreferMatchingOnPmatchResultImmediately.html">Prefer pattern matching on the result of <code>pmatch</code> immediately</a></li>
<li><a href="./Tricks/WorkingWithBoundFields.html">Working with bound fields yielded by <code>pletFields</code></a></li>
</ul>
<h1 id="common-issues-and-troubleshooting"><a class="header" href="#common-issues-and-troubleshooting">Common Issues and Troubleshooting</a></h1>
<p>Due to the highly abstracted nature of Plutarch and its utilization of advanced type level concepts, you might face unfamiliar errors. Don't worry, the guide is here to help!</p>
<ul>
<li><a href="./Troubleshooting.html#no-instance-for-punsafeliftdecl-a">No instance for <code>PUnsafeLiftDecl a</code></a></li>
<li><a href="./Troubleshooting.html#couldnt-match-representation-of-type--arising-from-the-deriving-clause">Couldn't match representation of type: ... arising from the 'deriving' clause</a></li>
<li><a href="./Troubleshooting.html#infinite-loop--infinite-ast">Infinite loop / Infinite AST</a></li>
<li><a href="./Troubleshooting.html#couldnt-match-type-plutarchdatareprinternalpunlabel--arising-from-a-use-of-pfield-or-getField-or-pletfields">Couldn't match type <code>Plutarch.DataRepr.Internal.PUnLabel ...</code> arising from a use of <code>pfield</code> (or <code>getField</code>, or <code>pletFields</code>)</a></li>
<li><a href="./Troubleshooting.html#expected-a-type-but-fieldname-has-kind-ghctypessymbol">Expected a type, but "fieldName" has kind <code>GHC.Types.Symbol</code></a></li>
<li><a href="./Troubleshooting.html#lifting-pasdata">Lifting <code>PAsData</code></a></li>
<li><a href="./Troubleshooting.html#type-match-errors-when-using-pfieldgetField-or-overloadedrecorddot-to-access-field">Type match errors when using <code>pfield</code>/<code>getField</code> (or <code>OverloadedRecordDot</code> to access field)</a></li>
</ul>
<h1 id="useful-links"><a class="header" href="#useful-links">Useful Links</a></h1>
<ul>
<li><a href="https://github.com/Plutonomicon/plutonomicon">Plutonomicon</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.Introduction (hf) where
import Plutarch.Prelude
</code></pre>
</p>
</details>
> Note: If you spot any mistakes/have any related questions that this guide lacks the answer to, please don't hesitate to raise an issue. The goal is to have high-quality documentation for Plutarch users!
<h1 id="overview-1"><a class="header" href="#overview-1">Overview</a></h1>
<p>Plutarch is an eDSL in Haskell for writing on-chain scripts for Cardano. With some caveats, Plutarch is a <a href="https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus">simply-typed lambda calculus</a> (or STLC). Writing a script in Plutarch allows us to leverage the language features provided by Haskell while retaining the ability to compile to compact Untyped Plutus Core (or UPLC, which is an untyped lambda calculus).</p>
<p>When we talk about "Plutarch scripts," we are referring to values of type <code>Term (s :: S) (a :: PType)</code>. <code>Term</code> is a <code>newtype</code> wrapper around a more complex type, the details of which Plutarch end-users can ignore. A <code>Term</code> is a typed lambda term; it can be thought of as representing a computation that, if successfully evaluated, will return a value of type <code>a</code>.</p>
<p>The two type variables of the <code>Term s a</code> declaration have particular kinds:</p>
<ul>
<li><code>s :: S</code> is like the <code>s</code> of <code>ST s a</code>. It represents the computation context in a manner that mimics mutable state while providing a familiar functional interface. Sections 1 through 4 of [<a href="Introduction.html#references">1</a>] give an accessible introduction to how this works. <code>s</code> is never instantiated with a concrete value; it is merely a type-level way to ensure that computational contexts remain properly encapsulated (i.e., different state threads don't interact). For more in-depth coverage of this and other eDSL design principles used in Plutarch, see [<a href="Introduction.html#references">2</a>].</li>
<li><code>a :: PType</code> is short-hand for "Plutarch Type". We prefix these types with a capital <code>P</code>, such as <code>PInteger</code>, <code>PBool</code>, and so forth. <em>Tagging</em> a <code>Term</code> with a <code>PType</code> indicates the type of the <code>Term</code>'s return value. Doing this allows us to bridge between the simple type system of Plutarch and the untyped UPLC.</li>
</ul>
<p>Note that we <em>should not</em> think of a type of kind <code>PType</code> as carrying a value; it is a tag for a computation that may produce a value. For instance, the definition of <code>PInteger</code> is simply</p>
<pre><code class="language-hs">data PInteger s
</code></pre>
<p>That is, there are no data constructors. <em>If</em> a value of type <code>Term s PInteger</code> successfully executes the computation within context <code>s</code>, the value <em>computed</em> will be an integer. We will never encounter values such as <code>y :: PInteger; y = 3</code>; they simply do not exist. While readers new to Plutarch may need some time to fit this into their mental model, it is a crucial distinction to keep in mind.</p>
<blockquote>
<p>For brevity, we will say a "value of type <code>Term s a</code> will evaluate to (...)". This phrase will carry two implicit notions: one, that <code>Term s a</code> represents a computation executed in the context <code>s</code>; two, evaluating <code>Term s a</code> is not guaranteed to succeed.</p>
</blockquote>
<p>In brief, when writing Plutarch scripts, we have a few tasks:</p>
<ul>
<li>A.) Defining <em>Plutarch Types</em> (or <em><code>PType</code>s</em>). We prefix these types with a capital <code>P</code>, such as <code>PInteger</code>, <code>PMaybe a</code>, <code>PBool</code>, and so forth. As previously mentioned, these form the "tags" for Plutarch <code>Term</code>'s, representing the type of the result of compiling and evaluating a Plutarch Script.</li>
<li>B.) Working with <em>Plutarch <code>Terms</code></em>, which are values of the type <code>Term (s :: S) (a :: PType)</code>. These are the Plutarch scripts themselves, from which we build up more complex scripts before compiling and executing them on-chain.</li>
<li>C.) Writing Haskell-level functions <em>between Plutarch Terms</em> (i.e., with types like <code>Term s a -&gt; Term s b</code>). Doing so allows us to leverage Haskell's language features and ecosystem.</li>
<li>D.) Efficiently Converting the functions from <em>(C.)</em> to <em>Plutarch-level functions</em>, which are of the type <code>Term s (a :--&gt; b)</code>. We can <em>directly</em> convert the functions from (C.) to Plutarch-level functions at the most naive level using <code>plam</code>. Additional Plutarch utilities provide for optimization opportunities.</li>
<li>E.) Compiling and executing the functions from <em>(D.)</em>, targeting UPLC for on-chain usage.</li>
</ul>
<p>As a preview, the bridge Plutarch provides between Haskell and UPLC looks something like this:</p>
<pre><code>------------------------------------------------------
|                  *Haskell World*                   |
------------------------------------------------------
| Values with types like `Bool`, `Integer`, `Maybe a`|
| and regular Haskell functions like a -&gt; b          |
------------------------------------------------------
                           ^                     |
 (functions like `plift`)--|                     |--(functions like `pconstant` or `plam`)
                           |                     |
                           |                     v         (`pcon`)
-------------------------------------------------------    |                     -------------------------------------------------------
|                  *Plutarch Term World*              | &lt;----------------------- |                  *Plutarch Type World*              |
-------------------------------------------------------                          -------------------------------------------------------
| STLC terms; constants like `Term s PInteger` and    | -----------------------&gt; | Types like `PInteger`, `PMaybe a`                   |
| lambdas like `Term s (PInteger :--&gt; PBool)`         |        |                 |                                                     |
-------------------------------------------------------        (`pmatch`)        -------------------------------------------------------
                              |
                              |
                              |--(`compile`)
                              |
                              |
                              v
-------------------------------------------------------
|                    *UPLC World*                     |
-------------------------------------------------------
| Untyped lambda calculus terms. Values of type `Data`|
|                                                     |
-------------------------------------------------------
</code></pre>
<p>Further, you may notice two general categories of functions in Plutarch: "Haskell-level" functions between terms, and "Plutarch-level"
functions <em>as</em> lambda terms. By convention, we will prefix the Haskell-level functions with <code>h</code> and the Plutarch-level lambdas
with <code>p</code>, for example</p>
<pre><code class="language-haskell">-- This example is listed here as a preview; the unfamiliar parts will
-- be detailed below.

-- A Plutarch-level lambda term
pf :: Term s (a :--&gt; b :--&gt; c)
pf = undefined

-- Recovering a Haskell level function from a Plutarch level function
hf :: Term s a -&gt; Term s b -&gt; Term s c
hf x y = pf # x # y
</code></pre>
<p>Note that <code>pf</code> is truly just a Plutarch <code>Term</code> and should not be treated specially.</p>
<p>The remainder of this document cover the bridge between Haskell and Plutarch at a high level. It will <em>not</em> cover all techniques necessary to write production-ready scripts. Nor will it cover the bridge between Plutarch and UPLC beyond the minimum. Nonetheless, it should provide sufficient background to prepare the reader for further study.</p>
<p>Sections:-</p>
<ul>
<li><a href="./Introduction/UntypedPlutusCore.html">Untyped Plutus Core (UPLC)</a></li>
<li><a href="./Introduction/PlutarchTypes.html">Plutarch Types</a></li>
<li><a href="./Introduction/PlutarchTerms.html">Plutarch <code>Term</code>s</a>
<ul>
<li><a href="./Introduction/PlutarchTerms/PlutarchConstants.html">Plutarch Constant <code>Term</code>s</a>
<ul>
<li><a href="./Introduction/PlutarchTerms/PlutarchConstants.html#static-building-of-constant-terms-with-pconstant">Static building of constant <code>Term</code>s with <code>pconstant</code></a></li>
<li><a href="./Introduction/PlutarchTerms/PlutarchConstants.html#dynamic-building-of-constant-terms-with-pcon">Dynamic building of constant <code>Term</code>s with <code>pcon</code></a></li>
<li><a href="./Introduction/PlutarchTerms/PlutarchConstants.html#overloaded-literals">Overloaded literals</a></li>
<li><a href="./Introduction/PlutarchTerms/PlutarchConstants.html#helper-functions">Helper functions</a></li>
</ul>
</li>
<li><a href="./Introduction/PlutarchTerms/PlutarchLambdas.html#lambdas-plutarch-level-function-terms">Lambdas; Plutarch-level Function <code>Term</code>s.</a>
<ul>
<li><a href="./Introduction/PlutarchTerms/PlutarchLambdas.html#function-application">Function Application</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="./Introduction/Patternmatching.html">Pattern matching constant <code>Term</code>s with <code>pmatch</code>.</a></li>
<li><a href="./Introduction/DelayandForce.html">Strictness and Laziness; Delayed Terms and Forcing</a></li>
</ul>
<h1 id="references"><a class="header" href="#references">References</a></h1>
<ul>
<li>[1]<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/1994/06/lazy-functional-state-threads.pdf">Lazy Functional State Threads, by John Launchbury and Simon L Peyton Jones</a></li>
<li>[2]<a href="https://bentnib.org/unembedding.pdf">Unembedding Domain-Specific Languages, by Robert Atkey, Sam Lindley, and Jeremy Yallop</a></li>
<li>[3]<a href="https://www.parsonsmatt.org/2017/04/26/basic_type_level_programming_in_haskell.html">Matt Parson: Basic Type Level Programming in Haskell</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.DelayAndForce (hif, pif') where 
import Plutarch.Prelude
</code></pre>
</p>
</details>
<h1 id="strictness-and-laziness-delayed-terms-and-forcing"><a class="header" href="#strictness-and-laziness-delayed-terms-and-forcing">Strictness and Laziness; Delayed Terms and Forcing</a></h1>
<p>Plutarch, like UPLC, is strict by default; this is in contrast to Haskell, which is non-strict by default (often called "lazy"). This means that evaluating a function application in Plutarch (<code>#</code>) always evaluates the argument before executing the function.</p>
<p>This behavior may be undesirable. For example, it is usually unwanted to evaluate both the <code>then</code> and <code>else</code> branches of an <code>if</code> function, for efficiency reasons.</p>
<p>The Plutarch level function <code>pif'</code> is naturally strict in its arguments, so it does exactly that. For the purpose of this chapter we take <code>pif'</code> as a given, and create the lazy version <code>pif</code> based on that.</p>
<blockquote>
<p>Note: The example below does not correspond to the actual implementations of <code>pif</code> or <code>pif'</code>. It is for pedagogic purposes only.</p>
</blockquote>
<pre><code class="language-hs">-- | Strict if-then-else.
pif' :: Term s (PBool :--&gt; a :--&gt; a :--&gt; a)
</code></pre>
<p>To prevent evaluation of a term when it gets used as an argument in a function application, we can use <code>pdelay</code> to mark the argument term as delayed. On the type-level, it wraps the <code>PType</code> tag of a <code>Term</code>, as can be seen in its type signature.</p>
<pre><code class="language-hs">pdelay :: Term s a -&gt; Term s (PDelayed a)
</code></pre>
<p>The <code>pforce</code> function is the inverse to that, it converts a delayed term such that it gets evaluated when used in a function application (<code>#</code>). Forcing a term strips the <code>PDelayed</code> wrapper on the type-level:</p>
<pre><code class="language-hs">pforce :: Term s (PDelayed a) -&gt; Term s a
</code></pre>
<p>We now have the tools needed to create the lazy <code>pif</code> based on <code>pif'</code>:</p>
<pre><code class="language-haskell">-- | Utilizing Haskell level functions with `pdelay` and `pforce` to have lazy wrapper around `pif`.
hif :: Term s PBool -&gt; Term s a -&gt; Term s a -&gt; Term s a
hif cond whenTrue whenFalse = pforce $ pif' # cond # pdelay whenTrue # pdelay whenFalse
</code></pre>
<p>A word of caution: Calling <code>pforce</code> on the same delayed term in multiple different places can lead to duplicate evaluation of the term. Users familiar with Haskell's handling of laziness -- where forcing a thunk twice never duplicates computation -- should note that UPLC behaves differently.</p>
<p>Note that <code>pdelay</code> is not the only way to get lazy behavior. Haskell-level <code>Term</code> arguments, the branches of <code>pmatch</code>, and continuation functions on the Plutarch level are all naturally lazy.</p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.PatternMatching (pisJust) where 
import Plutarch.Prelude
</code></pre>
</p>
</details>
# Pattern matching constant `Term`s with `pmatch`.
<p>We've shown how to construct <code>Term</code>s out of the data constructors of types with kind <code>PType</code> (i.e., <code>pcon . PJust</code>). Next, it is natural that we may want to pattern match on <code>Term</code> with a known <code>PType</code> tag (i.e., of a value with type <code>Term s (PMaybe a)</code>) to produce another <code>Term</code> (i.e., depending on whether the value matches <code>PJust _</code> or <code>Nothing</code>.)</p>
<p>The function that we need is a method of the <code>PMatch</code> typeclass. For the time being, we will ignore the details of implementation and only look at the type:</p>
<pre><code class="language-hs">pmatch :: 
  forall (a :: PType) (b :: PType) (s :: S).
  ( PlutusType a       -- `a` has to be a `PlutusType` instance. 
  ) =&gt; Term s a        -- Given a `Term` tagged with `a` and
  -&gt; (a s -&gt; Term s b) -- a continuation from `a s` to a Term s b`, 
  -&gt; Term s b          -- produce a `Term s b`.
</code></pre>
<p>The annotation of the second argument deserves some focus; the second argument has its type displayed as <code>(a s -&gt; Term s b)</code>. First, recall that <code>a</code> is declared to have kind <code>PType</code>, and <code>PType</code> is a kind synonym for <code>S -&gt; Type</code>. Thus, since <code>s</code> has kind <code>S</code>, we have that <code>a s</code> has the <em>kind</em> <code>Type</code>. That is, it is a regular Haskell type.</p>
<p>What this means, in practice, is that <code>pmatch</code> matches on the possible values of the <em>result</em> of evaluating a <code>Term s a</code> -- specifically, it matches on <em>values</em> of a <em>type</em> that has <em>kind <code>PType</code></em> -- and branches accordingly. The second argument to <code>pmatch</code> is a <em>continuation</em>; it determines how the program continues once <code>pmatch</code> has done its work.</p>
<p>We have already introduced a type with kind <code>PType</code> suitable for branching: <code>PMaybe</code>. Here is an example:</p>
<pre><code class="language-haskell">{- | This function takes in a Haskell-level `PMaybe s` value (specifically, _not_ a `Term`)
     and returns a `Term` depending on the Haskell-level pattern match on `PMaybe`s data
     constructors.
-}
continuation :: PMaybe a s -&gt; Term s PBool
continuation = \case
  PJust _ -&gt; pcon PTrue
  PNothing -&gt; pcon PFalse

{- | A Haskell-level `isJust` on Plutarch `Term`s. `pmatch` can match on
     the possibilities of `PJust _` or `PNothing` being the result of an evaluated
     `Term`.
-}
hisJust :: Term s (PMaybe a) -&gt; Term s PBool
hisJust x = pmatch x continuation

-- | A Plutarch-level `isJust`
pisJust :: Term s (PMaybe a :--&gt; PBool)
pisJust = plam hisJust
</code></pre>
<p>Readers should note that this is not the most ergonomic way to deal with pattern matching (Plutarch provides two versions of <code>do</code> syntax), but it <em>is</em> how the more ergonomic methods work under the hood.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plutarch-terms"><a class="header" href="#plutarch-terms">Plutarch <code>Term</code>s</a></h1>
<p>Plutarch <code>Term</code>s are terms in the sense of simply-typed lambda calculus terms. In a lambda calculus, we can construct terms as either "constants" or "lambdas," and terms can either be "open" (having free variables) or "closed" (having no free variables). We compose Plutarch <code>Term</code>s to build up increasingly complex computations. Once all free variables are eliminated from a <code>Term</code> (making it a <code>Closed Term</code>), we can compile it using the eponymous function from the <code>Plutarch</code> module:</p>
<pre><code class="language-hs">-- | Closed term is a type synonym
type ClosedTerm (a :: PType) = forall (s :: S). Term s a

-- | Compile operates on closed terms to produce usable UPLC scripts.
compile :: ClosedTerm a -&gt; Script
</code></pre>
<p><code>Term</code>s are constructed from Haskell values and are tagged with <code>PType</code>s.</p>
<ul>
<li><a href="Introduction/./PlutarchTerms/PlutarchConstants.html">Plutarch Constant <code>Term</code>s</a>
<ul>
<li><a href="Introduction/./PlutarchTerms/PlutarchConstants.html#static-building-of-constant-terms-with-pconstant">Static building of constant <code>Term</code>s with <code>pconstant</code></a></li>
<li><a href="Introduction/./PlutarchTerms/PlutarchConstants.html#dynamic-building-of-constant-terms-with-pcon">Dynamic building of constant <code>Term</code>s with <code>pcon</code></a></li>
<li><a href="Introduction/./PlutarchTerms/PlutarchConstants.html#overloaded-literals">Overloaded literals</a></li>
<li><a href="Introduction/./PlutarchTerms/PlutarchConstants.html#helper-functions">Helper functions</a></li>
</ul>
</li>
<li><a href="Introduction/./PlutarchTerms/PlutarchLambdas.html#lambdas-plutarch-level-function-terms">Lambdas; Plutarch-level Function <code>Term</code>s.</a>
<ul>
<li><a href="Introduction/./PlutarchTerms/PlutarchLambdas.html#function-application">Function Application</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">{-# LANGUAGE OverloadedStrings #-}
module Plutarch.Docs.PlutarchConstants (x, s, i, xd, hexs, justTerm, hPJustPInteger) where
import Plutarch.Prelude
</code></pre>
</p>
</details>
# Plutarch Constant `Term`s
<p>When evaluated, a constant Plutarch <code>Term</code> will always yield the same result. There are several ways of building constant <code>Term</code>s:</p>
<ul>
<li>Statically building constant <code>Term</code>s from concrete Haskell values when we know the value at compile-time.</li>
<li>Dynamically building constant <code>Term</code>s from Haskell values, i.e. when the constant produced depends on a dynamic value.</li>
<li>Overloaded literal syntax</li>
<li>Helper functions</li>
</ul>
<h2 id="static-building-of-constant-terms-with-pconstant"><a class="header" href="#static-building-of-constant-terms-with-pconstant">Static building of constant <code>Term</code>s with <code>pconstant</code></a></h2>
<p>If we know the desired value of a constant <code>Term</code> at compile-time, we can build the <code>Term</code> directly from <a href="Introduction/PlutarchTerms/../../Concepts/HaskellSynonym.html">Haskell synonyms</a>. The function to do so is <code>pconstant</code>.</p>
<p>Constructing constants in this way utilizes the <a href="Introduction/PlutarchTerms/../../Typeclasses/PLiftable.html"><code>PLiftable</code></a> typeclasses. These typeclasses expose the following <a href="https://wiki.haskell.org/GHC/Type_families#An_associated_type_synonym_example">associated type family</a>:</p>
<pre><code class="language-hs">type AsHaskell :: PType -&gt; Type
</code></pre>
<p><code>pconstant</code> takes a single argument: a regular Haskell type with a <code>PLiftable</code> instance, and yields a Plutarch term tagged with the corresponding Plutarch type. Note that you usually need to use type applications with <code>pconstant</code> as one Haskell type may have many Plutarch representations.</p>
<p>The relation between the Plutarch type and its Haskell synonym is established by the type family. For any Plutarch type <code>p</code>, <code>AsHaskell p</code> corresponds to the Haskell synonym.</p>
<p>For example:</p>
<pre><code class="language-haskell">-- | A Plutarch level boolean. Its value is "True", in this case.
x :: Term s PBool
x = pconstant True
</code></pre>
<p>You can also directly create a <a href="Introduction/PlutarchTerms/./../../Types/PAsData.html"><code>PAsData</code></a> term using <code>pconstantData</code>:</p>
<pre><code class="language-haskell">-- | A Plutarch level boolean encoded as `Data`.
xd :: Term s (PAsData PBool)
xd = pconstant @(PAsData PBool) True
</code></pre>
<h2 id="dynamic-building-of-constant-terms-with-pcon"><a class="header" href="#dynamic-building-of-constant-terms-with-pcon">Dynamic building of constant <code>Term</code>s with <code>pcon</code></a></h2>
<p>Sometimes the value that we want to treat as a constant <code>Term</code> is not known at compile time. To explain how to construct constants when we can only determine the value at runtime, we will examine the <code>PMaybe</code> Plutarch type. It can serve the same purpose as the <code>Maybe</code> type in Haskell: to represent the situation where computation may not produce a sensible result.</p>
<p><code>PMaybe</code> has the following definition:</p>
<pre><code class="language-hs">data PMaybe (a :: PType) (s :: S)
  = PJust (Term s a)
  | PNothing
</code></pre>
<p>and the following kind:</p>
<pre><code class="language-hs">&gt;&gt;&gt; :k PMaybe
PMaybe :: PType -&gt; S -&gt; Type
</code></pre>
<p>Let's dissect what this means.</p>
<ul>
<li><code>PMaybe</code> builds a <code>PType</code> from a <code>PType</code>; given a <code>PType</code>, we can tag a computation with the type <code>PMaybe a</code> to indicate that its return value should be semantically either <code>Just a</code> or <code>Nothing</code>. Such a tagging would look like a value with the type <code>Term s (PMaybe a)</code>.</li>
<li><code>PJust</code> and <code>PNothing</code> are data constructors. They are <em>not</em> tags. <code>PJust :: Term s a -&gt; PMaybe (a :: PType) (s :: S)</code> is a helper to signify the concept of <code>Just x</code>. It contains a Plutarch term.</li>
</ul>
<p>Now suppose that we want to carry around a constant <code>Term</code> in a Plutarch script that can be either <code>PJust a</code> or <code>PNothing</code>. To do so, we need a function to go from <code>PJust a</code> (which we <em>can</em> instantiate as a Haskell value, unlike <code>PInteger</code>) to a <code>Term s (PMaybe a)</code>. This function is <code>pcon</code>:</p>
<pre><code class="language-haskell">-- pcon :: a s -&gt; Term s a
-- For example:

x' :: Term s PInteger
x' = pconstant 3

justTerm :: Term s (PMaybe PInteger)
justTerm = pcon (PJust x')
</code></pre>
<p>These types deserve some explanation.</p>
<ul>
<li>We are familiar by now with the type of <code>x</code>; it is a computation that returns a value that can be interpreted as a Haskell integer if evaluated successfully (in this case, 3).</li>
<li>The type of <code>justTerm</code> represents a computation tagged with the <code>PMaybe PInteger</code> type.</li>
</ul>
<p>That is, if we ask <code>justTerm</code> what it will return when evaluated, it responds, "You should interpret the value I give you as either <code>Nothing</code> or <code>Just Integer</code>." Of course, we know that the result will always be <code>Just 3</code>; but this is the general mechanism to declare a function requiring a <code>Maybe</code>.</p>
<p>If you don't want to pretend to not know <code>x</code> during compile time, another example may be:</p>
<pre><code class="language-haskell">hPJustPInteger :: Term s PInteger -&gt; Term s (PMaybe PInteger)
hPJustPInteger x = pcon (PJust x)
</code></pre>
<p>The <code>pcon</code> function is a method of the <a href="Introduction/PlutarchTerms/./../../Typeclasses/PlutusType,PCon,PMatch.html"><code>PCon</code> typeclass</a>.</p>
<h2 id="overloaded-literals"><a class="header" href="#overloaded-literals">Overloaded literals</a></h2>
<p><code>pconstant</code> and <code>pcon</code> are the long-form ways of building constants. Specific constant Haskell literals are overloaded to help construct Plutarch constants. We provide two examples below.</p>
<pre><code class="language-haskell">-- | A Plutarch level integer. Its value is 1, in this case.
i :: Term s PInteger
i = 1

-- | A Plutarch level string (this is actually `Text`). Its value is "foobar", in this case.
s :: Term s PString
s = "foobar"
</code></pre>
<h2 id="helper-functions"><a class="header" href="#helper-functions">Helper functions</a></h2>
<p>Finally, Plutarch provides helper functions to build certain types of constants:</p>
<pre><code class="language-haskell">-- | A plutarch level bytestring. Its value is [65], in this case.
hexs :: Term s PByteString
hexs = phexByteStr "41"
-- ^ 'phexByteStr' interprets a hex string as a bytestring. 0x41 is 65 - of course.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">{-# LANGUAGE OverloadedStrings #-}
module Plutarch.Docs.PlutarchLambdas (pid, pid') where 
import Plutarch.Prelude
</code></pre>
</p>
</details>
# Lambdas; Plutarch-level Function `Term`s.
<p>Lambdas are the second form of Plutarch <code>Term</code>s. Lambda terms are represented at the type level by the infix type constructor <code>:--&gt;</code>; a value of type <code>Term s (a :--&gt; b)</code> evaluates to a function that takes a value of type <code>a</code> and produces a value of type <code>b</code>.</p>
<p>You can create Plutarch lambda <code>Term</code>s by applying the <code>plam</code> function to a Haskell-level function that works on Plutarch terms. The true type of <code>plam</code> itself is unimportant to end-users of Plutarch, but it should be thought of as</p>
<pre><code class="language-hs">plam :: (Term s a -&gt; Term s b) -&gt; Term s (a :--&gt; b)
</code></pre>
<p>To create the identity function as a Plutarch lambda, we would thus use:</p>
<pre><code class="language-haskell">-- | Haskell-level `id` function specialized to the `Term s a` type``
termId :: Term s a -&gt; Term s a
termId x = x

-- | Plutarch-level `id` lambda
pid :: Term s (a :--&gt; a)
pid = plam termId

-- | Equivalently:
pid' :: Term s (a :--&gt; a)
pid' = plam $ \x -&gt; x
</code></pre>
<p>Notice the type. A Plutarch lambda <code>Term</code> uses the <code>:--&gt;</code> infix operator to encode a function type. So in the above case, <code>pid</code> is a Plutarch level function that takes a type <code>a</code> and returns the same type. As one would expect, <code>:--&gt;</code> is right-associative, and things curry like a charm.</p>
<p>Guess what this Plutarch level function does:</p>
<pre><code class="language-hs">f :: Term s (PInteger :--&gt; PString :--&gt; a :--&gt; a)
</code></pre>
<p>It takes in an integer, a string, and a type <code>a</code> and returns the same type <code>a</code>. Notice that the types are all of kind <code>PType</code>. This means that when faced with filling out the gap:</p>
<pre><code class="language-hs">f :: Term s (PInteger :--&gt; PString :--&gt; a :--&gt; a)
f = plam $ \???
</code></pre>
<p>We know that the argument to <code>plam</code> here is a Haskell function <code>g</code> with type <code>Term s PInteger -&gt; Term s PString -&gt; Term s a -&gt; Term s a</code>.</p>
<h2 id="function-application"><a class="header" href="#function-application">Function Application</a></h2>
<p>Once we construct a Plutarch lambda <code>Term</code> using <code>plam</code>, it is rather useless unless we apply it to an argument. Plutarch provides two operators to do so</p>
<pre><code class="language-hs">{- |
  High precedence infixl function application, to be used like
  function juxtaposition. e.g.:

  &gt;&gt;&gt; f # x # y
  Conceptually: f x y
-}
(#) :: Term s (a :--&gt; b) -&gt; Term s a -&gt; Term s b
infixl 8 #

{- |
  Low precedence infixr function application, to be used like
  `$`, in combination with `#`. e.g.:

  &gt;&gt;&gt; f # x #$ g # y # z
  Conceptually: f x (g y z)
-}
(#$) :: Term s (a :--&gt; b) -&gt; Term s a -&gt; Term s b
infixr 0 #$
</code></pre>
<p>The types of each operator match our intuition. Applying a lambda <code>Term</code> to a <code>Term</code> (tagged with the <code>PType</code> of the domain of the lambda) produces a <code>Term</code> (tagged with the <code>PType</code> of the codomain.).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plutarch-types"><a class="header" href="#plutarch-types">Plutarch Types</a></h1>
<p>When this guide uses the term "Plutarch Type" we explicitly talk about a type of <em>kind</em> <code>PType</code>. We will refer to  <em>" types of kind <code>PType</code> "</em> simply as <code>PType</code>s. We explicitly qualify when referring to the <em>kind</em> <code>PType</code>.</p>
<blockquote>
<p>Note to beginners: Plutarch uses a language extension called <code>DataKinds</code>. This means that there are kinds beyond <code>Type</code> (aka <code>*</code>). We refer the read to [<a href="Introduction/./../Introduction.html#references">3</a>] for an extended beginner-level introduction to these concepts if desired.</p>
</blockquote>
<p><code>PType</code> is defined as <code>type PType = S -&gt; Type</code>; that is, it is a <em>kind synonym</em> for <code>S -&gt; Type</code> (where <code>S</code> and <code>Type</code> are themselves kinds). This synonym is important to keep in mind because when querying the kind of something like <code>PBool</code> in, say, GHCi, we will <em>not</em> see <code>PType</code> as the kind. Instead, we get</p>
<pre><code class="language-hs">ghci&gt; :k PBool
PBool :: S -&gt; Type
</code></pre>
<p>Thus, any time we see the kind <code>S -&gt; Type</code>, we should mentally substitute its kind synonym <code>PType</code>. We reiterate: types of kind <code>PType</code>, should be considered as <em>tags</em> on computation. They do not represent types of values in the same way as standard Haskell types.</p>
<p>The kind of basic types such as <code>Integer</code> in Haskell has the kind: <code>Type</code>; the corresponding "basic" kind in Plutarch is simply <code>PType</code>. Higher-kinded types in Haskell, such as <code>Maybe</code>, will have kinds such as <code>Type -&gt; Type</code>. In Plutarch, the corresponding kind is:</p>
<pre><code class="language-hs">ghci&gt; :k PMaybe
PMaybe :: PType -&gt; S -&gt; Type
</code></pre>
<p>Since the kind arrow <code>-&gt;</code> is right-associative, we first read this as <code>PMaybe :: PType -&gt; (S -&gt; Type)</code>; and since we know that that <code>PType</code> and <code>S -&gt; Type</code> and synonyms, we read this as <code>PMaybe :: PType -&gt; PType</code>, which should agree with our intuition.</p>
<p>The kind <code>S -&gt; Type</code> is mysterious at first, but we recall that <code>PType</code>s are <em>tags</em> on (unexecuted) computations indicating their result type. The <code>S</code> kind represents the computational context; thus, a <code>PType</code> expects to receive a <em>computational context</em> represented by a value <code>s</code> whose type has kind <code>S</code> that it will tag to produce a <code>Type</code>. Note that end-users never instantiate the value <code>s</code> with a concrete value; it is simply a type-level mechanism to maintain functional purity.</p>
<p>The above notion is essential to understanding why not all <code>PType</code>s have data constructors; the data constructors are irrelevant, except insofar as they enable the implementation to keep track of Haskell-level and UPLC-level representations. <code>PInteger</code> is one such case; it is impossible to construct a constant <code>y</code> where <code>y :: PInteger s</code>. Other <code>PType</code>s, such as <code>PMaybe</code>, <em>do</em> have data constructors (specifically <code>PJust</code> and <code>PNothing</code>), but <em>still</em> do not carry data from the viewpoint of UPLC. A value such as <code>PNothing</code> merely facilitates convenient term construction and deconstruction. When <code>pcon</code> sees <code>PNothing</code>, it knows it should build a UPLC constant that is <em>morally</em> equivalent to the concept of <code>Nothing :: Maybe a</code>.</p>
<p>In general, the concrete UPLC representations are connected to Plutarch types through their <code>PlutusType</code> implementation.</p>
<p>Also see: <a href="Introduction/./../Tricks/RepresentationOfPlutarchType.html">Figuring out the representation of a Plutarch type</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="untyped-plutus-core-uplc"><a class="header" href="#untyped-plutus-core-uplc">Untyped Plutus Core (UPLC)</a></h1>
<p>Plutarch compiles to UPLC. Most Plutarch end-users will not need to concern themselves with the details of UPLC, but a brief overview will aid in building a mental model of how Plutarch works.</p>
<p>Unlike Haskell, UPLC is a low-level and untyped language implementing a basic lambda calculus. Consequently, it supports only a handful of built-in values and functions which may be strung together in lambda applications. The built-in types provided by UPLC include the usual primitive types -- integers, byte strings and strings, booleans, and so forth -- and a special <code>Data</code> value that can encode representations of arbitrary sum-of-products Haskell types.</p>
<p>While the <em>semantic</em> meaning of a Haskell type such as <code>Maybe Integer</code> is missing in UPLC, it still can be <em>represented</em> in UPLC through certain <a href="Introduction/./../Concepts/DataAndScottEncoding.html">encodings</a>. The aforementioned <code>Data</code> encoding can be used to represent arbitrary types in on-chain components such as Datum and Redeemers. On the other hand Scott Encoding can additionally encode function types but cannot be used in Datums or Redeemers. The key idea is that UPLC doesn't track what differentiates semantically distinct values, regardless of their encoding, and will not prevent a programmer from operating on the underlying representation in non-sensical ways.</p>
<p>Plutarch's solution is to <em>tag</em> scripts that compile to UPLC (i.e., Plutarch <code>Term</code>s) with types. Doing so allows the Plutarch compiler to track and type check operations on semantically distinct UPLC values. These tags are provided by "Plutarch Types", or "types of kind <code>PType</code>".</p>
<p>For the Plutarch compiler to bridge between arbitrary, semantically-rich Haskell types and the untyped values of UPLC, it is necessary to associate various bits of information with <code>PType</code>s. On the one hand, each <code>PType</code> should have some semantic, type-level richness such as typeclass instances (otherwise, there would be little point in programming in Haskell!). On the other hand, each <code>PType</code> needs to have a UPLC representation, either as a built-in primitive value,<code>Data</code>, or as a Scott-encoded lambda, in order to compile to UPLC.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Looking to contribute to Plutarch? Looking for functionalities that are not currently provided by Plutarch from a safe interface? You've come to the right place!</p>
<blockquote>
<p>Note: If you spot any mistakes/have any related questions that this guide lacks the answer to, please don't hesitate to raise an issue. The goal is to have high quality documentation for Plutarch developers!</p>
</blockquote>
<details>
<summary> Table of Contents </summary>
<ul>
<li><a href="DEVGUIDE.html#code-style">Code Style</a></li>
<li><a href="DEVGUIDE.html#pre-commit-checks">Pre-commit checks</a></li>
<li><a href="DEVGUIDE.html#updating-changelog">Updating Changelog</a></li>
<li><a href="DEVGUIDE.html#targeting-branch-for-pr">Targeting branch for PR</a></li>
<li><a href="DEVGUIDE.html#concepts">Concepts</a>
<ul>
<li><a href="DEVGUIDE.html#plutus-core-constants-unsafe">Plutus Core constants (UNSAFE)</a></li>
<li><a href="DEVGUIDE.html#plutus-core-builtin-functions">Plutus core builtin functions</a></li>
<li><a href="DEVGUIDE.html#working-with-builtindatadatapdata">Working with BuiltinData/Data/PData</a></li>
</ul>
</li>
<li><a href="DEVGUIDE.html#lower-level-examples">Lower Level Examples</a>
<ul>
<li><a href="DEVGUIDE.html#extracting-txinfoinputs-from-scriptcontext-manually-untyped">Extracting <code>txInfoInputs</code> from <code>ScriptContext</code> manually (UNTYPED)</a></li>
</ul>
</li>
<li><a href="DEVGUIDE.html#useful-links">Useful Links</a></li>
<li><a href="DEVGUIDE.html#how-to-build-docs">How to build docs</a></li>
</ul>
</details>
<h1 id="code-style"><a class="header" href="#code-style">Code Style</a></h1>
<p>You should generally follow the <a href="https://github.com/mlabs-haskell/styleguide">MLabs style guide</a>, credit to <a href="https://github.com/kozross">@Koz Ross</a>.</p>
<p><strong>Discouraged Extensions</strong></p>
<ul>
<li><code>ImportQualifiedPost</code></li>
<li><code>RecordWildCards</code></li>
</ul>
<h1 id="pre-commit-checks"><a class="header" href="#pre-commit-checks">Pre-commit checks</a></h1>
<p>Remember to run <code>./bin/format</code> to format your code and <code>cabal test</code>, alongside <code>cabal test -f development</code>, to make sure all the tests pass prior to making a PR!</p>
<h1 id="updating-changelog"><a class="header" href="#updating-changelog">Updating Changelog</a></h1>
<p>If your PR makes a change to some user facing functionality - please summarize the change(s) and add it to <code>CHANGELOG.md</code>.</p>
<h1 id="targeting-branch-for-pr"><a class="header" href="#targeting-branch-for-pr">Targeting branch for PR</a></h1>
<p>More often than not, you'll be making PRs directly to <code>master</code>.</p>
<p>However, sometimes, there is a release cycle going on and the state of the repository is in flux. There will usually be a <code>master &lt;- staging</code> PR open during this time. As long as the <code>staging</code> PR is open, you should base most new branches on top of it and merge back into it. Bug fixes, for bugs present in <code>master</code>, are exempt from this requirement.</p>
<h1 id="concepts-1"><a class="header" href="#concepts-1">Concepts</a></h1>
<p>Even if certain functionalities are absent from the public facing API - you can always implement them using functions like <code>punsafeConstant</code> and <code>punsafeBuiltin</code> - these allow you to walk the lines between Plutus core and Plutarch.</p>
<p>A general familiarity with Plutus core is important. You can learn all of that through the following documents:</p>
<ul>
<li><a href="https://github.com/Plutonomicon/plutonomicon/blob/main/builtin-lists.md">Builtin lists</a></li>
<li><a href="https://github.com/Plutonomicon/plutonomicon/blob/main/builtin-pairs.md">Builtin pairs</a></li>
<li><a href="https://github.com/Plutonomicon/plutonomicon/blob/main/builtin-functions.md">Builtin functions</a></li>
<li><a href="https://github.com/Plutonomicon/plutonomicon/blob/main/builtin-data.md">Builtin data</a></li>
</ul>
<p>Parts of the <a href="https://github.com/Plutonomicon/pluto/blob/main/GUIDE.md">Pluto guide</a> may also prove useful.</p>
<h2 id="plutus-core-constants-unsafe"><a class="header" href="#plutus-core-constants-unsafe">Plutus Core constants (UNSAFE)</a></h2>
<blockquote>
<p><strong>NOTE</strong>: The following information is almost never necessary with the existence of <code>pconstant</code>. Refer to <a href="./Introduction/PlutarchTerms/PlutarchConstants.html">constant building</a> and <a href="./Typeclasses/PLiftable.html"><code>PLiftable</code></a> section of the Plutarch user guide.</p>
</blockquote>
<p>Often, you will need to build a Plutus core constant. You can do this using <code>Some</code> and <code>ValueOf</code>. Here's how <code>pcon PTrue</code> creates a Plutarch term that actually evaluates to a Plutus core constant representing a boolean:</p>
<pre><code class="language-haskell">import qualified PlutusCore as PLC

pcon' PTrue = punsafeConstant . PLC.Some $ PLC.ValueOf PLC.DefaultUniBool True
pcon' PFalse = punsafeConstant . PLC.Some $ PLC.ValueOf PLC.DefaultUniBool False
</code></pre>
<p>There's a lot to unpack here - but the general pattern is always the same. First step is to construct the Plutus core constant:</p>
<pre><code class="language-haskell">PLC.Some $ PLC.ValueOf PLC.DefaultUniBool True
</code></pre>
<p>The only parts that you will need to change when creating other constants, are the type and the value. Here the type is <code>DefaultUniBool</code>. This means the next argument must be a <code>Bool</code>. Ensured by the type system - don't you worry :)</p>
<p>You can glance at the other types in the default universe (what you will be working with). Can you guess how to make a Plutus core string from a Haskell string, and represent it as a Plutarch term?</p>
<pre><code class="language-haskell">import qualified Data.Text as Txt
import qualified PlutusCore as PLC

punsafeConstant . PLC.Some . PLC.ValueOf PLC.DefaultUniString . Txt.pack
</code></pre>
<p>(it's even pointfree!)</p>
<p>And that's <em>essentially</em> what the <code>IsString</code> implementation of <code>Term s PString</code> does. That is how your string literals end up as plutus core built in strings.</p>
<p>One more, how about something complex - <code>DefaultUniProtoList</code>. This is a builtin list. But what is the element type? Well, you'll have to specify that yourself! You use <code>DefaultUniApply</code> to "apply" a type (from the default universe) over <code>DefaultUniProtoList</code>:</p>
<pre><code class="language-haskell">import qualified PlutusCore as PLC

PLC.Some . PLC.ValueOf (PLC.DefaultUniProtoList `PLC.DefaultUniApply` PLC.DefaultUniInteger)
</code></pre>
<p>That right there converts a <code>[Integer]</code> into a Plutus core builtin list of builtin integers. Convenient!</p>
<p>Actually, there's a convenient <code>pattern</code> synonym for <code>DefaultUniProtoList `DefaultUniApply` a</code>- <code>DefaultUniList a</code>. Using that, you can simplify the above to:</p>
<pre><code class="language-haskell">PLC.Some . PLC.ValueOf (PLC.DefaultUniList PLC.DefaultUniInteger)
</code></pre>
<p>Note that you will have to provide the correct type annotations yourself, as <code>punsafeConstant</code> just infers to a <code>Term s a</code>. That's why it's unsafe! Make sure to provide the correct annotations when using this unsafe function:</p>
<pre><code class="language-haskell">foo :: Bool -&gt; Term s PBool
foo = punsafeConstant . PLC.Some . PLC.ValueOf PLC.DefaultUniBool
</code></pre>
<p>Of course, we represent Plutus core booleans as <code>Term s PBool</code> in Plutarch - so that's its type!</p>
<h2 id="plutus-core-builtin-functions"><a class="header" href="#plutus-core-builtin-functions">Plutus core builtin functions</a></h2>
<p>This is what you will be wrangling with the most. Builtin functions are going to be the foundation of <em>everything</em> you do. And the documentation on them is….. sparse.</p>
<p>You create Plutarch synonyms to Plutus core builtin functions using <code>punsafeBuiltin</code>. It creates a Plutarch level function from a Plutus core builtin functions.</p>
<p>Let's try making one, how about <code>AddInteger</code>?</p>
<pre><code class="language-haskell">import qualified PlutusCore as PLC

addI :: Term s (PInteger :--&gt; PInteger :--&gt; PInteger)
addI = punsafeBuiltin PLC.AddInteger
</code></pre>
<p>Just like <code>punsafeConstant</code>, you have to provide the right annotation yourself. We know that <code>AddInteger</code> takes two Plutus core builtin integers and returns another one. We represent these integers in Plutarch using <code>PInteger</code> terms - so there we go!</p>
<p>You can use and apply this Plutarch function just like any other.</p>
<p>Now here's where this goes off the rails, some builtin functions require <em>forces</em> to be used. These builtin functions have inherent polymorphic type variables. The number of times you need to force them, depends on the number of type variables they have.</p>
<p>Let's look at an example- <code>HeadList</code>. It's type can be thought of as - <code>forall a. [a] -&gt; a</code>. It has one type variable, so it needs to be forced once:</p>
<pre><code class="language-haskell">pheadBuiltin :: Term s (PBuiltinList a :--&gt; a)
pheadBuiltin = pforce $ punsafeBuiltin PLC.HeadList
</code></pre>
<p>We force a Plutarch term using <code>pforce</code>, recall that <code>punsafeBuiltin</code> returns a term. You need to type it all yourself of course. <code>pforce</code> doesn't mean you need to get rid of the type variable in your Plutarch level type. It'll still work with any <code>a</code> - the forcing just has to happen at call site.</p>
<p>You can sort of do this blindly, <code>HeadList</code> takes 1 force, so just <code>pforce</code> once. <code>TailList</code> also takes 1 force. <code>ChooseList</code> takes 2 forces (<code>forall a b. [a] -&gt; b -&gt; b -&gt; b</code>). Here's how you would implement a Plutarch synonym for it:</p>
<pre><code class="language-haskell">pchooseList :: Term s (PBuiltinList a :--&gt; b -&gt; b -&gt; b)
pchooseList = pforce $ pforce $ punsafeBuiltin PLC.ChooseList
</code></pre>
<blockquote>
<p>Aside: You should also hoist the synonyms here that take one or more forces!</p>
</blockquote>
<p>We have a <a href="https://github.com/Plutonomicon/plutonomicon/blob/main/builtin-functions.md">Plutus Core builtin functions reference</a> for everything you need to know about them. Including types, usage, and forcing.</p>
<h2 id="working-with-builtindatadatapdata"><a class="header" href="#working-with-builtindatadatapdata">Working with BuiltinData/Data/PData</a></h2>
<p>Most of the time, you'll be working with <code>BuiltinData</code>/<code>Data</code> - this is the type of the arguments that will be passed onto your script from the outside. This is the type of the datum, the redeemer and the script context. This is also the type of arguments you will be able to pass to a <code>Script</code>.</p>
<p>Plutarch aims to hide these low level details from the user. Ideally, you will be using <code>PDataSum</code>/<code>PDataList</code> and <code>PAsData</code> - these are essentially just <code>BuiltinData</code>, but it is typed at the Plutarch level.</p>
<p>If you want to work with <code>BuiltinData</code> directly however, which you may have to do during developing Plutarch, you can find all that you need to know at <a href="https://github.com/Plutonomicon/plutonomicon/blob/main/builtin-data.md">Plutonomicon</a>.</p>
<h1 id="lower-level-examples"><a class="header" href="#lower-level-examples">Lower Level Examples</a></h1>
<h2 id="extracting-txinfoinputs-from-scriptcontext-manually-untyped"><a class="header" href="#extracting-txinfoinputs-from-scriptcontext-manually-untyped">Extracting <code>txInfoInputs</code> from <code>ScriptContext</code> manually (UNTYPED)</a></h2>
<p>Here's a quick refresher on what <code>ScriptContext</code> looks like:</p>
<pre><code class="language-haskell">data ScriptContext = ScriptContext
  { scriptContextTxInfo :: TxInfo
  , scriptContextPurpose :: ScriptPurpose
  }
</code></pre>
<p>We are interested in <code>txInfoInputs</code>, which has type <code>TxInInfo</code>. It is the first field within <code>TxInfo</code>. If you have read <a href="DEVGUIDE.html#working-with-builtindatadatapdata">Working with <code>BuiltinData</code></a> already - you know that a <code>ScriptContext</code> translates to a <code>Data</code> value similar to:</p>
<pre><code class="language-haskell">Constr 0 [PlutusTx.toData txInfo, PlutusTx.toData txPurpose]
</code></pre>
<p>Where <code>txInfo</code> and <code>txPurpose</code> are values of type <code>TxInfo</code> and <code>ScriptPurpose</code> respectively.</p>
<p>We are interested in that first field. That's easy, we do the following actions in sequence:</p>
<ul>
<li><code>pasConstr</code> - yields a <code>PBuiltinPair PInteger (PBuiltinList PData)</code>. We know the constructor id is <code>0</code>. It doesn't matter, there's only one constructor.</li>
<li><code>psndBuiltin</code> - yields <code>PBuiltinList PData</code>, the second element of the pair. These are the fields within <code>ScriptContext</code>.</li>
<li><code>phead</code> - yields <code>PData</code>, the first field. We know this is our <code>TxInfo</code>.</li>
</ul>
<p>Combining that all up would give you:</p>
<pre><code class="language-haskell">import Plutarch.Prelude
import Plutarch.Builtin

f :: Term s (PData :--&gt; PData)
f = plam $ \x -&gt; phead #$ psndBuiltin #$ pasConstr # x
</code></pre>
<p>And if you test it with a mock context value, it does work:</p>
<pre><code class="language-haskell">{-# LANGUAGE OverloadedStrings #-}

import Plutus.V1.Ledger.Api
import Plutus.V1.Ledger.Interval
import qualified PlutusTx

mockCtx :: ScriptContext
mockCtx =
  ScriptContext
    (TxInfo
      [ TxInInfo
          (TxOutRef "" 1)
          (TxOut (Address (PubKeyCredential "0123") Nothing) mempty Nothing)
      ]
      mempty
      mempty
      mempty
      mempty
      mempty
      (interval (POSIXTime 1) (POSIXTime 2))
      mempty
      mempty
      ""
    )
    (Minting (CurrencySymbol ""))

&gt;  f `evalWithArgsT` [PlutusTx.toData mockCtx]
Right (Program () (Version () 1 0 0) (Constant () (Some (ValueOf data (Constr 0 [List [Constr 0 [Constr 0 [Constr 0 [B ""],I 1],Constr 0 [Constr 0 [Constr 0 [B "\SOH#"],Constr 1 []],Map [],Constr 1 []]]],List [],Map [],Map [],List [],List [],Constr 0 [Constr 0 [Constr 1 [I 1],Constr 1 []],Constr 0 [Constr 1 [I 2],Constr 1 []]],List [],List [],Constr 0 [B ""]])))))
</code></pre>
<blockquote>
<p>Aside: You can find the definition of <code>evalWithArgsT</code> above - <a href="./Overview.html#compiling-and-running">Compiling and Running</a>.</p>
</blockquote>
<p>But we're not done yet! We want <code>txInfoInputs</code>. You may have noticed where exactly it is located on the above output. See that <code>List …</code>? Inside the outermost <code>Constr</code>'s fields? That's our <code>txInfoInputs</code>!</p>
<blockquote>
<p>Aside: Recall that <code>List</code> data values are simply wrappers around lists. Also recall that the fields in a <code>Constr</code> value must be all of type <code>Data</code>. So any of your list fields get translated to <code>List</code> data. Just remember not to confuse these with builtin lists (<code>PBuiltinList</code>)! Functions like <code>pheadBuiltin</code> don't work on <code>List</code> data values.</p>
</blockquote>
<p>To obtain <code>txInfoInputs</code> from here, we do the following actions in sequence:</p>
<ul>
<li><code>pasConstr</code> - unpacks the <code>TxInfo</code>. There's only one constructor, <code>TxInfo</code> - we don't care about that. We need the fields.</li>
<li><code>psndBuiltin</code> - extracts the second member of the pair, the fields of <code>TxInfo</code>.</li>
<li><code>phead</code> - extracts the first element of the list. This is our field, <code>txInfoInputs</code>.</li>
<li>(optional) <code>pasList</code> - takes out the builtin list from the <code>List</code> data value.</li>
</ul>
<p>And that's it! Putting it all together:</p>
<pre><code class="language-haskell">f :: Term s (PData :--&gt; PBuiltinList PData)
f = plam $ \x -&gt;
  let txInfo = phead #$ psndBuiltin #$ pasConstr # x
  in pasList #$ phead #$ psndBuiltin #$ pasConstr # txInfo
</code></pre>
<p>Trying it on the same <code>mockCtx</code> yields:</p>
<pre><code class="language-haskell">&gt; f `evalWithArgsT` [PlutusTx.toData mockCtx]
Right (Program () (Version () 1 0 0) (Constant () (Some (ValueOf list (data) [Constr 0 [Constr 0 [Constr 0 [B ""],I 1],Constr 0 [Constr 0 [Constr 0 [B "\SOH#"],Constr 1 []],Map [],Constr 1 []]]]))))
</code></pre>
<p>Getting some of the boilerplate out of the way, this is what the value looks like:</p>
<pre><code class="language-haskell">Some
  (ValueOf list (data)
    [Constr 0
        [Constr 0 [Constr 0 [B ""],I 1],Constr 0 [Constr 0 [Constr 0 [B "\SOH#"],Constr 1 []],Map [],Constr 1 []]]
    ]
  )
</code></pre>
<p>There's just one element in <code>txInfoInputs</code> in this example, and there it is. Of course <code>TxInInfo</code>, the element type of this list, also gets translated to a <code>Constr</code> data with further fields. And that's what you see above.</p>
<h1 id="useful-links-1"><a class="header" href="#useful-links-1">Useful Links</a></h1>
<ul>
<li><a href="https://github.com/Plutonomicon/plutonomicon/blob/main/builtin-lists.md">Builtin lists</a></li>
<li><a href="https://github.com/Plutonomicon/plutonomicon/blob/main/builtin-pairs.md">Builtin pairs</a></li>
<li><a href="https://github.com/Plutonomicon/plutonomicon/blob/main/builtin-functions.md">Builtin functions</a></li>
<li><a href="https://github.com/Plutonomicon/plutonomicon/blob/main/builtin-data.md">Builtin data</a></li>
<li><a href="https://plutonomicon.github.io/plutarch-plutus/haddock/plutus-tx/html/PlutusTx-Builtins-Internal.html#v:error">Plutus builtin functions and types</a></li>
<li><a href="https://plutonomicon.github.io/plutarch-plutus/haddock/plutus-core/html/UntypedPlutusCore.html#t:DefaultFun">Plutus Core builtin function identifiers, aka <code>DefaultFun</code></a></li>
<li><a href="https://plutonomicon.github.io/plutarch-plutus/haddock/plutus-core/html/PlutusCore-Default.html#t:DefaultUni">Plutus Core types, aka <code>DefaultUni</code></a></li>
</ul>
<h1 id="how-to-build-docs"><a class="header" href="#how-to-build-docs">How to build docs</a></h1>
<p>To run the docs locally from the Git working copy (useful when editing them), from nix development shell,</p>
<pre><code class="language-sh-session"># in plutarch-docs directory
mdbook serve .
</code></pre>
<p>When you add new file that is compilable, please run <code>./createSymlinks</code> script. This will generate symbolic links to
<code>./compilable</code> directory which cabal will build. Don't forget to add the name of the module new file defines to <code>plutarch-docs.cabal</code> at <code>other-modules</code> section so that it will actually build.</p>
<p>To build the static HTML site,</p>
<pre><code class="language-sh-session">mdbook build .
</code></pre>
<p>To run the docs directly without cloning the Git repo,</p>
<pre><code class="language-sh-session">nix run github:Plutonomicon/plutarch#combined-docs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.Run (applyArguments, evalT, evalSerialize, evalWithArgsT, evalWithArgsT') where
import Data.Bifunctor (first)
import Data.ByteString.Short (ShortByteString)
import Data.Text (Text, pack)
import Plutarch.Internal.Term (ClosedTerm, compile)
import Plutarch.Script (Script (unScript), serialiseScript)
import Plutarch.Evaluate (evalScript, applyArguments)
import PlutusLedgerApi.V1 (Data, ExBudget)
import UntypedPlutusCore (DeBruijn, DefaultFun, DefaultUni, Program)
</code></pre>
</p>
</details>
This document describes how to compile and run Plutarch - whether for on chain deployment or off chain testing.
<blockquote>
<p>Note: If you spot any mistakes/have any related questions that this guide lacks the answer to, please don't hesitate to raise an issue. The goal is to have high quality documentation for Plutarch users!</p>
</blockquote>
<details>
<summary> Table of Contents </summary>
<ul>
<li><a href="Run.html#common-extensions-and-ghc-options">Common Extensions and GHC options</a></li>
<li><a href="Run.html#evaluation">Evaluation</a></li>
</ul>
</details>
<h1 id="common-extensions-and-ghc-options"><a class="header" href="#common-extensions-and-ghc-options">Common Extensions and GHC options</a></h1>
<p>You generally want to adhere to the same extensions and GHC options the <a href="https://github.com/Plutonomicon/plutarch/blob/master/plutarch.cabal">Plutarch repo</a> uses.</p>
<details>
<summary> List of GHC extensions </summary>
<ul>
<li><code>NoStarIsType</code></li>
<li><code>BangPatterns</code></li>
<li><code>BinaryLiterals</code></li>
<li><code>ConstrainedClassMethods</code></li>
<li><code>ConstraintKinds</code></li>
<li><code>DataKinds</code></li>
<li><code>DeriveAnyClass</code></li>
<li><code>DeriveDataTypeable</code></li>
<li><code>DeriveFoldable</code></li>
<li><code>DeriveFunctor</code></li>
<li><code>DeriveGeneric</code></li>
<li><code>DeriveLift</code></li>
<li><code>DeriveTraversable</code></li>
<li><code>DerivingStrategies</code></li>
<li><code>DerivingVia</code></li>
<li><code>DoAndIfThenElse</code></li>
<li><code>EmptyCase</code></li>
<li><code>EmptyDataDecls</code></li>
<li><code>EmptyDataDeriving</code></li>
<li><code>ExistentialQuantification</code></li>
<li><code>ExplicitForAll</code></li>
<li><code>FlexibleContexts</code></li>
<li><code>FlexibleInstances</code></li>
<li><code>ForeignFunctionInterface</code></li>
<li><code>GADTSyntax</code></li>
<li><code>GeneralisedNewtypeDeriving</code></li>
<li><code>HexFloatLiterals</code></li>
<li><code>ImplicitPrelude</code></li>
<li><code>InstanceSigs</code></li>
<li><code>KindSignatures</code></li>
<li><code>LambdaCase</code></li>
<li><code>MonomorphismRestriction</code></li>
<li><code>MultiParamTypeClasses</code></li>
<li><code>NamedFieldPuns</code></li>
<li><code>NamedWildCards</code></li>
<li><code>NumericUnderscores</code></li>
<li><code>OverloadedStrings</code></li>
<li><code>PartialTypeSignatures</code></li>
<li><code>PatternGuards</code></li>
<li><code>PolyKinds</code></li>
<li><code>PostfixOperators</code></li>
<li><code>RankNTypes</code></li>
<li><code>RelaxedPolyRec</code></li>
<li><code>ScopedTypeVariables</code></li>
<li><code>StandaloneDeriving</code></li>
<li><code>StandaloneKindSignatures</code></li>
<li><code>TraditionalRecordSyntax</code></li>
<li><code>TupleSections</code></li>
<li><code>TypeApplications</code></li>
<li><code>TypeFamilies</code></li>
<li><code>TypeOperators</code></li>
<li><code>TypeSynonymInstances</code></li>
<li><code>ViewPatterns</code></li>
</ul>
</details>
<h1 id="evaluation"><a class="header" href="#evaluation">Evaluation</a></h1>
<p>You can compile a Plutarch term using <code>compile</code> (from <code>Plutarch</code> module), making sure it has no free variables. <code>compile</code> returns a <code>Script</code>, which you can use as you would any other Plutus script.</p>
<blockquote>
<p>For further insight into what is compiled - you can use <code>Plutarch.Pretty.prettyTerm</code>.</p>
</blockquote>
<blockquote>
<p>Note: You can pretty much ignore the UPLC types involved here. All it really means is that the result is a "UPLC program". When it's printed, it's pretty legible - especially for debugging purposes. Although not necessary to use Plutarch, you may find the <a href="https://github.com/Plutonomicon/plutonomicon/blob/main/uplc.md">Plutonomicon UPLC guide</a> useful.</p>
</blockquote>
<pre><code class="language-haskell">evalSerialize :: ClosedTerm a -&gt; Either Text ShortByteString
evalSerialize x = serialiseScript . (\(a, _, _) -&gt; a) &lt;$&gt; evalT x

evalT :: ClosedTerm a -&gt; Either Text (Script, ExBudget, [Text])
evalT x = evalWithArgsT x []

evalWithArgsT :: ClosedTerm a -&gt; [Data] -&gt; Either Text (Script, ExBudget, [Text])
evalWithArgsT x args = do
  cmp &lt;- compile mempty x
  let (escr, budg, trc) = evalScript $ applyArguments cmp args
  scr &lt;- first (pack . show) escr
  pure (scr, budg, trc)

evalWithArgsT' :: ClosedTerm a -&gt; [Data] -&gt; Either Text (Program DeBruijn DefaultUni DefaultFun (), ExBudget, [Text])
evalWithArgsT' x args =
  (\(res, budg, trcs) -&gt; (unScript res, budg, trcs))
    &lt;$&gt; evalWithArgsT x args
</code></pre>
<p>Note there might be utilities already in Plutarch that replaces above functions.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>Note: If you spot any mistakes/have any related questions that this guide lacks the answer to, please don't hesitate to raise an issue. The goal is to have high quality documentation for Plutarch users!</p>
</blockquote>
<details>
<summary> Table of Contents </summary>
<ul>
<li><a href="Troubleshooting.html#no-instance-for-punsafeliftdecl-a">No instance for <code>PUnsafeLiftDecl a</code></a></li>
<li><a href="Troubleshooting.html#couldnt-match-representation-of-type--arising-from-the-deriving-clause">Couldn't match representation of type: ... arising from the 'deriving' clause</a></li>
<li><a href="Troubleshooting.html#infinite-loop--infinite-ast">Infinite loop / Infinite AST</a></li>
<li><a href="Troubleshooting.html#couldnt-match-type-plutarchdatareprinternalpunlabel--arising-from-a-use-of-pfield-or-getfield-or-pletfields">Couldn't match type <code>Plutarch.DataRepr.Internal.PUnLabel ...</code> arising from a use of <code>pfield</code> (or <code>getField</code>, or <code>pletFields</code>)</a></li>
<li><a href="Troubleshooting.html#expected-a-type-but-fieldname-has-kind-ghctypessymbol">Expected a type, but "fieldName" has kind <code>GHC.Types.Symbol</code></a></li>
<li><a href="Troubleshooting.html#lifting-pasdata">Lifting <code>PAsData</code></a></li>
<li><a href="Troubleshooting.html#type-match-errors-when-using-pfieldgetfield-or-overloadedrecorddot-to-access-field">Type match errors when using <code>pfield</code>/<code>getField</code> (or <code>OverloadedRecordDot</code> to access field)</a></li>
</ul>
</details>
<h1 id="no-instance-for-punsafeliftdecl-a"><a class="header" href="#no-instance-for-punsafeliftdecl-a">No instance for <code>PUnsafeLiftDecl a</code></a></h1>
<p>You should add <code>PLift a</code> to the context! <code>PLift</code> is just a synonym to <code>PUnsafeLiftDecl</code>.</p>
<h1 id="couldnt-match-representation-of-type--arising-from-the-deriving-clause"><a class="header" href="#couldnt-match-representation-of-type--arising-from-the-deriving-clause">Couldn't match representation of type: ... arising from the 'deriving' clause</a></h1>
<p>If you're getting these errors when deriving typeclasses using the machinery provided by Plutarch
(e.g. generic deriving of <code>PlutusType</code>) - it means you're missing a constructor import.</p>
<h1 id="infinite-loop--infinite-ast"><a class="header" href="#infinite-loop--infinite-ast">Infinite loop / Infinite AST</a></h1>
<p>While may not be immediately obvious, things like the following are a no-go in Plutarch:</p>
<pre><code class="language-haskell">f :: Term s (PInteger :--&gt; PInteger)
f = phoistAcyclic $ plam $ \n -&gt;
  pif (n #== 0)
    0
    (n + f # (n - 1))
</code></pre>
<p>The issue here is that the AST is infinitely large. Plutarch will try to traverse this AST and will in
the process not terminate, as there is no end to it. In these cases, consider using <code>pfix</code>.</p>
<p>Relevant issue: <a href="https://github.com/Plutonomicon/plutarch/issues/19">#19</a></p>
<h1 id="couldnt-match-type-plutarchdatareprinternalpunlabel--arising-from-a-use-of-pfield-getfield"><a class="header" href="#couldnt-match-type-plutarchdatareprinternalpunlabel--arising-from-a-use-of-pfield-getfield">Couldn't match type <code>Plutarch.DataRepr.Internal.PUnLabel ...</code> arising from a use of <code>pfield</code>, <code>getField</code>,</a></h1>
<p><code>pletFields</code>, <code>hrecField</code> (deprecated)</p>
<p>You might get some weird errors when using <code>pfield</code>/<code>getField</code>/<code>pletFields</code> like the above. Don't be scared! It just
means that the type application you used is incorrect. Specifically, the type application names a non-existent field.
Re-check the field name string you used in the type application for typos!</p>
<h1 id="expected-a-type-but-fieldname-has-kind-ghctypessymbol"><a class="header" href="#expected-a-type-but-fieldname-has-kind-ghctypessymbol">Expected a type, but "fieldName" has kind <code>GHC.Types.Symbol</code></a></h1>
<p>This just means the argument of a type application wasn't correctly promoted. Most likely arising from a usage of
<code>pletFields</code>. In the case of <code>pfield</code> and <code>getField</code>, the argument of type application should have kind <code>Symbol</code>.
A simple string literal representing the field name should work in this case. In the case of <code>pletFields</code>, the
argument of type application should have kind <code>[Symbol]</code> - a type level list of types with kind <code>Symbol</code>. When you use
a singleton list here, like <code>["foo"]</code> - it's actually parsed as something of <em>kind</em> <code>Type</code> (like <code>[a]</code>).</p>
<p>All you need to do, is put a <code>'</code> (quote) in front of the list, like so- <code>@'["foo"]</code>. This will promote the list
constructor to the type level.</p>
<h1 id="lifting-pasdata"><a class="header" href="#lifting-pasdata">Lifting <code>PAsData</code></a></h1>
<p>Don't try to lift a <code>PAsData</code> term! It's intentionally blocked and partial. The <code>PLift</code> instance for <code>PAsData</code> is
only there to make some important functionality work correctly. But the instance methods will simply <code>error</code> if used.
Instead, you should either use <code>pforgetData</code> and <code>plift</code> that, or extract the <code>Term s a</code> out of <code>Term s (PAsData a)</code>
using <code>pfromData</code> and <code>plift</code> that instead!</p>
<h1 id="type-match-errors-when-using-pfieldgetfield-or-overloadedrecorddot-or-hrecfielddeprecated-to-access-field"><a class="header" href="#type-match-errors-when-using-pfieldgetfield-or-overloadedrecorddot-or-hrecfielddeprecated-to-access-field">Type match errors when using <code>pfield</code>/<code>getField</code> (or <code>OverloadedRecordDot</code>, or <code>hrecField</code>(deprecated)) to access field</a></h1>
<p>You might get nonsensical "Couldn't match type" errors when extracting fields. This has to do with GHC
incorrectly inferring the return type. Field extraction is meant to be polymorphic in its return type in the sense that
it might either return a <code>Term s (PAsData p)</code> term, or simply a <code>Term s p</code> (automatic <code>pfromData</code>). Unfortunately,
sometimes this polymorphism makes it harder for GHC to infer the types. Also be aware that this automatic <code>pfromData</code>
will infer <code>PAsData</code>d terms more eagerly.</p>
<p>You can fix this by providing an explicit type annotation on <em>the result</em> of <code>pfield</code> or <code>getField</code> (or
<code>OverloadedRecordDot</code> for field access). Otherwise, you can also explicitly use <code>pfromData</code> on the result.
This will also help to make code more readable and is generally a good idea as plutarch validators and policies
tend to get very long and consequently confusing without explicit type annotations on the bound terms.</p>
<p>Relevant issue: <a href="https://github.com/Plutonomicon/plutarch/issues/275">#275</a></p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.BasicExample (fib) where

import Plutarch.Prelude
</code></pre>
</p>
</details>
Basic examples demonstrating Plutarch usage.
<blockquote>
<p>Note: If you spot any mistakes/have any related questions that this guide lacks the answer to, please don't hesitate to raise an issue. The goal is to have high quality documentation for Plutarch users!</p>
</blockquote>
<blockquote>
<p>Aside: Be sure to check out <a href="examples/./../Overview.html#compiling-and-running">Compiling and Running</a> first!</p>
</blockquote>
<h1 id="fibonacci-number-at-given-index"><a class="header" href="#fibonacci-number-at-given-index">Fibonacci number at given index</a></h1>
<pre><code class="language-haskell">fib :: Term s (PInteger :--&gt; PInteger)
fib = phoistAcyclic $
  pfix #$ plam $ \self n -&gt;
    pif
      (n #== 0)
      0
      $ pif
        (n #== 1)
        1
        $ self # (n - 1) + self # (n - 2)
</code></pre>
<p>Execution:</p>
<pre><code class="language-hs">&gt; evalT $ fib # 2
Right (Program () (Version () 1 0 0) (Constant () (Some (ValueOf integer 2))))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">{-# LANGUAGE QualifiedDo #-}
{-# LANGUAGE OverloadedRecordDot #-}
module Plutarch.Docs.ValidatorExample (alwaysSucceeds, checkSignatory, res', res, alwaysFails) where

import Plutarch.Prelude
import Plutarch.LedgerApi.V3 (
  PDatum,
  PRedeemer,
  PScriptContext (pscriptContext'scriptInfo, pscriptContext'txInfo),
  PTxInfo (ptxInfo'signatories),
  PPubKeyHash,
  PScriptInfo(PSpendingScript)
  )
import Plutarch.Docs.Run (evalWithArgsT)
import Plutarch.Script (Script)
import qualified PlutusTx
import PlutusCore.Evaluation.Machine.ExBudget (ExBudget)
import Data.Text (Text)
</code></pre>
</p>
</details>
Examples of validators and minting policies written in Plutarch.
<blockquote>
<p>Note: If you spot any mistakes/have any related questions that this guide lacks the answer to, please don't hesitate to raise an issue. The goal is to have high quality documentation for Plutarch users!</p>
</blockquote>
<ul>
<li><a href="examples/VALIDATOR.html#validator-that-always-succeeds">Validator that always succeeds</a></li>
<li><a href="examples/VALIDATOR.html#validator-that-always-fails">Validator that always fails</a></li>
<li><a href="examples/VALIDATOR.html#validator-that-checks-whether-a-value-is-present-within-signatories">Validator that checks whether a value is present within signatories</a></li>
<li><a href="examples/VALIDATOR.html#using-custom-datumredeemer-in-your-validator">Using custom datum/redeemer in your Validator</a></li>
</ul>
<blockquote>
<p>Aside: Be sure to check out <a href="examples/./../Overview.html#compiling-and-running">Compiling and Running</a> first!</p>
</blockquote>
<h1 id="validator-that-always-succeeds"><a class="header" href="#validator-that-always-succeeds">Validator that always succeeds</a></h1>
<pre><code class="language-haskell">alwaysSucceeds :: Term s (PAsData PDatum :--&gt; PAsData PRedeemer :--&gt; PAsData PScriptContext :--&gt; PUnit)
alwaysSucceeds = plam $ \_datm _redm _ctx -&gt; pconstant ()
</code></pre>
<p>All the arguments are ignored.</p>
<p>Execution:</p>
<pre><code class="language-haskell">res' :: Either Text (Script, ExBudget, [Text])
res' = alwaysSucceeds `evalWithArgsT` [PlutusTx.toData (), PlutusTx.toData (), PlutusTx.toData ()]
-- &gt;&gt;&gt; res'
-- Right (Program () (Version () 1 0 0) (Constant () (Some (ValueOf unit ()))))
</code></pre>
<h1 id="validator-that-always-fails"><a class="header" href="#validator-that-always-fails">Validator that always fails</a></h1>
<pre><code class="language-haskell">alwaysFails :: Term s (PAsData PDatum :--&gt; PAsData PRedeemer :--&gt; PAsData PScriptContext :--&gt; PUnit)
alwaysFails = plam $ \_datm _redm _ctx -&gt; perror
</code></pre>
<p>Similar to the example above.</p>
<p>Execution:</p>
<pre><code class="language-haskell">res :: Either Text (Script, ExBudget, [Text])
res = alwaysFails `evalWithArgsT` [PlutusTx.toData (), PlutusTx.toData (), PlutusTx.toData ()]
-- &gt;&gt;&gt; res
-- Left (EvaluationError [] "(CekEvaluationFailure,Nothing)")
</code></pre>
<h1 id="validator-that-checks-whether-a-value-is-present-within-signatories"><a class="header" href="#validator-that-checks-whether-a-value-is-present-within-signatories">Validator that checks whether a value is present within signatories</a></h1>
<pre><code class="language-haskell">
checkSignatory :: Term s (PPubKeyHash :--&gt; PAsData PDatum :--&gt; PAsData PRedeemer :--&gt; PScriptContext :--&gt; PUnit)
checkSignatory = plam $ \ph _ _ ctx' -&gt; unTermCont $ do
  ctx &lt;- pmatchC ctx'
  PSpendingScript _ _ &lt;- pmatchC $ pscriptContext'scriptInfo ctx
  txInfo &lt;- pmatchC $ pscriptContext'txInfo ctx
  let signatories = ptxInfo'signatories txInfo
  pure $
    pif
      (pelem # pdata ph # pfromData signatories)
      -- Success!
      (pconstant ())
      -- Signature not present.
      perror
</code></pre>
<blockquote>
<p>Note: The above snippet uses GHC 9 features (<code>QualifiedDo</code> and <code>OverloadedRecordDot</code>). Be sure to check out <a href="examples/./../Usage/DoSyntaxWithTermCont.html">Do syntax with <code>TermCont</code></a> and <a href="examples/../Typeclasses/PIsDataReprAndPDataFields.html#alternatives-to-overloadedrecorddot">alternatives to <code>OverloadedRecordDot</code></a>.</p>
</blockquote>
<p>We match on the script purpose to see if its actually for <em>spending</em> - and we get the signatories field from <code>txInfo</code> (the 7th field), check if the given pub key hash is present within the signatories and that's it!</p>
<p>It's important that we pass a <code>PPubKeyHash</code> <em>prior</em> to treating <code>checkSignatory</code> as a validator script.</p>
<pre><code class="language-hs">{-# LANGUAGE OverloadedStrings #-}

import Plutus.V1.Ledger.Api
import Plutus.V1.Ledger.Interval
import qualified PlutusTx

hashStr :: PubKeyHash
hashStr = "abce0f123e"

pubKeyHash :: Term s PPubKeyHash
pubKeyHash = pconstant hashStr

mockCtx :: ScriptContext
mockCtx =
  ScriptContext
    (TxInfo
      mempty
      mempty
      mempty
      mempty
      mempty
      mempty
      (interval (POSIXTime 1) (POSIXTime 2))
      [fromString hashStr, "f013", "ab45"]
      mempty
      ""
    )
    (Spending (TxOutRef "" 1))

&gt; evalWithArgsT (checkSignatory # pubKeyHash) [PlutusTx.toData (), PlutusTx.toData (), PlutusTx.toData mockCtx]
Right (Program () (Version () 1 0 0) (Constant () (Some (ValueOf unit ()))))
</code></pre>
<h1 id="using-custom-datumredeemer-in-your-validator"><a class="header" href="#using-custom-datumredeemer-in-your-validator">Using custom datum/redeemer in your Validator</a></h1>
<p>All you have to do is <a href="examples/../Typeclasses/PIsDataReprAndPDataFields.html#implementing-pisdatarepr-and-friends">implement <code>PIsDataRepr</code> and friends</a> for your custom datum/redeemer and you can use it just like <code>PScriptContext</code> in your validators!</p>
<div style="break-before: page; page-break-before: always;"></div><p>This section describes various concepts applicable in Plutarch.</p>
<blockquote>
<p>Note: If you spot any mistakes/have any related questions that this guide lacks the answer to, please don't hesitate to raise an issue. The goal is to have high quality documentation for Plutarch users!</p>
</blockquote>
<ul>
<li><a href="./Concepts/Hoisting.html">Hoisting, metaprogramming, and fundamentals</a>
<ul>
<li><a href="./Concepts/Hoisting.html#hoisting-operators">Hoisting Operators</a></li>
</ul>
</li>
<li><a href="./Concepts/WhatIsTheS.html#what-is-the-s">What is the <code>s</code>?</a></li>
<li><a href="./Concepts/DataAndScottEncoding.html">Data encoding and Scott encoding</a>
<ul>
<li><a href="./Concepts/DataAndScottEncoding.html#data-encoding">Data encoding</a></li>
<li><a href="./Concepts/DataAndScottEncoding.html#scott-encoding">Scott encoding</a></li>
</ul>
</li>
<li><a href="./Concepts/HaskellSynonym.html">Haskell synonym of Plutarch types</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">{-# LANGUAGE RankNTypes #-}
module Plutarch.Docs.DataAndScottEncoding (nothing, just, foo) where

import Prelude (Integer, (+))
</code></pre>
</p>
</details>
<h1 id="data-encoding-and-scott-encoding"><a class="header" href="#data-encoding-and-scott-encoding">Data encoding and Scott encoding</a></h1>
<p>In Plutus Core, there are multiple (conflicting) ways to represent non-trivial ADTs: <a href="https://plutonomicon.github.io/plutarch-plutus/haddock/plutus-ledger-api/html/PlutusLedgerApi-V3.html#t:Data"><code>Constr</code></a> data encoding, Scott encoding, or native SoP added in UPLC 1.1.0. You should use only one of these representations for your non-trivial types.</p>
<blockquote>
<p>Aside: What's a "trivial" type? The non-data builtin types! <code>PInteger</code>, <code>PByteString</code>, <code>PBuiltinList</code>, <code>PBuiltinPair</code>, and <code>PMap</code> (actually just a builtin list of builtin pairs). It's important to note that <a href="https://plutonomicon.github.io/plutarch-plutus/haddock/plutus-ledger-api/html/PlutusLedgerApi-V3.html#t:Data"><code>Data</code></a> (<code>Constr</code> or otherwise) is also a builtin type.</p>
</blockquote>
<h2 id="data-encoding"><a class="header" href="#data-encoding">Data encoding</a></h2>
<p><code>Constr</code> data is essentially a sum-of-products representation. However, it can only contain other <code>Data</code> values (not necessarily just <code>Constr</code> data, could be <code>I</code> data, <code>B</code> data etc.) as its fields. Plutus Core famously lacks the ability to represent functions using this encoding, and thus <code>Constr</code> encoded values simply cannot contain functions.</p>
<blockquote>
<p>Note: You can find out more about the deep details of <code>Data</code>/<code>BuiltinData</code> at <a href="https://github.com/Plutonomicon/plutonomicon/blob/main/builtin-data.md">plutonomicon</a>.</p>
</blockquote>
<p>With that said, <code>Data</code> encoding is <em>ubiquitous</em> on the chain. It's the encoding used by the ledger api types, it's the type of the arguments that can be passed to a script on the chain etc. As a result, your datums and redeemers <em>must</em> use data encoding.</p>
<h2 id="scott-encoding"><a class="header" href="#scott-encoding">Scott encoding</a></h2>
<p>On the opposite (and conflicting) end, is Scott encoding. <a href="https://crypto.stanford.edu/~blynn/compiler/scott.html">The internet</a> can explain Scott encoding way better than I can. But I'll be demonstrating Scott encoding with an example anyway.</p>
<p>Firstly, what good is Scott encoding? Well it doesn't share the limitation of not being able to contain functions! However, you cannot use Scott encoded types within, for example, your datums and redeemers.</p>
<p>Briefly, Scott encoding is a way to represent data with functions. The Scott encoded representation of <code>Maybe a</code> would be:</p>
<pre><code class="language-hs">(a -&gt; b) -&gt; b -&gt; b
</code></pre>
<p><code>Just 42</code>, for example, would be represented as this function:</p>
<pre><code class="language-hs">\f _ -&gt; f 42
</code></pre>
<p>Whereas <code>Nothing</code> would be represented as this function:</p>
<pre><code class="language-hs">\_ n -&gt; n
</code></pre>
<p>We covered construction. What about usage/deconstruction? That's also just as simple. Let's say you have a function, <code>foo :: Maybe Integer -&gt; Integer</code>, it takes in a Scott encoded <code>Maybe Integer</code>, and adds <code>42</code> to its <code>Just</code> value. If it's <code>Nothing</code>, it just returns <code>0</code>.</p>
<pre><code class="language-haskell">type Maybe a = forall b. (a -&gt; b) -&gt; b -&gt; b

just :: a -&gt; Maybe a
just x = \f _ -&gt; f x

nothing :: Maybe a
nothing = \_ n -&gt; n

foo :: Maybe Integer -&gt; Integer
foo mb = mb (\x -&gt; x + 42) 0
</code></pre>
<p>How does that work? Recall that <code>mb</code> is really just a function. Here's how the application of <code>f</code> would work:</p>
<pre><code class="language-hs">foo (just 1)
foo (\f _ -&gt; f 1)
(\f _ -&gt; f 1) (\x -&gt; x + 42) 0
(\x -&gt; x + 42) 1
43
</code></pre>
<pre><code class="language-hs">foo nothing
foo (\_ n -&gt; n)
(\_ n -&gt; n) (\x -&gt; x + 42) 0
0
</code></pre>
<p>Neat!</p>
<p>This is the same recipe followed in the implementation of <code>PMaybe</code>. See its <a href="Concepts/./../Typeclasses/PlutusType,PCon,PMatch.html">PlutusType impl</a>!</p>
<h2 id="sop-encoding"><a class="header" href="#sop-encoding">SoP Encoding</a></h2>
<p>SoP stands for Sum of Product and it is another way of encoding data types. UPLC introduced these as a native construct with two new UPLC constructors, <code>Constr</code> that encodes a numerical tag (that is used to encode which constructor is used) and a list of terms (that represent fields of the constructor) and <code>Case</code> - an eliminator that given a <code>Vector</code> of terms that handle each of the constructors and all evaluate to the same value.</p>
<p>To use SoP datatype representation you can use <code>DeriveAsSOPStruct</code> <code>deriving via</code> helper, see how <code>Maybe</code> is doing it in <a href="Concepts/./../Typeclasses/PlutusType,PCon,PMatch.html">PlutusType section</a></p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">{-# OPTIONS_GHC -Wno-redundant-constraints #-}
{-# LANGUAGE UndecidableInstances #-}

module Plutarch.Docs.PMatch (Tree(..), swap, TreeRepr) where
import Plutarch.Prelude
import Plutarch.Internal.PlutusType (PlutusType (pcon', pmatch'))
import Data.Kind (Type)
import GHC.Generics (Generic)
import Generics.SOP qualified as SOP
import Plutarch.Unsafe (punsafeCoerce)
</code></pre>
</p>
</details>
<h1 id="generic-programming-over-plutarch-types"><a class="header" href="#generic-programming-over-plutarch-types">Generic programming over Plutarch types</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<h3 id="term"><a class="header" href="#term"><code>Term</code></a></h3>
<p>A <code>Term</code> or <code>ClosedTerm</code> represents Plutus Lambda Calculus expression in Plutarch world.
Allows for additional checks and safety compared to UPLC.
See more: <a href="Concepts/../Introduction/PlutarchTerms.html">Plutarch Terms</a>.</p>
<h3 id="data-and-scott-encoding"><a class="header" href="#data-and-scott-encoding">Data and Scott encoding</a></h3>
<p>Datatypes can be encoded using Scott and <code>Data</code> encoding.
These concepts are well explained in Plutonomicon:
<a href="Concepts/../Concepts/DataAndScottEncoding.html#data-encoding">Data encoding</a>
and <a href="Concepts/../Concepts/DataAndScottEncoding.html#scott-encoding">Scott encoding</a>.</p>
<h3 id="anyclass-deriving-strategy"><a class="header" href="#anyclass-deriving-strategy"><code>anyclass</code> deriving strategy</a></h3>
<p><code>anyclass</code> derivation strategy uses default implementation of given typeclass to derive an instance of it.
Usually depends that given datatype derives <code>Generic</code> typeclass also or some other too.</p>
<h3 id="generics-sop"><a class="header" href="#generics-sop">generics-sop</a></h3>
<p>A really good introduction to <code>generics-sop</code> by the maker of the library, Andres Löh, can be found
<a href="https://www.youtube.com/watch?v=pwnrfREbhWY">in this YouTube video recorded at the 2020 ZuriHac</a></p>
<p>Overall image of <a href="https://github.com/well-typed/generics-sop">generics-sop</a> package.</p>
<p><a href="https://srid.ca/generics-sop-intro">Introduction by srid</a>.</p>
<p>Why is sum-of-products considered? It's very close to what developers think JSON is.</p>
<p>Generic representation of ADTs as sum of products, which can be automatically derived.
Some commonly used types/functions:</p>
<pre><code>I - Identity functor (`newtype I a = I a`)
K - Constant functor (`newtype K a b = K a`)

Z - zero (as in Peano numbers)
S - successor (as in Peano numbers)

&lt;https://hackage.haskell.org/package/generics-sop-0.5.1.2/docs/Generics-SOP.html#t:NS&gt;
NS - n-ary Sum
Picking nth element of sum comes from composing Z and S

&lt;https://hackage.haskell.org/package/generics-sop-0.5.1.2/docs/Generics-SOP.html#t:NP&gt;
NP - n-ary Product
Value level witness for a list of types parametrized by some functor f.

SOP - sum of products
`SOP I` corresponds to haskell's structure of given SOP encoded datatype.
`SOP (Term s)` corresponds to Plutarch structure of given SOP encoded datatype.

`Code a`
The code of a datatype.

This is a list of lists of its components. The outer list contains one element per constructor. The inner list contains one element per constructor argument (field).
</code></pre>
<pre><code class="language-haskell">data Tree = Leaf Int | Node Tree Tree
</code></pre>
<p>is supposed to have the following Representation:</p>
<pre><code class="language-haskell">type TreeRepr =
  '[ '[ Int ]
   , '[ Tree, Tree ]
   ]
</code></pre>
<pre><code class="language-hs">-- Generic representation of given Haskell datatype
type Rep a = SOP I (Code a)
</code></pre>
<p>This mechanism allows for generic programming over Haskell types and Plutarch types</p>
<h2 id="intro"><a class="header" href="#intro">Intro</a></h2>
<p>As Plutarch is an eDSL in Haskell, it does not allow us to work on Plutus-level variables directly.
Manipulating ADTs can be done in terms of <code>pcon</code> and <code>pmatch</code> which belong to a class called <code>PlutusType</code>.</p>
<p>How this class is implemented is not that important but can be looked up in <code>Plutarch/Internal/PlutusType.hs</code>
by the interested reader.</p>
<p>These typeclass methods could be written manually, but is a bit tedious and error-prone, thus the generic
representation from <code>GHC.Generics</code> is used.
Under the hood all necessary transformations are done to be able to access the data on Haskell level.</p>
<p>Also - as parsing data costs computation resources, it is common to pass tagged raw data until it's really needed to parse.
<code>PlutusType</code> typeclass serves 2 purposes:</p>
<ol>
<li>Adds derivation via anyclass for Haskell ADTs</li>
<li>Manipulates given <code>S -&gt; Type</code> on its internal representation (provided as type <code>PInner</code>),
rather than parsing/constructing the datatype back and forth.</li>
</ol>
<p>Examples on how to derive <code>PlutusType</code> to either Data or SOP encoding:</p>
<pre><code class="language-haskell">data MyType (a :: S -&gt; Type) (b :: S -&gt; Type) (s :: S)
  = One (Term s a)
  | Two (Term s b)
  deriving stock (Generic)
  deriving anyclass (SOP.Generic)
  deriving (PlutusType) via (DeriveAsSOPStruct (MyType a b))

-- If you instead want to use data encoding, you should derive 'PlutusType' and provide data strategy:

data MyTypeD (a :: S -&gt; Type) (b :: S -&gt; Type) (s :: S)
  = OneD (Term s (PAsData a))
  | TwoD (Term s (PAsData b))
  deriving stock (Generic)
  deriving anyclass (SOP.Generic)
  deriving (PlutusType) via (DeriveAsDataStruct (MyTypeD a b))

-- Alternatively, you may derive 'PlutusType' by hand as well. A simple example, encoding a
-- Sum type as an Enum via PInteger:

data AB (s :: S) = A | B

instance PlutusType AB where
  type PInner AB = PInteger

  pcon' A = 0
  pcon' B = 1

  pmatch' x f =
    pif (x #== 0) (f A) (f B)


-- instead of using `pcon'` and `pmatch'` directly,
-- use 'pcon' and 'pmatch', to hide the `PInner` type:

swap :: Term s AB -&gt; Term s AB
swap x = pmatch x $ \case
  A -&gt; pcon B
  B -&gt; pcon A
</code></pre>
<p><code>Maybe</code> manually encoded in both ways:</p>
<pre><code class="language-haskell">-- | Scott
data PSMaybe a s = PSJust (Term s a) | PSNothing

-- | Newtype wrapper around function that represents Scott encoding,
-- | Plutarch uses generic one for deriving.
newtype ScottEncodedMaybe a b s = ScottEncodedMaybe (Term s ((a :--&gt; b) :--&gt; PDelayed b :--&gt; b))

instance PlutusType (ScottEncodedMaybe a r) where
  type PInner (ScottEncodedMaybe a r) = (a :--&gt; r) :--&gt; PDelayed r :--&gt; r
  pcon' (ScottEncodedMaybe x) = x
  pmatch' x f = f (ScottEncodedMaybe x)

instance PlutusType (PSMaybe a) where
  -- The resulting type of pattern matching on Maybe is quantified via `PForall`
  type PInner (PSMaybe a) = PForall (ScottEncodedMaybe a)
  pcon' (PSJust x) = pcon $ PForall $ pcon $ ScottEncodedMaybe $ plam $ \f _ -&gt; f # x
  pcon' PSNothing = pcon $ PForall $ pcon $ ScottEncodedMaybe $ plam $ \_ g -&gt; pforce g
  pmatch' x' f =
    pmatch x' $ \(PForall sem) -&gt;
      pmatch sem $ \(ScottEncodedMaybe x) -&gt;
        x # plam (f . PSJust) # pdelay (f PSNothing)

-- | Maybe encoded using Constr
data PMaybeData a (s :: S)
  = PDJust (Term s a)
  | PDNothing

-- | Note - thing hold in PMaybeData must be able to be represented as Data too, not needed in case of Scott version
instance PIsData a =&gt; PlutusType (PMaybeData a) where
  type PInner (PMaybeData a) = PData
  pcon' (PDJust x) = pforgetData $ pconstrBuiltin # 0 #$ psingleton # pforgetData (pdata x)
  pcon' PDNothing = pforgetData $ pconstrBuiltin # 1 # pnil
  pmatch' x f = (`runTermCont` f) $ do
    constrPair &lt;- TermCont $ plet (pasConstr # x)
    indexNum &lt;- TermCont $ plet (pfstBuiltin # constrPair)
    TermCont $ \g -&gt; pif (indexNum #== 0)
        (g $ PDJust $ punsafeCoerce $ phead # (psndBuiltin # constrPair))
        (pif (indexNum #== 1)
          (g PDNothing)
          perror
        )

</code></pre>
<h3 id="generic-derivation-of-pconpmatch"><a class="header" href="#generic-derivation-of-pconpmatch">Generic derivation of PCon/PMatch</a></h3>
<p>The mechanism of <code>PlutusType</code> derivation relies heavily on generic representation of ADT as sum-of-products.
Very high level overview:
For <code>pmatch</code>:</p>
<ul>
<li>Scott encoding - for each <code>sum</code> branch, create a corresponding <code>plam</code> handler</li>
<li>Data encoding - for each <code>sum</code> branch, apply each element of list in <code>Constr</code> to a handler</li>
</ul>
<p>For <code>pcon</code>:</p>
<ul>
<li>Scott encoding - encode data type as lambda</li>
<li>Data encoding - create a <code>Constr</code> with corresponding number of constructor</li>
</ul>
<h2 id="recommended-patterns-when-working-with-pconpmatch"><a class="header" href="#recommended-patterns-when-working-with-pconpmatch">Recommended patterns when working with pcon/pmatch</a></h2>
<ul>
<li><a href="Concepts/../../Tricks/PreferMatchingOnPmatchResultImmediately.html">Tricks - Prefer matching on pmatch result immediately</a></li>
<li><a href="Concepts/../../Typeclasses/PlutusType,PCon,PMatch.html">Typeclasses - PlutusType, PCon, and PMatch - derive instances automatically</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="haskell-synonym-of-plutarch-types"><a class="header" href="#haskell-synonym-of-plutarch-types">Haskell synonym of Plutarch types</a></h1>
<p>Several sections of the guide use the terminology "Haskell synonym". What does it mean? It's simply the Haskell type that <em>is supposed to</em> correspond to a Plutarch type. There doesn't <em>necessarily</em> have to be some sort of concrete connection (though there can be, using <a href="Concepts/../Typeclasses/PLiftable.html"><code>PLiftable</code></a>) - it's merely a connection you can establish mentally.</p>
<p>This detail does come into play in concrete use cases though. After compiling your Plutarch code to a <code>Script</code>, when you pass Haskell data types as arguments to the <code>Script</code> - they obviously need to correspond to the actual arguments of the Plutarch code. For example, if the Plutarch code is a function taking <code>PByteString</code>, after compilation to <code>Script</code>, you <em>should</em> pass in the Haskell data type that actually shares the same representation as <code>PByteString</code> - the "Haskell synonym", so to speak. In this case, that's <code>ByteString</code>*.</p>
<p>[*]: You can't actually pass a <code>ByteString</code> into a compiled script. Notice that you can only pass <code>Data</code> arguments using <code>applyArguments</code> (from <code>Plutarch.Evaluate</code>). The Haskell synonym to <code>Data</code> is <code>PAsData a</code> (for any <code>a</code>), and <code>PData</code>.</p>
<p>Also see: <a href="Concepts/../Tricks/RepresentationOfPlutarchType.html">Figuring out the representation of a Plutarch type</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.Hoisting (hor, (#||)) where
import Plutarch.Prelude hiding ((#||))
</code></pre>
</p>
</details>
<h1 id="hoisting-metaprogramming-and-fundamentals"><a class="header" href="#hoisting-metaprogramming-and-fundamentals">Hoisting, metaprogramming, and fundamentals</a></h1>
<p>Plutarch has a two-stage compilation process. First GHC compiles our code, then our code generates an <em>AST</em> of our Plutus script, which is then serialized using <code>compile</code>.</p>
<p>The important thing to note, is that when you have a definition like:</p>
<pre><code class="language-hs">x :: Term s PInteger
x = something complex
</code></pre>
<p>Any use of <code>x</code> will inline the <strong>full definition</strong> of <code>x</code>. <code>x + x</code> will duplicate <code>something complex</code> in the AST. To avoid this, you should <a href="Concepts/./../Tricks/DontDuplicateWork.html">use <code>plet</code> in order to avoid duplicate work</a>. Do note that this is <strong>strictly evaluated, and hence isn't always the best solution.</strong></p>
<p>There is however still a problem: what about top-level functions like <code>fib</code>, <code>sum</code>, <code>filter</code>, and such? We can use <code>plet</code> to avoid duplicating the definition, but this is error-prone. To do this perfectly means that each function that generates part of the AST would need to have access to the <code>plet</code>'ed definitions, meaning that we'd likely have to put it into a record or typeclass.</p>
<p>To solve this problem, Plutarch supports <em>hoisting</em>. Hoisting only works for <em>closed terms</em>, that is, terms that don't reference any free variables (introduced by <code>plam</code>).</p>
<p>Hoisted terms are essentially moved to a top-level <code>plet</code>, i.e. it's essentially common sub-expression elimination. Do note that because of this, your hoisted term is <strong>also strictly evaluated</strong>, meaning that you <em>shouldn't</em> hoist non-lazy complex computations (use <a href="Concepts/./../Introduction/DelayAndForce.html"><code>pdelay</code></a> to avoid this).</p>
<p>In general, you should use <code>phoistAcyclic</code> on every top level function:</p>
<pre><code class="language-hs">foo = phoistAcyclic $ plam $ \x -&gt; &lt;something complex&gt;
</code></pre>
<p>As long as the Plutarch lambda you're hoisting does not have <a href="https://wiki.haskell.org/Free_variable">free variables</a> (as Plutarch terms), you will be able to hoist it!</p>
<h2 id="hoisting-operators"><a class="header" href="#hoisting-operators">Hoisting Operators</a></h2>
<p>For the sake of convenience, you often would want to use operators - which must be Haskell level functions. This is the case for <code>+</code>, <code>-</code>, <code>#==</code> and many more.</p>
<p>Choosing convenience over efficiency is difficult, but if you notice that your operator uses complex logic and may end up creating big terms - you can trivially factor out the logic into a Plutarch level function, hoist it, and simply apply that function within the operator.</p>
<p>Consider "boolean or":</p>
<pre><code class="language-haskell">hor :: Term s PBool -&gt; Term s PBool -&gt; Term s PBool
x `hor` y = pif x (pconstant True) $ pif y (pconstant True) $ pconstant False
</code></pre>
<p>You can factor out most of the logic to a Plutarch level function, and apply that in the operator definition:</p>
<pre><code class="language-haskell">(#||) :: Term s PBool -&gt; Term s PBool -&gt; Term s PBool
x #|| y = pforce $ por # x # pdelay y

por :: Term s (PBool :--&gt; PDelayed PBool :--&gt; PDelayed PBool)
por = phoistAcyclic $ plam $ \x y -&gt; pif' # x # pdelay (pconstant True) # y
</code></pre>
<p>In general the pattern goes like this:</p>
<pre><code class="language-hs">(&lt;//&gt;) :: Term s x -&gt; Term s y -&gt; Term s z
x &lt;//&gt; y = f # x # y

f :: Term s (x :--&gt; y :--&gt; z)
f = phoistAcyclic $ plam $ \x y -&gt; &lt;complex computation&gt;
</code></pre>
<p>(OR, simply inlined)</p>
<pre><code class="language-hs">(&lt;//&gt;) :: Term s x -&gt; Term s y -&gt; Term s z
x &lt;//&gt; y = (\f -&gt; f # x # y) $ phoistAcyclic $ plam $ \x y -&gt; &lt;complex computation&gt;
</code></pre>
<blockquote>
<p>Note: You don't even need to export the Plutarch level function or anything! You can simply have that complex logic factored out into a <em>hoisted, internal Plutarch function</em> and everything will work just fine!</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-the-s"><a class="header" href="#what-is-the-s">What is the <code>s</code>?</a></h1>
<p>The <code>s</code> essentially represents the context, and is like the <code>s</code> of <code>ST</code>.</p>
<p>It's used to distinguish between closed and open terms:</p>
<ul>
<li>Closed term: <code>type ClosedTerm = forall s. Term s a</code></li>
<li>Arbitrary term: <code>exists s. Term s a</code></li>
<li>NB: <code>(exists s. Term s a) -&gt; b</code> is isomorphic to</li>
<li><code>forall s. Term s a -&gt; b</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>This section describes the fundamental, commonly used Plutarch types.</p>
<blockquote>
<p>Note: If you spot any mistakes/have any related questions that this guide lacks the answer to, please don't hesitate to raise an issue. The goal is to have high quality documentation for Plutarch users!</p>
</blockquote>
<ul>
<li><a href="./Types/PInteger.html"><code>PInteger</code></a></li>
<li><a href="./Types/PBool.html"><code>PBool</code></a></li>
<li><a href="./Types/PString.html"><code>PString</code></a></li>
<li><a href="./Types/PByteString.html"><code>PByteString</code></a></li>
<li><a href="./Types/PUnit.html"><code>PUnit</code></a></li>
<li><a href="./Types/PBuiltinList.html"><code>PBuiltinList</code></a></li>
<li><a href="./Types/PList.html"><code>PList</code></a></li>
<li><a href="./Types/PBuiltinPair.html"><code>PBuiltinPair</code></a></li>
<li><a href="./Types/PAsData.html"><code>PAsData</code></a></li>
<li><a href="./Types/PDataSumAndPDataRecord.html"><code>PDataSum</code> &amp; <code>PDataRecord</code></a></li>
<li><a href="./Types/PData.html"><code>PData</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.PAsData (fooData, fooConcrete) where 
import Plutarch.Prelude
</code></pre>
</p>
</details>
<h1 id="pasdata"><a class="header" href="#pasdata"><code>PAsData</code></a></h1>
<p>This is a typed way of representing <a href="https://github.com/Plutonomicon/plutonomicon/blob/main/builtin-data.md"><code>BuiltinData</code>/<code>Data</code></a>. It is highly encouraged you use <code>PAsData</code> to keep
track of what "species" of <code>Data</code> value you actually have. <code>Data</code> can be a <code>Constr</code> (for sum of products - ADTs), <code>Map</code> (for wrapping assoc maps of Data to Data), <code>List</code> (for wrapping
builtin lists of data), <code>I</code> (for wrapping builtin integers), and <code>B</code> (for wrapping builtin bytestrings).</p>
<p>Consider a function that takes in and returns a <code>B</code> data value - aka <code>ByteString</code> as a <code>Data</code> value. If you use the direct Plutarch synonym to <code>Data</code> - <code>PData</code>, you'd have:</p>
<pre><code class="language-haskell">fooData :: Term s (PData :--&gt; PData)
fooData = undefined
</code></pre>
<p>That's not very informative - you have no way to ensure that you're actually working with <code>B</code> data values. You could use <code>PAsData</code> instead:</p>
<pre><code class="language-haskell">fooConcrete :: Term s (PAsData PByteString :--&gt; PAsData PByteString)
fooConcrete = undefined
</code></pre>
<p>Now, you have assurance that you're working with a <code>Data</code> value that actually represents a builtin bytestring!</p>
<p>Wrapping and unwrapping to and from <code>PAsData</code> terms is provided by the <a href="Types/./../Typeclasses/PIsData.html"><code>PIsData</code></a> typeclass. Specifically, by the functions- <code>pfromData</code> and <code>pdata</code>.</p>
<p>Some useful instances of these functions:</p>
<pre><code class="language-hs">pfromData :: Term s (PAsData PInteger) -&gt; Term s PInteger

pfromData :: Term s (PAsData PByteString) -&gt; Term s PByteString

pfromData :: Term s (PAsData (PBuiltinList (PAsData a))) -&gt; Term s (PBuiltinList (PAsData a))

pdata :: Term s PInteger -&gt; Term s (PAsData PInteger)

pdata :: Term s PByteString -&gt; Term s (PAsData PByteString)

pdata :: Term s (PBuiltinList (PAsData a)) -&gt; Term s (PAsData (PBuiltinList (PAsData a)))
</code></pre>
<blockquote>
<p>Note: using <code>pfromData</code> and <code>pdata</code> on builtin primitive types (such as <code>PByteString</code>, <code>PInteger</code>, ...) has an associated cost. Use them sparingly and try to use them only
once if possible (i.e. if you used <code>pfromData</code> once, <code>plet</code> the result and reuse it.)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.PBool (pTheAnswer) where
import Plutarch.Prelude
</code></pre>
</p>
</details>
<h1 id="pbool"><a class="header" href="#pbool"><code>PBool</code></a></h1>
<p>Plutarch level boolean terms can be constructed using <code>pconstant True</code> and <code>pconstant False</code>.</p>
<pre><code class="language-haskell">pTheAnswer :: forall s. Term s PInteger
pTheAnswer = pif (pconstant False) 7 42
</code></pre>
<p>You can combine Plutarch booleans terms using <code>#&amp;&amp;</code> and <code>#||</code>, which are synonyms to <code>&amp;&amp;</code> and <code>||</code>. These are Haskell level operators and therefore have short circuiting.
If you don't need short circuiting, you can use the Plutarch level alternatives- <code>pand'</code> and <code>por'</code> respectively.</p>
<blockquote>
<p>Note: Be aware that there's a difference between <code>pif'</code> and <code>pif</code>, the former of which is strict (i.e. it evaluates both br&lt;anches eagerly), the latter of which is lazy.
<code>pif'</code> will be a Plutarch level function, whereas <code>pif</code> is Haskell level.</p>
</blockquote>
<p>This is synonymous to Plutus Core <a href="https://plutonomicon.github.io/plutarch-plutus/haddock/plutus-tx/html/PlutusTx-Builtins-Internal.html#t:BuiltinBool">builtin boolean</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">{-# OPTIONS_GHC -Wno-redundant-constraints #-}
module Plutarch.Docs.PBuiltinList (validBuiltinList, listOfBs, matchOnList, matchOnList') where
import Plutarch.Prelude
</code></pre>
</p>
</details>
<h1 id="pbuiltinlist"><a class="header" href="#pbuiltinlist"><code>PBuiltinList</code></a></h1>
<p>You'll be using builtin lists quite a lot in Plutarch. <code>PBuiltinList</code> has a <a href="Types/./../Typeclasses/PListLike.html"><code>PListLike</code></a> instance, giving you access to all the goodies from there!
However, <code>PBuiltinList</code> can only contain builtin types. In particular, it cannot contain Plutarch functions (which also implies it cannot contain scott-encoded datatypes).</p>
<p>You can express the constraint of "only builtin types" using <code>PLift</code>, exported from <code>Plutarch.Builtin</code>-</p>
<pre><code class="language-haskell">validBuiltinList :: forall a s. PLiftable a =&gt; Term s (PBuiltinList a)
validBuiltinList = undefined
</code></pre>
<p>As mentioned before, <code>PBuiltinList</code> gets access to all the <code>PListLike</code> utilities. Other than that, <code>PLift a =&gt; PBuiltinList a</code> also has a
<a href="Types/./../Typeclasses/PlutusType,PCon,PMatch.html"><code>PlutusType</code></a> instance. You can construct a <code>PBuiltinList</code> using <code>pcon</code> (but you should prefer using <code>pcons</code> from <code>PListLike</code>):</p>
<pre><code class="language-haskell">listOfBs :: forall s. Term s (PBuiltinList (PAsData PByteString))
listOfBs = pcon $ PCons (pdata $ phexByteStr "fe") $ pcon PNil
</code></pre>
<p>would yield a <code>PBuiltinList (PAsData PByteString)</code> with one element - <code>0xfe</code>. Of course, you could have done that with <code>pcons # pdata (phexByteStr "fe") # pnil</code> instead!</p>
<p>You can also use <code>pmatch</code> to match on a list:</p>
<pre><code class="language-haskell">matchOnList :: forall s. Term s PString
matchOnList = pmatch (pcon $ PCons (phexByteStr "fe") $ pcon PNil) $ \case
  PNil -&gt; "hey hey there's nothing here!"
  PCons _ _ -&gt; "oooo fancy!"
</code></pre>
<p>But you should prefer <code>pelimList</code> from <code>PListLike</code> instead:</p>
<pre><code class="language-haskell">matchOnList' :: forall s. Term s PString
matchOnList' = pelimList (\_ _ -&gt; "oooo fancy") "hey hey there's nothing here!" $ pcon $ PCons (phexByteStr "fe") $ pcon PNil
</code></pre>
<p>The first argument is a function that is invoked for the <code>PCons</code> case, with the head and tail of the list as arguments.</p>
<p>The second argument is the value to return when the list is empty. It's <em>only evaluated</em> <strong>if the list is empty</strong>.</p>
<p>The final argument is, of course, the list itself.</p>
<blockquote>
<p>Aside: Interested in the lower level details of <code>PBuiltinList</code> (i.e. Plutus Core builtin lists)? You can find all you need to
know about it at <a href="https://github.com/Plutonomicon/plutonomicon/blob/main/builtin-lists.md">Plutonomicon</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.PBuiltinPair () where 
import Plutarch.Prelude ()
</code></pre>
</p>
</details>
<h1 id="pbuiltinpair"><a class="header" href="#pbuiltinpair"><code>PBuiltinPair</code></a></h1>
<p>Much like in the case of builtin lists, you'll just be working with builtin functions (or rather, Plutarch synonyms to builtin functions) here. You can find everything about
that in <a href="https://github.com/Plutonomicon/plutonomicon/blob/main/builtin-pairs.md">builtin-pairs</a>. Feel free to only read the <code>Plutarch</code> examples.</p>
<p>In particular, you can deconstruct <code>PBuiltinPair</code> using <code>pfstBuiltin</code> and <code>psndBuiltin</code>. You can build <code>PBuiltinPair (PAsData a) (PAsData b)</code> terms with <code>ppairDataBuiltin</code>:</p>
<pre><code class="language-hs">ppairDataBuiltin :: Term s (PAsData a :--&gt; PAsData b :--&gt; PBuiltinPair (PAsData a) (PAsData b))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.PByteString (notQuiteTheAnswer, aChar) where
import Plutarch.Prelude
import qualified Data.ByteString as BS
</code></pre>
</p>
</details>
<h1 id="pbytestring"><a class="header" href="#pbytestring"><code>PByteString</code></a></h1>
<p>Plutarch level bytestring terms can be created using <code>phexByteStr</code> and <code>pconstant</code> (<code>pbyteStr</code> is deprecated). <code>phexByteStr</code> interprets a hex string literal as a
<code>Term s PByteString</code> and <code>pconstant</code> (<code>pbyteStr</code>) merely converts a <code>ByteString</code> into a <code>Term s PByteString</code>.</p>
<pre><code class="language-haskell">notQuiteTheAnswer :: forall s. Term s PByteString
notQuiteTheAnswer = phexByteStr "41"
-- yields a `Term s PByteString`, which represents [65]

aChar :: forall s. Term s PByteString
aChar = pconstant (BS.pack [91])
-- yields a `Term s PByteString`, which represents [91]
</code></pre>
<p>Similar to <code>PString</code>, it has a <code>PEq</code> instance. As well as <code>Semigroup</code> and <code>Monoid</code> instances for its terms.</p>
<p>It <strong>does not</strong> have a <code>PlutusType</code> instance.</p>
<p>This is synonymous to Plutus Core <a href="https://plutonomicon.github.io/plutarch-plutus/haddock/plutus-tx/html/PlutusTx-Builtins-Internal.html#t:BuiltinByteString">builtin bytestring</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.PData () where
import Plutarch.Prelude ()
</code></pre>
</p>
</details>
<h1 id="pdata"><a class="header" href="#pdata"><code>PData</code></a></h1>
<p>This is a direct synonym to <a href="https://github.com/Plutonomicon/plutonomicon/blob/main/builtin-data.md"><code>BuiltinData</code>/<code>Data</code></a>. As such,
it doesn't keep track of what "species" of <code>Data</code> it actually is. Is it an <code>I</code> data? Is it a <code>B</code> data? Nobody can tell for sure!</p>
<p>Consider using <a href="Types/./PAsData.html"><code>PAsData</code></a> instead for simple cases, i.e. cases other than <code>Constr</code>.</p>
<p>Consider using <a href="Types/./PDataSumAndPDataRecord.html"><code>PDataSum</code>/<code>PDataList</code></a> instead when dealing with ADTs, i.e. <code>Constr</code> data values.</p>
<p>You can find more information about <code>PData</code> at <a href="Types/../DEVGUIDE.html">Developers' Corner</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pdatasum-and-pdatarecord"><a class="header" href="#pdatasum-and-pdatarecord">PDataSum and PDataRecord</a></h1>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.PInteger () where
import Plutarch.Prelude ()
</code></pre>
</p>
</details>
<h1 id="pinteger"><a class="header" href="#pinteger"><code>PInteger</code></a></h1>
<p><code>Term s PInteger</code> has a convenient <code>Num</code> instance that allows you to construct Plutarch level integer terms from integer literals.
It also means you have all the typical arithmetic operations available to you:</p>
<pre><code class="language-hs">1 + 2
</code></pre>
<p>where <code>1</code> and <code>2</code> are <code>Term s PInteger</code>s.</p>
<p>Alongside <code>Num</code>, it also has a <code>PIntegral</code> instance, allowing you to use division, modulus etc.</p>
<p>It also has a <code>PEq</code> and <code>POrd</code> instance, allowing you to do Plutarch level equality and comparison.</p>
<p>It <strong>does not</strong> have a <code>PlutusType</code> instance.</p>
<blockquote>
<p>Note: be aware that GHC offers constant folding, i.e. at compile time expressions like <code>3 * 20000</code> will be folded to their result. This is important
because if you were to instead use the Plutarch level function, the evaluation would instead be delayed until plutarch runtime increasing the script
cost.</p>
</blockquote>
<p>This is synonymous to Plutus Core <a href="https://plutonomicon.github.io/plutarch-plutus/haddock/plutus-tx/html/PlutusTx-Builtins-Internal.html#t:BuiltinInteger">builtin integer</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.PList (pFe, pFeElim, pFeList) where
import Plutarch.Prelude
</code></pre>
</p>
</details>
<h1 id="plist"><a class="header" href="#plist"><code>PList</code></a></h1>
<p>Here's the <a href="Types/./../Concepts/DataAndScottEncoding.html#scott-encoding">Scott encoded</a> cousin of <code>PBuiltinList</code>. What does that mean? Well, in practice, it just means that <code>PList</code> can contain <em>any arbitrary</em> term - not just builtin types. <code>PList</code> also has a <a href="Types/./../Typeclasses/PListLike.html"><code>PListLike</code></a> instance - so you won't be missing any of those utilities here!</p>
<p><code>PList</code> also has a <a href="Types/../Typeclasses/PlutusType,PCon,PMatch.html"><code>PlutusType</code></a> instance. You can construct a <code>PList</code> using <code>pcon</code> (but you should prefer using <code>pcons</code> from <code>PListLike</code>):</p>
<pre><code class="language-haskell">pFeList :: forall s. Term s (PList PByteString)
pFeList = pcon $ PSCons (phexByteStr "fe") $ pcon PSNil
</code></pre>
<p>would yield a <code>PList PByteString</code> with one element - <code>0xfe</code>. Of course, you could have done that with <code>pcons # phexByteStr "fe" # pnil</code> instead!</p>
<p>You can also use <code>pmatch</code> to match on a list:</p>
<pre><code class="language-haskell">pFe :: forall s. Term s PString
pFe = pmatch (pcon $ PSCons (phexByteStr "fe") $ pcon PSNil) $ \case
  PSNil -&gt; "hey hey there's nothing here!"
  PSCons _ _ -&gt; "oooo fancy!"
</code></pre>
<p>But you should prefer <code>pelimList</code> from <code>PListLike</code> instead:</p>
<pre><code class="language-haskell">pFeElim :: forall s. Term s PString
pFeElim = pelimList (\_ _ -&gt; "oooo fancy") "hey hey there's nothing here!" $ pcon $ PSCons (phexByteStr "fe") $ pcon PSNil
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">{-# LANGUAGE OverloadedStrings #-}

module Plutarch.Docs.PString (pfoo) where
import Plutarch.Prelude
</code></pre>
</p>
</details>
<h1 id="pstring"><a class="header" href="#pstring"><code>PString</code></a></h1>
<p><code>Term s PString</code> has a <code>IsString</code> instance. This allows you to make Plutarch level string terms from regular string literals, provided you have <code>OverloadedStrings</code> turned on.</p>
<pre><code class="language-haskell">pfoo :: forall s. Term s PString
pfoo = "foo"
</code></pre>
<p>It also has a <code>PEq</code> instance. And its terms have <code>Semigroup</code> and <code>Monoid</code> instances - which work the way you would expect.</p>
<p>It <strong>does not</strong> have a <code>PlutusType</code> instance.</p>
<p>This is synonymous to Plutus Core <a href="https://plutonomicon.github.io/plutarch-plutus/haddock/plutus-tx/html/PlutusTx-Builtins-Internal.html#t:BuiltinString">builtin string</a> (actually Text).</p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.PUnit () where
import Plutarch.Prelude ()
</code></pre>
</p>
</details>
<h1 id="punit"><a class="header" href="#punit"><code>PUnit</code></a></h1>
<p>The Plutarch level unit term can be constructed using <code>pconstant ()</code> or <code>pcon PUnit</code>.</p>
<p>This is synonymous to Plutus Core <a href="https://plutonomicon.github.io/plutarch-plutus/haddock/plutus-tx/html/PlutusTx-Builtins-Internal.html#t:BuiltinUnit">builtin unit</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>This section describes the primary typeclasses used in Plutarch.</p>
<blockquote>
<p>Note: If you spot any mistakes/have any related questions that this guide lacks the answer to, please don't
hesitate to raise an issue. The goal is to have high quality documentation for Plutarch users!</p>
</blockquote>
<ul>
<li><a href="./Typeclasses/PEqAndPOrd.html"><code>PEq</code> &amp; <code>POrd</code></a></li>
<li><a href="./Typeclasses/PIntegral.html"><code>PIntegral</code></a></li>
<li><a href="./Typeclasses/PIsData.html"><code>PIsData</code></a></li>
<li><a href="./Typeclasses/PlutusType,PCon,PMatch.html"><code>PlutusType</code>, <code>PCon</code>, and <code>PMatch</code></a>
<ul>
<li><a href="./Typeclasses/PlutusType,PCon,PMatch.html#implementing-plutustype-for-your-own-types-scott-encoding">Implementing <code>PlutusType</code> for your own types (Scott Encoding)</a></li>
<li><a href="./Typeclasses/PlutusType,PCon,PMatch.html#implementing-plutustype-for-your-own-types-data-encoding">Implementing <code>PlutusType</code> for your own types (<code>Data</code> Encoding)</a></li>
<li><a href="./Typeclasses/PlutusType,PCon,PMatch.html#implementing-plutustype-for-your-own-types-newtype">Implementing <code>PlutusType</code> for your own types (<code>newtype</code>)</a></li>
</ul>
</li>
<li><a href="./Typeclasses/PLiftable.html"><code>PLiftable</code></a></li>
<li><a href="./Typeclasses/PListLike.html"><code>PListLike</code></a></li>
<li><a href="./Typeclasses/PIsDataReprAndPDataFields.html"><code>PIsDataRepr</code> &amp; <code>PDataFields</code></a>
<ul>
<li><a href="./Typeclasses/PIsDataReprAndPDataFields.html#all-about-extracting-fields">All about extracting fields</a>
<ul>
<li><a href="./Typeclasses/PIsDataReprAndPDataFields.html#alternatives-to-overloadedrecorddot">Alternatives to <code>OverloadedRecordDot</code></a></li>
</ul>
</li>
<li><a href="./Typeclasses/PIsDataReprAndPDataFields.html#all-about-constructing-data-values">All about constructing data values</a></li>
<li><a href="./Typeclasses/PIsDataReprAndPDataFields.html#implementing-pisdatarepr-and-friends">Implementing <code>PIsDataRepr</code> and friends</a></li>
</ul>
</li>
<li><a href="./Typeclasses/PTryFrom.html"><code>PTryFrom</code></a>
<ul>
<li><a href="./Typeclasses/PTryFrom.html#laws">Laws</a></li>
<li><a href="./Typeclasses/PTryFrom.html#ptryfromexcess"><code>PTryFromExcess</code></a></li>
<li><a href="./Typeclasses/PTryFrom.html#recovering-only-partially">Recovering only partially</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pliftable"><a class="header" href="#pliftable"><code>PLiftable</code></a></h1>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>You should be familiar with <code>PlutusType</code> and what it does, as well as how to
make instances of it. Furthermore, understanding how associated types and
<code>via</code>-deriving works is required. Lastly, familiarity with higher-rank arguments
is helpful, but not essential.</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>A <code>PlutusType</code> instance specifies two capabilities:</p>
<ul>
<li>Constructing a value by way of <code>pcon</code>; and</li>
<li>Matching on a value by way of <code>pmatch</code></li>
</ul>
<p>This is enough as long as we remain entirely in the Plutarch universe. However,
we often need to interact with Plutus stuff more
directly, and deal with equivalents to the types built-in to the Plutus default
universe (<code>Integer</code>, for example), as well as types that operate via a <code>Data</code>
encoding (such as most ledger stuff). We need to be able to create a 'bridge'
between the world that Plutus understands (Haskell, essentially) and Plutarch.</p>
<p><code>PLiftable</code> is designed to act as that bridge. If a type is an instance of
<code>PLiftable</code>, we have the following:</p>
<ul>
<li>A Haskell-level equivalent of this type</li>
<li>A way of transforming a value of the Haskell-level equivalent into a Plutarch
term</li>
<li>A way of transforming a closed Plutarch term into a Haskell-level equivalent
value (with the possibility of erroring)</li>
</ul>
<h2 id="the-type-class"><a class="header" href="#the-type-class">The type class</a></h2>
<p><code>PLiftable</code> is defined as follows:</p>
<pre><code class="language-haskell">class PlutusType a =&gt; PLiftable (a :: S -&gt; Type) where
    type AsHaskell a :: Type
    type PlutusRepr a :: Type
    toPlutarch :: forall (s :: S) . AsHaskell a -&gt; PLifted a s
    toPlutarchRepr :: AsHaskell a -&gt; PlutusRepr a
    fromPlutarch :: (forall (s :: S) . PLifted a s) -&gt; Either LiftError (AsHaskell a)
    fromPlutarchRepr :: PlutusRepr a -&gt; Maybe (AsHaskell a)
</code></pre>
<p>Even though we rarely need to interact with <code>PLiftable</code> and its methods
directly, it is worth understanding what exactly this type class requires from
its instances.</p>
<p>Firstly, we define an associated type <code>AsHaskell</code>, which determines the 'Haskell
equivalent' of the Plutarch type <code>a</code>. We can see which is which by looking at
the kinds involved: <code>a</code> has the kind <code>S -&gt; Type</code> (meaning, 'Plutarch type'),
while <code>AsHaskell a</code> has the kind <code>Type</code> (meaning, 'Haskell type'). We also note
that any type with a <code>PLiftable</code> instance must also have a <code>PlutusType</code>
instance; this is not surprising, as we need some way of operating on whatever
we bring into Plutarch.</p>
<p>In general, <code>AsHaskell a</code> must either be a type directly in the Plutus default
universe, or else a type which has a <code>Data</code> encoding. Nearly every case you are
likely to see, or define, will be one of these two. As a result, we provide two
helpers to derive such instances with less effort (further description of these
will come later).</p>
<p>We also define two methods: one for moving from the 'Haskell world' into the
'Plutarch world', and another for the opposite direction. We note that the
direction specified by <code>toPlutarch</code> is unconditional (cannot fail), whereas the
direction specified by <code>fromPlutarch</code> is conditional (can fail). This is because
a Plutarch term may represent a computation (valid or not), and to determine its
Haskell-equivalent value, we must compile and evaluate the term, which could
fail.</p>
<p>To fully grasp how these methods work, we need to examine two more types: the
<code>PLifted</code> wrapper, and the <code>LiftError</code> type:</p>
<pre><code class="language-haskell">newtype PLifted (a :: S -&gt; Type) (s :: S) = PLifted (Term s POpaque)

data LiftError
  = CouldNotEvaluate EvalError
  | TypeError BuiltinError
  | CouldNotCompile Text
  | CouldNotDecodeData
</code></pre>
<p><code>PLifted a s</code> is an implementation detail needed to drive <code>via</code>-derivation.
Whenever you see it, mentally substitute it for <code>Term s a</code>. Unless you plan to
write <code>PLiftable</code> instances by hand, you will never need to interact with this
type directly, or know anything about the distinction between <code>PLifted a s</code> and
<code>Term s a</code>. <code>LiftError</code> on the other hand designates all the ways in which
transforming a closed Plutarch term into its Haskell-level equivalent can fail:</p>
<ul>
<li>The term does not compile</li>
<li>The evaluation of the term errors instead of giving a value</li>
<li>We attempt to transform into a type not part of the Plutus default universe</li>
<li>We evaluate to an invalid <code>Data</code> encoding</li>
</ul>
<p>Once again, you almost never have to interact with this type directly unless
manually specifying an instance of this type class. The main advantage of having
a 'structured error type' here is debugging.</p>
<h2 id="defining-an-instance"><a class="header" href="#defining-an-instance">Defining an instance</a></h2>
<p>Aside from the manual method, we provide two <code>via</code>-deriving helpers, for the two
most common cases. We explain how to use each of them below. In almost all
situations, one of the two <code>via</code>-deriving helpers is what you want to use.</p>
<h3 id="via-derivebuiltinpliftable"><a class="header" href="#via-derivebuiltinpliftable">Via <code>DeriveBuiltinPLiftable</code></a></h3>
<p>This helper is designed for types which have direct representations in Haskell
using a type that's part of the default Plutus universe. An example of such a
type is <code>PInteger</code>: <code>Term s PInteger</code> is meant to represent computations that
result in an <code>Integer</code> (or an error), and <code>Integer</code>s are part of the Plutus
default universe. Indeed, if you attempt to use this helper with a Haskell type
that <em>isn't</em> part of the default Plutus universe, you will get a compile error.</p>
<p>The type is defined as follows: its implementation is not important.</p>
<pre><code class="language-haskell">newtype DeriveBuiltinPLiftable (a :: S -&gt; Type) (h :: Type) (s :: S)
  = DeriveBuiltinPLiftable (a s)
</code></pre>
<p>We can see that this <code>newtype</code> has two type arguments (besides the <code>s</code> to make
it a Plutarch type): one for the Plutarch type for which we want to derive the
instance, and one for a Haskell type that is meant to be its <code>AsHaskell</code>
equivalent. As an example of how to use this helper, consider the following:</p>
<pre><code class="language-haskell">deriving via (DeriveBuiltinPLiftable PInteger Integer) 
    instance PLiftable PInteger
</code></pre>
<p>This specifies that <code>PInteger</code>'s Haskell-level equivalent is <code>Integer</code> by way of
its presence in the default Plutarch universe.</p>
<h3 id="via-derivedatapliftable"><a class="header" href="#via-derivedatapliftable">Via <code>DeriveDataPLiftable</code></a></h3>
<p>This helper is designed for types which are represented onchain by way of their
<code>Data</code> encoding, rather than being part of the Plutus universe directly. An
example of such a type is <code>PScriptContext</code>: its equivalent in Haskell is
<code>ScriptContext</code> from <code>plutus-ledger-api</code>, which is essentially a 'skin' over
<code>Data</code>.</p>
<p>This type is defined as follows: its implementation is not important.</p>
<pre><code class="language-haskell">newtype DeriveDataPLiftable (a :: S -&gt; Type) (h :: Type) (s :: S)
  = DeriveDataPLiftable (a s)
</code></pre>
<p>Similarly to <code>DeriveBuiltinPLiftable</code>, we have two relevant type arguments:
one for the Plutarch type for which we want to derive an instance, and
another for its Haskell-level equivalent. As an example of how to use this
helper, consider the following:</p>
<pre><code class="language-haskell">deriving via (DeriveDataPLiftable PScriptContext ScriptContext) 
    instance PLiftable PScriptContext
</code></pre>
<p>This declares that <code>PScriptContext</code>'s Haskell-level equivalent is
<code>ScriptContext</code> (from <code>plutus-ledger-api</code>), by way of its <code>Data</code> encoding.</p>
<p>There are additional requirements for using this helper with Plutarch type <code>a</code>
and Haskell-level equivalent <code>h</code>. Aside from <code>a</code> being an instance of
<code>PlutusType</code>, we also must have the following:</p>
<ul>
<li><code>PInner a</code> is <code>PData</code> (namely, construction and matching is actually carried
out in a computation involving <code>Data</code>)</li>
<li><code>h</code> is an instance of both <code>ToData</code> and <code>FromData</code> (namely, it has a <code>Data</code>
encoding that we can decode from and encode into)</li>
</ul>
<h3 id="via-derivenewtypepliftable"><a class="header" href="#via-derivenewtypepliftable">Via <code>DeriveNewtypePLiftable</code></a></h3>
<p>This helper is for types that have the same representation as some other
type that already defined <code>PLiftable</code>. Instance defined that way will have
the same <code>PlutusRepr</code>.</p>
<pre><code class="language-haskell">newtype PPositive s = PPositive (Term s PInteger)
  deriving stock (Generic)
  deriving anyclass (PlutusType, PIsData)

deriving via
  DeriveNewtypePLiftable PPositive PInteger Positive
  instance PLiftable PPositive
</code></pre>
<p>This defines that <code>PPositive</code>'s Haskell-level equivalent is <code>Positive</code> and <code>PPositive</code> has the same representation as <code>PInteger</code>.</p>
<p>Implementation is not important but is useful to talk about its type parameters</p>
<pre><code class="language-haskell">newtype DeriveNewtypePLiftable (wrapper :: S -&gt; Type) (inner :: S -&gt; Type) (h :: Type) (s :: S)
  = DeriveNewtypePLiftable (wrapper s)
</code></pre>
<p>To use <code>DeriveNewtypePLiftable</code> the following must hold:</p>
<ul>
<li><code>inner</code> has <code>PLiftable</code> instance</li>
<li><code>AsHaskell inner</code> is coercible to <code>h</code></li>
</ul>
<h3 id="via-derivetagpliftable"><a class="header" href="#via-derivetagpliftable">Via <code>DeriveTagPLiftable</code></a></h3>
<pre><code class="language-haskell">data Foo = A | B
  deriving stock (Generic)
  deriving anyclass (SOP.Generic)

data PFoo s = PB | PA
  deriving stock (Generic)
  deriving anyclass (SOP.Generic)
  deriving (PlutusType) via DeriveTagPlutusType PFoo
  deriving (PLiftable) via DeriveTagPLiftable PFoo Foo
</code></pre>
<h3 id="manual-derivation"><a class="header" href="#manual-derivation">Manual derivation</a></h3>
<p>In the (unlikely) case that your type fits neither of the above, you will have
to write the instance manually. Given how unusual this situation is, we can't
really give any general guidance as to how this should be done. Instead, we
recommend examining the definitions of <code>PLiftable</code>, as well as the two
derivation helpers described above, in the source code. Alternatively, reach out
to us: we might be able to advise better.</p>
<h3 id="ensuring-your-instance-is-correct"><a class="header" href="#ensuring-your-instance-is-correct">Ensuring your instance is correct</a></h3>
<p>Any instance of <code>PLiftable</code> must obey the following laws:</p>
<pre><code>1. fromPlutarch . toPlutarch = Right
2. fmap toPlutarch . fromPlutarch = Right
</code></pre>
<p>If you use either of <code>DeriveBuiltinPLiftable</code> or <code>DeriveDataPLiftable</code> with
<code>via</code> derivation, these laws will automatically be satisfied. If you write an
instance manually, you will have to ensure this yourself. We provide a helper
for testing that these laws hold in <code>plutarch-testlib</code>, in the
<code>Plutarch.Test.Laws</code> module, called <code>checkPLiftableLaws</code>, which uses QuickCheck
to verify that the laws are maintained. For example, to check that the instances
for <code>PLiftable PInteger</code> and <code>PLiftable PScriptContext</code> are correct, we would
write:</p>
<pre><code class="language-haskell">main :: IO ()
main = defaultMain . testGroup "Laws" $ [
    checkPLiftableLaws @PInteger,
    checkPLiftableLaws @PScriptContext
    ]
</code></pre>
<p><code>checkPLiftableLaws</code> requires the use of a type argument, as it is otherwise
ambiguous. It also works largely by way of <code>AsHaskell</code>, which means that the
Haskell-level equivalent of the type being tested must be an instance of
<code>Arbitrary</code>, <code>Eq</code> and <code>Show</code>, as well as <code>Pretty</code>. The name of the type being
tested will automatically be added to the output of the test suite.</p>
<p>One important caveat to any definition of <code>PLiftable</code> instances, manual or not:
ensure that the Haskell-level equivalent that you declare is genuine. While
there is nothing stopping you from defining something like <code>PLiftable PNatural</code>
with <code>AsHaskell PNatural = Text</code>, this is clearly not sensible, and we cannot
check this. Your intent is taken at its word: the only checks are that what you
want is not literally impossible. Keep this in mind when defining your
instances.</p>
<h2 id="using-an-instance"><a class="header" href="#using-an-instance">Using an instance</a></h2>
<p>To simplify the use of <code>PLiftable</code>, we provide two functions:</p>
<pre><code class="language-haskell">pconstant :: forall (a :: S -&gt; Type) (s :: S) .
    PLiftable a =&gt;
    AsHaskell a -&gt; 
    Term s a

plift :: forall (a :: S -&gt; Type) .
    PLiftable a =&gt; 
    (forall (s :: S) . Term s a) -&gt; 
    AsHaskell a
</code></pre>
<p>The type signatures more-or-less speak for themselves: <code>pconstant</code> is the
Haskell-to-Plutarch direction, while <code>plift</code> is the Plutarch-to-Haskell
direction. There are three minor caveats to their use:</p>
<ul>
<li><code>pconstant</code> is technically ambiguous, as many different Plutarch types can
share the same choice for <code>AsHaskell</code>. A good example is that <code>PAsData PInteger</code> and <code>PInteger</code> would have the same <code>AsHaskell</code> (namely, <code>Integer</code>).
Thus, you may need to use a type argument to avoid ambiguity errors from the
compiler.</li>
<li><code>plift</code> transforms any <code>LiftError</code> into a call to <code>error</code>.</li>
<li><code>plift</code> requires a rank-2 argument for the Plutarch term (to ensure it's
closed). This can occasionally confuse the compiler's inference when combined
with <code>.</code> or similar operators: consider either manually bracketing, or using
<code>ImpredicativeTypes</code>.</li>
</ul>
<p>These functions are the main interface enabled by <code>PLiftable</code> that you should
use in your own code. <code>plift</code> is something that should be used fairly rarely
outside of testing, however: as it requires compilation and evaluation, it will
never be efficient.</p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">{-# LANGUAGE UndecidableInstances #-}

module Plutarch.Docs.PEqAndPOrd (PMaybe'(..)) where

import Data.Kind (Type)
import GHC.Generics (Generic)
import Generics.SOP qualified as SOP
import Plutarch.Prelude
</code></pre>
</p>
</details>
<h1 id="peq--pord"><a class="header" href="#peq--pord"><code>PEq</code> &amp; <code>POrd</code></a></h1>
<p>Plutarch level equality is provided by the <code>PEq</code> typeclass:</p>
<pre><code class="language-hs">class PEq t where
  (#==) :: Term s t -&gt; Term s t -&gt; Term s PBool
</code></pre>
<p><code>PInteger</code> implements <code>PEq</code> as you would expect. So you could do:</p>
<pre><code class="language-hs">1 #== 2
</code></pre>
<p>That would yield a <code>Term s PBool</code>, which you would probably use with <code>pif</code> (or similar).</p>
<p>Similarly, <code>POrd</code> emulates <code>Ord</code>:</p>
<pre><code class="language-hs">-- The actual POrd has more methods, but these are the only required ones.
class PEq =&gt; POrd t where
  (#&lt;) :: Term s t -&gt; Term s t -&gt; Term s PBool
  (#&lt;=) :: Term s t -&gt; Term s t -&gt; Term s PBool
</code></pre>
<p>It works as you would expect:</p>
<pre><code class="language-hs">pif (1 #&lt; 7) "indeed" "what"
</code></pre>
<p>evaluates to <code>"indeed"</code> - of type <code>Term s PString</code>.</p>
<p>For SOP encoded types, you can easily derive <code>PEq</code> via generic deriving:</p>
<pre><code class="language-haskell">data PMaybe' a s
  = PNothing'
  | PJust' (Term s a)
  deriving stock (Generic)
  deriving anyclass (SOP.Generic, PEq)
  deriving (PlutusType) via (DeriveAsSOPStruct (PMaybe' a))
</code></pre>
<p>For data encoded types, you can derive <code>PEq</code> via their data representation:</p>
<pre><code class="language-haskell">data PTriplet (a :: S -&gt; Type) (s :: S)
  = PTriplet
      { ptriplet'a :: Term s (PAsData a)
      , ptriplet'b :: Term s (PAsData a)
      , ptriplet'c :: Term s (PAsData a)
      }
  deriving stock (Generic)
  deriving anyclass (SOP.Generic, PIsData, PEq)
  deriving (PlutusType) via (DeriveAsDataStruct (PTriplet a))
</code></pre>
<blockquote>
<p>Aside: <code>PEq</code> derivation for data encoded types uses "Data equality". It simply ensures the structure (as represented through <a href="Typeclasses/../Concepts/DataAndScottEncoding.html#data-encoding">data encoding</a>) of both values are <em>exactly</em> the same. It does not take into account any custom <code>PEq</code> instances for the individual fields within.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pintegral"><a class="header" href="#pintegral"><code>PIntegral</code></a></h1>
<p>This is similar to the <code>Integral</code> typeclass. However, it only has the following class methods:</p>
<ul>
<li><code>pdiv</code> - similar to <code>div</code></li>
<li><code>pmod</code> - similar to <code>mod</code></li>
<li><code>pquot</code> - similar to <code>quot</code></li>
<li><code>prem</code> - similar to <code>rem</code></li>
</ul>
<p>Using these functions, you can do division/modulus etc. on Plutarch level values:</p>
<pre><code class="language-hs">pdiv # 6 # 3
</code></pre>
<p>where <code>6</code> and <code>3</code> are <code>Term s PInteger</code>s yields <code>2</code> - also a <code>Term s PInteger</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pisdata"><a class="header" href="#pisdata"><code>PIsData</code></a></h1>
<p>The <code>PIsData</code> typeclass facilitates easy and type safe conversion between Plutarch types and their corresponding
<a href="https://github.com/Plutonomicon/plutonomicon/blob/main/builtin-data.md"><code>BuiltinData</code>/<code>Data</code></a> representation. It keeps track of the type information through <a href="Typeclasses/./../Types/PAsData.html"><code>PAsData</code></a>.</p>
<pre><code class="language-hs">class PIsData a where
  pfromData :: Term s (PAsData a) -&gt; Term s a
  pdata :: Term s a -&gt; Term s (PAsData a)
</code></pre>
<p><a href="Typeclasses/./../Types/PInteger.html"><code>PInteger</code></a> has a <code>PIsData</code> instance. The <code>PData</code> representation of <code>PInteger</code> is, of course, an <code>I</code> data. And you can get the <code>PInteger</code> back from an <code>I</code> data using <code>UnIData</code> (i.e. <code>pasInt</code>).</p>
<pre><code class="language-hs">instance PIsData PInteger where
  pfromData x = pasInt # pforgetData x
  pdata x = punsafeBuiltin PLC.IData # x
</code></pre>
<p>In essence, <code>pdata</code> wraps a <code>PInteger</code> into an <code>I</code> data value. Whereas <code>pfromData</code> simply unwraps the <code>I</code> data value to get a <code>PInteger</code>.</p>
<blockquote>
<p>Aside: You might be asking, what's an "<code>I</code> data value"? This is referring to the different constructors of <code>Data</code>/<code>BuiltinData</code>. You can find a full explanation of this at
<a href="https://github.com/Plutonomicon/plutonomicon/blob/main/builtin-data.md">Plutonomicon</a>.</p>
</blockquote>
<p>For the simple constructors that merely wrap a builtin type into <code>Data</code>, e.g. <code>Integer</code>s, <code>Bytestrings</code>, lists, and <code>AssocMap</code>, <code>PIsData</code> works in much the same way as above. However, what
about <code>Constr</code> data values? When you have an ADT that doesn't correspond to those simple builtin types directly - but you still need to encode it as <code>Data</code> (e.g. <code>PScriptContext</code>). In this
case, you should <a href="Typeclasses/./PIsDataReprAndPDataFields.html#implementing-pisdatarepr-and-friends">implement <code>PIsDataRepr</code></a> and you'll get the <code>PIsData</code> instance for free!</p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">{-# LANGUAGE QualifiedDo #-}
module Plutarch.Docs.PDataFields (foo, foo', res, mockCtx, purpose, Vehicle (..), PVehicle (..), PVehicle' (..), PFoo (..), test) where

import GHC.Generics (Generic)
import Plutarch.Prelude
import Plutarch.LedgerApi.V3 (
  PScriptContext,
  PScriptPurpose (PMinting),
  PScriptInfo (
    PSpendingScript,
    PMintingScript,
    PRewardingScript,
    PCertifyingScript,
    PVotingScript,
    PProposingScript
    ),
    PCurrencySymbol
  )
import qualified Plutarch.Monadic as P
import PlutusLedgerApi.V3 (
  TxInfo (TxInfo),
  POSIXTime(POSIXTime),
  ScriptContext (ScriptContext),
  ScriptInfo (MintingScript),
  Redeemer (Redeemer)
  )
import PlutusLedgerApi.V1.Value (CurrencySymbol (CurrencySymbol))
import PlutusLedgerApi.V1.Interval (interval)
import qualified PlutusTx
import qualified PlutusTx.AssocMap as AssocMap
import qualified PlutusTx.Builtins as Builtins
import Plutarch.Docs.Run (evalWithArgsT)
</code></pre>
</p>
</details>
<h1 id="pdatarecord-is-deprecated-in-favor-of-plutarchreprdata-this-documentation-is-unmaintained"><a class="header" href="#pdatarecord-is-deprecated-in-favor-of-plutarchreprdata-this-documentation-is-unmaintained">PDataRecord is deprecated in favor of <code>Plutarch.Repr.Data</code>. This documentation is unmaintained.</a></h1>
<h1 id="plutustype-via-plutustypedata--pdatafields"><a class="header" href="#plutustype-via-plutustypedata--pdatafields"><code>PlutusType</code> via <code>PlutusTypeData</code> &amp; <code>PDataFields</code></a></h1>
<p>Deriving <code>PlutusType</code> with <code>DPTStrat PlutusTypeData</code> allows for easily constructing <em>and</em> deconstructing <code>Constr</code>
<a href="https://github.com/Plutonomicon/plutonomicon/blob/main/builtin-data.md"><code>BuiltinData</code>/<code>Data</code></a> values. It allows fully type safe matching on
<a href="Typeclasses/./../Concepts/DataAndScottEncoding.html"><code>Data</code> encoded</a> values, without embedding type information within the generated script - unlike
PlutusTx. <code>PDataFields</code>, on top of that, allows for ergonomic field access.</p>
<blockquote>
<p>Aside: What's a <code>Constr</code> data value? Briefly, it's how Plutus Core encodes non-trivial ADTs into <code>Data</code>/<code>BuiltinData</code>. Together with <code>BuiltinList</code>s it allows for a sum-of-products encoding.
Essentially, whenever you have a custom non-trivial ADT (that isn't just an integer, bytestring, string/text, list, or assoc map) - and you want to represent it as a data encoded value -
you should derive <code>PIsData</code> for it</p>
</blockquote>
<p>For example, <code>PScriptContext</code> - which is the Plutarch synonym to <a href="https://plutonomicon.github.io/plutarch-plutus/haddock/plutus-ledger-api/html/PlutusLedgerApi-V3-Contexts.html#t:ScriptContext"><code>ScriptContext</code></a></p>
<ul>
<li>has the necessary instances. This lets you easily keep track of its type, match on it, deconstruct it - you name it!</li>
</ul>
<pre><code class="language-haskell">foo :: Term s (PScriptContext :--&gt; PString)
foo = plam $ \ctx -&gt; P.do
  scriptInfo &lt;- pmatch $ pfield @"scriptInfo" # ctx
  case scriptInfo of
    PMintingScript _ -&gt; "It's minting!"
    PSpendingScript _ -&gt; "It's spending!"
    PRewardingScript _ -&gt; "It's rewarding!"
    PCertifyingScript _ -&gt; "It's certifying!"
    PVotingScript _ -&gt; "It's voting!"
    PProposingScript _ -&gt; "It's proposing!"
</code></pre>
<blockquote>
<p>Note: The above snippet uses GHC 9 features (<code>QualifiedDo</code>). Be sure to check out <a href="Typeclasses/./../Usage/DoSyntaxWithTermCont.html">Do syntax with <code>TermCont</code></a>.</p>
</blockquote>
<p>Of course, just like <code>ScriptContext</code> - <code>PScriptContext</code> is represented as a <code>Data</code> value in Plutus Core. Plutarch just lets you keep track of the <em>exact representation</em> of it within the type system.</p>
<p>Here's how <code>PScriptContext</code> is defined:</p>
<pre><code class="language-hs">newtype PScriptContext (s :: S)
  = PScriptContext
      ( Term
          s
          ( PDataRecord
              '[ "txInfo" ':= PTxInfo
               , "purpose" ':= PScriptPurpose
               ]
          )
      )
</code></pre>
<p>It's a constructor containing a <a href="Typeclasses/./../Types/PDataSumAndPDataRecord.html"><code>PDataRecord</code></a> term. It has 2 fields- <code>txInfo</code> and <code>purpose</code>.</p>
<p>First, we extract the <code>purpose</code> field using <code>pfield @"purpose"</code>:</p>
<pre><code class="language-hs">pfield :: Term s (PScriptContext :--&gt; PScriptPurpose)
</code></pre>
<blockquote>
<p>Note: When extracting several fields from the same variable, you should instead use <code>pletFields</code>. See: <a href="Typeclasses/PIsDataReprAndPDataFields.html#all-about-extracting-fields">Extracting fields</a></p>
</blockquote>
<blockquote>
<p>Aside: <code>pfield</code> is actually return type polymorhpic. It could've returned either <code>PAsData PScriptPurpose</code> and <code>PScriptPurpose</code>. In this case, GHC correctly infers that we actually want a
<code>PScriptPurpose</code>, since <code>pmatch</code> doesn't work on <code>PAsData PScriptPurpose</code>!</p>
</blockquote>
<blockquote>
<p>Sometimes GHC isn't so smart, and you're forced to provide an explicit type annotation. Or you can simply use <code>pfromData $ pfield ....</code>.</p>
</blockquote>
<p>Now, we can <code>pmatch</code> on our <code>Term s PScriptPurpose</code> to extract the Haskell ADT (<code>PScriptPurpose s</code>) out of the Plutarch term:</p>
<pre><code class="language-hs">pmatch :: Term s PScriptPurpose -&gt; (PScriptPurpose s -&gt; Term s PString) -&gt; Term s PString
</code></pre>
<p>Now that we have <code>PScriptPurpose s</code>, we can just <code>case</code> match on it! <code>PScriptPurpose</code> is defined as:</p>
<pre><code class="language-hs">data PScriptPurpose (s :: S)
  = PMinting (Term s (PDataRecord '["_0" ':= PCurrencySymbol]))
  | PSpending (Term s (PDataRecord '["_0" ':= PTxOutRef]))
  | PRewarding (Term s (PDataRecord '["_0" ':= PStakingCredential]))
  | PCertifying (Term s (PDataRecord '["_0" ':= PDCert]))
</code></pre>
<p>It's just a Plutarch sum type.</p>
<p>We're not really interested in the fields (the <code>PDataRecord</code> term), so we just match on the constructor with the familiar <code>case</code>. Easy!</p>
<p>Let's pass in a <code>ScriptContext</code> as a <code>Data</code> value from Haskell to this Plutarch script and see if it works!</p>
<pre><code class="language-haskell">mockCtx :: ScriptContext
mockCtx =
  ScriptContext
    (TxInfo
      mempty -- inputs
      mempty -- reference inputs
      mempty -- outputs
      0 -- fee
      mempty -- mint
      mempty -- certs
      AssocMap.empty -- withdrawals
      (interval (POSIXTime 1) (POSIXTime 2)) -- valid range
      mempty -- signatories
      AssocMap.empty -- redeemers
      AssocMap.empty -- data
      "" -- id
      AssocMap.empty -- votes
      mempty -- proposal procedures
      Nothing -- current treasury amount
      Nothing -- current treasury donation
    )
    (Redeemer . Builtins.mkI $ 0)
    (MintingScript (CurrencySymbol ""))

res :: Either _ _
res = foo `evalWithArgsT` [PlutusTx.toData mockCtx]
-- Right (Program () (Version () 1 0 0) (Constant () (Some (ValueOf string "It's minting!"))))
</code></pre>
<blockquote>
<p>Aside: You can find the definition of <code>evalWithArgsT</code> at <a href="Typeclasses/../Overview.html#compiling-and-running">Compiling and Running</a>.</p>
</blockquote>
<h2 id="all-about-extracting-fields"><a class="header" href="#all-about-extracting-fields">All about extracting fields</a></h2>
<p>We caught a glimpse of field extraction in the example above, thanks to <code>pfield</code>. However, that barely touched the surface.</p>
<p>Once a type has a <code>PDataFields</code> instance, field extraction can be done with these 3 functions:</p>
<ul>
<li><code>pletFields</code></li>
<li><code>pfield</code></li>
<li><code>getField</code> (when not using <code>OverloadedRecordDot</code> or <a href="https://hackage.haskell.org/package/record-dot-preprocessor">record dot preprocessor</a>)</li>
</ul>
<p>Each has its own purpose. However, <code>pletFields</code> is arguably the most general purpose and most efficient. Whenever you need to extract several fields from the same variable, you should use <code>pletFields</code>:</p>
<pre><code class="language-haskell">foo' :: Term s (PScriptContext :--&gt; PUnit)
foo' = plam $ \ctx' -&gt; P.do
  ctx &lt;- pletFields @["txInfo", "scriptInfo"] ctx'
  let
    _scriptInfo = ctx.scriptInfo
    _txInfo = ctx.txInfo
  -- &lt;use scriptInfo and txInfo here&gt;
  pconstant ()
</code></pre>
<blockquote>
<p>Note: The above snippet uses GHC 9 features (<code>QualifiedDo</code> and <code>OverloadedRecordDot</code>). Be sure to check out <a href="Typeclasses/./../Usage/DoSyntaxWithTermCont.html">Do syntax with <code>TermCont</code></a> and <a href="Typeclasses/./../Typeclasses/PIsDataReprAndPDataFields.html#alternatives-to-overloadedrecorddot">alternatives to <code>OverloadedRecordDot</code></a>.</p>
</blockquote>
<p>In essence, <code>pletFields</code> takes in a type level list of the field names that you want to access and a continuation function that takes in an <code>HRec</code>. This <code>HRec</code> is essentially a collection of the bound fields. You don't have to worry too much about the details of <code>HRec</code>. This particular usage has type:</p>
<pre><code class="language-hs">pletFields :: Term s PScriptContext
  -&gt; (HRec
        (BoundTerms
           '[ "txInfo" ':= PTxInfo, "purpose" ':= PScriptPurpose]
           '[ 'Bind, 'Bind]
           s)
      -&gt; Term s PUnit)
  -&gt; Term s PUnit
</code></pre>
<p>You can then access the fields on this <code>HRec</code> using <code>OverloadedRecordDot</code>.</p>
<p>Next up is <code>pfield</code>. You should <em>only ever</em> use this if you just want one field from a variable and no more. Its usage is simply <code>pfield @"fieldName" # variable</code>. You can, however, also use <code>pletFields</code> in this case (e.g. <code>pletFields @'["fieldName"] variable</code>). <code>pletFields</code> with a singular field has the same efficiency as <code>pfield</code>!</p>
<p>Finally, <code>getField</code> is merely there to supplement the lack of record dot syntax. See: <a href="Typeclasses/PIsDataReprAndPDataFields.html#alternatives-to-overloadedrecorddot">Alternative to <code>OverloadedRecordDot</code></a>.</p>
<blockquote>
<p>Note: An important thing to realize is that <code>pfield</code> and <code>getField</code> (or overloaded record dot on <code>HRec</code>) are <em>return type polymorphic</em>. They can return both <code>PAsData Foo</code> or <code>Foo</code> terms,
depending on the surrounding context. This is very useful in the case of <code>pmatch</code>, as <code>pmatch</code> doesn't work on <code>PAsData</code> terms. So you can simply write <code>pmatch $ pfield ...</code> and <code>pfield</code>
will correctly choose to <em>unwrap</em> the <code>PAsData</code> term.</p>
</blockquote>
<h3 id="alternatives-to-overloadedrecorddot"><a class="header" href="#alternatives-to-overloadedrecorddot">Alternatives to <code>OverloadedRecordDot</code></a></h3>
<p>If <code>OverloadedRecordDot</code> is not available, you can also try using the <a href="https://hackage.haskell.org/package/record-dot-preprocessor">record dot preprocessor plugin</a>.</p>
<p>If you don't want to use either, you can simply use <code>getField</code>. In fact, <code>ctx.purpose</code> above just translates to <code>getField @"purpose" ctx</code>. Nothing magical there!</p>
<h2 id="all-about-constructing-data-values"><a class="header" href="#all-about-constructing-data-values">All about constructing data values</a></h2>
<p>We learned about type safe matching (through <code>PlutusType</code>) as well as type safe field access (through <code>PDataFields</code>) - how about construction? You can derive
<a href="Typeclasses/./PlutusType,PCon,PMatch.html"><code>PlutusType</code></a>, using a data representation by using <code>DPTStrat _ = PlutusTypeData</code> and <code>PlutusType</code> bestows the ability
to not only <em>deconstruct</em>, but also <strong>construct</strong> values - you can do that just as easily!</p>
<p>Let's see how we could build a <code>PMinting</code> <code>PScriptPurpose</code> given a <code>PCurrencySymbol</code>:</p>
<pre><code class="language-haskell">currSym :: Term s PCurrencySymbol
currSym = pconstant $ CurrencySymbol "foo"

purpose :: Term s PScriptPurpose
purpose = pcon $ PMinting fields
  where
    currSymDat :: Term _ (PAsData PCurrencySymbol)
    currSymDat = pdata currSym
    fields :: Term _ (PDataRecord '[ "_0" ':= PCurrencySymbol ])
    fields = pdcons # currSymDat # pdnil
</code></pre>
<p>All the type annotations are here to help!</p>
<p>This is just like regular <code>pcon</code> usage you've <a href="Typeclasses/./PlutusType,PCon,PMatch.html">from <code>PlutusType</code>/<code>PCon</code></a>. It takes in the Haskell ADT of your Plutarch type and gives back a Plutarch term.</p>
<p>What's more interesting, is the <code>fields</code> binding. Recall that <code>PMinting</code> is a constructor with one argument, that argument is a <a href="Typeclasses/../Types/PDataSumAndPDataRecord.html"><code>PDataRecord</code></a> term. In particular, we want: <code>Term s (PDataRecord '["_0" ':= PCurrencySymbol ])</code>. It encodes the exact type, position, and name of the field. So, all we have to do is create a <code>PDataRecord</code> term!</p>
<p>Of course, we do that using <code>pdcons</code> - which is just the familiar <code>cons</code> but for <code>PDataRecord</code> terms.</p>
<pre><code class="language-hs">pdcons :: forall label a l s. Term s (PAsData a :--&gt; PDataRecord l :--&gt; PDataRecord ((label ':= a) ': l))
</code></pre>
<p>It takes a <code>PAsData a</code> and adds that <code>a</code> to the <code>PDataRecord</code> heterogenous list. We feed it a <code>PAsData PCurrencySymbol</code> term and <code>pdnil</code> - the empty data record. That should give us:</p>
<pre><code class="language-hs">pdcons # currSymDat # pdnil :: Term _ (PDataRecord '[ label ':= PCurrencySymbol ])
</code></pre>
<p>Cool! Wait, what's <code>label</code>? It's the field name associated with the field, in our case, we want the field name to be <code>_0</code> - because that's what the <code>PMinting</code> constructor wants. You can
either specify the label with a type application or you can just have a type annotation for the binding (which is what we do here). Or you can let GHC try and match up the <code>label</code> with
the surrounding environment!</p>
<p>Now that we have <code>fields</code>, we can use it with <code>PMinting</code> to build a <code>PScriptPurpose s</code> and feed it to <code>pcon</code> - we're done!</p>
<h2 id="implementing-pisdata-and-friends"><a class="header" href="#implementing-pisdata-and-friends">Implementing <code>PIsData</code> and friends</a></h2>
<p>Implementing these is rather simple with generic deriving. All you need is a well formed type using <code>PDataRecord</code>. For example, suppose you wanted to implement <code>PIsData</code> for the Plutarch
version of this Haskell type:</p>
<pre><code class="language-haskell">data Vehicle
  = FourWheeler Integer Integer Integer Integer
  | TwoWheeler Integer Integer
  | ImmovableBox
</code></pre>
<p>You'd declare the corresponding Plutarch type as:</p>
<pre><code class="language-haskell">data PVehicle' (s :: S)
  = PFourWheeler' (Term s (PDataRecord '["_0" ':= PInteger, "_1" ':= PInteger, "_2" ':= PInteger, "_3" ':= PInteger]))
  | PTwoWheeler' (Term s (PDataRecord '["_0" ':= PInteger, "_1" ':= PInteger]))
  | PImmovableBox' (Term s (PDataRecord '[]))
</code></pre>
<p>Each field type must also have a <code>PIsData</code> instance. We've fulfilled this criteria above as <code>PInteger</code> does indeed have a <code>PIsData</code> instance. However, think of <code>PBuiltinList</code>s, as an example. <code>PBuiltinList</code>'s <code>PIsData</code> instance is restricted to only <code>PAsData</code> elements.</p>
<pre><code class="language-hs">instance PIsData a =&gt; PIsData (PBuiltinList (PAsData a))
</code></pre>
<p>Thus, you can use <code>PBuiltinList (PAsData PInteger)</code> as a field type, but not <code>PBuiltinList PInteger</code>.</p>
<blockquote>
<p>Note: The constructor ordering in <code>PVehicle</code> matters! If you used <a href="https://plutonomicon.github.io/plutarch-plutus/haddock/plutus-tx/html/PlutusTx-IsData.html#v:makeIsDataIndexed"><code>makeIsDataIndexed</code></a> on
<code>Vehicle</code> to assign an index to each constructor - the Plutarch type's constructors must follow the same indexing order.</p>
</blockquote>
<blockquote>
<p>In this case, <code>PFourWheeler</code> is at the 0th index, <code>PTwoWheeler</code> is at the 1st index, and <code>PImmovableBox</code> is at the 3rd index. Thus, the corresponding <code>makeIsDataIndexed</code> usage should be:</p>
</blockquote>
<blockquote>
<pre><code class="language-hs">PlutusTx.makeIsDataIndexed ''PVehicle [('FourWheeler,0),('TwoWheeler,1),('ImmovableBox,2)]
</code></pre>
</blockquote>
<blockquote>
<p>Also see: <a href="Typeclasses/./../Tricks/makeIsDataIndexed,HaskellADTs,PIsDataRepr.html">Isomorphism between Haskell ADTs and <code>PIsData</code></a></p>
</blockquote>
<p>And you'd simply derive <code>PlutustType</code> with plutus data representation using generics. You can then also derive <code>PIsData</code> and if the dataype only has one ocnstructor <code>PDataFields</code>.</p>
<p>Furthermore, you can also derive the following typeclasses after deriving <code>PlutusType</code> with <code>DPTStrat _ = PlutusTypeData</code></p>
<ul>
<li><a href="Typeclasses/./PEqAndPOrd.html"><code>PEq</code></a></li>
<li><a href="Typeclasses/./PEqAndPOrd.html"><code>POrd</code></a></li>
</ul>
<p>Combine all that, and you have:</p>
<pre><code class="language-haskell">data PVehicle (s :: S)
  = PFourWheeler (Term s (PDataRecord '["_0" ':= PInteger, "_1" ':= PInteger, "_2" ':= PInteger, "_3" ':= PInteger]))
  | PTwoWheeler (Term s (PDataRecord '["_0" ':= PInteger, "_1" ':= PInteger]))
  | PImmovableBox (Term s (PDataRecord '[]))
  deriving stock (Generic)
  deriving anyclass (PlutusType, PIsData)
instance DerivePlutusType PVehicle where type DPTStrat _ = PlutusTypeData
</code></pre>
<blockquote>
<p>Note: You cannot derive <code>PIsData</code> for types that are represented using <a href="Typeclasses/./../Concepts/DataAndScottEncoding.html#scott-encoding">Scott encoding</a>. Your types must be well formed and
should be using <code>PDataRecord</code> terms instead.</p>
</blockquote>
<p>That's it! Now you can represent <code>PVehicle</code> as a <code>Data</code> value, as well as deconstruct and access its fields super ergonomically. Let's try it!</p>
<pre><code class="language-haskell">test :: Term s (PVehicle :--&gt; PInteger)
test = plam $ \veh' -&gt; P.do
  veh &lt;- pmatch veh'
  case veh of
    PFourWheeler fwh' -&gt; P.do
      fwh &lt;- pletFields @'["_0", "_1", "_2", "_3"] fwh'
      fwh._0 + fwh._1 + fwh._2 + fwh._3
    PTwoWheeler twh' -&gt; P.do
      twh &lt;- pletFields @'["_0", "_1"] twh'
      twh._0 + twh._1
    PImmovableBox _ -&gt; 0
</code></pre>
<p>What about types with singular constructors? It's quite similar to the sum type case. Here's how it looks:</p>
<pre><code class="language-haskell">newtype PFoo (s :: S) = PMkFoo (Term s (PDataRecord '["foo" ':= PByteString]))
  deriving stock (Generic)
  deriving anyclass (PlutusType, PDataFields, PIsData)
instance DerivePlutusType PFoo where type DPTStrat _ = PlutusTypeData
</code></pre>
<p>Just an extra <code>PDataFields</code> derivation compared to the sum type usage!</p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">{-# OPTIONS_GHC -Wno-redundant-constraints #-}
module Plutarch.Docs.PListLike (pfoo, pfoo', x, x') where 
import Plutarch.Prelude
</code></pre>
</p>
</details>
<h1 id="plistlike"><a class="header" href="#plistlike"><code>PListLike</code></a></h1>
<p>The <code>PListLike</code> typeclass bestows beautiful and familiar list utilities to its instances. Plutarch has two list types- <a href="Typeclasses/./../Types/PBuiltinList.html"><code>PBuiltinList</code></a> and
<a href="Typeclasses/./../Types/PList.html"><code>PList</code></a>. Both have <code>PListLike</code> instances! However, <code>PBuiltinList</code> can only contain builtin types. That means that, for example, it cannot contain
Plutarch functions. The element type of <code>PBuiltinList</code> can be constrained using <code>PLift a =&gt; PBuiltinList a</code>.</p>
<p>As long as it's a <code>PLift a =&gt; PBuiltinList a</code> or <code>PList a</code> - it has access to all the <code>PListLike</code> goodies, out of the box. It helps to look into some of these functions
at <a href="https://github.com/Plutonomicon/plutarch/blob/master/Plutarch/List.hs"><code>Plutarch.List</code></a>.</p>
<p>Along the way, you might be confronted by 2 big mean baddies ...err, constraints:</p>
<pre><code class="language-hs">PIsListLike list a
</code></pre>
<p>This just means that the type <code>list a</code>, is <em>indeed</em> a valid <code>PListLike</code> containing valid elements! Of course, all <code>PList a</code>s are valid <code>PListLike</code>, but
we have to think about <code>PBuiltinList</code> since it can only contain <code>PLift a =&gt; a</code> elements! So, in essence a function declared as:</p>
<pre><code class="language-haskell">pfoo :: PIsListLike list a =&gt; Term s (list a :--&gt; list a)
pfoo = undefined
</code></pre>
<p>when specialized to <code>PBuiltinList</code>, can be simplified as:</p>
<pre><code class="language-haskell">pfoo' :: PLiftable a =&gt; Term s (PBuiltinList a :--&gt; PBuiltinList a)
pfoo' = undefined
</code></pre>
<p>That's all it is. Don't be scared of it!</p>
<p>What about this one:</p>
<pre><code class="language-hs">PElemConstraint list a
</code></pre>
<p>This one ensures that the element type <code>a</code> can indeed be contained within the list type - <code>list</code>. For <code>PList</code>, this constraint means nothing - it's always true. For <code>PBuiltinList</code>, it can be simplified as <code>PLift a</code>. Easy!</p>
<p>Here's two of my favorite <code>PListLike</code> utilities (not biased):</p>
<pre><code class="language-hs">-- | Cons an element onto an existing list.
pcons :: PElemConstraint list a =&gt; Term s (a :--&gt; list a :--&gt; list a)

-- | The empty list
pnil :: PElemConstraint list a =&gt; Term s (list a)
</code></pre>
<p>What would life be without cons and nil?</p>
<p>Let's build a <code>PBuiltinList</code> of <code>PInteger</code>s with that:</p>
<pre><code class="language-haskell">x :: Term s (PBuiltinList PInteger)
x = pcons # 1 #$ pcons # 2 #$ pcons # 3 # pnil
</code></pre>
<p>Wooo! Let's not leave <code>PList</code> alone in the corner though:</p>
<pre><code class="language-haskell">x' :: Term s (PList PInteger)
x' = pcons # 1 #$ pcons # 2 #$ pcons # 3 # pnil
</code></pre>
<p>The code is the same, we just changed the type annotation. Cool!</p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">{-# OPTIONS_GHC -Wno-redundant-constraints #-}
{-# LANGUAGE UndecidableInstances #-}
module Plutarch.Docs.PlutusTypePConAndPMatch (PMyTypeData(..)) where
import Data.Kind (Type)
import GHC.Generics (Generic)
import Generics.SOP qualified as SOP
import Plutarch.Prelude
</code></pre>
</p>
</details>
<h1 id="plutustype"><a class="header" href="#plutustype"><code>PlutusType</code></a></h1>
<p><code>PlutusType</code> is the primary typeclass that determines the underlying representation for a Plutarch type. It lets you construct and deconstruct Plutus Core constants from a Plutarch type's constructors
(possibly containing other Plutarch terms).</p>
<blockquote>
<p>NOTE: It's essentially a combination of <code>PCon</code> (for term construction) and <code>PMatch</code> (for term deconstruction). Nowadays, <code>PCon</code> and <code>PMatch</code> are actually both
just an alias for <code>PlutusType</code> and you'll get a deprecation warning if you use them.</p>
</blockquote>
<pre><code class="language-hs">class PlutusType (a :: S -&gt; Type) where
  {-
    snip
  -}
  pcon' :: forall s. a s -&gt; Term s (PInner a)
  default pcon' :: DerivePlutusType a =&gt; forall s. a s -&gt; Term s (PInner a)
  pcon' = let _ = witness (Proxy @(PlutusType a)) in derivedPCon

  pmatch' :: forall s b. Term s (PInner a) -&gt; (a s -&gt; Term s b) -&gt; Term s b
  default pmatch' :: DerivePlutusType a =&gt; forall s b. Term s (PInner a) -&gt; (a s -&gt; Term s b) -&gt; Term s b
  pmatch' = derivedPMatch

</code></pre>
<blockquote>
<p>Note: You don't need to look too much into the types! After all, you'll be using <code>pcon</code> and <code>pmatch</code>, rather than <code>pcon'</code> and <code>pmatch'</code>.
<code>PInner</code> is meant to represent the "inner" type of <code>a</code> - the Plutarch type representing the Plutus Core constant used to represent <code>a</code>.</p>
</blockquote>
<p>You should always use <code>pcon</code> and <code>pmatch</code> instead of <code>pcon'</code> and <code>pmatch'</code> - these are provided by the <code>PCon</code> and <code>PMatch</code> typeclasses:</p>
<p>Another feature of <code>PlutusType</code> instances is that you can extract out the <em>inner</em> type of any <code>PlutusType</code> instance! Above, the inner type
(or representation) of <code>PMaybe</code> was a function. You can use <code>pto</code> to safely take this inner type out-</p>
<pre><code class="language-hs">pto :: Term s a -&gt; Term s (PInner a)
</code></pre>
<p>This is quite useful when working with <code>newtype</code>s. Notice how <code>PCurrencySymbol</code>, for example, is simply a newtype to a <code>PByteString</code>. Its
<code>PInner</code> is also <code>PByteString</code>. To be able to use functions that operate on <code>PByteString</code>s with your <code>PCurrencySymbol</code>, you can simply take
out the <code>PByteString</code> using <code>pto</code>!</p>
<h2 id="implementing-plutustype-for-your-own-types-data-encoding"><a class="header" href="#implementing-plutustype-for-your-own-types-data-encoding">Implementing <code>PlutusType</code> for your own types (<code>Data</code> Encoding)</a></h2>
<p>If your type is supposed to be represented using <a href="Typeclasses/./../Concepts/DataAndScottEncoding.html#data-encoding"><code>Data</code> encoding</a> instead,
you can derive <code>PlutusType</code> via <code>PlutusTypeData</code>:</p>
<pre><code class="language-haskell">data PMyTypeData (a :: S -&gt; Type) (b :: S -&gt; Type) (s :: S)
  = POneD (Term s (PAsData a))
  | PTwoD (Term s (PAsData b))
  deriving stock (Generic)
  deriving anyclass (SOP.Generic)
  deriving (PlutusType) via (DeriveAsDataStruct (PMyTypeData a b))
</code></pre>
<h2 id="implementing-plutustype-for-your-own-types-sop-encoding"><a class="header" href="#implementing-plutustype-for-your-own-types-sop-encoding">Implementing <code>PlutusType</code> for your own types (SoP Encoding)</a></h2>
<p>Mechanism is the same as in Scott encoding case but using <code>DeriveAsSOPStruct</code> instead.</p>
<blockquote>
<p>NOTE: You must import <code>DeriveAsSOPStruct</code> with constructor (like imports at the top of this page do) for GHC to see that the helper is coercible to your own type.</p>
</blockquote>
<pre><code class="language-haskell">data PMaybeSoP (a :: S -&gt; Type) (s :: S)
  = PJustSoP (Term s a)
  | PNothingSoP
  deriving stock (Generic)
  deriving anyclass (SOP.Generic, PEq, PShow)

deriving via DeriveAsSOPStruct (PMaybeSoP a) instance PlutusType (PMaybeSoP a)
</code></pre>
<h2 id="implementing-plutustype-for-your-own-types-newtype"><a class="header" href="#implementing-plutustype-for-your-own-types-newtype">Implementing <code>PlutusType</code> for your own types (<code>newtype</code>)</a></h2>
<p>See: <a href="Typeclasses/./../Usage/DerivingForNewtypes.html"><code>DPTStrat PlutusTypeNewtype</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">{-# LANGUAGE FlexibleInstances, UndecidableInstances #-}

module Plutarch.Docs.PTryFrom (recoverListFromPData, recoverListPartially, recoverAB) where 

import Plutarch.Prelude
import GHC.Generics (Generic)
import Generics.SOP qualified as SOP
</code></pre>
</p>
</details>
<h1 id="ptryfrom"><a class="header" href="#ptryfrom"><code>PTryFrom</code></a></h1>
<pre><code class="language-hs">class PTryFrom (a :: PType) (b :: PType) where
  type PTryFromExcess a b :: PType
  ptryFrom :: forall s r. Term s a -&gt; ((Term s b, Reduce (PTryFromExcess a b s)) -&gt; Term s r) -&gt; Term s r
</code></pre>
<p><code>PTryFrom</code> is a typeclass to prove equality between a type that in some way can't be trusted about its representation and another type that we want the untrusted type to be represented as.
<code>PTryFrom</code> proves the structure of the untrusted type and recovers it as the trusted, type which hence also carries more information.</p>
<p>A good example is getting a <code>PData</code> from a redeemer and wanting to prove that it is of a certain kind, e.g. a <code>PAsData (PBuiltinList (PAsData PInteger))</code>. We could do this with:</p>
<pre><code class="language-haskell">recoverListFromPData :: forall (s :: S). Term s PData -&gt; Term s (PAsData (PBuiltinList (PAsData PInteger)))
recoverListFromPData = unTermCont . fmap fst . tcont . ptryFrom @(PAsData (PBuiltinList (PAsData PInteger)))
</code></pre>
<blockquote>
<p>Note: You can find a specialized version of <code>ptryFrom</code> in <code>Plutarch.Extra</code> that is the same as <code>ptryFrom @PData @(PAsData a)</code></p>
</blockquote>
<h2 id="implementing-ptryfrom"><a class="header" href="#implementing-ptryfrom">Implementing <code>PTryFrom</code></a></h2>
<p>Implementing <code>PTryFrom</code> for your type should be easy as soon as you have a datatype deriving its Plutarch data representation
via <code>PlutusTypeData</code> as <code>PTryFrom</code> also has a generic <code>default</code> implementation.</p>
<pre><code class="language-haskell">-- your datatype
data PAB (s :: S)
  = PA (Term s (PAsData PInteger)) (Term s (PAsData PByteString))
  | PB (Term s (PAsData (PBuiltinList (PAsData PInteger)))) (Term s (PAsData PByteString))
  deriving stock (Generic)
  deriving anyclass (SOP.Generic, PIsData)
  deriving (PlutusType) via (DeriveAsDataStruct PAB)

-- getting a generic `PTryFrom` instance that recovers your type 
-- from an opaque `PData`
instance PTryFrom PData (PAsData PAB)

-- a valid AB
sampleAB :: Term s (PAsData PAB)
sampleAB = pdata $ pcon $ PA (pconstant 4) (pdata (pconstant "foo"))

-- we forget the structure of our `sampleAB`
sampleABdata :: Term s PData
sampleABdata = pforgetData sampleAB

-- recovers an `AB` from an opaque `PData`
recoverAB :: Term s (PAsData PAB)
recoverAB = unTermCont $ fst &lt;$&gt; tcont (ptryFrom sampleABdata)

</code></pre>
<blockquote>
<p>Note: There are other valid implementations for recovering your datatype from <code>PData</code>, in some cases you might,
for example, want to include additional checks, think making sure that some <code>PNatural</code> is indeed positive.
In this case you will have to hand-roll the implementation of <code>PTryFrom</code>. For some examples, see <code>plutarch-test</code>'s
<code>PTryFromSpec.hs</code></p>
</blockquote>
<h2 id="laws"><a class="header" href="#laws">Laws</a></h2>
<ul>
<li>the operation <code>ptryFrom</code> mustn't change the representation of the underlying data</li>
<li>the operation <code>ptryFrom</code> must always prove the integrity of the whole target type
<ul>
<li>example:
<code>ptryFrom @PData @(PAsData (PBuiltinList PData))</code> ssucceeds iff the underlying representation is a <code>BuiltinList</code> containing any <code>PData</code></li>
</ul>
</li>
<li>all conversions are fallible, this happens if the representation doesn't match the expected type.</li>
<li>the operation <code>ptryFrom @a @b</code> proves equality between the less expressive <code>PType</code> <code>a</code> and the more expressive <code>PType</code> <code>b</code>, hence the first
element of the resulting Tuple must always be wrapped in <code>PAsData</code> if the origin type was <code>PData</code> (see law 1)</li>
<li>the result type <code>b</code> must always be safer than the origin type <code>a</code>, i.e. it must carry more information</li>
</ul>
<blockquote>
<p>Note: doing this in a manner that doesn't error would be really costly and hence we only offer a version that fails with <code>perror</code>.</p>
</blockquote>
<h2 id="ptryfromexcess"><a class="header" href="#ptryfromexcess"><code>PTryFromExcess</code></a></h2>
<p>An important note is, that <code>PTryFrom</code> carries a type <code>PTryFromExcess</code> which safes data that arose as "excess" during the act of verifying. For
<code>PData (PAsData PSomething)</code> instances this most times
carries a <code>PSomething</code>, i.e. the type that has been proven equality for but without <code>PAsData</code> wrapper. In cases where this type is not useful,
the excess type is just an empty <code>HRec</code>.</p>
<h2 id="recovering-only-partially"><a class="header" href="#recovering-only-partially">Recovering only partially</a></h2>
<p>In case we don't want to verify the whole structure but rather part of it (this can be a reasonable decision to lower the fees), we can just leave the part
of the data that is not to be verified a <code>PData</code> which serves as the base case:</p>
<pre><code class="language-haskell">recoverListPartially :: forall r s. Term s PData  -&gt; ((Term s (PAsData (PBuiltinList PData)), Term s (PBuiltinList PData)) -&gt; Term s r) -&gt; Term s r
recoverListPartially = ptryFrom @(PAsData (PBuiltinList PData)) @PData
</code></pre>
<p>This is especially important with something like <code>PDataSum</code> which simply cannot store the excess types over the barrier of <code>pmatch</code> because obviously,
you don't know the type of the excess before actually matching on it. The solution would be to recover an equivalent <code>PDataSum</code> whose constructors
contain <code>PData</code> and after having matched on those, recover the underlying record or whatever field you're interested in. If you're not interested
in the excess, you could of course also just recover the whole Sum without issue, in this case it won't be more expensive.</p>
<p>Please be aware, that nuances can already make a performance difference, e.g.</p>
<ul>
<li>recovering <code>ptryFromData @(PAsData (PBuiltinList PData))</code> is cheaper than <code>ptryFromData @(PAsData (PBuiltinList (PAsData PDAta)))</code> because the latter
maps over no-ops, whereas the former just asserts that the <code>PData</code> indeed contains a <code>PBuiltinList</code>.</li>
<li>If you only, say, need the head of a list, first recovering a <code>PAsData (PBuiltinList PData)</code> (don't forget to use the excess instead of using
<code>pfromData</code>), <em>then</em> using head and after that recovering the field in there will be cheaper than recovering the whole list with the target type and
using head on that.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>This section describes various core Plutarch usage concepts.</p>
<blockquote>
<p>Note: If you spot any mistakes/have any related questions that this guide lacks the answer to, please don't hesitate to raise an issue. The goal is to have high quality documentation for Plutarch users!</p>
</blockquote>
<ul>
<li><a href="./Usage/Conditionals.html">Conditionals</a></li>
<li><a href="./Usage/Recursion.html">Recursion</a></li>
<li><a href="./Usage/PreludeMixin.html">Using the Plutarch Prelude</a></li>
<li><a href="./Usage/DoSyntaxWithTermCont.html">Do syntax with <code>TermCont</code></a></li>
<li><a href="./Usage/DoSyntaxWithQualifiedDo.html">Do syntax with <code>QualifiedDo</code> and <code>Plutarch.Monadic</code></a></li>
<li><a href="./Usage/DerivingForNewtypes.html">Deriving typeclasses for <code>newtype</code>s</a></li>
<li><a href="./Usage/DerivingWithGenerics.html">Deriving typeclasses with generics</a></li>
<li><a href="./Usage/AvoidWorkDuplicationUsingPlet.html"><code>plet</code> to avoid work duplication</a></li>
<li><a href="./Usage/Tracing.html">Tracing</a></li>
<li><a href="./Usage/RaisingErrors.html">Raising errors</a></li>
<li><a href="./Usage/UnsafeFunctions.html">Unsafe functions</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.UsePlet (pfoo, pfoo') where
import Plutarch.Prelude
</code></pre>
</p>
</details>
<h1 id="plet-to-avoid-work-duplication"><a class="header" href="#plet-to-avoid-work-duplication"><code>plet</code> to avoid work duplication</a></h1>
<p>Sometimes, when writing Haskell level functions working on Plutarch terms, you may find yourself needing to re-use the Haskell level function's argument(s) multiple times:</p>
<pre><code class="language-haskell">pfoo :: forall s. Term s PString -&gt; Term s PString
pfoo x = x &lt;&gt; x
</code></pre>
<p>In such cases, you should use <code>plet</code> on the argument to <a href="Usage/./../Tricks/DontDuplicateWork.html">avoid duplicating work</a>.</p>
<pre><code class="language-haskell">pfoo' :: forall s. Term s PString -&gt; Term s PString
pfoo' x = plet x $ \x' -&gt; x' &lt;&gt; x'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.Conditionals (one) where 
import Plutarch.Prelude 
</code></pre>
</p>
</details>
<h1 id="conditionals"><a class="header" href="#conditionals">Conditionals</a></h1>
<p>You can simulate <code>if/then/else</code> at the Plutarch level using <code>pif</code>:</p>
<pre><code class="language-hs">pif :: Term s PBool -&gt; Term s a -&gt; Term s a -&gt; Term s a
</code></pre>
<p>This has similar semantics to Haskell's <code>if/then/else</code>. That is, only the branch for which the predicate holds - is evaluated.</p>
<pre><code class="language-haskell">one :: forall s. Term s PInteger
one = pif (pconstant True) 1 2
</code></pre>
<p>The above evaluates to <code>1</code>, which has type <code>Term s PInteger</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">{-# OPTIONS_GHC -Wno-redundant-constraints #-}
{-# LANGUAGE StandaloneDeriving, FlexibleInstances, UndecidableInstances #-}

module Plutarch.Docs.DerivingForNewtype (PPubKeyHash'(..), PPubKeyHash(..)) where
import Plutarch.Prelude
import GHC.Generics (Generic)
import Generics.SOP qualified as SOP
</code></pre>
</p>
</details>
<h1 id="deriving-typeclasses-for-newtypes"><a class="header" href="#deriving-typeclasses-for-newtypes">Deriving typeclasses for <code>newtype</code>s</a></h1>
<p>If you're defining a <code>newtype</code> to an existing Plutarch type, like so:</p>
<pre><code class="language-haskell">newtype PPubKeyHash' (s :: S) = PPubKeyHash' (Term s (PDataNewtype PByteString))
</code></pre>
<p>You ideally want to just have this <code>newtype</code> be represented as a <code>PByteString</code> under the hood. Therefore, all the typeclass instances of <code>PByteString</code> make sense for
<code>PPubKeyHash</code> as well. In this case, you can simply derive all those typeclasses for your <code>PPubKeyHash</code> type as well:</p>
<pre><code class="language-haskell">newtype PPubKeyHash (s :: S) = PPubKeyHash (Term s (PDataNewtype PByteString))
  deriving stock (Generic)
  deriving anyclass (SOP.Generic, PIsData, PEq, POrd, PShow)
  deriving (PlutusType) via (DeriveNewtypePlutusType PPubKeyHash)
</code></pre>
<blockquote>
<p>Note: It's important to note that the content of a <code>newtype</code> <em>that aims to be a Plutarch type</em> (i.e. can be represented as a Plutarch term), must also be a Plutarch term.
The type <code>PByteString s</code> simply doesn't exist in the Plutus Core world after compilation. It's all just <code>Term</code>s. So, when you say <code>Term s PPubKeyHash</code>, you're really just
describing a <code>Term s PByteString</code> under the hood - since that's what it <em>is</em> during runtime.</p>
</blockquote>
<blockquote>
<p>Aside: You can access the inner type using <code>pto</code> (assuming it's a <code>PlutusType</code> instance). For example, <code>pto x</code>, where <code>x :: Term s PPubKeyHash</code>, would give you
<code>Term s PByteString</code>. <code>pto</code> converts a <a href="Usage/./../Typeclasses/PlutusType,PCon,PMatch.html"><code>PlutusType</code></a> term to its inner type. This is very useful, for
example, when you need to use a function that operates on bytestring terms, but all you have is a <code>Term s PPubKeyHash</code>. You <em>know</em> it's literally a bytestring
under the hood anyway - but how do you obtain that? Using <code>pto</code>!</p>
</blockquote>
<p>Currently, <code>DerivePNewtype</code> lets you derive the following typeclasses for your Plutarch <em>types</em>:</p>
<ul>
<li><code>PEq</code></li>
<li><code>PIntegral</code></li>
<li><code>PIsData</code></li>
<li><code>PNum</code></li>
<li><code>POrd</code></li>
<li><code>PShow</code></li>
<li><code>PlutusType</code></li>
</ul>
<blockquote>
<p>Note: You cannot derive instances for <code>Term</code>s anymore because of coherence issues with the previous solutions. All derivations have to
be done for the PlutusType (e.g. you cannot newtype derive <code>Semigroup</code> for <code>PPubKeyHash</code> anymore)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">{-# LANGUAGE UndecidableInstances #-}

module Plutarch.Docs.DerivingGenerics (PMyType (..)) where

import Plutarch.Prelude
import Data.Kind (Type)
import GHC.Generics (Generic)
import Generics.SOP qualified as SOP
</code></pre>
</p>
</details>
<h1 id="deriving-typeclasses-with-generics"><a class="header" href="#deriving-typeclasses-with-generics">Deriving typeclasses with generics</a></h1>
<p>Plutarch also provides sophisticated generic deriving support for completely custom types. In particular, you can easily derive <code>PlutusType</code> for your own type:</p>
<pre><code class="language-haskell">data PMyType (a :: S -&gt; Type) (b :: S -&gt; Type) (s :: S)
  = POne (Term s a)
  | PTwo (Term s b)
  deriving stock (Generic)
  deriving anyclass (SOP.Generic)
  deriving (PlutusType) via (DeriveAsSOPStruct (PMyType a b))
</code></pre>
<blockquote>
<p>Note: This requires the <code>generics-sop</code> package.</p>
</blockquote>
<p>This will use a <a href="Usage/./../Concepts/DataAndScottEncoding.html#scott-encoding">SOP encoding representation</a> for <code>MyType</code>, which is typically what you want.
If you want to use <a href="Usage/./../Concepts/DataAndScottEncoding.html">data encoding representation</a> instead in your <code>PlutusType</code> instance - you should derive it
using <code>PlutusTypeData</code>. Check out: <a href="Usage/./../Typeclasses/PIsDataReprAndPDataFields.html#implementing-pisdatarepr-and-friends">implementing <code>PIsDataRepr</code> and friends</a></p>
<p>Currently, generic deriving supports the following typeclasses:</p>
<ul>
<li><a href="Usage/./../Typeclasses/PlutusType,PCon,PMatch.html#implementing-plutustype-for-your-own-types-scott-encoding"><code>PlutusType</code></a> (Scott encoding only)</li>
<li><a href="Usage/./../Typeclasses/PEqAndPOrd.html"><code>PEq</code></a></li>
<li><a href="Usage/./../Typeclasses/PEqAndPOrd.html"><code>POrd</code></a></li>
<li><a href="Usage/./../Typeclasses/PTryFrom.html"><code>PTryFrom</code></a></li>
<li><code>PShow</code></li>
<li><code>PIsData</code></li>
<li><code>PDataFields</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">{-# LANGUAGE QualifiedDo #-}

module Plutarch.Docs.QDo (f) where
import Plutarch.LedgerApi.V3 (PScriptPurpose (PSpending))
import qualified Plutarch.Monadic as P
import Plutarch.Prelude

</code></pre>
</p>
</details>
<h1 id="do-syntax-with-qualifieddo-and-plutarchmonadic"><a class="header" href="#do-syntax-with-qualifieddo-and-plutarchmonadic">Do syntax with <code>QualifiedDo</code> and <code>Plutarch.Monadic</code></a></h1>
<p>In <code>ghc92</code>+ we can use do notation without using the <code>Monad</code> instances for some type by using overloaded syntax.
This overloaded syntax is provided by the <code>-XQualifiedDo</code> extension</p>
<p>The <code>Plutarch.Monadic</code> module exports <code>&gt;&gt;=</code>, <code>&gt;&gt;</code>, and <code>fail</code> functions suitable to be used with <code>QualifiedDo</code>.</p>
<pre><code class="language-haskell">f :: Term s (PScriptPurpose :--&gt; PUnit)
f = plam $ \x -&gt; P.do
  PSpending _ &lt;- pmatch x
  ptraceInfo "matched spending script purpose"
  pconstant ()
</code></pre>
<p>In essence, <code>P.do { x; y }</code> simply translates to <code>x y</code>; where <code>x :: a -&gt; Term s b</code> and <code>y :: a</code>.</p>
<p>Similarly, <code>P.do { y &lt;- x; z }</code> translates to <code>x $ \case { y -&gt; z; _ -&gt; ptraceError &lt;msg&gt; }</code>; where <code>x :: (a -&gt; Term s b) -&gt; Term s b</code>, <code>y :: a</code>, and <code>z :: Term s b</code>.
Of course, if <code>y</code> is a fully exhaustive pattern match (e.g. singular constructor), the extra <code>_ -&gt; ptraceError &lt;msg&gt;</code> case will not be generated at all and you'd simply
get <code>x $ \y -&gt; z</code>.</p>
<blockquote>
<p>Note: if a pattern match fails, e.g. when using the <code>PJust a &lt;- ...</code> syntax, it will use <code>Plutarch.Monadic</code>'s implementation of <code>fail</code></p>
</blockquote>
<p>Finally, <code>P.do { x }</code> is just <code>x</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.TermCont (test, testC, foo) where
import Plutarch.LedgerApi.V3 (PScriptPurpose (PSpending))
import Plutarch.Prelude hiding (pmatchC, ptraceC)
</code></pre>
</p>
</details>
<h1 id="do-syntax-with-termcont"><a class="header" href="#do-syntax-with-termcont">Do syntax with <code>TermCont</code></a></h1>
<blockquote>
<p>Note: The use of qualified do is preferred compared to the use of <code>TermCont</code> due to some shortcomings of the implementation
of the <code>Monad</code> typeclass in <code>base</code></p>
</blockquote>
<p>Continuation functions like <code>pmatch</code>, <code>plet</code>, and <code>pletFields</code> aren't exactly the most convenient, are they? Fortunately,
<code>TermCont</code> makes it much easier to use. <code>TermCont</code> is the familiar
<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Cont.html"><code>Cont</code></a> monad, specialized for Plutarch terms.</p>
<p><code>TermCont @b s a</code> essentially represents <code>(a -&gt; Term s b) -&gt; Term s b</code>. <code>a</code> being the input to the continuation, and <code>Term s b</code>
being the output. Notice the type application - <code>b</code> must have been brought into scope through another binding first.</p>
<p>Consider the snippet:</p>
<pre><code class="language-haskell">test :: Term s (PScriptPurpose :--&gt; PUnit)
test = plam $ \x -&gt; pmatch x $ \case
  PSpending _ -&gt; ptraceInfo "matched spending script purpose" $ pconstant ()
  _ -&gt; ptraceInfoError "pattern match failure"
</code></pre>
<p>That's rather ugly! <a href="Usage/./../Typeclasses/PlutusType,PCon,PMatch.html"><code>pmatch</code></a> takes in a continuation as its second argument. Can we make this a bit more ergonomic?</p>
<pre><code class="language-haskell">pmatchC :: PlutusType a =&gt; Term s a -&gt; TermCont s (a s)
pmatchC = tcont . pmatch

ptraceInfoC :: Term s PString -&gt; TermCont s ()
ptraceInfoC s = tcont $ \f -&gt; ptraceInfo s (f ())

testC :: Term s (PScriptPurpose :--&gt; PUnit)
testC = plam $ \x -&gt; unTermCont $ do
  PSpending _ &lt;- pmatchC x
  ptraceInfoC "matched spending script purpose"
  pure $ pconstant ()
</code></pre>
<p>How cool is that? You can use regular <code>do</code> syntax on the <code>TermCont</code> monad. All the continuations are flattened! Just remember to <code>unTermCont</code> the result.</p>
<p>Furthermore, this is very similar to the <code>Cont</code> monad - it just operates on Plutarch level terms. This means you can draw parallels to utilities and patterns
one would use when utilizing the <code>Cont</code> monad. Here's an example:</p>
<pre><code class="language-haskell">-- | Terminate with given value on empty list, otherwise continue with head and tail.
nonEmpty :: Term s r -&gt; PList a s -&gt; TermCont @r s (Term s a, Term s (PList a))
nonEmpty x0 list = tcont $ \k -&gt;
  case list of
    PSCons x xs -&gt; k (x, xs)
    PSNil -&gt; x0

foo :: Term s (PList PInteger :--&gt; PInteger)
foo = plam $ \l -&gt; unTermCont $ do
  (x, xs) &lt;- nonEmpty 0 =&lt;&lt; tcont (pmatch l)
  pure $ x + plength # xs
</code></pre>
<p><code>foo</code> adds up the first element of the given list with the length of its tail. Unless the list was empty, in which case, it just returns 0. It uses
continuations with the <code>do</code> syntax to elegantly utilize short circuiting!</p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.RaiseErrs (fails) where
import Plutarch.Prelude
</code></pre>
</p>
</details>
<h1 id="raising-errors"><a class="header" href="#raising-errors">Raising errors</a></h1>
<p>In PlutusTx, you'd signal validation failure with the <a href="https://plutonomicon.github.io/plutarch-plutus/haddock/plutus-tx/html/PlutusTx-Builtins-Internal.html#v:error"><code>error</code></a> function. You can do the same in Plutarch using <code>perror</code>.</p>
<pre><code class="language-haskell">fails :: Term s (PData :--&gt; PData :--&gt; PData :--&gt; PUnit)
fails = plam $ \_ _ _ -&gt; perror
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.Recursion (pfac) where 
import Plutarch.Prelude
</code></pre>
</p>
</details>
<h1 id="recursion"><a class="header" href="#recursion">Recursion</a></h1>
<p>To emulate recursion in <a href="https://github.com/Plutonomicon/plutonomicon/blob/main/uplc.md">UPLC (Untyped Plutus Core)</a>, you need to
use <a href="https://stackoverflow.com/questions/93526/what-is-a-y-combinator">the Y combinator</a>. Plutarch provides the Y combinator with the name <code>pfix</code>:</p>
<pre><code class="language-hs">pfix :: Term s (((a :--&gt; b) :--&gt; (a :--&gt; b)) :--&gt; (a :--&gt; b))
</code></pre>
<p>It works as you would expect, though the type is scary. Think of it as the Haskell type:</p>
<pre><code class="language-hs">fix :: ((a -&gt; b) -&gt; (a -&gt; b)) -&gt; (a -&gt; b)
</code></pre>
<p>The first argument is "self", or the function you want to recurse with.</p>
<p>The below example implements a Plutarch-level factorial function:</p>
<pre><code class="language-haskell">pfac :: Term s (PInteger :--&gt; PInteger)
pfac = pfix #$ plam f
  where
    f :: Term s (PInteger :--&gt; PInteger) -&gt; Term s PInteger -&gt; Term s PInteger
    f self n = pif (n #== 1) n $ n * (self #$ n - 1)
-- (ignore the existence of non positives :D)
</code></pre>
<p>Note how <code>f</code> takes in a <code>self</code> and just recurses on it. All you have to do, is create a Plutarch level function by using <code>plam</code> on <code>f</code> and <code>pfix</code>
the result - and that <code>self</code> argument will be taken care of for you.</p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.Tracing () where 
import Plutarch.Prelude ()
</code></pre>
</p>
</details>
<h1 id="tracing"><a class="header" href="#tracing">Tracing</a></h1>
<p>Fundamentally, there are two kinds of traces Plutarch can add to your code:</p>
<ul>
<li>Info tracing, which is the 'regular' kind of tracing; and</li>
<li>Debug tracing, which is supposed to be more verbose and provide more detail
for debugging purposes.</li>
</ul>
<p>The basic way you can add traces to your code is using <code>ptraceInfo</code> to add an
info trace, and <code>ptraceDebug</code> to add a debug trace. <code>Plutarch.Trace</code> (and
<code>Plutarch.Prelude</code>) export additional functions for more specific cases,
including ones that include use of <code>PShow</code>, and that only inject a trace under
certain conditions. See those modules, and their documentation, for more
details.</p>
<p>If you have the <code>development</code> flag for <code>plutarch</code> turned on - you'll see the
trace messages appear in the trace log during script evaluation. When not
in development mode, these functions basically do nothing.</p>
<h1 id="important-note"><a class="header" href="#important-note">Important note</a></h1>
<p>Use of <code>PShow</code> is strongly discouraged in any production on-chain scripts.
This uses a lot of resources onchain, and can easily exhaust script
limits unless done carefully. In general, only resort to <code>PShow</code> if you
absolutely have to: otherwise, prefer static strings as outputs.</p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.Unsafe () where 
import Plutarch.Prelude ()
</code></pre>
</p>
</details>
<h1 id="unsafe-functions"><a class="header" href="#unsafe-functions">Unsafe functions</a></h1>
<p>There are internal functions such as <code>punsafeCoerce</code>, <code>punsafeConstant</code> etc. that give you terms without their specific type.
These <strong>should not</strong> be used by Plutarch users. It is the duty of the user of these unsafe functions to get the type right -
and it is very easy to get the type wrong. You can easily make the type system believe you're creating a <code>Term s PInteger</code>,
when in reality, you created a function.</p>
<p>Things will go very wrong during script evaluation if you do that kind of thing.</p>
<p>The good thing is that unsafe functions all have explicit indicators through the names, as long as you don't use any <code>punsafe*</code>
functions - you should be fine!</p>
<blockquote>
<p>Note: unsafe functions are exported by the <code>Plutarch.Unsafe</code> module</p>
</blockquote>
<p>Of course, these have legitimate use cases. Most often, we use these functions to convert between types that <em>truly</em> have the same
internal representation in UPLC - but the type system simply isn't expressive enough to infer that.</p>
<div style="break-before: page; page-break-before: always;"></div><p>This document discusses various rules of thumb and general trivia, aiming to make life as a Plutarch user or auditor easier.</p>
<blockquote>
<p>Note: If you spot any mistakes/have any related questions that this guide lacks the answer to, please don't hesitate to raise an issue. The goal is to have high quality documentation for Plutarch users!</p>
</blockquote>
<ul>
<li><a href="./Tricks/PlutarchFunctionsStrict.html">Plutarch functions are strict</a></li>
<li><a href="./Tricks/DontDuplicateWork.html">Don't duplicate work</a>
<ul>
<li><a href="./Tricks/DontDuplicateWork.html#where-should-arguments-be-pleted">Where should arguments be <code>plet</code>ed?</a></li>
</ul>
</li>
<li><a href="./Tricks/PreferPlutarchFunctions.html">Prefer Plutarch level functions</a></li>
<li><a href="./Tricks/UsingHaskellLevelFunctions.html">When to use Haskell level functions?</a></li>
<li><a href="./Tricks/DifferenceBetweenPconAndPconstant.html">The difference between <code>PlutusType</code>/<code>PCon</code> and <code>PLift</code>'s <code>pconstant</code></a></li>
<li><a href="./Tricks/ResponsibilityOfEvaluationInHaskellFunctions.html">Let Haskell level functions take responsibility of evaluation</a></li>
<li><a href="./Tricks/makeIsDataIndexed,HaskellADTs,PIsDataRepr.html">The isomorphism between <code>makeIsDataIndexed</code>, Haskell ADTs, and <code>PIsDataRepr</code></a></li>
<li><a href="./Tricks/PreferStaticallyBuildingConstants.html">Prefer statically building constants whenever possible</a></li>
<li><a href="./Tricks/RepresentationOfPlutarchType.html">Figuring out the representation of a Plutarch type</a></li>
<li><a href="./Tricks/PreferMatchingOnPmatchResultImmediately.html">Prefer pattern matching on the result of <code>pmatch</code> immediately</a></li>
<li><a href="./Tricks/WorkingWithBoundFields.html">Working with bound fields yielded by <code>pletFields</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.DifferencePconPconstant () where
import Plutarch.Prelude
import Plutarch.Internal.PlutusType (PlutusType(pcon', pmatch'))
</code></pre>
</p>
</details>
<h1 id="the-difference-between-plutustypepcon-and-plifts-pconstant"><a class="header" href="#the-difference-between-plutustypepcon-and-plifts-pconstant">The difference between <code>PlutusType</code>/<code>PCon</code> and <code>PLift</code>'s <code>pconstant</code></a></h1>
<p><code>PlutusType</code> is especially useful for building up Plutarch terms <em>dynamically</em> - i.e. from arbitrary Plutarch terms. This is when your Plutarch type's constructors contain other Plutarch terms.</p>
<p>Another case <code>PlutusType</code> is useful is when you want to give your Plutarch type a custom representation, Scott encoding, enum - what have you. From the <code>PlutusType</code> haddock example:</p>
<pre><code class="language-haskell">data AB (s :: S) = A | B

instance PlutusType AB where
  type PInner AB = PInteger
  pcon' A = 0
  pcon' B = 1
  pmatch' x f = pif (x #== 0) (f A) (f B)
</code></pre>
<p>You can use the <code>A</code> and <code>B</code> constructors during building, but still have your type be represented as integers under the hood! You cannot do this with <code>pconstant</code>.</p>
<p>You should prefer <code>pconstant</code>/<code>pconstantData</code> (from <a href="Tricks/./../Typeclasses/PLiftable.html"><code>PLiftable</code>/</a>) when you can build something up entirely from Haskell level constants and that <em>something</em> has the same representation as the Haskell constant.</p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.WorkDuplication (abs, abs', pf, pf') where
import Plutarch.Prelude
import Prelude hiding (abs)
</code></pre>
</p>
</details>
<h1 id="dont-duplicate-work"><a class="header" href="#dont-duplicate-work">Don't duplicate work</a></h1>
<p>Haskell bindings are simply "inlined" during Plutarch compilation.</p>
<p>Consider the simple snippet:</p>
<pre><code class="language-haskell">pf :: Term s PInteger
pf =
  let
    foo :: forall s. Term s PInteger
    foo = 1 + 2      -- | A Haskell binding.
  in pif
       (foo #== 3)     -- | A.) ...then inline here...
       foo             -- | B.) ...and inline here.
       7
</code></pre>
<p>Using the <code>printTerm</code> function (provided by the top level <code>Plutarch</code> module), we can view
the computation bound to <code>foo</code>. The formatting below is our own; notice that
<code>foo</code>, which becomes <code>(addInteger 1 2)</code> in UPLC, is inlined twice:</p>
<pre><code class="language-hs">&gt; printTerm pf

(...)

(force
    (force ifThenElse
       (equalsInteger
          (addInteger 1 2)      -- | A.) `foo` appears here...
          3
       )
       (delay (addInteger 1 2)) -- | B.) ...and here
       (delay 7)
    )
)
</code></pre>
<p>Performing this computation twice is obviously bad (in this circumstance), since it will increase
the execution budget for the script.</p>
<p>A technique to circumvent this is to introduce a free variable via a lambda,
replace the inlined expression (in our case, <code>(addInteger 1 2)</code>) with that variable, and them
apply the lambda to the <em>calculated</em> expression:</p>
<pre><code class="language-hs">&gt; printTerm pf'

(...)

((\\i0 -&gt;                          -- | A'.) Introduce a lambda here,...
    force
        (force ifThenElse
            (equalsInteger i1 3)   -- | B'.) ...apply the argument here,...
            (delay i1)             -- | C'.) ...and apply the argument here,
            (delay 7)
        )
 ) (addInteger 1 2)                -- | D'.) ...then calculate `foo` once and apply the lambda
)
</code></pre>
<p>Plutarch provides the <code>plet :: Term s a -&gt; (Term s a -&gt; Term s b) -&gt; Term s b</code> function
to accomplish exactly this. To demonstrate this technique, the implementation of <code>pf'</code> that
will lead to the above UPLC is given as:</p>
<pre><code class="language-haskell">{-
Note: the letter labels on our annotations match the operations in the
previous example.
-}

pf' :: Term s PInteger
pf' =
  plet (1 + 2) $             -- | D.') Calculate the desired value here (strictly),...
  \foo -&gt;                    -- | A.') ...introduce a lambda abstraction,...
    pif
      (foo #== 3)            -- | B.') ...and apply the argument here...
      foo                    -- | C.') ... and here.
      7
</code></pre>
<p>Another example of this would be:</p>
<pre><code class="language-haskell">abs :: Term s PInteger -&gt; Term s PInteger
abs x = pif (x #&lt;= -1) (negate x) x
</code></pre>
<p>Guess what would happen if you used it like:</p>
<pre><code class="language-hs">abs (reallyExpensiveFunction # arg)
</code></pre>
<p>It'd turn into:</p>
<pre><code class="language-hs">pif ((reallyExpensiveFunction # arg) #&lt;= -1) (negate (reallyExpensiveFunction # arg)) (reallyExpensiveFunction # arg)
</code></pre>
<p>Oh no. <code>reallyExpensiveFunction</code> is going to be <em>applied three times</em>. That's 3 times the cost!</p>
<p>Instead, consider using <code>plet</code>:</p>
<pre><code class="language-haskell">abs' :: Term s PInteger -&gt; Term s PInteger
abs' x' = plet x' $ \x -&gt; pif (x #&lt;= -1) (negate x) x
</code></pre>
<p>Of course, what you <em>really</em> should do , is prefer Plutarch level functions whenever possible. Since arguments to Plutarch level functions are pre-evaluated and those bindings are completely ok to use as many times as you want!</p>
<h2 id="where-should-arguments-be-pleted"><a class="header" href="#where-should-arguments-be-pleted">Where should arguments be <code>plet</code>ed?</a></h2>
<p>You don't have to worry about work duplication on arguments in <em>every single scenario</em>. In particular, the argument to <code>plam</code> is also a Haskell function, isn't it? But you don't need to worry about <code>plet</code>ing your arguments there since it becomes a Plutarch level function through <code>plam</code> - thus, all the arguments are evaluated before being passed in.</p>
<p>Where else is <code>plet</code> unnecessary? Functions taking in continuations, such as <code>plet</code> (duh) and <code>pletFields</code>, always pre-evaluate the binding. An exception, however, is <code>pmatch</code>. In certain cases, you don't need to <code>plet</code> bindings within the <code>pmatch</code> case handler. For example, if you use <code>pmatch</code> on a <code>PList</code>, the <code>x</code> and <code>xs</code> in the <code>PSCons x xs</code> <em>will always be pre-evaluated</em>. On the other hand, if you use <code>pmatch</code> on a <code>PBuiltinList</code>, the <code>x</code> and <code>xs</code> in the <code>PCons x xs</code> <em>are <strong>not</strong> pre-evaluated</em>. Be sure to <code>plet</code> them if you use them several times!</p>
<p>In general, <code>plet</code>ing something back-to-back several times will be optimized to a singular <code>plet</code> anyway. However, you should know that for data encoded types (types that follow "<a href="Tricks/./../Typeclasses/PIsDataReprAndPDataFields.html#implementing-pisdatarepr-and-friends">implementing <code>PIsDataRepr</code> and friends</a>") and Scott encoded types, <code>pmatch</code> handlers get pre-evaluated bindings. For <code>PBuiltinList</code>, and <code>PDataRecord</code> - the bindings are not pre-evaluated.</p>
<p>You should also <code>plet</code> local bindings! In particular, if you applied a function (Plutarch level or Haskell level) to obtain a value, then bound that value to a variable e.g. with <code>let</code> or <code>where</code>, then avoid using it multiple times. The binding will simply get inlined as the function application - and it'll keep getting re-evaluated. You should <code>plet</code> it first!</p>
<p>This also applies to field accesses using <code>OverloadedRecordDot</code>. When you do <code>ctx.purpose</code>, it really gets translated to <code>getField @"purpose" ctx</code>, which is a function call! If you use the field multiple times, <code>plet</code> it first.</p>
<p>Another slightly obscure case can be observed in scott encoded types. When you build a scott encoded type using <code>pcon</code> - the Plutarch terms you use as fields are simply inlined within the scott encoded type. As such, <code>pcon $ PPair &lt;complex expr&gt; &lt;another complex expr&gt;</code> ends up like:</p>
<pre><code class="language-hs">(\f -&gt; f &lt;complex expr&gt; &lt;another complex expr&gt;)
</code></pre>
<p>This is practically pseudocode. However, it demonstrates that your expressions are not evaluated when <em>building</em> the scott encoded pair. Indeed, they will be evaluated when you <code>pmatch</code> on it. As such, if you <code>pmatch</code> on this pair multiple times, those expressions will evaluate multiple times!</p>
<p>If you <em>must</em> <code>pmatch</code> on such types several times, <code>plet</code> the fields before building the container type!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-isomorphism-between-makeisdataindexed-haskell-adts-and-pisdatarepr"><a class="header" href="#the-isomorphism-between-makeisdataindexed-haskell-adts-and-pisdatarepr">The isomorphism between <code>makeIsDataIndexed</code>, Haskell ADTs, and <code>PIsDataRepr</code></a></h1>
<p>When <a href="Tricks/./../Typeclasses/PIsDataReprAndPDataFields.html#implementing-pisdatarepr-and-friends">implementing <code>PIsDataRepr</code></a> for a Plutarch type, if the Plutarch type also has a <a href="Tricks/./../Concepts/HaskellSynonym.html">Haskell synonym</a> (e.g. <code>ScriptContext</code> is the Haskell synonym to <code>PScriptContext</code>) that uses <a href="https://plutonomicon.github.io/plutarch-plutus/haddock/plutus-tx/html/PlutusTx-IsData.html#v:makeIsDataIndexed"><code>makeIsDataIndexed</code></a> - you must make sure the constructor ordering is correct.</p>
<p>In particular, with <code>makeIsDataIndexed</code>, you can assign <em>indices</em> to your Haskell ADT's constructors. This determines how the ADT will be represented in Plutus Core. It's important to ensure that the corresponding Plutarch type <em>knows</em> about these indices so it can decode the ADT correctly - in case you passed it into Plutarch code, through Haskell.</p>
<p>For example, consider <code>Maybe</code>. Plutus assigns these indices to its constructors:</p>
<pre><code class="language-hs">makeIsDataIndexed ''Maybe [('Just, 0), ('Nothing, 1)]
</code></pre>
<p>0 to <code>Just</code>, 1 to <code>Nothing</code>. So the corresponding Plutarch type, <code>PMaybeData</code> is defined as:</p>
<pre><code class="language-hs">data PMaybeData a (s :: S)
  = PDJust (Term s (PDataRecord '["_0" ':= a]))
  | PDNothing (Term s (PDataRecord '[]))
</code></pre>
<p>It'd be a very subtle mistake to instead define it as:</p>
<pre><code class="language-hs">data PMaybeData a (s :: S)
  = PDNothing (Term s (PDataRecord '[]))
  | PDJust (Term s (PDataRecord '["_0" ':= a]))
</code></pre>
<p>The constructor ordering is wrong!</p>
<p>It's not just constructor ordering that matters - field ordering does too! Though this is self explanatory. Notice how <code>PTxInfo</code> shares the exact same field ordering as its Haskell synonym - <code>TxInfo</code>.</p>
<pre><code class="language-hs">newtype PTxInfo (s :: S)
  = PTxInfo
      ( Term
          s
          ( PDataRecord
              '[ "inputs" ':= PBuiltinList (PAsData PTxInInfo)
               , "outputs" ':= PBuiltinList (PAsData PTxOut)
               , "fee" ':= PValue
               , "mint" ':= PValue
               , "dcert" ':= PBuiltinList (PAsData PDCert)
               , "wdrl" ':= PBuiltinList (PAsData (PBuiltinPair (PAsData PStakingCredential) (PInteger)))
               , "validRange" ':= PPOSIXTimeRange
               , "signatories" ':= PBuiltinList (PAsData PPubKeyHash)
               , "datums" ':= PBuiltinList (PAsData (PBuiltinPair (PAsData PDatumHash) (PAsData PDatum)))
               , "id" ':= PTxId
               ]
          )
      )
</code></pre>
<pre><code class="language-hs">data TxInfo = TxInfo
  { txInfoInputs      :: [TxInInfo]
  , txInfoOutputs     :: [TxOut]
  , txInfoFee         :: Value
  , txInfoMint        :: Value
  , txInfoDCert       :: [DCert]
  , txInfoWdrl        :: [(StakingCredential, Integer)]
  , txInfoValidRange  :: POSIXTimeRange
  , txInfoSignatories :: [PubKeyHash]
  , txInfoData        :: [(DatumHash, Datum)]
  , txInfoId          :: TxId
  }
</code></pre>
<p>The <em>field names</em> don't matter though. They are merely labels that don't exist at runtime.</p>
<h2 id="what-about-newtypes"><a class="header" href="#what-about-newtypes">What about <code>newtype</code>s?</a></h2>
<p>Of course, this does not apply when you're using <code>newtype</code> derivation (e.g <code>derive newtype ...</code>) to derive <code>FromData</code> or <code>ToData</code> for your PlutusTx types. In that case, the <code>Data</code> representation is simply the same as the inner type.</p>
<pre><code class="language-hs">import qualified PlutusTx
import PlutusTx.Prelude

newtype CurrencySymbol = CurrencySymbol { unCurrencySymbol :: BuiltinByteString }
  deriving newtype (PlutusTx.ToData, PlutusTx.FromData, PlutusTx.UnsafeFromData)
</code></pre>
<p>Here, for example, <code>CurrencySymbol</code> has the very same <code>Data</code> representation as <code>BuiltinByteString</code>. No extra information is added.</p>
<blockquote>
<p>note that in plutarch what matters is not whether you declare a datatype as haskell data or as haskell newtype but in what
way you derive the plutuscore representation</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.OptimizingUnhoistable (pfoo, pfoo') where
import Plutarch.Prelude
</code></pre>
</p>
</details>
<h1 id="optimizing-unhoistable-lambdas"><a class="header" href="#optimizing-unhoistable-lambdas">Optimizing unhoistable lambdas</a></h1>
<p>Often times, you'll be creating utility functions inside your Plutarch level functions that use free variables. In such cases, the function is unhoistable (i.e, you cannot use <code>phoistAcyclic</code> on it). However, it is likely that your goal is to use this utility function within your primary Plutarch level function several times. At which point, your unhoisted function will be inlined every time you use it and therefore increase script size.</p>
<pre><code class="language-haskell">pfoo :: Term s (PInteger :--&gt; PBuiltinList PInteger :--&gt; PInteger)
pfoo = plam $ \x l -&gt;
  let innerf = plam $ \y -&gt; x + y
  in innerf # 42 + plength # (pmap # innerf # l)
</code></pre>
<p>Here, both uses of <code>innerf</code> will inline the lambda and then apply. This is problematic since you probably wanted to have a single lambda that you could simply reference with a variable.</p>
<p>In these cases, you can simply <a href="Tricks/./DontDuplicateWork.html">use <code>plet</code></a> as you would have <a href="Tricks/../Usage/AvoidWorkDuplicationUsingPlet.html">in other places</a></p>
<pre><code class="language-haskell">pfoo' :: Term s (PInteger :--&gt; PBuiltinList PInteger :--&gt; PInteger)
pfoo' = plam $ \x l -&gt;
  plet (plam $ \y -&gt; x + y) $ \innerf -&gt;
    innerf # 42 + plength # (pmap # innerf # l)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plutarch-functions-are-strict"><a class="header" href="#plutarch-functions-are-strict">Plutarch functions are strict</a></h1>
<p>All Plutarch functions are strict. When you apply a Plutarch function to an argument using <code>papp</code> (or <code>#</code>/<code>#$</code> - synonyms to <code>papp</code>) - the argument will be evaluated before being passed into to the function. If you don't want the argument to be evaluated, you can use <code>pdelay</code>.</p>
<p>See: <a href="Tricks/./../Introduction/DelayAndForce.html">Delay and Force</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.PreferMatchingOnResult (this, this') where
import Plutarch.Prelude
import Plutarch.LedgerApi.V3 (
  PScriptPurpose (
    PSpending,
    PMinting,
    PRewarding,
    PCertifying,
    PVoting,
    PProposing
    )
  )
</code></pre>
</p>
</details>
<h1 id="prefer-pattern-matching-on-the-result-of-pmatch-immediately"><a class="header" href="#prefer-pattern-matching-on-the-result-of-pmatch-immediately">Prefer pattern matching on the result of <code>pmatch</code> immediately</a></h1>
<p>You should always try and pattern match on the result of <code>pmatch</code> <em>immediately</em>. This is because the semantics of <code>pmatch</code> will make anything you write <em>before</em> the pattern match be inlined for every single branch:</p>
<pre><code class="language-haskell">this :: Term s (PScriptPurpose :--&gt; PInteger)
this = plam $ \x -&gt; pmatch x $ \l -&gt;
  plet (1 + 2) $ \i -&gt; case l of
    PMinting _ -&gt; i + 3
    PSpending _ -&gt; i + 4
    PRewarding _ -&gt; i + 5
    PCertifying _ _ -&gt; i + 6
    PVoting _ -&gt; i + 7
    PProposing _ _ -&gt; i + 8
</code></pre>
<p>Notice how the above code <code>plet</code>s a computation <em>before</em> matching on <code>l</code>, the <code>pmatch</code> result. This will make the <code>plet $ 1 + 2 $ \i -&gt; i + &lt;something&gt;</code> be inlined in every branch of your pattern match! That is, not only will it compute the <code>1 + 2</code> every time, it will <em>also</em> <code>plet</code> it, which introduced an extra lambda, only to immediately apply the lambda!</p>
<p>You <em>should always</em> match on the result immediately, whenever possible:</p>
<pre><code class="language-haskell">this' :: Term s (PScriptPurpose :--&gt; PInteger)
this' = plam $ \x -&gt; plet (1 + 2) $ \i -&gt;
  pmatch x $ \case
    PMinting _ -&gt; i + 3
    PSpending _ -&gt; i + 4
    PRewarding _ -&gt; i + 5
    PCertifying _ _ -&gt; i + 6
    PVoting _ -&gt; i + 7
    PProposing _ _ -&gt; i + 8
</code></pre>
<p>This applies much the same with <code>do</code> syntax (whether with <code>TermCont</code> or with <code>QualifiedDo</code>). Try to use inline partial pattern matching (e.g <code>PMinting _ &lt;- pmatch x</code>), or pattern match on the very next line (e.g <code>l &lt;- pmatch x; case l of ...</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prefer-plutarch-level-functions"><a class="header" href="#prefer-plutarch-level-functions">Prefer Plutarch level functions</a></h1>
<p>Plutarch level functions have a lot of advantages - they can be hoisted; they are strict so you can <a href="Tricks/./DontDuplicateWork.html">use their arguments however many times you like without duplicating work</a> etc. Unless you <em>really</em> need laziness, like <code>pif</code> does, try to use Plutarch level functions.</p>
<p>Also see: <a href="Tricks/./../Concepts/Hoisting.html">Hoisting</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.PreferStaticallyBuilding (viacon, viaconstant) where

import Plutarch.Prelude
import Plutarch.LedgerApi.V3 (PScriptPurpose (PMinting), PCurrencySymbol (PCurrencySymbol))
import PlutusLedgerApi.V3 (ScriptPurpose (Minting), CurrencySymbol(CurrencySymbol))

</code></pre>
</p>
</details>
<h1 id="prefer-statically-building-constants-whenever-possible"><a class="header" href="#prefer-statically-building-constants-whenever-possible">Prefer statically building constants whenever possible</a></h1>
<p>Whenever you can build a Plutarch constant out of a pure Haskell value - do it! Functions such as <code>pconstant</code>, <code>phexByteStr</code> operate on regular <a href="Tricks/./../Concepts/HaskellSynonym.html">Haskell synonyms</a> of Plutarch types. Unlike <code>pcon</code>, which potentially works on Plutarch terms (e.g. <code>pcon $ PJust x</code>, <code>x</code> is a <code>Term s a</code>). A Plutarch term is an entirely "runtime" concept. "Runtime" as in "Plutus Core Runtime". They only get evaluated during runtime!</p>
<p>On the other hand, whenever you transform a Haskell synonym to its corresponding Plutarch type using <code>pconstant</code>, <code>phexByteStr</code> etc. - you're <em>directly</em> building a Plutus Core constant. This is entirely static! There are no runtime function calls, no runtime building, it's just <em>there</em>, inside the compiled script.</p>
<p>Here's an example, let's say you want to build a <code>PScriptPurpose</code> - <code>PMinting "f1e301"</code>. Which snippet, do you think, is better?</p>
<pre><code class="language-haskell">viaconstant :: Term s PScriptPurpose
viaconstant = pconstant (Minting (CurrencySymbol "f1e301"))
-- (or)

viacon :: Term s PScriptPurpose
viacon = let currSym = pcon . PCurrencySymbol $ phexByteStr "f1e301"
 in pcon $ PMinting $ pdata currSym
</code></pre>
<p>The semantics are both are the same. But the former (<code>pconstant</code>) compiles to a constant term directly. Whereas the latter compiles to some code that <em>builds</em> the constant during Plutus Core runtime.</p>
<blockquote>
<p>Aside: Remember that Haskell runtime is actually compile-time for Plutarch! Even if you have a dynamically computed variable in the Haskell world, it's still a <em>constant</em> in the Plutarch world. So you can use it just as well as an argument to <code>pconstant</code>!</p>
</blockquote>
<p>Whenever you need to build a Plutarch term of type <code>a</code>, from a Haskell value, use <code>pconstant</code>. Whenever you need to build a Plutarch term of type <code>PAsData a</code>, use <code>pconstantData</code>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="figuring-out-the-representation-of-a-plutarch-type"><a class="header" href="#figuring-out-the-representation-of-a-plutarch-type">Figuring out the representation of a Plutarch type</a></h1>
<p>We've discussed before how <a href="Tricks/./../Introduction/PlutarchTypes.html">Plutarch types are merely tags</a> and don't have a direct connection to their runtime representations. It's important to be able to intuitively figure out the runtime representations from the data type declaration though. This is why most types follow certain conventions.</p>
<p>The representation can only be one of two categories: builtin and Scott encoded. All <em>trivial</em> builtin types are already defined
in Plutarch: <code>PInteger</code>, <code>PByteString</code>, <code>PString</code>, <code>PBool</code>, <code>PUnit</code>, <code>PBuiltinList</code> and <code>PBuiltinPair</code>.</p>
<p>Now, let's discuss patterns of data declarations and what representation they <em>should</em> hint at:</p>
<ul>
<li>
<p>If it's an ADT that derives <code>PlutusType</code> with <code>DPTStrat _ = PlutusTypeScott</code>, then the ADTs will be scottencoded. This is
what you generally want for non-trivial types that are not stored in datums or redeemers.</p>
<p>e.g. <code>PList</code> derives <code>PlutusType</code> generically and is represented with Scott encoding.</p>
</li>
<li>
<p>If it's an ADT that derives PlutusType with <code>DPTStrat _ = PlutusTypeData</code> it's data encoded. Particularly, it's
a <a href="https://plutonomicon.github.io/plutarch-plutus/haddock/plutus-tx/html/PlutusTx.html#t:Data"><code>Data</code></a> value - which
is part of the builtin types.</p>
<p>e.g. <code>PScriptContext</code> derives <code>PlutusType</code> using <code>DPTStrat _ = PlutusTypeData</code></p>
</li>
<li>
<p>If it's a representationally equal wrapper (think Haskell <code>newtype</code>) to a term containing a Plutarch type - it should have the
same representation as that underlying Plutarch type.</p>
<p>e.g. <code>newtype PPositive (s :: S) = PPositive (Term s PInteger)</code> is just represented as <code>PInteger</code>. This is ensured
by deriving <code>PlutusType</code> with <a href="Tricks/./../Usage/DerivingForNewtypes.html"><code>DPTStrat _ = PlutusTypeNewtype</code></a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="let-haskell-level-functions-take-responsibility-of-evaluation"><a class="header" href="#let-haskell-level-functions-take-responsibility-of-evaluation">Let Haskell level functions take responsibility of evaluation</a></h1>
<p>We've discussed how a Haskell level function that operates on Plutarch level terms needs to
<a href="Tricks/./DontDuplicateWork.html">be careful</a> about <a href="Tricks/../Usage/AvoidWorkDuplicationUsingPlet.html">work duplication</a>.
Related to this point, it's good practice to design your Haskell level functions so that <em>it takes responsibility</em> for evaluation.</p>
<p>The user of your Haskell level function doesn't know how many times it uses the argument it has been passed! If it uses the
argument multiple times without <code>plet</code>ing it - there's duplicate work! There are two solutions here:</p>
<ul>
<li>The user <code>plet</code>s the argument before passing it to the Haskell level function.</li>
<li>The Haskell level function takes responsibility of its argument and <code>plet</code>s it itself.</li>
</ul>
<p>The former is problematic since it's based on <em>assumption</em>. What if the Haskell level function is a good rule follower, and correctly <code>plet</code>s its argument if using it multiple times? Well, then there's a redundant <code>plet</code> (though back-to-back <code>plet</code>s <em>will</em> be optimized away into one).</p>
<p>Instead, try to offload the responsibility for evaluation to the Haskell level function - so that it only <code>plet</code>s when it needs to.</p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.UsingHaskellLevelFunctions (pelimList, pelimList') where
import Data.Kind (Type)
import Plutarch.Prelude hiding (pelimList)
</code></pre>
</p>
</details>
<h1 id="when-to-use-haskell-level-functions"><a class="header" href="#when-to-use-haskell-level-functions">When to use Haskell level functions?</a></h1>
<p>Although you should generally <a href="Tricks/./PreferPlutarchFunctions.html">prefer Plutarch level functions</a>, there are times when a Haskell level function is actually much better. However, figuring out <em>when</em> that is the case - is a delicate art.</p>
<p>There is one simple and straightforward use case though, when you want a function argument to be lazily evaluated. In such a case, you should use a Haskell level function that <code>pdelay</code>s the argument before calling some Plutarch level function. Recall that <a href="Tricks/./PlutarchFunctionsStrict.html">Plutarch level functions are strict</a>.</p>
<p>Outside of that straightforward use case, figuring out when to use Haskell level functions is quite complex. Haskell level functions will always be inlined when generating the Plutus Core. Unless the function is used <em>only once</em>, this sort of inlining will increase the script size - which is problematic.</p>
<p>However, if the function is used <em>only once</em>, and making it Plutarch level causes extra <code>plam</code>s and <code>#</code>s to be introduced - you should just make it Haskell level. For example, consider the <code>pelimList</code> implementation:</p>
<pre><code class="language-haskell">pelimList ::   PElemConstraint PBuiltinList a =&gt; Term s (a :--&gt; PBuiltinList a :--&gt; r) -&gt; Term s r -&gt; Term s (PBuiltinList a) -&gt; Term s r
pelimList match_cons match_nil ls = pmatch ls $ \case
  PCons x xs -&gt; match_cons # x # xs
  PNil -&gt; match_nil
</code></pre>
<p>It takes in a Plutarch level function, let's see a typical usage:</p>
<pre><code class="language-hs">pelimList
  (plam $ \x xs -&gt; pcons # x # (self # xs))
  pnil
  ls
</code></pre>
<p>This is rather redundant, the above snippet will translate to:</p>
<pre><code class="language-hs">pmatch ls $ \case
  PCons x xs -&gt; (plam $ \x xs -&gt; pcons # x # (self # xs)) # x # xs
  PNil -&gt; match_nil
</code></pre>
<p>Extra <code>plam</code>s and <code>#</code>s have been introduced. Really, <code>pelimList</code> could have taken a Haskell level function instead:</p>
<pre><code class="language-haskell">pelimList' ::
  forall (a :: S -&gt; Type) (r :: S -&gt; Type) (s :: S).
  PElemConstraint PBuiltinList a
  =&gt; (Term s a -&gt; Term s (PBuiltinList a) -&gt; Term s r)
  -&gt; Term s r -&gt; Term s (PBuiltinList a)
  -&gt; Term s r
pelimList' match_cons match_nil ls = pmatch ls $ \case
  PCons x xs -&gt; match_cons x xs
  PNil -&gt; match_nil
</code></pre>
<p>Now, the following usage:</p>
<pre><code class="language-hs">pelimList
  (\x xs -&gt; pcons # x # (self # xs))
  pnil
  ls
</code></pre>
<p>would turn into:</p>
<pre><code class="language-hs">pmatch ls $ \case
  PCons x xs -&gt; pcons # x # (self # xs)
  PNil -&gt; match_nil
</code></pre>
<p>It turns out that using <code>pelimList</code> <em>almost always</em> involves using a one-off Haskell level function (and therefore a redundant <code>plam</code>). As such, <code>pelimList</code> benefits greatly from just taking a Haskell level function directly.</p>
<p>However, <strong>not all higher order functions</strong> benefit from taking Haskell level functions. In many higher order function use cases, you could benefit from passing a commonly used function argument, rather than a one-off function argument. Imagine <code>map</code>, you don't always map with one-off functions - often, you <code>map</code> with existing, commonly used functions. In these cases, that commonly used function ought to be a Plutarch level function, so it can be hoisted and <code>map</code> can simply reference it.</p>
<div style="break-before: page; page-break-before: always;"></div><details>
<summary> imports </summary>
<p>
<pre><code class="language-haskell">module Plutarch.Docs.WorkingWithBoundFields (foo, foo', coreValidator) where

import GHC.Records (getField)
import GHC.Generics (Generic)
import Plutarch.Prelude
import Plutarch.DataRepr (HRec, HRecOf, PMemberFields)
import Plutarch.LedgerApi.V3 (PTxInfo, PScriptContext)
</code></pre>
</p>
</details>
<h1 id="pdatarecord-is-deprecated-in-favor-of-plutarchreprdata-this-documentation-is-unmaintained-1"><a class="header" href="#pdatarecord-is-deprecated-in-favor-of-plutarchreprdata-this-documentation-is-unmaintained-1">PDataRecord is deprecated in favor of <code>Plutarch.Repr.Data</code>. This documentation is unmaintained.</a></h1>
<h1 id="working-with-bound-fields-yielded-by-pletfields"><a class="header" href="#working-with-bound-fields-yielded-by-pletfields">Working with bound fields yielded by <code>pletFields</code></a></h1>
<p>You may have noticed that <code>pletFields</code> actually returns a Haskell level heterogenous list, with all the interesting fields
"bound" to it. Only the fields you actually use from these bindings are extracted and put into the resulting script. Therefore,
you <em>only pay for what you use</em>.</p>
<pre><code class="language-hs">pletFields ::
  forall fs a s b ps bs.
  ( PDataFields a
  , ps ~ (PFields a)
  , bs ~ (Bindings ps fs)
  , BindFields ps bs
  ) =&gt;
  Term s a -&gt;
  (HRecOf a fs s -&gt; Term s b) -&gt;
  Term s b
</code></pre>
<p>The real juice of that massive type is the <code>HRecOf</code>, which is a utility type alias you can use in functions that operate on the return value of <code>pletFields</code>:</p>
<pre><code class="language-haskell">newtype PFooType s
  = PFooType (Term s (PDataRecord '["frst" ':= PInteger, "scnd" ':= PBool, "thrd" ':= PString]))
  deriving stock (Generic)
  deriving anyclass (PlutusType, PDataFields)
instance DerivePlutusType PFooType where type DPTStrat _ = PlutusTypeData

foo :: HRecOf (PAsData PFooType) '[ "frst", "scnd" ] s -&gt; Term s PInteger
foo h = pif (getField @"scnd" h) (getField @"frst" h) 0
</code></pre>
<blockquote>
<p>Note: Be careful to derive <code>PDataFields</code> on your type if it has only one constructor</p>
</blockquote>
<p>This is very useful for single use functions that you use as "branches" in your validators - they work more like macros or templates rather than real functions. For example, you might have different branches for different constructors of a redeemer, but all branches end up needing to do common field extraction. You could abstract it out using:</p>
<pre><code class="language-haskell">data PSomeRedm s
  = FirstRedm (Term s (PDataRecord '[]))
  | SecondRedm (Term s (PDataRecord '[]))
  deriving stock (Generic)
  deriving anyclass (PlutusType, PIsData)
instance DerivePlutusType PSomeRedm where type DPTStrat _ = PlutusTypeData

firstRedmCheck ::
  HRecOf PTxInfo '[ "inputs", "outputs", "mint", "datums" ] s
  -&gt; TermCont s (Term s PUnit)
firstRedmCheck _info = do
  -- Do checks with info fields here.
  pure $ pconstant ()

secondRedmCheck ::
  HRecOf PTxInfo '[ "inputs", "outputs", "mint", "datums" ] s
  -&gt; TermCont s (Term s PUnit)
secondRedmCheck _info = do
  -- Do checks with info fields here.
  pure $ pconstant ()

coreValidator :: Term s (PData :--&gt; PAsData PSomeRedm :--&gt; PScriptContext :--&gt; PUnit)
coreValidator = plam $ \_ (pfromData -&gt; redm) ctx' -&gt; unTermCont $ do
  ctx &lt;- tcont $ pletFields @'["txInfo", "purpose"] ctx'
  info &lt;- tcont $ pletFields @'["inputs", "outputs", "mint", "datums"] $ getField @"txInfo" ctx
  pmatchC redm &gt;&gt;= \case
    FirstRedm _ -&gt; firstRedmCheck info
    SecondRedm _ -&gt; secondRedmCheck info
</code></pre>
<p>Without it, you may have to fallback to deconstructing <code>info</code> with <code>pletFields</code> in every single branch.</p>
<p>However, this is rather <em>nominal</em>. What if you don't need the exact same fields in all
branches? Let's go back to the example with <code>foo</code> and <code>FooType</code>. What if someone has:</p>
<pre><code class="language-hs">fooTypeHrec &lt;- tcont $ pletFields @'["frst", "scnd", "thrd"] fooTypeValue
foo fooTypeHrec
-- uh oh
</code></pre>
<p>The type required by <code>foo</code> should <em>morally</em> work just fine with <code>fooTypeHrec</code>, but it won't!
What we really want, is some sort of row polymorphism. This is where the <code>PMemberFields</code> type
from <code>Plutarch.DataRepr</code> comes in:</p>
<pre><code class="language-haskell">foo' :: PMemberFields PFooType '["scnd", "frst"] s as =&gt; HRec as -&gt; Term s PInteger
foo' h = pif (getField @"scnd" h) (getField @"frst" h) 0
</code></pre>
<p>Now <code>foo</code> merely requires the <code>HRec</code> to have the <code>"scnd"</code> and <code>"frst"</code> fields from <code>PFooType</code>, more fields are allowed just fine!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
