-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package plutarch-ledger-api
@version 3.3.0


-- | This module is meant to be imported qualified, as some of its
--   identifiers clash with the Plutarch prelude, as well as other parts of
--   the Plutarch API.
module Plutarch.LedgerApi.Interval

data PInterval (a :: S -> Type) (s :: S)
PInterval :: Term s (PLowerBound a) -> Term s (PUpperBound a) -> PInterval (a :: S -> Type) (s :: S)
[$sel:pinteral'from:PInterval] :: PInterval (a :: S -> Type) (s :: S) -> Term s (PLowerBound a)
[$sel:pinteral'to:PInterval] :: PInterval (a :: S -> Type) (s :: S) -> Term s (PUpperBound a)

data PLowerBound (a :: S -> Type) (s :: S)
PLowerBound :: Term s (PExtended a) -> Term s (PAsData PBool) -> PLowerBound (a :: S -> Type) (s :: S)

data PUpperBound (a :: S -> Type) (s :: S)
PUpperBound :: Term s (PExtended a) -> Term s (PAsData PBool) -> PUpperBound (a :: S -> Type) (s :: S)

data PExtended (a :: S -> Type) (s :: S)
PNegInf :: PExtended (a :: S -> Type) (s :: S)
PFinite :: Term s (PAsData a) -> PExtended (a :: S -> Type) (s :: S)
PPosInf :: PExtended (a :: S -> Type) (s :: S)

-- | Given <tt>x</tt>, create the interval <tt>[x, x]</tt>.
psingleton :: forall (a :: S -> Type) (s :: S). Term s (PAsData a :--> PInterval a)

-- | Given <tt>x</tt>, create the interval <tt>[x, +infty)</tt>
pfrom :: forall (a :: S -> Type) (s :: S). Term s (PAsData a :--> PInterval a)

-- | Given <tt>x</tt>, create the interval <tt>(-infty, x]</tt>.
pto :: forall (a :: S -> Type) (s :: S). Term s (PAsData a :--> PInterval a)

-- | Create the interval <tt>(-infty, +infty)</tt>.
palways :: forall (a :: S -> Type) (s :: S). (FromData (AsHaskell a), ToData (AsHaskell a)) => Term s (PInterval a)

-- | <tt><a>pinterval</a> x y</tt> creates the interval <tt>[x, y]</tt>.
pinterval :: forall (a :: S -> Type) (s :: S). Term s (PAsData a :--> (PAsData a :--> PInterval a))

-- | Turn a <a>PLowerBound</a> into a single inclusive bounding value.
pinclusiveLowerBound :: forall (a :: S -> Type) (s :: S). (PIsData a, PCountable a) => Term s (PLowerBound a :--> PExtended a)

-- | Turn a <a>PUpperBound</a> into a single inclusive bounding value.
pinclusiveUpperBound :: forall (a :: S -> Type) (s :: S). (PIsData a, PEnumerable a) => Term s (PUpperBound a :--> PExtended a)

-- | Check if a value is inside the given interval.
pmember :: forall (a :: S -> Type) (s :: S). (PIsData a, PEnumerable a) => Term s (PAsData a :--> (PInterval a :--> PBool))

-- | <tt><a>pcontains</a> # i1 # i2</tt> is true if <tt>i2</tt> is entirely
--   contained in <tt>i1</tt>: more specifically, if for any <tt>s</tt>, if
--   <tt><a>pmember</a> # s # i2</tt>, then <tt><a>pmember</a> # s #
--   i1</tt>.
pcontains :: forall (a :: S -> Type) (s :: S). (PIsData a, PEnumerable a) => Term s (PInterval a :--> (PInterval a :--> PBool))

-- | <tt><tt>before</tt> x i</tt> is true if <tt>x</tt> is earlier than the
--   start of <tt>i</tt>.
pbefore :: forall (a :: S -> Type) (s :: S). (POrd a, PIsData a) => Term s (a :--> (PInterval a :--> PBool))

-- | <tt><tt>after</tt> x u</tt> is true if <tt>x</tt> is later than the
--   end of <tt>i</tt>.
pafter :: forall (a :: S -> Type) (s :: S). (POrd a, PIsData a) => Term s (a :--> (PInterval a :--> PBool))

-- | Check if a <a>PInterval</a> is empty.
pisEmpty :: forall (a :: S -> Type) (s :: S). (PIsData a, PEnumerable a) => Term s (PInterval a :--> PBool)

-- | <tt><a>phull</a> i1 i2</tt> gives the smallest interval that contains
--   both <tt>i1</tt> and <tt>i2</tt>.
phull :: forall (a :: S -> Type) (s :: S). (POrd a, PIsData a) => Term s (PInterval a :--> (PInterval a :--> PInterval a))

-- | <tt><a>pintersection</a> i1 i2</tt> gives the largest interval that is
--   contained in both <tt>i1</tt> and <tt>i2</tt>.
pintersection :: forall (a :: S -> Type) (s :: S). (POrd a, PIsData a) => Term s (PInterval a :--> (PInterval a :--> PInterval a))
instance Plutarch.Internal.PlutusType.PlutusType (Plutarch.LedgerApi.Interval.PExtended a)
instance (Plutarch.Internal.IsData.PIsData a, Plutarch.Internal.Show.PShow a) => Plutarch.Internal.Show.PShow (Plutarch.LedgerApi.Interval.PExtended a)
instance Plutarch.Internal.Eq.PEq (Plutarch.LedgerApi.Interval.PExtended a)
instance Plutarch.Internal.IsData.PIsData (Plutarch.LedgerApi.Interval.PExtended a)
instance Generics.SOP.Universe.Generic (Plutarch.LedgerApi.Interval.PExtended a s)
instance GHC.Generics.Generic (Plutarch.LedgerApi.Interval.PExtended a s)
instance Plutarch.Internal.PlutusType.PlutusType (Plutarch.LedgerApi.Interval.PUpperBound a)
instance (Plutarch.Internal.IsData.PIsData a, Plutarch.Internal.Show.PShow a) => Plutarch.Internal.Show.PShow (Plutarch.LedgerApi.Interval.PUpperBound a)
instance Plutarch.Internal.IsData.PIsData (Plutarch.LedgerApi.Interval.PUpperBound a)
instance Generics.SOP.Universe.Generic (Plutarch.LedgerApi.Interval.PUpperBound a s)
instance GHC.Generics.Generic (Plutarch.LedgerApi.Interval.PUpperBound a s)
instance Plutarch.Internal.PlutusType.PlutusType (Plutarch.LedgerApi.Interval.PLowerBound a)
instance (Plutarch.Internal.IsData.PIsData a, Plutarch.Internal.Show.PShow a) => Plutarch.Internal.Show.PShow (Plutarch.LedgerApi.Interval.PLowerBound a)
instance Plutarch.Internal.IsData.PIsData (Plutarch.LedgerApi.Interval.PLowerBound a)
instance Generics.SOP.Universe.Generic (Plutarch.LedgerApi.Interval.PLowerBound a s)
instance GHC.Generics.Generic (Plutarch.LedgerApi.Interval.PLowerBound a s)
instance Plutarch.Internal.PlutusType.PlutusType (Plutarch.LedgerApi.Interval.PInterval a)
instance (Plutarch.Internal.IsData.PIsData a, Plutarch.Internal.Show.PShow a) => Plutarch.Internal.Show.PShow (Plutarch.LedgerApi.Interval.PInterval a)
instance (Plutarch.Internal.IsData.PIsData a, Plutarch.Enum.PEnumerable a) => Plutarch.Internal.Eq.PEq (Plutarch.LedgerApi.Interval.PInterval a)
instance Plutarch.Internal.IsData.PIsData (Plutarch.LedgerApi.Interval.PInterval a)
instance Generics.SOP.Universe.Generic (Plutarch.LedgerApi.Interval.PInterval a s)
instance GHC.Generics.Generic (Plutarch.LedgerApi.Interval.PInterval a s)
instance (PlutusTx.IsData.Class.FromData (Plutarch.Internal.Lift.AsHaskell a), PlutusTx.IsData.Class.ToData (Plutarch.Internal.Lift.AsHaskell a)) => Plutarch.Internal.Lift.PLiftable (Plutarch.LedgerApi.Interval.PInterval a)
instance (PlutusTx.IsData.Class.FromData (Plutarch.Internal.Lift.AsHaskell a), PlutusTx.IsData.Class.ToData (Plutarch.Internal.Lift.AsHaskell a)) => Plutarch.Internal.Lift.PLiftable (Plutarch.LedgerApi.Interval.PLowerBound a)
instance (PlutusTx.IsData.Class.FromData (Plutarch.Internal.Lift.AsHaskell a), PlutusTx.IsData.Class.ToData (Plutarch.Internal.Lift.AsHaskell a)) => Plutarch.Internal.Lift.PLiftable (Plutarch.LedgerApi.Interval.PUpperBound a)
instance (PlutusTx.IsData.Class.FromData (Plutarch.Internal.Lift.AsHaskell a), PlutusTx.IsData.Class.ToData (Plutarch.Internal.Lift.AsHaskell a)) => Plutarch.Internal.Lift.PLiftable (Plutarch.LedgerApi.Interval.PExtended a)
instance (Plutarch.Internal.IsData.PIsData a, Plutarch.Enum.PCountable a) => Plutarch.Internal.Eq.PEq (Plutarch.LedgerApi.Interval.PLowerBound a)
instance (Plutarch.Internal.IsData.PIsData a, Plutarch.Enum.PCountable a) => Plutarch.Internal.Ord.POrd (Plutarch.LedgerApi.Interval.PLowerBound a)
instance (Plutarch.Internal.IsData.PIsData a, Plutarch.Enum.PEnumerable a) => Plutarch.Internal.Eq.PEq (Plutarch.LedgerApi.Interval.PUpperBound a)
instance (Plutarch.Internal.IsData.PIsData a, Plutarch.Enum.PEnumerable a) => Plutarch.Internal.Ord.POrd (Plutarch.LedgerApi.Interval.PUpperBound a)
instance (Plutarch.Internal.Ord.POrd a, Plutarch.Internal.IsData.PIsData a) => Plutarch.Internal.Ord.POrd (Plutarch.LedgerApi.Interval.PExtended a)


-- | Useful tools that aren't part of the Plutarch API per se, but get used
--   in multiple places.
module Plutarch.LedgerApi.Utils

-- | <a>Term</a>, but with its type arguments flipped. This is a useful
--   helper for defining <a>PTryFrom</a> instances.
--   
--   For example, consider the <a>PTryFrom</a> instance for
--   <tt>PTokenName</tt>:
--   
--   <pre>
--   instance PTryFrom PData (PAsData PTokenName) where
--      type PTryFromExcess PData (PAsData PTokenName) = Mret PTokenName
--   </pre>
--   
--   We need to do this because <a>PTryFromExcess</a> expects something of
--   kind <tt>S -&gt; Type</tt>, but <a>Term</a> has kind <tt>S -&gt; (S
--   -&gt; Type) -&gt; Type</tt>, which doesn't quite fit. By using
--   <a>Mret</a>, we end up with something of kind <tt>(S -&gt; Type) -&gt;
--   S -&gt; Type</tt>, which fits.
--   
--   The name is just <a>Term</a> written backwards.
newtype Mret (a :: S -> Type) (s :: S)
Mret :: Term s a -> Mret (a :: S -> Type) (s :: S)

data PMaybeData (a :: S -> Type) (s :: S)
PDJust :: Term s (PAsData a) -> PMaybeData (a :: S -> Type) (s :: S)
PDNothing :: PMaybeData (a :: S -> Type) (s :: S)

-- | A Rational type that corresponds to the data encoding used by
--   <a>Rational</a>.
data PRationalData s
PRationalData :: Term s (PAsData PInteger) -> Term s (PAsData PPositive) -> PRationalData s
[$sel:prationalData'numerator:PRationalData] :: PRationalData s -> Term s (PAsData PInteger)
[$sel:prationalData'denominator:PRationalData] :: PRationalData s -> Term s (PAsData PPositive)

-- | Scott-encoded boolean.
data PSBool (s :: S)
PSTrue :: PSBool (s :: S)
PSFalse :: PSBool (s :: S)

-- | Extracts the element out of a <a>PDJust</a> and throws an error if its
--   argument is <a>PDNothing</a>.
pfromDJust :: forall (a :: S -> Type) (s :: S). PIsData a => Term s (PMaybeData a :--> a)

-- | Yield <a>PTrue</a> if a given <a>PMaybeData</a> is of the form
--   <tt><a>PDJust</a> _</tt>.
pisDJust :: forall (a :: S -> Type) (s :: S). Term s (PMaybeData a :--> PBool)

-- | Special version of <tt>pmaybe</tt> that works with <a>PMaybeData</a>.
pmaybeData :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). PIsData a => Term s (b :--> ((a :--> b) :--> (PMaybeData a :--> b)))

-- | Construct a <a>PDJust</a> value.
pdjust :: forall (a :: S -> Type) (s :: S). PIsData a => Term s (a :--> PMaybeData a)

-- | Construct a <a>PDNothing</a> value.
pdnothing :: forall (a :: S -> Type) (s :: S). Term s (PMaybeData a)

-- | Construct a <a>PMaybeData</a> given a <a>PMaybe</a>. Could be useful
--   if you want to "lift" from <a>PMaybe</a> to <a>Maybe</a>.
pmaybeToMaybeData :: forall (a :: S -> Type) (s :: S). PIsData a => Term s (PMaybe a :--> PMaybeData a)

-- | Inverse of <a>pmaybeToMaybeData</a>
pmaybeDataToMaybe :: forall (a :: S -> Type) (s :: S). PIsData a => Term s (PMaybeData a :--> PMaybe a)

-- | Extract the value stored in a <a>PMaybeData</a> container. If there's
--   no value, throw an error with the given message.
passertPDJust :: forall (a :: S -> Type) (s :: S). PIsData a => Term s (PString :--> (PMaybeData a :--> a))

pmapMaybeData :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). Term s ((PAsData a :--> PAsData b) :--> (PMaybeData a :--> PMaybeData b))

prationalFromData :: ClosedTerm (PRationalData :--> PRational)

-- | Strict version of <a>pmatch</a> for <a>PSBool</a>.
pmatchStrict :: forall (r :: S -> Type) (s :: S). Term s PSBool -> (PSBool s -> Term s r) -> Term s r

pstrue :: forall (s :: S). Term s PSBool

psfalse :: forall (s :: S). Term s PSBool

-- | Lazy <tt>if</tt> on Scott-encoded bool.
psif :: forall (s :: S) (a :: S -> Type). Term s PSBool -> Term s a -> Term s a -> Term s a

-- | Strict <tt>if</tt> on Scott-encoded bool.
psif' :: forall (s :: S) (a :: S -> Type). Term s PSBool -> Term s a -> Term s a -> Term s a

-- | <tt>not</tt> on Scott-encoded bool.
psnot :: forall (s :: S). Term s PSBool -> Term s PSBool

-- | Lazy AND on Scott-encoded bool.
psand :: forall (s :: S). Term s PSBool -> Term s PSBool -> Term s PSBool

-- | Strict AND on Scott-encoded bool.
psand' :: forall (s :: S). Term s PSBool -> Term s PSBool -> Term s PSBool

-- | Lazy OR on Scott-encoded bool
psor :: forall (s :: S). Term s PSBool -> Term s PSBool -> Term s PSBool

-- | Strict OR on Scott-encoded bool.
psor' :: forall (s :: S). Term s PSBool -> Term s PSBool -> Term s PSBool
instance GHC.Generics.Generic (Plutarch.LedgerApi.Utils.Mret a s)
instance Plutarch.Internal.PlutusType.PlutusType (Plutarch.LedgerApi.Utils.PMaybeData a)
instance (Plutarch.Internal.IsData.PIsData a, Plutarch.Internal.Show.PShow a) => Plutarch.Internal.Show.PShow (Plutarch.LedgerApi.Utils.PMaybeData a)
instance Plutarch.Internal.Eq.PEq (Plutarch.LedgerApi.Utils.PMaybeData a)
instance Generics.SOP.Universe.Generic (Plutarch.LedgerApi.Utils.PMaybeData a s)
instance GHC.Generics.Generic (Plutarch.LedgerApi.Utils.PMaybeData a s)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.Utils.PRationalData
instance Plutarch.Internal.Show.PShow Plutarch.LedgerApi.Utils.PRationalData
instance Plutarch.Internal.Eq.PEq Plutarch.LedgerApi.Utils.PRationalData
instance Plutarch.Internal.IsData.PIsData Plutarch.LedgerApi.Utils.PRationalData
instance Generics.SOP.Universe.Generic (Plutarch.LedgerApi.Utils.PRationalData s)
instance GHC.Generics.Generic (Plutarch.LedgerApi.Utils.PRationalData s)
instance GHC.Show.Show (Plutarch.LedgerApi.Utils.PSBool s)
instance GHC.Classes.Ord (Plutarch.LedgerApi.Utils.PSBool s)
instance GHC.Classes.Eq (Plutarch.LedgerApi.Utils.PSBool s)
instance (PlutusTx.IsData.Class.ToData (Plutarch.Internal.Lift.AsHaskell a), PlutusTx.IsData.Class.FromData (Plutarch.Internal.Lift.AsHaskell a)) => Plutarch.Internal.Lift.PLiftable (Plutarch.LedgerApi.Utils.PMaybeData a)
instance Plutarch.Internal.Lift.PLiftable Plutarch.LedgerApi.Utils.PRationalData
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.Utils.PSBool
instance Plutarch.Internal.PlutusType.PlutusType (Plutarch.LedgerApi.Utils.PSBoolRaw a)
instance Plutarch.Internal.Ord.POrd Plutarch.LedgerApi.Utils.PRationalData
instance Plutarch.Internal.IsData.PIsData (Plutarch.LedgerApi.Utils.PMaybeData a)
instance (Plutarch.Internal.IsData.PIsData a, Plutarch.Internal.Ord.POrd a) => Plutarch.Internal.Ord.POrd (Plutarch.LedgerApi.Utils.PMaybeData a)


-- | This module is designed to be imported qualified, as many of its
--   identifiers clash with the Plutarch prelude.
module Plutarch.LedgerApi.AssocMap

newtype PMap (keysort :: KeyGuarantees) (k :: S -> Type) (v :: S -> Type) (s :: S)
PMap :: Term s (PBuiltinList (PBuiltinPair (PAsData k) (PAsData v))) -> PMap (keysort :: KeyGuarantees) (k :: S -> Type) (v :: S -> Type) (s :: S)

data KeyGuarantees
Sorted :: KeyGuarantees
Unsorted :: KeyGuarantees

data Commutativity
Commutative :: Commutativity
NonCommutative :: Commutativity

-- | Construct an empty <a>PMap</a>.
pempty :: Term s (PMap 'Sorted k v)

-- | Construct a singleton <a>PMap</a> with the given key and value.
psingleton :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (PIsData k, PIsData v) => Term s (k :--> (v :--> PMap 'Sorted k v))

-- | Construct a singleton <a>PMap</a> with the given data-encoded key and
--   value.
psingletonData :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). Term s (PAsData k :--> (PAsData v :--> PMap 'Sorted k v))

punsortedMapFromFoldable :: forall (k :: S -> Type) (v :: S -> Type) (f :: Type -> Type) (s :: S). (Foldable f, PIsData k, PIsData v) => f (Term s k, Term s v) -> Term s (PMap 'Unsorted k v)

psortedMapFromFoldable :: forall (k :: S -> Type) (v :: S -> Type) (f :: Type -> Type) (s :: S). (Foldable f, POrd k, PIsData k, PIsData v) => f (Term s k, Term s v) -> Term s (PMap 'Sorted k v)

-- | Given a <a>PMap</a> of uncertain order, yield a <a>PMap</a> that is
--   known to be sorted.
passertSorted :: forall (k :: S -> Type) (v :: S -> Type) (any :: KeyGuarantees) (s :: S). (POrd k, PIsData k) => Term s (PMap any k v :--> PMap 'Sorted k v)

-- | Forget the knowledge that keys were sorted.
pforgetSorted :: forall (g :: KeyGuarantees) (k :: S -> Type) (v :: S -> Type) (s :: S). Term s (PMap 'Sorted k v) -> Term s (PMap g k v)

-- | Applies a function to every value in the map, much like <a>map</a>.
pmap :: forall (g :: KeyGuarantees) (k :: S -> Type) (a :: S -> Type) (b :: S -> Type) (s :: S). (PIsData a, PIsData b) => Term s ((a :--> b) :--> (PMap g k a :--> PMap g k b))

-- | As <a>pmap</a>, but over Data representations.
pmapData :: forall (g :: KeyGuarantees) (k :: S -> Type) (a :: S -> Type) (b :: S -> Type) (s :: S). Term s ((PAsData a :--> PAsData b) :--> (PMap g k a :--> PMap g k b))

-- | As <a>pmap</a>, but gives key access as well.
pmapWithKey :: forall (k :: S -> Type) (a :: S -> Type) (b :: S -> Type) (keysort :: KeyGuarantees) (s :: S). (PIsData k, PIsData a, PIsData b) => Term s ((k :--> (a :--> b)) :--> (PMap keysort k a :--> PMap 'Unsorted k b))

-- | Maps and filters the map, much like <a>mapMaybe</a>.
pmapMaybe :: forall (g :: KeyGuarantees) (k :: S -> Type) (a :: S -> Type) (b :: S -> Type) (s :: S). (PIsData a, PIsData b) => Term s ((a :--> PMaybe b) :--> (PMap g k a :--> PMap g k b))

-- | As <a>pmapMaybe</a>, but over Data representation.
pmapMaybeData :: forall (g :: KeyGuarantees) (k :: S -> Type) (a :: S -> Type) (b :: S -> Type) (s :: S). Term s ((PAsData a :--> PMaybe (PAsData b)) :--> (PMap g k a :--> PMap g k b))

-- | Given a comparison function and a "zero" value, check whether a binary
--   relation holds over 2 sorted <a>PMap</a>s.
--   
--   <h1>Important note</h1>
--   
--   This is primarily intended to be used with <tt>PValue</tt>. We assume
--   that the comparison behaves like a comparison would (thus, being at
--   least a partial order, or possibly a total order or equivalence), and
--   that the starting value does not break it. Use with extreme care.
pcheckBinRel :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (POrd k, PIsData k, PIsData v) => Term s ((v :--> (v :--> PBool)) :--> (v :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PBool))))

-- | Gives <a>PTrue</a> if both argument <a>PMap</a>s contain mappings for
--   exactly the same set of keys. Requires a number of equality
--   comparisons between keys proportional to the length of the shorter
--   argument.
pkeysEqual :: forall (k :: S -> Type) (a :: S -> Type) (b :: S -> Type) (s :: S). (PEq k, PIsData k) => Term s (PMap 'Sorted k a :--> (PMap 'Sorted k b :--> PBool))

-- | As <a>pkeysEqual</a>, but requires only <a>PEq</a> constraints for the
--   keys, and works for <a>Unsorted</a> <a>PMap</a>s. This requires a
--   number of equality comparisons between keys proportional to the
--   product of the lengths of both arguments: that is, this function is
--   quadratic.
pkeysEqualUnsorted :: forall (k :: S -> Type) (a :: S -> Type) (b :: S -> Type) (s :: S). (PIsData k, PIsData a, PIsData b) => Term s (PMap 'Unsorted k a :--> (PMap 'Unsorted k b :--> PBool))

-- | Verifies all values in the map satisfy the given predicate.
pall :: forall (any :: KeyGuarantees) (k :: S -> Type) (v :: S -> Type) (s :: S). PIsData v => Term s ((v :--> PBool) :--> (PMap any k v :--> PBool))

-- | Tests if anu value in the map satisfies the given predicate.
pany :: forall (k :: S -> Type) (v :: S -> Type) (any :: KeyGuarantees) (s :: S). PIsData v => Term s ((v :--> PBool) :--> (PMap any k v :--> PBool))

-- | Project all key-value pairs into a <a>Monoid</a>, then combine. Keys
--   and values will be presented in key order.
pfoldMapWithKey :: forall (m :: S -> Type) (k :: S -> Type) (v :: S -> Type) (s :: S). (PIsData k, PIsData v, forall (s' :: S). Monoid (Term s' m)) => Term s ((k :--> (v :--> m)) :--> (PMap 'Sorted k v :--> m))

-- | Left-associative fold of a <a>PMap</a> with keys. Keys and values will
--   be presented in key order.
pfoldlWithKey :: forall (a :: S -> Type) (k :: S -> Type) (v :: S -> Type) (s :: S). (PIsData k, PIsData v) => Term s ((a :--> (k :--> (v :--> a))) :--> (a :--> (PMap 'Sorted k v :--> a)))

-- | Build the union of two <a>PMap</a>s, merging values that share the
--   same key using the given function.
punionResolvingCollisionsWith :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (POrd k, PIsData k, PIsData v) => Commutativity -> Term s ((v :--> (v :--> v)) :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Build the union of two <a>PMap</a>s, merging values that share the
--   same key using the given function.
punionResolvingCollisionsWithData :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (POrd k, PIsData k) => Commutativity -> Term s ((PAsData v :--> (PAsData v :--> PAsData v)) :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Build the union of two <a>PMap</a>s. Take the value from the left
--   argument for colliding keys.
--   
--   Prefer this over 'punionResolvingCollisionsWith NonCommutative # plam
--   const'. It performs better.
pleftBiasedUnion :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (POrd k, PIsData k, PIsData v) => Term s (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v))

-- | Difference of two maps. Return elements of the first map not existing
--   in the second map.
pdifference :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (PIsData k, POrd k, PIsData v) => Term s (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v))

-- | Zip two <a>PMap</a>s, using the given potentially non-commutative
--   value merge function for key collisions, and different values for the
--   sides.
pzipWithDefaults :: forall (s :: S) (k :: S -> Type) (v :: S -> Type). (POrd k, PIsData k, PIsData v) => (forall (s' :: S). Term s' v) -> (forall (s' :: S). Term s' v) -> Term s ((v :--> (v :--> v)) :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Build the intersection of two <a>PMap</a>s, merging values that share
--   the same key using the given function.
pintersectionWith :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (POrd k, PIsData k, PIsData v) => Commutativity -> Term s ((v :--> (v :--> v)) :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Build the intersection of two <a>PMap</a>s, merging data-encoded
--   values that share the same key using the given function.
pintersectionWithData :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (POrd k, PIsData k) => Commutativity -> Term s ((PAsData v :--> (PAsData v :--> PAsData v)) :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Tests whether the map is empty.
pnull :: forall (any :: KeyGuarantees) (k :: S -> Type) (v :: S -> Type) (s :: S). Term s (PMap any k v :--> PBool)

-- | Look up the given key in a <a>PMap</a>.
plookup :: forall (k :: S -> Type) (v :: S -> Type) (any :: KeyGuarantees) (s :: S). (PIsData k, PIsData v) => Term s (k :--> (PMap any k v :--> PMaybe v))

-- | as <a>plookup</a>, except over Data representation.
plookupData :: Term s (PAsData k :--> (PMap any k v :--> PMaybe (PAsData v)))

-- | Look up the given key data in a <a>PMap</a>, applying the given
--   function to the found key-value pair.
plookupDataWith :: Term s ((PBuiltinPair (PAsData k) (PAsData v) :--> PMaybe x) :--> (PAsData k :--> (PMap any k v :--> PMaybe x)))

-- | Look up the given key in a <a>PMap</a>, returning the default value if
--   the key is absent.
pfindWithDefault :: forall (k :: S -> Type) (v :: S -> Type) (any :: KeyGuarantees) (s :: S). (PIsData k, PIsData v) => Term s (v :--> (k :--> (PMap any k v :--> v)))

-- | Look up the given key in a <a>PMap</a>; return the default if the key
--   is absent or apply the argument function to the value data if present.
pfoldAt :: forall (k :: S -> Type) (v :: S -> Type) (any :: KeyGuarantees) (r :: S -> Type) (s :: S). PIsData k => Term s (k :--> (r :--> ((PAsData v :--> r) :--> (PMap any k v :--> r))))

-- | Look up the given key data in a <a>PMap</a>; return the default if the
--   key is absent or apply the argument function to the value data if
--   present.
pfoldAtData :: forall (k :: S -> Type) (v :: S -> Type) (any :: KeyGuarantees) (r :: S -> Type) (s :: S). Term s (PAsData k :--> (r :--> ((PAsData v :--> r) :--> (PMap any k v :--> r))))

-- | As <a>plookup</a>, but errors when the key is missing.
ptryLookup :: forall (k :: S -> Type) (v :: S -> Type) (keys :: KeyGuarantees) (s :: S). (PIsData k, PIsData v) => Term s (k :--> (PMap keys k v :--> v))

-- | Insert a new key/value pair into the map, overriding the previous if
--   any.
pinsert :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (POrd k, PIsData k, PIsData v) => Term s (k :--> (v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Delete a key from the map.
pdelete :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (POrd k, PIsData k) => Term s (k :--> (PMap 'Sorted k v :--> PMap 'Sorted k v))

-- | Given an 'updater' and a key, if the key exists in the <a>PMap</a>,
--   apply the 'updater' to it, otherwise do nothing. If the 'updater'
--   produces <a>PNothing</a>, the value is deleted; otherwise, it is
--   modified to the result.
--   
--   Performance will be equivalent to a lookup followed by an insert (or
--   delete), as well as the cost of calling the 'updater'.
pupdate :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (PIsData k, PIsData v, POrd k) => Term s ((v :--> PMaybe v) :--> (k :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | If a value exists at the specified key, apply the function argument to
--   it; otherwise, do nothing.
padjust :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (PIsData k, PEq k, PIsData v) => Term s ((v :--> v) :--> (k :--> (PMap 'Unsorted k v :--> PMap 'Unsorted k v)))

-- | Get the key of a key-value pair.
pkvPairKey :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). PIsData k => Term s (PBuiltinPair (PAsData k) (PAsData v) :--> k)

-- | Get the value of a key-value pair.
pkvPairValue :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). PIsData v => Term s (PBuiltinPair (PAsData k) (PAsData v) :--> v)

-- | Compare two key-value pairs by their keys. Gives <a>PTrue</a> if the
--   key of the first argument pair is less than the key of the second
--   argument pair.
pkvPairLt :: forall (k :: S -> Type) (v :: S -> Type) (s :: S). (PIsData k, POrd k) => Term s (PBuiltinPair (PAsData k) (PAsData v) :--> (PBuiltinPair (PAsData k) (PAsData v) :--> PBool))

-- | Get a list-like structure full of the keys of the argument
--   <a>PMap</a>. If the <a>PMap</a> is <a>Sorted</a>, the keys will
--   maintain that order, and will be unique; otherwise, the order is
--   unspecified, and duplicates may exist.
--   
--   <h1>Note</h1>
--   
--   You will need to specify what manner of list-like structure you want;
--   we have arranged the type signature to make specifying this easy with
--   <tt>TypeApplications</tt>.
pkeys :: forall (ell :: (S -> Type) -> S -> Type) (k :: S -> Type) (v :: S -> Type) (keys :: KeyGuarantees) (s :: S). (PListLike ell, PElemConstraint ell (PAsData k)) => Term s (PMap keys k v :--> ell (PAsData k))
instance Plutarch.Internal.PlutusType.PlutusType (Plutarch.LedgerApi.AssocMap.PMap keysort k v)
instance Generics.SOP.Universe.Generic (Plutarch.LedgerApi.AssocMap.PMap keysort k v s)
instance (Plutarch.Internal.IsData.PIsData k, Plutarch.Internal.IsData.PIsData v, Plutarch.Internal.Show.PShow k, Plutarch.Internal.Show.PShow v) => Plutarch.Internal.Show.PShow (Plutarch.LedgerApi.AssocMap.PMap keysort k v)
instance GHC.Generics.Generic (Plutarch.LedgerApi.AssocMap.PMap keysort k v s)
instance GHC.Show.Show Plutarch.LedgerApi.AssocMap.Commutativity
instance GHC.Classes.Ord Plutarch.LedgerApi.AssocMap.Commutativity
instance GHC.Classes.Eq Plutarch.LedgerApi.AssocMap.Commutativity
instance (forall a b. GHC.Show.Show (f a b)) => GHC.Show.Show (Plutarch.LedgerApi.AssocMap.SomeMergeHandler_ f k v)
instance (forall a b. GHC.Show.Show (f a b)) => GHC.Show.Show (Plutarch.LedgerApi.AssocMap.MergeHandler_ f k v)
instance (forall a b. GHC.Show.Show (f a b)) => GHC.Show.Show (Plutarch.LedgerApi.AssocMap.MergeHandlerCommutative_ f k v)
instance (forall a b. GHC.Show.Show (f a b)) => GHC.Show.Show (Plutarch.LedgerApi.AssocMap.BothPresentHandler_ f k v)
instance (forall a b. GHC.Show.Show (f a b)) => GHC.Show.Show (Plutarch.LedgerApi.AssocMap.BothPresentHandlerCommutative_ f k v)
instance (forall a b. GHC.Show.Show (f a b)) => GHC.Show.Show (Plutarch.LedgerApi.AssocMap.OnePresentHandler_ f k v)
instance (PlutusTx.IsData.Class.ToData (Plutarch.Internal.Lift.AsHaskell k), PlutusTx.IsData.Class.ToData (Plutarch.Internal.Lift.AsHaskell v), PlutusTx.IsData.Class.FromData (Plutarch.Internal.Lift.AsHaskell k), PlutusTx.IsData.Class.FromData (Plutarch.Internal.Lift.AsHaskell v)) => Plutarch.Internal.Lift.PLiftable (Plutarch.LedgerApi.AssocMap.PMap 'Plutarch.LedgerApi.AssocMap.Unsorted k v)
instance Plutarch.Internal.IsData.PIsData (Plutarch.LedgerApi.AssocMap.PMap keysort k v)
instance Plutarch.Internal.Eq.PEq (Plutarch.LedgerApi.AssocMap.PMap 'Plutarch.LedgerApi.AssocMap.Sorted k v)


-- | Value-related functionality. In order to keep the interface efficient
--   and safe at the same time, there is a type-level distinction between
--   <a>PValue</a>s that are guaranteed to be properly normalized and those
--   that provide no such guarantee.
--   
--   Also for efficiency reasons, the Ada-specific functions assume that
--   there can be only one token name for the Ada currency symbol, and they
--   don't check whether it matches <a>adaToken</a>.
module Plutarch.LedgerApi.Value

newtype PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)
PValue :: Term s (PMap keys PCurrencySymbol (PMap keys PTokenName PInteger)) -> PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)

newtype PCurrencySymbol (s :: S)
PCurrencySymbol :: Term s PByteString -> PCurrencySymbol (s :: S)

newtype PTokenName (s :: S)
PTokenName :: Term s PByteString -> PTokenName (s :: S)

data AmountGuarantees
NoGuarantees :: AmountGuarantees
NonZero :: AmountGuarantees
Positive :: AmountGuarantees

newtype PLovelace (s :: S)
PLovelace :: Term s PInteger -> PLovelace (s :: S)

newtype PAssetClass (s :: S)
PAssetClass :: Term s (PBuiltinPair (PAsData PCurrencySymbol) (PAsData PTokenName)) -> PAssetClass (s :: S)

-- | The <a>PCurrencySymbol</a> of the Ada currency.
padaSymbol :: forall (s :: S). Term s PCurrencySymbol

-- | Data-encoded <a>PCurrencySymbol</a> of the Ada currency.
padaSymbolData :: forall (s :: S). Term s (PAsData PCurrencySymbol)

-- | The <a>PTokenName</a> of the Ada currency.
padaToken :: Term s PTokenName

-- | Construct a singleton <a>PValue</a> containing only the given quantity
--   of the given currency.
psingleton :: forall (s :: S). Term s (PCurrencySymbol :--> (PTokenName :--> (PInteger :--> PValue 'Sorted 'NonZero)))

-- | Construct a singleton <a>PValue</a> containing only the given quantity
--   of the given currency, taking data-encoded parameters.
psingletonData :: forall (s :: S). Term s (PAsData PCurrencySymbol :--> (PAsData PTokenName :--> (PAsData PInteger :--> PValue 'Sorted 'NonZero)))

-- | Construct a constant singleton <a>PValue</a> containing only the given
--   positive quantity of the given currency.
pconstantPositiveSingleton :: forall (s :: S). (forall (s' :: S). Term s' PCurrencySymbol) -> (forall (s' :: S). Term s' PTokenName) -> (forall (s' :: S). Term s' PInteger) -> Term s (PValue 'Sorted 'Positive)

-- | Given a <a>PValue</a>, either construct another <a>PValue</a> with the
--   same contents and a proof that all amounts in it are positive, or
--   error.
passertPositive :: forall (kg :: KeyGuarantees) (ag :: AmountGuarantees) (s :: S). Term s (PValue kg ag :--> PValue kg 'Positive)
passertNonZero :: forall (kg :: KeyGuarantees) (ag :: AmountGuarantees). forall (s :: S). Term s (PValue kg ag :--> PValue kg 'NonZero)

-- | Assert the value is properly sorted and normalized.
passertSorted :: forall (anyKey :: KeyGuarantees) (anyAmount :: AmountGuarantees) (s :: S). Term s (PValue anyKey anyAmount :--> PValue 'Sorted 'NonZero)

-- | 'Forget' that a <tt>Value</tt> has an only-positive guarantee.
pforgetPositive :: forall (a :: AmountGuarantees) (k :: KeyGuarantees) (s :: S). Term s (PValue k 'Positive) -> Term s (PValue k a)

-- | Forget the knowledge of all value's guarantees.
pforgetSorted :: forall (a :: AmountGuarantees) (k :: KeyGuarantees) (s :: S). Term s (PValue 'Sorted a) -> Term s (PValue k a)

-- | Normalize the argument to contain no zero quantity nor empty token
--   map.
pnormalize :: forall (any :: AmountGuarantees) (s :: S). Term s (PValue 'Sorted any :--> PValue 'Sorted 'NonZero)

-- | Strip all non-Ada from a <a>PValue</a>.
padaOnlyValue :: forall (v :: AmountGuarantees) (s :: S). Term s (PValue 'Sorted v :--> PValue 'Sorted v)

-- | Strip all Ada from a <a>PValue</a>.
pnoAdaValue :: forall (v :: AmountGuarantees) (s :: S). Term s (PValue 'Sorted v :--> PValue 'Sorted v)

-- | Mimics the <tt>lt</tt> operation on <tt>plutus-ledger-api</tt>'s
--   <tt>Value</tt>.
pltPositive :: forall (s :: S). Term s (PValue 'Sorted 'Positive) -> Term s (PValue 'Sorted 'Positive) -> Term s PBool

-- | As <a>pltPositive</a>, but for nonzero guaranteed <a>PValue</a>s
--   instead.
pltNonZero :: forall (s :: S). Term s (PValue 'Sorted 'NonZero) -> Term s (PValue 'Sorted 'NonZero) -> Term s PBool

-- | Mimics the <tt>leq</tt> operation on <tt>plutus-ledger-api</tt>'s
--   <tt>Value</tt>.
pleqPositive :: forall (s :: S). Term s (PValue 'Sorted 'Positive) -> Term s (PValue 'Sorted 'Positive) -> Term s PBool

-- | As <tt>pletPositive</tt>, but for nonzero guaranteed <a>PValue</a>s
--   instead.
pleqNonZero :: forall (s :: S). Term s (PValue 'Sorted 'NonZero) -> Term s (PValue 'Sorted 'NonZero) -> Term s PBool

-- | Given a description of a relation on amounts, check whether that
--   relation holds over sorted <a>PValue</a>s.
--   
--   <h1>Important note</h1>
--   
--   This is intended for use with boolean comparison functions, which must
--   define at least a partial order (total orders and equivalences are
--   acceptable as well). Use of this with anything else is not guaranteed
--   to give anything resembling a sensible answer. Use with extreme care.
pcheckBinRel :: forall (any0 :: AmountGuarantees) (any1 :: AmountGuarantees) (s :: S). Term s ((PInteger :--> (PInteger :--> PBool)) :--> (PValue 'Sorted any0 :--> (PValue 'Sorted any1 :--> PBool)))

-- | Combine two <a>PValue</a>s, taking the tokens from the left only, if a
--   currency occurs on both sides.
pleftBiasedCurrencyUnion :: forall (any0 :: AmountGuarantees) (any1 :: AmountGuarantees) (s :: S). Term s (PValue 'Sorted any0 :--> (PValue 'Sorted any1 :--> PValue 'Sorted 'NoGuarantees))

-- | Combine two <a>PValue</a>s, taking the tokens from the left only, if a
--   token name of the same currency occurs on both sides.
--   
--   Prefer this over 'punionResolvingCollisionsWith NonCommutative # plam
--   const'. It is equivalent, but performs better.
pleftBiasedTokenUnion :: forall (any0 :: AmountGuarantees) (any1 :: AmountGuarantees) (s :: S). Term s (PValue 'Sorted any0 :--> (PValue 'Sorted any1 :--> PValue 'Sorted 'NoGuarantees))

-- | Combine two <a>PValue</a>s applying the given function to any pair of
--   quantities with the same asset class. Note that the result is _not_
--   <tt>normalize</tt>d and may contain zero quantities.
punionResolvingCollisionsWith :: forall (any0 :: AmountGuarantees) (any1 :: AmountGuarantees) (s :: S). Commutativity -> Term s ((PInteger :--> (PInteger :--> PInteger)) :--> (PValue 'Sorted any0 :--> (PValue 'Sorted any1 :--> PValue 'Sorted 'NoGuarantees)))

-- | Combine two <a>PValue</a>s applying the given function to any pair of
--   data-encoded quantities with the same asset class. Note that the
--   result is _not_ <tt>normalize</tt>d and may contain zero quantities.
punionResolvingCollisionsWithData :: forall (any0 :: AmountGuarantees) (any1 :: AmountGuarantees) (s :: S). Commutativity -> Term s ((PAsData PInteger :--> (PAsData PInteger :--> PAsData PInteger)) :--> (PValue 'Sorted any0 :--> (PValue 'Sorted any1 :--> PValue 'Sorted 'NoGuarantees)))

-- | Get the quantity of the given currency in the <a>PValue</a>.
pvalueOf :: forall (anyKey :: KeyGuarantees) (anyAmount :: AmountGuarantees) (s :: S). Term s (PValue anyKey anyAmount :--> (PCurrencySymbol :--> (PTokenName :--> PInteger)))

-- | Get the amount of Lovelace in the <a>PValue</a>.
plovelaceValueOf :: forall (v :: AmountGuarantees) (s :: S). Term s (PValue 'Sorted v :--> PInteger)

-- | Test if the value contains nothing but Ada
pisAdaOnlyValue :: forall (s :: S). Term s (PValue 'Sorted 'Positive :--> PBool)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.Value.PLovelace
instance Plutarch.Internal.Show.PShow Plutarch.LedgerApi.Value.PLovelace
instance Plutarch.Internal.Ord.POrd Plutarch.LedgerApi.Value.PLovelace
instance Plutarch.Internal.Eq.PEq Plutarch.LedgerApi.Value.PLovelace
instance Plutarch.Internal.IsData.PIsData Plutarch.LedgerApi.Value.PLovelace
instance Generics.SOP.Universe.Generic (Plutarch.LedgerApi.Value.PLovelace s)
instance GHC.Generics.Generic (Plutarch.LedgerApi.Value.PLovelace s)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.Value.PTokenName
instance Plutarch.Internal.Show.PShow Plutarch.LedgerApi.Value.PTokenName
instance Plutarch.Internal.Ord.POrd Plutarch.LedgerApi.Value.PTokenName
instance Plutarch.Internal.Eq.PEq Plutarch.LedgerApi.Value.PTokenName
instance Plutarch.Internal.IsData.PIsData Plutarch.LedgerApi.Value.PTokenName
instance Generics.SOP.Universe.Generic (Plutarch.LedgerApi.Value.PTokenName s)
instance GHC.Generics.Generic (Plutarch.LedgerApi.Value.PTokenName s)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.Value.PCurrencySymbol
instance Plutarch.Internal.Show.PShow Plutarch.LedgerApi.Value.PCurrencySymbol
instance Plutarch.Internal.Ord.POrd Plutarch.LedgerApi.Value.PCurrencySymbol
instance Plutarch.Internal.Eq.PEq Plutarch.LedgerApi.Value.PCurrencySymbol
instance Plutarch.Internal.IsData.PIsData Plutarch.LedgerApi.Value.PCurrencySymbol
instance Generics.SOP.Universe.Generic (Plutarch.LedgerApi.Value.PCurrencySymbol s)
instance GHC.Generics.Generic (Plutarch.LedgerApi.Value.PCurrencySymbol s)
instance Plutarch.Internal.PlutusType.PlutusType (Plutarch.LedgerApi.Value.PValue keys amounts)
instance Plutarch.Internal.Show.PShow (Plutarch.LedgerApi.Value.PValue keys amounts)
instance Plutarch.Internal.IsData.PIsData (Plutarch.LedgerApi.Value.PValue keys amounts)
instance Generics.SOP.Universe.Generic (Plutarch.LedgerApi.Value.PValue keys amounts s)
instance GHC.Generics.Generic (Plutarch.LedgerApi.Value.PValue keys amounts s)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.Value.PAssetClass
instance Plutarch.Internal.Show.PShow Plutarch.LedgerApi.Value.PAssetClass
instance Plutarch.Internal.Eq.PEq Plutarch.LedgerApi.Value.PAssetClass
instance Plutarch.Internal.IsData.PIsData Plutarch.LedgerApi.Value.PAssetClass
instance Generics.SOP.Universe.Generic (Plutarch.LedgerApi.Value.PAssetClass s)
instance GHC.Generics.Generic (Plutarch.LedgerApi.Value.PAssetClass s)
instance Plutarch.Internal.Lift.PLiftable Plutarch.LedgerApi.Value.PLovelace
instance Plutarch.Internal.Lift.PLiftable (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Unsorted 'Plutarch.LedgerApi.Value.NoGuarantees)
instance Plutarch.Internal.Lift.PLiftable Plutarch.LedgerApi.Value.PAssetClass
instance Plutarch.Internal.Ord.POrd Plutarch.LedgerApi.Value.PAssetClass
instance Plutarch.Internal.Eq.PEq (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.Positive)
instance Plutarch.Internal.Eq.PEq (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NonZero)
instance Plutarch.Internal.Eq.PEq (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NoGuarantees)
instance Plutarch.Internal.Semigroup.PSemigroup (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.Positive)
instance GHC.Base.Semigroup (Plutarch.Internal.Term.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.Positive))
instance PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.Positive))
instance Plutarch.Internal.Semigroup.PSemigroup (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NonZero)
instance GHC.Base.Semigroup (Plutarch.Internal.Term.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NonZero))
instance PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NonZero))
instance Plutarch.Internal.Semigroup.PSemigroup (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NoGuarantees)
instance GHC.Base.Semigroup (Plutarch.Internal.Term.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NoGuarantees))
instance PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NoGuarantees))
instance Plutarch.Internal.Semigroup.PSemigroup (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted normalization) => Plutarch.Internal.Semigroup.PMonoid (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted normalization)
instance GHC.Base.Semigroup (Plutarch.Internal.Term.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted normalization)) => GHC.Base.Monoid (Plutarch.Internal.Term.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted normalization))
instance PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted normalization)) => PlutusTx.Monoid.Monoid (Plutarch.Internal.Term.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted normalization))
instance PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NoGuarantees)) => PlutusTx.Monoid.Group (Plutarch.Internal.Term.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NoGuarantees))
instance PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NonZero)) => PlutusTx.Monoid.Group (Plutarch.Internal.Term.Term s (Plutarch.LedgerApi.Value.PValue 'Plutarch.LedgerApi.AssocMap.Sorted 'Plutarch.LedgerApi.Value.NonZero))
instance Plutarch.Internal.Lift.PLiftable Plutarch.LedgerApi.Value.PCurrencySymbol
instance Plutarch.Internal.Lift.PLiftable Plutarch.LedgerApi.Value.PTokenName


-- | <h1>Note</h1>
--   
--   The <a>PValue</a>, <a>PMap</a> and <a>PInterval</a>-related
--   functionality can be found in other modules, as these clash with the
--   Plutarch prelude. These should be imported qualified.
module Plutarch.LedgerApi.V3

data PScriptContext (s :: S)
PScriptContext :: Term s PTxInfo -> Term s PRedeemer -> Term s PScriptInfo -> PScriptContext (s :: S)
[$sel:pscriptContext'txInfo:PScriptContext] :: PScriptContext (s :: S) -> Term s PTxInfo
[$sel:pscriptContext'redeemer:PScriptContext] :: PScriptContext (s :: S) -> Term s PRedeemer
[$sel:pscriptContext'scriptInfo:PScriptContext] :: PScriptContext (s :: S) -> Term s PScriptInfo
data PTxInfo (s :: S)
PTxInfo :: Term s (PAsData (PBuiltinList (PAsData PTxInInfo))) -> Term s (PAsData (PBuiltinList (PAsData PTxInInfo))) -> Term s (PAsData (PBuiltinList (PAsData PTxOut))) -> Term s (PAsData PLovelace) -> Term s (PAsData (PValue 'Sorted 'NonZero)) -> Term s (PAsData (PBuiltinList (PAsData PTxCert))) -> Term s (PAsData (PMap 'Unsorted PCredential PLovelace)) -> Term s (PInterval PPosixTime) -> Term s (PAsData (PBuiltinList (PAsData PPubKeyHash))) -> Term s (PAsData (PMap 'Unsorted PScriptPurpose PRedeemer)) -> Term s (PAsData (PMap 'Unsorted PDatumHash PDatum)) -> Term s (PAsData PTxId) -> Term s (PAsData (PMap 'Unsorted PVoter (PMap 'Unsorted PGovernanceActionId PVote))) -> Term s (PAsData (PBuiltinList (PAsData PProposalProcedure))) -> Term s (PAsData (PMaybeData PLovelace)) -> Term s (PMaybeData PLovelace) -> PTxInfo (s :: S)
[$sel:ptxInfo'inputs:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PBuiltinList (PAsData PTxInInfo)))
[$sel:ptxInfo'referenceInputs:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PBuiltinList (PAsData PTxInInfo)))
[$sel:ptxInfo'outputs:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PBuiltinList (PAsData PTxOut)))
[$sel:ptxInfo'fee:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData PLovelace)
[$sel:ptxInfo'mint:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PValue 'Sorted 'NonZero))
[$sel:ptxInfo'txCerts:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PBuiltinList (PAsData PTxCert)))
[$sel:ptxInfo'wdrl:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PMap 'Unsorted PCredential PLovelace))
[$sel:ptxInfo'validRange:PTxInfo] :: PTxInfo (s :: S) -> Term s (PInterval PPosixTime)
[$sel:ptxInfo'signatories:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PBuiltinList (PAsData PPubKeyHash)))
[$sel:ptxInfo'redeemers:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PMap 'Unsorted PScriptPurpose PRedeemer))
[$sel:ptxInfo'data:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PMap 'Unsorted PDatumHash PDatum))
[$sel:ptxInfo'id:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData PTxId)
[$sel:ptxInfo'votes:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PMap 'Unsorted PVoter (PMap 'Unsorted PGovernanceActionId PVote)))
[$sel:ptxInfo'proposalProcedures:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PBuiltinList (PAsData PProposalProcedure)))
[$sel:ptxInfo'currentTreasuryAmount:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PMaybeData PLovelace))
[$sel:ptxInfo'treasuryDonation:PTxInfo] :: PTxInfo (s :: S) -> Term s (PMaybeData PLovelace)

data PScriptInfo (s :: S)
PMintingScript :: Term s (PAsData PCurrencySymbol) -> PScriptInfo (s :: S)
PSpendingScript :: Term s PTxOutRef -> Term s (PMaybeData PDatum) -> PScriptInfo (s :: S)
PRewardingScript :: Term s PCredential -> PScriptInfo (s :: S)
PCertifyingScript :: Term s (PAsData PInteger) -> Term s PTxCert -> PScriptInfo (s :: S)
PVotingScript :: Term s PVoter -> PScriptInfo (s :: S)
PProposingScript :: Term s (PAsData PInteger) -> Term s PProposalProcedure -> PScriptInfo (s :: S)

data PScriptPurpose (s :: S)
PMinting :: Term s (PAsData PCurrencySymbol) -> PScriptPurpose (s :: S)
PSpending :: Term s PTxOutRef -> PScriptPurpose (s :: S)

PRewarding :: Term s PCredential -> PScriptPurpose (s :: S)
PCertifying :: Term s (PAsData PInteger) -> Term s PTxCert -> PScriptPurpose (s :: S)

PVoting :: Term s PVoter -> PScriptPurpose (s :: S)

PProposing :: Term s (PAsData PInteger) -> Term s PProposalProcedure -> PScriptPurpose (s :: S)

data PTxOutRef (s :: S)
PTxOutRef :: Term s (PAsData PTxId) -> Term s (PAsData PInteger) -> PTxOutRef (s :: S)
[$sel:ptxOutRef'id:PTxOutRef] :: PTxOutRef (s :: S) -> Term s (PAsData PTxId)
[$sel:ptxOutRef'idx:PTxOutRef] :: PTxOutRef (s :: S) -> Term s (PAsData PInteger)

data PTxOut (s :: S)
PTxOut :: Term s PAddress -> Term s (PAsData (PValue 'Sorted 'Positive)) -> Term s POutputDatum -> Term s (PMaybeData PScriptHash) -> PTxOut (s :: S)
[$sel:ptxOut'address:PTxOut] :: PTxOut (s :: S) -> Term s PAddress
[$sel:ptxOut'value:PTxOut] :: PTxOut (s :: S) -> Term s (PAsData (PValue 'Sorted 'Positive))
[$sel:ptxOut'datum:PTxOut] :: PTxOut (s :: S) -> Term s POutputDatum
[$sel:ptxOut'referenceScript:PTxOut] :: PTxOut (s :: S) -> Term s (PMaybeData PScriptHash)

-- | Hashed with <tt>BLAKE2b-256</tt>.
newtype PTxId (s :: S)
PTxId :: Term s PByteString -> PTxId (s :: S)

-- | An input of the pending transaction.
data PTxInInfo (s :: S)
PTxInInfo :: Term s PTxOutRef -> Term s PTxOut -> PTxInInfo (s :: S)
[$sel:ptxInInfo'outRef:PTxInInfo] :: PTxInInfo (s :: S) -> Term s PTxOutRef
[$sel:ptxInInfo'resolved:PTxInInfo] :: PTxInInfo (s :: S) -> Term s PTxOut

data POutputDatum (s :: S)
PNoOutputDatum :: POutputDatum (s :: S)
POutputDatumHash :: Term s (PAsData PDatumHash) -> POutputDatum (s :: S)
[$sel:poutputDatum'datumHash:PNoOutputDatum] :: POutputDatum (s :: S) -> Term s (PAsData PDatumHash)

-- | Inline datum as per <a>CIP-0032</a>
POutputDatum :: Term s PDatum -> POutputDatum (s :: S)
[$sel:poutputDatum'outputDatum:PNoOutputDatum] :: POutputDatum (s :: S) -> Term s PDatum

-- | Find the output txns corresponding to the input being validated.
--   
--   Takes as arguments the inputs, outputs and the spending transaction
--   referenced from <tt>PScriptPurpose</tt>.
--   
--   <b>Example:</b>
--   
--   <pre>
--   ctx &lt;- tcont $ pletFields <tt>["txInfo", "purpose"] sc
--   pmatchC (getField </tt>"purpose" ctx) &gt;&gt;= case
--     PSpending outRef' -&gt; do
--       let outRef = pfield <tt>"_0" # outRef'
--           inputs = pfield </tt>"inputs" # (getField <tt>"txInfo" ctx)
--           outputs = pfield </tt>"outputs" # (getField @"txInfo" ctx)
--       pure $ pgetContinuingOutputs # inputs # outputs # outRef
--     _ -&gt;
--       pure $ ptraceInfoError "not a spending tx"
--   
--   </pre>
pgetContinuingOutputs :: forall (s :: S). Term s (PBuiltinList PTxInInfo :--> (PBuiltinList PTxOut :--> (PTxOutRef :--> PBuiltinList PTxOut)))

-- | Find the input being spent in the current transaction.
--   
--   Takes as arguments the inputs, as well as the spending transaction
--   referenced from <tt>PScriptPurpose</tt>.
--   
--   <b>Example:</b>
--   
--   <pre>
--   ctx &lt;- tcont $ pletFields <tt>["txInfo", "purpose"] sc
--   pmatchC (getField </tt>"purpose" ctx) &gt;&gt;= case
--     PSpending outRef' -&gt; do
--       let outRef = pfield <tt>"_0" # outRef'
--           inputs = pfield </tt>"inputs" # (getField @"txInfo" ctx)
--       pure $ pfindOwnInput # inputs # outRef
--     _ -&gt;
--       pure $ ptraceInfoError "not a spending tx"
--   
--   </pre>
pfindOwnInput :: forall (s :: S). Term s (PBuiltinList PTxInInfo :--> (PTxOutRef :--> PMaybe PTxInInfo))

newtype PDatum (s :: S)
PDatum :: Term s PData -> PDatum (s :: S)

newtype PDatumHash (s :: S)
PDatumHash :: Term s PByteString -> PDatumHash (s :: S)

newtype PRedeemer (s :: S)
PRedeemer :: Term s PData -> PRedeemer (s :: S)

newtype PRedeemerHash (s :: S)
PRedeemerHash :: Term s PByteString -> PRedeemerHash (s :: S)

newtype PScriptHash (s :: S)
PScriptHash :: Term s PByteString -> PScriptHash (s :: S)

-- | Hash a script, appending the Plutus V2 prefix.
scriptHash :: Script -> ScriptHash

datumHash :: Datum -> DatumHash

redeemerHash :: Redeemer -> RedeemerHash

dataHash :: forall (a :: Type). ToData a => a -> BuiltinByteString

-- | Lookup up the datum given the datum hash.
--   
--   Takes as argument the datum assoc list from a <tt>PTxInfo</tt>.
--   Validates the datum using <a>PTryFrom</a>.
--   
--   <b>Example:</b>
--   
--   <pre>
--   pparseDatum <tt>MyType # datumHash #$ pfield </tt>"datums" # txinfo
--   
--   </pre>
pparseDatum :: forall (a :: S -> Type) (s :: S). PTryFrom PData (PAsData a) => Term s (PDatumHash :--> (PMap 'Unsorted PDatumHash PDatum :--> PMaybe (PAsData a)))

newtype PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)
PValue :: Term s (PMap keys PCurrencySymbol (PMap keys PTokenName PInteger)) -> PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)

data AmountGuarantees
NoGuarantees :: AmountGuarantees
NonZero :: AmountGuarantees
Positive :: AmountGuarantees

newtype PCurrencySymbol (s :: S)
PCurrencySymbol :: Term s PByteString -> PCurrencySymbol (s :: S)

newtype PTokenName (s :: S)
PTokenName :: Term s PByteString -> PTokenName (s :: S)

newtype PLovelace (s :: S)
PLovelace :: Term s PInteger -> PLovelace (s :: S)

newtype PMap (keysort :: KeyGuarantees) (k :: S -> Type) (v :: S -> Type) (s :: S)
PMap :: Term s (PBuiltinList (PBuiltinPair (PAsData k) (PAsData v))) -> PMap (keysort :: KeyGuarantees) (k :: S -> Type) (v :: S -> Type) (s :: S)

data KeyGuarantees
Sorted :: KeyGuarantees
Unsorted :: KeyGuarantees

data Commutativity
Commutative :: Commutativity
NonCommutative :: Commutativity

data PCredential (s :: S)
PPubKeyCredential :: Term s (PAsData PPubKeyHash) -> PCredential (s :: S)
PScriptCredential :: Term s (PAsData PScriptHash) -> PCredential (s :: S)

data PStakingCredential (s :: S)
PStakingHash :: Term s PCredential -> PStakingCredential (s :: S)
PStakingPtr :: Term s (PAsData PInteger) -> Term s (PAsData PInteger) -> Term s (PAsData PInteger) -> PStakingCredential (s :: S)

data PAddress (s :: S)
PAddress :: Term s PCredential -> Term s (PMaybeData PStakingCredential) -> PAddress (s :: S)
[$sel:paddress'credential:PAddress] :: PAddress (s :: S) -> Term s PCredential
[$sel:paddress'stakingCredential:PAddress] :: PAddress (s :: S) -> Term s (PMaybeData PStakingCredential)

newtype PPosixTime (s :: S)
PPosixTime :: Term s PInteger -> PPosixTime (s :: S)

-- | Construct a <a>PPosixTime</a> from a <a>PInteger</a>. Same as using
--   the constructor, but a lot shorter.
pposixTime :: forall (s :: S). Term s PInteger -> Term s PPosixTime

-- | Unwrap a <a>PPosixTime</a> to get a <a>PInteger</a>. Same as using
--   <a>pmatch</a>, but a lot shorter. Also unwraps the <tt>Data</tt>
--   encoding.
unPPosixTime :: forall (s :: S). Term s PPosixTime -> Term s PInteger

data PInterval (a :: S -> Type) (s :: S)
PInterval :: Term s (PLowerBound a) -> Term s (PUpperBound a) -> PInterval (a :: S -> Type) (s :: S)
[$sel:pinteral'from:PInterval] :: PInterval (a :: S -> Type) (s :: S) -> Term s (PLowerBound a)
[$sel:pinteral'to:PInterval] :: PInterval (a :: S -> Type) (s :: S) -> Term s (PUpperBound a)

data PLowerBound (a :: S -> Type) (s :: S)
PLowerBound :: Term s (PExtended a) -> Term s (PAsData PBool) -> PLowerBound (a :: S -> Type) (s :: S)

data PUpperBound (a :: S -> Type) (s :: S)
PUpperBound :: Term s (PExtended a) -> Term s (PAsData PBool) -> PUpperBound (a :: S -> Type) (s :: S)

data PExtended (a :: S -> Type) (s :: S)
PNegInf :: PExtended (a :: S -> Type) (s :: S)
PFinite :: Term s (PAsData a) -> PExtended (a :: S -> Type) (s :: S)
PPosInf :: PExtended (a :: S -> Type) (s :: S)

data PTxCert (s :: S)
PTxCertRegStaking :: Term s PCredential -> Term s (PMaybeData PLovelace) -> PTxCert (s :: S)
PTxCertUnRegStaking :: Term s PCredential -> Term s (PMaybeData PLovelace) -> PTxCert (s :: S)
PTxCertDelegStaking :: Term s PCredential -> Term s PDelegatee -> PTxCert (s :: S)
PTxCertRegDeleg :: Term s PCredential -> Term s PDelegatee -> Term s (PAsData PLovelace) -> PTxCert (s :: S)
PTxCertRegDRep :: Term s PDRepCredential -> Term s (PAsData PLovelace) -> PTxCert (s :: S)
PTxCertUpdateDRep :: Term s PDRepCredential -> PTxCert (s :: S)
PTxCertUnRegDRep :: Term s PDRepCredential -> Term s (PAsData PLovelace) -> PTxCert (s :: S)
PTxCertPoolRegister :: Term s (PAsData PPubKeyHash) -> Term s (PAsData PPubKeyHash) -> PTxCert (s :: S)
PTxCertPoolRetire :: Term s (PAsData PPubKeyHash) -> Term s (PAsData PInteger) -> PTxCert (s :: S)
PTxCertAuthHotCommittee :: Term s PColdCommitteeCredential -> Term s PHotCommitteeCredential -> PTxCert (s :: S)
PTxCertResignColdCommittee :: Term s PColdCommitteeCredential -> PTxCert (s :: S)

data PDelegatee (s :: S)
PDelegStake :: Term s (PAsData PPubKeyHash) -> PDelegatee (s :: S)
PDelegVote :: Term s PDRep -> PDelegatee (s :: S)
PDelegStakeVote :: Term s (PAsData PPubKeyHash) -> Term s PDRep -> PDelegatee (s :: S)

newtype PDRepCredential (s :: S)
PDRepCredential :: Term s PCredential -> PDRepCredential (s :: S)

newtype PColdCommitteeCredential (s :: S)
PColdCommitteeCredential :: Term s PCredential -> PColdCommitteeCredential (s :: S)

newtype PHotCommitteeCredential (s :: S)
PHotCommitteeCredential :: Term s PCredential -> PHotCommitteeCredential (s :: S)

data PDRep (s :: S)
PDRep :: Term s (PAsData PDRepCredential) -> PDRep (s :: S)
PDRepAlwaysAbstain :: PDRep (s :: S)
PDRepAlwaysNoConfidence :: PDRep (s :: S)

data PVoter (s :: S)
PCommitteeVoter :: Term s PHotCommitteeCredential -> PVoter (s :: S)
PDRepVoter :: Term s PDRepCredential -> PVoter (s :: S)
PStakePoolVoter :: Term s (PAsData PPubKeyHash) -> PVoter (s :: S)

data PGovernanceActionId (s :: S)
PGovernanceActionId :: Term s (PAsData PTxId) -> Term s (PAsData PInteger) -> PGovernanceActionId (s :: S)

data PVote (s :: S)
PVoteYes :: PVote (s :: S)
PVoteNo :: PVote (s :: S)
PAbstain :: PVote (s :: S)

data PProtocolVersion (s :: S)
PProtocolVersion :: Term s (PAsData PInteger) -> Term s (PAsData PInteger) -> PProtocolVersion (s :: S)
[$sel:pprotocolVersion'major:PProtocolVersion] :: PProtocolVersion (s :: S) -> Term s (PAsData PInteger)
[$sel:pprotocolVersion'minor:PProtocolVersion] :: PProtocolVersion (s :: S) -> Term s (PAsData PInteger)

data PProposalProcedure (s :: S)
PProposalProcedure :: Term s (PAsData PLovelace) -> Term s PCredential -> Term s PGovernanceAction -> PProposalProcedure (s :: S)
[$sel:pproposalProcedure'deposit:PProposalProcedure] :: PProposalProcedure (s :: S) -> Term s (PAsData PLovelace)
[$sel:pproposalProcedure'returnAddr:PProposalProcedure] :: PProposalProcedure (s :: S) -> Term s PCredential
[$sel:pproposalProcedure'governanceAction:PProposalProcedure] :: PProposalProcedure (s :: S) -> Term s PGovernanceAction

data PGovernanceAction (s :: S)
PParameterChange :: Term s (PMaybeData PGovernanceActionId) -> Term s PChangedParameters -> Term s (PMaybeData PScriptHash) -> PGovernanceAction (s :: S)
PHardForkInitiation :: Term s (PMaybeData PGovernanceActionId) -> Term s PProtocolVersion -> PGovernanceAction (s :: S)
PTreasuryWithdrawals :: Term s (PAsData (PMap 'Unsorted PCredential PLovelace)) -> Term s (PMaybeData PScriptHash) -> PGovernanceAction (s :: S)
PNoConfidence :: Term s (PMaybeData PGovernanceActionId) -> PGovernanceAction (s :: S)
PUpdateCommittee :: Term s (PMaybeData PGovernanceActionId) -> Term s (PAsData (PBuiltinList (PAsData PColdCommitteeCredential))) -> Term s (PAsData (PMap 'Unsorted PColdCommitteeCredential PInteger)) -> Term s PRationalData -> PGovernanceAction (s :: S)
PNewConstitution :: Term s (PMaybeData PGovernanceActionId) -> Term s PConstitution -> PGovernanceAction (s :: S)
PInfoAction :: PGovernanceAction (s :: S)

newtype PChangedParameters (s :: S)
PChangedParameters :: Term s PData -> PChangedParameters (s :: S)

-- | A constitution, omitting the optional anchor.
newtype PConstitution (s :: S)
PConstitution :: Term s (PMaybeData PScriptHash) -> PConstitution (s :: S)

data PCommittee (s :: S)
PCommittee :: Term s (PAsData (PMap 'Unsorted PColdCommitteeCredential PInteger)) -> Term s PRationalData -> PCommittee (s :: S)
[$sel:pcommittee'members:PCommittee] :: PCommittee (s :: S) -> Term s (PAsData (PMap 'Unsorted PColdCommitteeCredential PInteger))
[$sel:pcommittee'quorum:PCommittee] :: PCommittee (s :: S) -> Term s PRationalData

newtype PubKey
PubKey :: LedgerBytes -> PubKey

[$sel:getPubKey:PubKey] :: PubKey -> LedgerBytes

newtype PPubKeyHash (s :: S)
PPubKeyHash :: Term s PByteString -> PPubKeyHash (s :: S)

pubKeyHash :: PubKey -> PubKeyHash

data PMaybeData (a :: S -> Type) (s :: S)
PDJust :: Term s (PAsData a) -> PMaybeData (a :: S -> Type) (s :: S)
PDNothing :: PMaybeData (a :: S -> Type) (s :: S)

-- | A Rational type that corresponds to the data encoding used by
--   <a>Rational</a>.
data PRationalData s
PRationalData :: Term s (PAsData PInteger) -> Term s (PAsData PPositive) -> PRationalData s
[$sel:prationalData'numerator:PRationalData] :: PRationalData s -> Term s (PAsData PInteger)
[$sel:prationalData'denominator:PRationalData] :: PRationalData s -> Term s (PAsData PPositive)

-- | Extracts the element out of a <a>PDJust</a> and throws an error if its
--   argument is <a>PDNothing</a>.
pfromDJust :: forall (a :: S -> Type) (s :: S). PIsData a => Term s (PMaybeData a :--> a)

-- | Yield <a>PTrue</a> if a given <a>PMaybeData</a> is of the form
--   <tt><a>PDJust</a> _</tt>.
pisDJust :: forall (a :: S -> Type) (s :: S). Term s (PMaybeData a :--> PBool)

-- | Special version of <tt>pmaybe</tt> that works with <a>PMaybeData</a>.
pmaybeData :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). PIsData a => Term s (b :--> ((a :--> b) :--> (PMaybeData a :--> b)))

-- | Construct a <a>PDJust</a> value.
pdjust :: forall (a :: S -> Type) (s :: S). PIsData a => Term s (a :--> PMaybeData a)

-- | Construct a <a>PDNothing</a> value.
pdnothing :: forall (a :: S -> Type) (s :: S). Term s (PMaybeData a)

-- | Construct a <a>PMaybeData</a> given a <a>PMaybe</a>. Could be useful
--   if you want to "lift" from <a>PMaybe</a> to <a>Maybe</a>.
pmaybeToMaybeData :: forall (a :: S -> Type) (s :: S). PIsData a => Term s (PMaybe a :--> PMaybeData a)

-- | Extract the value stored in a <a>PMaybeData</a> container. If there's
--   no value, throw an error with the given message.
passertPDJust :: forall (a :: S -> Type) (s :: S). PIsData a => Term s (PString :--> (PMaybeData a :--> a))

prationalFromData :: ClosedTerm (PRationalData :--> PRational)
instance GHC.Show.Show Plutarch.LedgerApi.V3.PubKey
instance GHC.Classes.Ord Plutarch.LedgerApi.V3.PubKey
instance GHC.Classes.Eq Plutarch.LedgerApi.V3.PubKey

module Plutarch.LedgerApi.V2

data PScriptPurpose (s :: S)
PMinting :: Term s (PAsData PCurrencySymbol) -> PScriptPurpose (s :: S)
PSpending :: Term s PTxOutRef -> PScriptPurpose (s :: S)
PRewarding :: Term s PStakingCredential -> PScriptPurpose (s :: S)
PCertifying :: Term s PDCert -> PScriptPurpose (s :: S)

data PScriptContext (s :: S)
PScriptContext :: Term s PTxInfo -> Term s PScriptPurpose -> PScriptContext (s :: S)
[$sel:pscriptContext'txInfo:PScriptContext] :: PScriptContext (s :: S) -> Term s PTxInfo
[$sel:pscriptContext'purpose:PScriptContext] :: PScriptContext (s :: S) -> Term s PScriptPurpose

data PDCert (s :: S)
PDCertDelegRegKey :: Term s PStakingCredential -> PDCert (s :: S)
PDCertDelegDeRegKey :: Term s PStakingCredential -> PDCert (s :: S)
PDCertDelegDelegate :: Term s PStakingCredential -> Term s (PAsData PPubKeyHash) -> PDCert (s :: S)
PDCertPoolRegister :: Term s (PAsData PPubKeyHash) -> Term s (PAsData PPubKeyHash) -> PDCert (s :: S)
PDCertPoolRetire :: Term s (PAsData PPubKeyHash) -> Term s (PAsData PInteger) -> PDCert (s :: S)
PDCertGenesis :: PDCert (s :: S)
PDCertMir :: PDCert (s :: S)

data PCredential (s :: S)
PPubKeyCredential :: Term s (PAsData PPubKeyHash) -> PCredential (s :: S)
PScriptCredential :: Term s (PAsData PScriptHash) -> PCredential (s :: S)

data PStakingCredential (s :: S)
PStakingHash :: Term s PCredential -> PStakingCredential (s :: S)
PStakingPtr :: Term s (PAsData PInteger) -> Term s (PAsData PInteger) -> Term s (PAsData PInteger) -> PStakingCredential (s :: S)

newtype PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)
PValue :: Term s (PMap keys PCurrencySymbol (PMap keys PTokenName PInteger)) -> PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)

data AmountGuarantees
NoGuarantees :: AmountGuarantees
NonZero :: AmountGuarantees
Positive :: AmountGuarantees

newtype PLovelace (s :: S)
PLovelace :: Term s PInteger -> PLovelace (s :: S)

newtype PTokenName (s :: S)
PTokenName :: Term s PByteString -> PTokenName (s :: S)

newtype PCurrencySymbol (s :: S)
PCurrencySymbol :: Term s PByteString -> PCurrencySymbol (s :: S)

newtype PPosixTime (s :: S)
PPosixTime :: Term s PInteger -> PPosixTime (s :: S)

-- | Construct a <a>PPosixTime</a> from a <a>PInteger</a>. Same as using
--   the constructor, but a lot shorter.
pposixTime :: forall (s :: S). Term s PInteger -> Term s PPosixTime

-- | Unwrap a <a>PPosixTime</a> to get a <a>PInteger</a>. Same as using
--   <a>pmatch</a>, but a lot shorter. Also unwraps the <tt>Data</tt>
--   encoding.
unPPosixTime :: forall (s :: S). Term s PPosixTime -> Term s PInteger

data PExtended (a :: S -> Type) (s :: S)
PNegInf :: PExtended (a :: S -> Type) (s :: S)
PFinite :: Term s (PAsData a) -> PExtended (a :: S -> Type) (s :: S)
PPosInf :: PExtended (a :: S -> Type) (s :: S)

data PLowerBound (a :: S -> Type) (s :: S)
PLowerBound :: Term s (PExtended a) -> Term s (PAsData PBool) -> PLowerBound (a :: S -> Type) (s :: S)

data PUpperBound (a :: S -> Type) (s :: S)
PUpperBound :: Term s (PExtended a) -> Term s (PAsData PBool) -> PUpperBound (a :: S -> Type) (s :: S)

data PInterval (a :: S -> Type) (s :: S)
PInterval :: Term s (PLowerBound a) -> Term s (PUpperBound a) -> PInterval (a :: S -> Type) (s :: S)
[$sel:pinteral'from:PInterval] :: PInterval (a :: S -> Type) (s :: S) -> Term s (PLowerBound a)
[$sel:pinteral'to:PInterval] :: PInterval (a :: S -> Type) (s :: S) -> Term s (PUpperBound a)

newtype PDatum (s :: S)
PDatum :: Term s PData -> PDatum (s :: S)

newtype PRedeemer (s :: S)
PRedeemer :: Term s PData -> PRedeemer (s :: S)

newtype PDatumHash (s :: S)
PDatumHash :: Term s PByteString -> PDatumHash (s :: S)

newtype PRedeemerHash (s :: S)
PRedeemerHash :: Term s PByteString -> PRedeemerHash (s :: S)

newtype PScriptHash (s :: S)
PScriptHash :: Term s PByteString -> PScriptHash (s :: S)

data PAddress (s :: S)
PAddress :: Term s PCredential -> Term s (PMaybeData PStakingCredential) -> PAddress (s :: S)
[$sel:paddress'credential:PAddress] :: PAddress (s :: S) -> Term s PCredential
[$sel:paddress'stakingCredential:PAddress] :: PAddress (s :: S) -> Term s (PMaybeData PStakingCredential)

newtype PPubKeyHash (s :: S)
PPubKeyHash :: Term s PByteString -> PPubKeyHash (s :: S)

-- | Hashed with <tt>BLAKE2b-256</tt>.
newtype PTxId (s :: S)
PTxId :: Term s (PAsData PByteString) -> PTxId (s :: S)

data PTxInfo (s :: S)
PTxInfo :: Term s (PAsData (PBuiltinList (PAsData PTxInInfo))) -> Term s (PAsData (PBuiltinList (PAsData PTxInInfo))) -> Term s (PAsData (PBuiltinList (PAsData PTxOut))) -> Term s (PAsData (PValue 'Sorted 'Positive)) -> Term s (PAsData (PValue 'Sorted 'NoGuarantees)) -> Term s (PAsData (PBuiltinList (PAsData PDCert))) -> Term s (PAsData (PMap 'Unsorted PStakingCredential PInteger)) -> Term s (PInterval PPosixTime) -> Term s (PAsData (PBuiltinList (PAsData PPubKeyHash))) -> Term s (PAsData (PMap 'Unsorted PScriptPurpose PRedeemer)) -> Term s (PAsData (PMap 'Unsorted PDatumHash PDatum)) -> Term s PTxId -> PTxInfo (s :: S)
[$sel:ptxInfo'inputs:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PBuiltinList (PAsData PTxInInfo)))
[$sel:ptxInfo'referenceInputs:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PBuiltinList (PAsData PTxInInfo)))
[$sel:ptxInfo'outputs:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PBuiltinList (PAsData PTxOut)))
[$sel:ptxInfo'fee:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PValue 'Sorted 'Positive))
[$sel:ptxInfo'mint:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PValue 'Sorted 'NoGuarantees))
[$sel:ptxInfo'dcert:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PBuiltinList (PAsData PDCert)))
[$sel:ptxInfo'wdrl:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PMap 'Unsorted PStakingCredential PInteger))
[$sel:ptxInfo'validRange:PTxInfo] :: PTxInfo (s :: S) -> Term s (PInterval PPosixTime)
[$sel:ptxInfo'signatories:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PBuiltinList (PAsData PPubKeyHash)))
[$sel:ptxInfo'redeemers:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PMap 'Unsorted PScriptPurpose PRedeemer))
[$sel:ptxInfo'data:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PMap 'Unsorted PDatumHash PDatum))
[$sel:ptxInfo'id:PTxInfo] :: PTxInfo (s :: S) -> Term s PTxId

data PTxOut (s :: S)
PTxOut :: Term s PAddress -> Term s (PAsData (PValue 'Sorted 'Positive)) -> Term s POutputDatum -> Term s (PMaybeData PScriptHash) -> PTxOut (s :: S)
[$sel:ptxOut'address:PTxOut] :: PTxOut (s :: S) -> Term s PAddress
[$sel:ptxOut'value:PTxOut] :: PTxOut (s :: S) -> Term s (PAsData (PValue 'Sorted 'Positive))
[$sel:ptxOut'datum:PTxOut] :: PTxOut (s :: S) -> Term s POutputDatum
[$sel:ptxOut'referenceScript:PTxOut] :: PTxOut (s :: S) -> Term s (PMaybeData PScriptHash)

-- | Reference to a transaction output, with an index referencing which
--   exact output we mean.
data PTxOutRef (s :: S)
PTxOutRef :: Term s PTxId -> Term s (PAsData PInteger) -> PTxOutRef (s :: S)
[$sel:ptxOutRef'id:PTxOutRef] :: PTxOutRef (s :: S) -> Term s PTxId
[$sel:ptxOutRef'idx:PTxOutRef] :: PTxOutRef (s :: S) -> Term s (PAsData PInteger)

data PTxInInfo (s :: S)
PTxInInfo :: Term s PTxOutRef -> Term s PTxOut -> PTxInInfo (s :: S)
[$sel:ptxInInfo'outRef:PTxInInfo] :: PTxInInfo (s :: S) -> Term s PTxOutRef
[$sel:ptxInInfo'resolved:PTxInInfo] :: PTxInInfo (s :: S) -> Term s PTxOut

data POutputDatum (s :: S)
PNoOutputDatum :: POutputDatum (s :: S)
POutputDatumHash :: Term s (PAsData PDatumHash) -> POutputDatum (s :: S)
[$sel:poutputDatum'datumHash:PNoOutputDatum] :: POutputDatum (s :: S) -> Term s (PAsData PDatumHash)

-- | Inline datum as per <a>CIP-0032</a>
POutputDatum :: Term s PDatum -> POutputDatum (s :: S)
[$sel:poutputDatum'outputDatum:PNoOutputDatum] :: POutputDatum (s :: S) -> Term s PDatum

newtype PMap (keysort :: KeyGuarantees) (k :: S -> Type) (v :: S -> Type) (s :: S)
PMap :: Term s (PBuiltinList (PBuiltinPair (PAsData k) (PAsData v))) -> PMap (keysort :: KeyGuarantees) (k :: S -> Type) (v :: S -> Type) (s :: S)

data KeyGuarantees
Sorted :: KeyGuarantees
Unsorted :: KeyGuarantees

data Commutativity
Commutative :: Commutativity
NonCommutative :: Commutativity

data PMaybeData (a :: S -> Type) (s :: S)
PDJust :: Term s (PAsData a) -> PMaybeData (a :: S -> Type) (s :: S)
PDNothing :: PMaybeData (a :: S -> Type) (s :: S)

-- | A Rational type that corresponds to the data encoding used by
--   <a>Rational</a>.
data PRationalData s
PRationalData :: Term s (PAsData PInteger) -> Term s (PAsData PPositive) -> PRationalData s
[$sel:prationalData'numerator:PRationalData] :: PRationalData s -> Term s (PAsData PInteger)
[$sel:prationalData'denominator:PRationalData] :: PRationalData s -> Term s (PAsData PPositive)

-- | Extracts the element out of a <a>PDJust</a> and throws an error if its
--   argument is <a>PDNothing</a>.
pfromDJust :: forall (a :: S -> Type) (s :: S). PIsData a => Term s (PMaybeData a :--> a)

-- | Yield <a>PTrue</a> if a given <a>PMaybeData</a> is of the form
--   <tt><a>PDJust</a> _</tt>.
pisDJust :: forall (a :: S -> Type) (s :: S). Term s (PMaybeData a :--> PBool)

-- | Special version of <tt>pmaybe</tt> that works with <a>PMaybeData</a>.
pmaybeData :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). PIsData a => Term s (b :--> ((a :--> b) :--> (PMaybeData a :--> b)))

-- | Construct a <a>PDJust</a> value.
pdjust :: forall (a :: S -> Type) (s :: S). PIsData a => Term s (a :--> PMaybeData a)

-- | Construct a <a>PDNothing</a> value.
pdnothing :: forall (a :: S -> Type) (s :: S). Term s (PMaybeData a)

-- | Construct a <a>PMaybeData</a> given a <a>PMaybe</a>. Could be useful
--   if you want to "lift" from <a>PMaybe</a> to <a>Maybe</a>.
pmaybeToMaybeData :: forall (a :: S -> Type) (s :: S). PIsData a => Term s (PMaybe a :--> PMaybeData a)

-- | Extract the value stored in a <a>PMaybeData</a> container. If there's
--   no value, throw an error with the given message.
passertPDJust :: forall (a :: S -> Type) (s :: S). PIsData a => Term s (PString :--> (PMaybeData a :--> a))

prationalFromData :: ClosedTerm (PRationalData :--> PRational)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.V2.PTxInInfo
instance Plutarch.Internal.Show.PShow Plutarch.LedgerApi.V2.PTxInInfo
instance Plutarch.Internal.Eq.PEq Plutarch.LedgerApi.V2.PTxInInfo
instance Plutarch.Internal.IsData.PIsData Plutarch.LedgerApi.V2.PTxInInfo
instance Generics.SOP.Universe.Generic (Plutarch.LedgerApi.V2.PTxInInfo s)
instance GHC.Generics.Generic (Plutarch.LedgerApi.V2.PTxInInfo s)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.V2.PTxInfo
instance Plutarch.Internal.Show.PShow Plutarch.LedgerApi.V2.PTxInfo
instance Plutarch.Internal.Eq.PEq Plutarch.LedgerApi.V2.PTxInfo
instance Plutarch.Internal.IsData.PIsData Plutarch.LedgerApi.V2.PTxInfo
instance Generics.SOP.Universe.Generic (Plutarch.LedgerApi.V2.PTxInfo s)
instance GHC.Generics.Generic (Plutarch.LedgerApi.V2.PTxInfo s)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.V2.PScriptContext
instance Plutarch.Internal.Show.PShow Plutarch.LedgerApi.V2.PScriptContext
instance Plutarch.Internal.Eq.PEq Plutarch.LedgerApi.V2.PScriptContext
instance Plutarch.Internal.IsData.PIsData Plutarch.LedgerApi.V2.PScriptContext
instance Generics.SOP.Universe.Generic (Plutarch.LedgerApi.V2.PScriptContext s)
instance GHC.Generics.Generic (Plutarch.LedgerApi.V2.PScriptContext s)
instance Plutarch.Internal.Lift.PLiftable Plutarch.LedgerApi.V2.PTxInInfo
instance Plutarch.Internal.Lift.PLiftable Plutarch.LedgerApi.V2.PTxInfo
instance Plutarch.Internal.Lift.PLiftable Plutarch.LedgerApi.V2.PScriptContext

module Plutarch.LedgerApi.V1

data PScriptPurpose (s :: S)
PMinting :: Term s (PAsData PCurrencySymbol) -> PScriptPurpose (s :: S)
PSpending :: Term s PTxOutRef -> PScriptPurpose (s :: S)
PRewarding :: Term s PStakingCredential -> PScriptPurpose (s :: S)
PCertifying :: Term s PDCert -> PScriptPurpose (s :: S)

data PScriptContext (s :: S)
PScriptContext :: Term s PTxInfo -> Term s PScriptPurpose -> PScriptContext (s :: S)
[$sel:pscriptContext'txInfo:PScriptContext] :: PScriptContext (s :: S) -> Term s PTxInfo
[$sel:pscriptContext'purpose:PScriptContext] :: PScriptContext (s :: S) -> Term s PScriptPurpose

data PDCert (s :: S)
PDCertDelegRegKey :: Term s PStakingCredential -> PDCert (s :: S)
PDCertDelegDeRegKey :: Term s PStakingCredential -> PDCert (s :: S)
PDCertDelegDelegate :: Term s PStakingCredential -> Term s (PAsData PPubKeyHash) -> PDCert (s :: S)
PDCertPoolRegister :: Term s (PAsData PPubKeyHash) -> Term s (PAsData PPubKeyHash) -> PDCert (s :: S)
PDCertPoolRetire :: Term s (PAsData PPubKeyHash) -> Term s (PAsData PInteger) -> PDCert (s :: S)
PDCertGenesis :: PDCert (s :: S)
PDCertMir :: PDCert (s :: S)

data PCredential (s :: S)
PPubKeyCredential :: Term s (PAsData PPubKeyHash) -> PCredential (s :: S)
PScriptCredential :: Term s (PAsData PScriptHash) -> PCredential (s :: S)

data PStakingCredential (s :: S)
PStakingHash :: Term s PCredential -> PStakingCredential (s :: S)
PStakingPtr :: Term s (PAsData PInteger) -> Term s (PAsData PInteger) -> Term s (PAsData PInteger) -> PStakingCredential (s :: S)

newtype PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)
PValue :: Term s (PMap keys PCurrencySymbol (PMap keys PTokenName PInteger)) -> PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)

data AmountGuarantees
NoGuarantees :: AmountGuarantees
NonZero :: AmountGuarantees
Positive :: AmountGuarantees

newtype PLovelace (s :: S)
PLovelace :: Term s PInteger -> PLovelace (s :: S)

newtype PTokenName (s :: S)
PTokenName :: Term s PByteString -> PTokenName (s :: S)

newtype PCurrencySymbol (s :: S)
PCurrencySymbol :: Term s PByteString -> PCurrencySymbol (s :: S)

newtype PPosixTime (s :: S)
PPosixTime :: Term s PInteger -> PPosixTime (s :: S)

-- | Construct a <a>PPosixTime</a> from a <a>PInteger</a>. Same as using
--   the constructor, but a lot shorter.
pposixTime :: forall (s :: S). Term s PInteger -> Term s PPosixTime

-- | Unwrap a <a>PPosixTime</a> to get a <a>PInteger</a>. Same as using
--   <a>pmatch</a>, but a lot shorter. Also unwraps the <tt>Data</tt>
--   encoding.
unPPosixTime :: forall (s :: S). Term s PPosixTime -> Term s PInteger

data PExtended (a :: S -> Type) (s :: S)
PNegInf :: PExtended (a :: S -> Type) (s :: S)
PFinite :: Term s (PAsData a) -> PExtended (a :: S -> Type) (s :: S)
PPosInf :: PExtended (a :: S -> Type) (s :: S)

data PLowerBound (a :: S -> Type) (s :: S)
PLowerBound :: Term s (PExtended a) -> Term s (PAsData PBool) -> PLowerBound (a :: S -> Type) (s :: S)

data PUpperBound (a :: S -> Type) (s :: S)
PUpperBound :: Term s (PExtended a) -> Term s (PAsData PBool) -> PUpperBound (a :: S -> Type) (s :: S)

data PInterval (a :: S -> Type) (s :: S)
PInterval :: Term s (PLowerBound a) -> Term s (PUpperBound a) -> PInterval (a :: S -> Type) (s :: S)
[$sel:pinteral'from:PInterval] :: PInterval (a :: S -> Type) (s :: S) -> Term s (PLowerBound a)
[$sel:pinteral'to:PInterval] :: PInterval (a :: S -> Type) (s :: S) -> Term s (PUpperBound a)

newtype PDatum (s :: S)
PDatum :: Term s PData -> PDatum (s :: S)

newtype PRedeemer (s :: S)
PRedeemer :: Term s PData -> PRedeemer (s :: S)

newtype PDatumHash (s :: S)
PDatumHash :: Term s PByteString -> PDatumHash (s :: S)

newtype PRedeemerHash (s :: S)
PRedeemerHash :: Term s PByteString -> PRedeemerHash (s :: S)

newtype PScriptHash (s :: S)
PScriptHash :: Term s PByteString -> PScriptHash (s :: S)

data PAddress (s :: S)
PAddress :: Term s PCredential -> Term s (PMaybeData PStakingCredential) -> PAddress (s :: S)
[$sel:paddress'credential:PAddress] :: PAddress (s :: S) -> Term s PCredential
[$sel:paddress'stakingCredential:PAddress] :: PAddress (s :: S) -> Term s (PMaybeData PStakingCredential)

-- | Hashed with <tt>BLAKE2b-256</tt>.
newtype PTxId (s :: S)
PTxId :: Term s (PAsData PByteString) -> PTxId (s :: S)

data PTxOut (s :: S)
PTxOut :: Term s (PAsData PAddress) -> Term s (PAsData (PValue 'Sorted 'Positive)) -> Term s (PAsData PDatumHash) -> PTxOut (s :: S)
[$sel:ptxOut'address:PTxOut] :: PTxOut (s :: S) -> Term s (PAsData PAddress)
[$sel:ptxOut'value:PTxOut] :: PTxOut (s :: S) -> Term s (PAsData (PValue 'Sorted 'Positive))
[$sel:ptxOut'datumHash:PTxOut] :: PTxOut (s :: S) -> Term s (PAsData PDatumHash)

data PTxInInfo (s :: S)
PTxInInfo :: Term s PTxOutRef -> Term s PTxOut -> PTxInInfo (s :: S)
[$sel:ptxInInfo'outRef:PTxInInfo] :: PTxInInfo (s :: S) -> Term s PTxOutRef
[$sel:ptxInInfo'resolved:PTxInInfo] :: PTxInInfo (s :: S) -> Term s PTxOut

-- | Reference to a transaction output, with an index referencing which
--   exact output we mean.
data PTxOutRef (s :: S)
PTxOutRef :: Term s PTxId -> Term s (PAsData PInteger) -> PTxOutRef (s :: S)
[$sel:ptxOutRef'id:PTxOutRef] :: PTxOutRef (s :: S) -> Term s PTxId
[$sel:ptxOutRef'idx:PTxOutRef] :: PTxOutRef (s :: S) -> Term s (PAsData PInteger)

newtype PPubKeyHash (s :: S)
PPubKeyHash :: Term s PByteString -> PPubKeyHash (s :: S)

data PTxInfo (s :: S)
PTxInfo :: Term s (PAsData (PBuiltinList (PAsData PTxInInfo))) -> Term s (PAsData (PBuiltinList (PAsData PTxOut))) -> Term s (PAsData (PValue 'Sorted 'Positive)) -> Term s (PAsData (PValue 'Sorted 'NoGuarantees)) -> Term s (PAsData (PBuiltinList (PAsData PDCert))) -> Term s (PAsData (PBuiltinList (PAsData (PBuiltinPair (PAsData PStakingCredential) (PAsData PInteger))))) -> Term s (PInterval PPosixTime) -> Term s (PAsData (PBuiltinList (PAsData PPubKeyHash))) -> Term s (PAsData (PBuiltinList (PAsData (PBuiltinPair (PAsData PDatumHash) (PAsData PDatum))))) -> Term s (PAsData PTxId) -> PTxInfo (s :: S)
[$sel:ptxInfo'inputs:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PBuiltinList (PAsData PTxInInfo)))
[$sel:ptxInfo'outputs:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PBuiltinList (PAsData PTxOut)))
[$sel:ptxInfo'fee:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PValue 'Sorted 'Positive))
[$sel:ptxInfo'mint:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PValue 'Sorted 'NoGuarantees))
[$sel:ptxInfo'dCert:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PBuiltinList (PAsData PDCert)))
[$sel:ptxInfo'wdrl:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PBuiltinList (PAsData (PBuiltinPair (PAsData PStakingCredential) (PAsData PInteger)))))
[$sel:ptxInfo'validRange:PTxInfo] :: PTxInfo (s :: S) -> Term s (PInterval PPosixTime)
[$sel:ptxInfo'signatories:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PBuiltinList (PAsData PPubKeyHash)))
[$sel:ptxInfo'data:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData (PBuiltinList (PAsData (PBuiltinPair (PAsData PDatumHash) (PAsData PDatum)))))
[$sel:ptxInfo'id:PTxInfo] :: PTxInfo (s :: S) -> Term s (PAsData PTxId)

newtype PMap (keysort :: KeyGuarantees) (k :: S -> Type) (v :: S -> Type) (s :: S)
PMap :: Term s (PBuiltinList (PBuiltinPair (PAsData k) (PAsData v))) -> PMap (keysort :: KeyGuarantees) (k :: S -> Type) (v :: S -> Type) (s :: S)

data KeyGuarantees
Sorted :: KeyGuarantees
Unsorted :: KeyGuarantees

data Commutativity
Commutative :: Commutativity
NonCommutative :: Commutativity

data PMaybeData (a :: S -> Type) (s :: S)
PDJust :: Term s (PAsData a) -> PMaybeData (a :: S -> Type) (s :: S)
PDNothing :: PMaybeData (a :: S -> Type) (s :: S)

-- | A Rational type that corresponds to the data encoding used by
--   <a>Rational</a>.
data PRationalData s
PRationalData :: Term s (PAsData PInteger) -> Term s (PAsData PPositive) -> PRationalData s
[$sel:prationalData'numerator:PRationalData] :: PRationalData s -> Term s (PAsData PInteger)
[$sel:prationalData'denominator:PRationalData] :: PRationalData s -> Term s (PAsData PPositive)

-- | Extracts the element out of a <a>PDJust</a> and throws an error if its
--   argument is <a>PDNothing</a>.
pfromDJust :: forall (a :: S -> Type) (s :: S). PIsData a => Term s (PMaybeData a :--> a)

-- | Yield <a>PTrue</a> if a given <a>PMaybeData</a> is of the form
--   <tt><a>PDJust</a> _</tt>.
pisDJust :: forall (a :: S -> Type) (s :: S). Term s (PMaybeData a :--> PBool)

-- | Special version of <tt>pmaybe</tt> that works with <a>PMaybeData</a>.
pmaybeData :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). PIsData a => Term s (b :--> ((a :--> b) :--> (PMaybeData a :--> b)))

-- | Construct a <a>PDJust</a> value.
pdjust :: forall (a :: S -> Type) (s :: S). PIsData a => Term s (a :--> PMaybeData a)

-- | Construct a <a>PDNothing</a> value.
pdnothing :: forall (a :: S -> Type) (s :: S). Term s (PMaybeData a)

-- | Construct a <a>PMaybeData</a> given a <a>PMaybe</a>. Could be useful
--   if you want to "lift" from <a>PMaybe</a> to <a>Maybe</a>.
pmaybeToMaybeData :: forall (a :: S -> Type) (s :: S). PIsData a => Term s (PMaybe a :--> PMaybeData a)

-- | Extract the value stored in a <a>PMaybeData</a> container. If there's
--   no value, throw an error with the given message.
passertPDJust :: forall (a :: S -> Type) (s :: S). PIsData a => Term s (PString :--> (PMaybeData a :--> a))

prationalFromData :: ClosedTerm (PRationalData :--> PRational)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.V1.PTxOut
instance Plutarch.Internal.Show.PShow Plutarch.LedgerApi.V1.PTxOut
instance Plutarch.Internal.Eq.PEq Plutarch.LedgerApi.V1.PTxOut
instance Plutarch.Internal.IsData.PIsData Plutarch.LedgerApi.V1.PTxOut
instance Generics.SOP.Universe.Generic (Plutarch.LedgerApi.V1.PTxOut s)
instance GHC.Generics.Generic (Plutarch.LedgerApi.V1.PTxOut s)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.V1.PTxInInfo
instance Plutarch.Internal.Show.PShow Plutarch.LedgerApi.V1.PTxInInfo
instance Plutarch.Internal.Eq.PEq Plutarch.LedgerApi.V1.PTxInInfo
instance Plutarch.Internal.IsData.PIsData Plutarch.LedgerApi.V1.PTxInInfo
instance Generics.SOP.Universe.Generic (Plutarch.LedgerApi.V1.PTxInInfo s)
instance GHC.Generics.Generic (Plutarch.LedgerApi.V1.PTxInInfo s)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.V1.PTxInfo
instance Plutarch.Internal.Show.PShow Plutarch.LedgerApi.V1.PTxInfo
instance Plutarch.Internal.Eq.PEq Plutarch.LedgerApi.V1.PTxInfo
instance Plutarch.Internal.IsData.PIsData Plutarch.LedgerApi.V1.PTxInfo
instance Generics.SOP.Universe.Generic (Plutarch.LedgerApi.V1.PTxInfo s)
instance GHC.Generics.Generic (Plutarch.LedgerApi.V1.PTxInfo s)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.LedgerApi.V1.PScriptContext
instance Plutarch.Internal.Show.PShow Plutarch.LedgerApi.V1.PScriptContext
instance Plutarch.Internal.Eq.PEq Plutarch.LedgerApi.V1.PScriptContext
instance Plutarch.Internal.IsData.PIsData Plutarch.LedgerApi.V1.PScriptContext
instance Generics.SOP.Universe.Generic (Plutarch.LedgerApi.V1.PScriptContext s)
instance GHC.Generics.Generic (Plutarch.LedgerApi.V1.PScriptContext s)
instance Plutarch.Internal.Lift.PLiftable Plutarch.LedgerApi.V1.PTxOut
instance Plutarch.Internal.Lift.PLiftable Plutarch.LedgerApi.V1.PTxInInfo
instance Plutarch.Internal.Lift.PLiftable Plutarch.LedgerApi.V1.PTxInfo
instance Plutarch.Internal.Lift.PLiftable Plutarch.LedgerApi.V1.PScriptContext
