-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package plutarch
@version 1.10.1

module Plutarch.Internal.PrettyStack
prettyStack :: Text -> CallStack -> Text

module Plutarch.Internal.Witness
witness :: c => Proxy c -> ()

module Plutarch.Pretty.Internal.Config
keywords :: Set Text
indentWidth :: Int

-- | Prefix to use for naming forced builtin functions.
forcedPrefix :: Text

module Plutarch.Pretty.Internal.BuiltinConstant
prettyConstant :: Some (ValueOf DefaultUni) -> Doc ()

module Plutarch.Pretty.Internal.TermUtils
unwrapLamAbs :: Index -> Term name uni fun ann -> (Index, Term name uni fun ann)
unwrapBindings :: [Term name uni fun ann] -> Term name uni fun ann -> ([Term name uni fun ann], Term name uni fun ann)
unwrapApply :: [Term name uni fun ann] -> Term name uni fun ann -> ([Term name uni fun ann], Term name uni fun ann)

-- | Increment the debruijn index of a <a>Var</a>, leave any other AST node
--   unchanged.
incrVar :: Term DeBruijn uni fun () -> Term DeBruijn uni fun ()
pattern PFixAst :: Term name uni fun ()
pattern ComposeAST :: Term DeBruijn uni fun () -> Term DeBruijn uni fun () -> Term DeBruijn uni fun ()
pattern IfThenElseLikeAST :: Term name uni fun () -> Term name uni fun () -> Term name uni fun () -> Term name uni fun () -> Term name uni fun ()

module Plutarch.Pretty.Internal.Types

-- | Notifies the prettifier what "state" the cursor currently is, so it
--   can decide whether or not to wrap the target expression in parens.
--   
--   Normal indicates no parens wrapping is necessary, even for complex
--   expressions.
--   
--   Special indicates complex expressions should be wrapped in parens.
--   
--   Usually, <a>Special</a> just hints at one of three states:
--   
--   <ol>
--   <li>Applying - The expression is being applied like a function.</li>
--   <li>Applied - The expression is being applied as a function
--   argument.</li>
--   <li>Unary arg - The expression is being used as an argument to a high
--   arity unary operator (~ and !).</li>
--   </ol>
data PrettyCursor
Normal :: PrettyCursor
Special :: PrettyCursor
data PrettyState
PrettyState :: Map Index Text -> Set Text -> PrettyCursor -> PrettyState
[$sel:ps'nameMap:PrettyState] :: PrettyState -> Map Index Text
[$sel:ps'names:PrettyState] :: PrettyState -> Set Text
[$sel:ps'cursor:PrettyState] :: PrettyState -> PrettyCursor
type PrettyMonad s = ReaderT (STGenM StdGen s) (StateT PrettyState (ST s))
forkState :: MonadState s m => m b -> m b
normalizeCursor :: PrettyState -> PrettyState
specializeCursor :: PrettyState -> PrettyState
memorizeName :: Text -> PrettyState -> PrettyState

-- | Insert a fresh binding onto the name map, i.e a name at index 0 -
--   incrementing all other indices.
insertName :: Text -> PrettyState -> PrettyState
insertBindings :: [Text] -> PrettyState -> PrettyState
builtinFunAtRef :: Map Index Text -> Index -> Maybe DefaultFun
nameOfRef :: Index -> Map Index Text -> Maybe Text
instance GHC.Show.Show Plutarch.Pretty.Internal.Types.PrettyCursor
instance GHC.Classes.Eq Plutarch.Pretty.Internal.Types.PrettyCursor
instance GHC.Enum.Enum Plutarch.Pretty.Internal.Types.PrettyCursor
instance GHC.Enum.Bounded Plutarch.Pretty.Internal.Types.PrettyCursor

module Plutarch.Pretty.Internal.Name
smartName :: Term DeBruijn uni DefaultFun () -> PrettyMonad s Text
freshVarName :: PrettyMonad s Text

module Plutarch.Script
newtype Script
Script :: Program DeBruijn DefaultUni DefaultFun () -> Script
[$sel:unScript:Script] :: Script -> Program DeBruijn DefaultUni DefaultFun ()
serialiseScript :: Script -> ShortByteString
deserialiseScript :: ShortByteString -> Script
instance GHC.Generics.Generic Plutarch.Script.Script
instance GHC.Show.Show Plutarch.Script.Script
instance GHC.Classes.Eq Plutarch.Script.Script

module Plutarch.Internal.Evaluate
uplcVersion :: Version

-- | Evaluate a script with a big budget, returning the trace log and term
--   result.
evalScript :: Script -> (Either EvalError Script, ExBudget, [Text])

-- | Evaluate a script with a huge budget, returning the trace log and term
--   result.
evalScriptHuge :: Script -> (Either EvalError Script, ExBudget, [Text])

-- | Evaluate a script without budget limit
evalScriptUnlimited :: Script -> (Either (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun) Script, ExBudget, [Text])

-- | Evaluate a script with a specific budget, returning the trace log and
--   term result.
evalScript' :: ExBudget -> Script -> (Either (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun) Script, ExBudget, [Text])
type EvalError = (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun)

module Plutarch.Internal.Term
newtype (:-->) (a :: PType) (b :: PType) (s :: S)
PLam :: (Term s a -> Term s b) -> (:-->) (a :: PType) (b :: PType) (s :: S)
infixr 0 :-->
data PDelayed (a :: PType) (s :: S)
newtype Term (s :: S) (a :: PType)
Term :: (Word64 -> TermMonad TermResult) -> Term (s :: S) (a :: PType)
[$sel:asRawTerm:Term] :: Term (s :: S) (a :: PType) -> Word64 -> TermMonad TermResult
asClosedRawTerm :: ClosedTerm a -> TermMonad TermResult
newtype Script
Script :: Program DeBruijn DefaultUni DefaultFun () -> Script
mapTerm :: (RawTerm -> RawTerm) -> TermResult -> TermResult

-- | Lambda abstraction.
--   
--   Only works with a single argument. Use <tt>plam</tt> instead, to
--   support currying.
plam' :: (Term s a -> Term s b) -> Term s (a :--> b)

-- | Let bindings.
--   
--   This is approximately a shorthand for a lambda and application:
--   
--   <tt>plet v f</tt> == <tt> papp (plam f) v</tt>
--   
--   But sufficiently small terms in WHNF may be inlined for efficiency.
plet :: Term s a -> (Term s a -> Term s b) -> Term s b

-- | Lambda Application.
papp :: Term s (a :--> b) -> Term s a -> Term s b

-- | Plutus 'delay', used for laziness.
pdelay :: Term s a -> Term s (PDelayed a)

-- | Plutus 'force', used to force evaluation of <a>PDelayed</a> terms.
pforce :: Term s (PDelayed a) -> Term s a
phoistAcyclic :: HasCallStack => ClosedTerm a -> Term s a

-- | Plutus 'error'.
--   
--   When using this explicitly, it should be ensured that the containing
--   term is delayed, avoiding premature evaluation.
perror :: Term s a

-- | Same as <tt>perror</tt> except this holds integer id for AST
--   look-ahead.
--   
--   This can be used to "tag" branch and generate AST first to see if that
--   branch is actually used or not, allowing optimization cutting unused
--   branches. For more detailed uscases, check <tt>pmatchDataRec</tt>.
pplaceholder :: Integer -> Term s a

-- | Unsafely coerce the type-tag of a Term.
--   
--   This should mostly be avoided, though it can be safely used to assert
--   known types of Datums, Redeemers or ScriptContext.
punsafeCoerce :: forall b a s. Term s a -> Term s b
punsafeBuiltin :: DefaultFun -> Term s a

-- | <i>Deprecated: Use <tt>pconstant</tt> instead.</i>
punsafeConstant :: Some (ValueOf DefaultUni) -> Term s a
punsafeConstantInternal :: Some (ValueOf DefaultUni) -> Term s a

-- | Compile a (closed) Plutus Term to a usable script
compile :: Config -> ClosedTerm a -> Either Text Script

-- | As <a>compile</a>, but performs UPLC optimizations. Furthermore, this
--   will always elide tracing (as if with <a>NoTracing</a>).
compileOptimized :: forall (a :: S -> Type). (forall (s :: S). Term s a) -> Either Text Script
compile' :: Config -> TermResult -> UTerm

-- | Given a closed <a>Term</a>, run the UPLC optimizer on it.
--   
--   <h1>Important note</h1>
--   
--   If the input term has any hoisted dependencies, these are completely
--   erased by this process. Thus, if the resulting <a>Term</a> is used as
--   part of a larger computation with the same dependencies, the Plutarch
--   compiler will not be aware of them, and will not be able to optimize
--   them properly. More concretely, in a case like this:
--   
--   @<tt> padd # optimizeTerm (f # pexpensive) # optimizeTerm (g #
--   pexpensive) </tt>@
--   
--   <tt>pexpensive</tt> will end up being duplicated entirely into each
--   'arm' of the <tt>padd</tt>, even though under normal circumstances it
--   could be shared.
--   
--   Thus, if you plan to use this, ensure that it is done 'as late as
--   possible'; embedding <a>Term</a>s produced by <a>optimizeTerm</a> into
--   larger computations can lead to size blowout if not done carefully.
optimizeTerm :: forall (a :: S -> Type). (forall (s :: S). Term s a) -> forall (s :: S). Term s a

-- | <ul>
--   <li>Closed* terms with no free variables.</li>
--   </ul>
type ClosedTerm (a :: PType) = forall (s :: S). Term s a
type Dig = Digest Blake2b_160
hashTerm :: Config -> ClosedTerm a -> Either Text Dig
hashRawTerm :: RawTerm -> Dig
data RawTerm
RVar :: Word64 -> RawTerm
RLamAbs :: Word64 -> RawTerm -> RawTerm
RApply :: RawTerm -> [RawTerm] -> RawTerm
RForce :: RawTerm -> RawTerm
RDelay :: RawTerm -> RawTerm
RConstant :: Some (ValueOf DefaultUni) -> RawTerm
RBuiltin :: DefaultFun -> RawTerm
RCompiled :: UTerm -> RawTerm
RError :: RawTerm
RHoisted :: HoistedTerm -> RawTerm
RPlaceHolder :: Integer -> RawTerm
RConstr :: Word64 -> [RawTerm] -> RawTerm
RCase :: RawTerm -> [RawTerm] -> RawTerm
data HoistedTerm
HoistedTerm :: Dig -> RawTerm -> HoistedTerm
data TermResult
TermResult :: RawTerm -> [HoistedTerm] -> TermResult
[$sel:getTerm:TermResult] :: TermResult -> RawTerm
[$sel:getDeps:TermResult] :: TermResult -> [HoistedTerm]
data S
SI :: S

-- | Shorthand for Plutarch types.
type PType = S -> Type
pthrow :: HasCallStack => Text -> Term s a

-- | Configuration for Plutarch scripts at compile time. This indicates
--   whether we want to trace, and if so, under what log level and mode.
data Config

-- | Pattern for the config that does no tracing (also the default).
pattern NoTracing :: Config

-- | Pattern for a tracing config, with both its log level and mode.
pattern Tracing :: LogLevel -> TracingMode -> Config

-- | Pattern for matching constant hoist configuration
--   
--   @since WIP
pattern ConstantHoistThreshold :: Integer -> Config

-- | Pattern for matching constant hoist configuration
--   
--   @since WIP
pattern ConstantHoistNever :: Config
newtype InternalConfig
InternalConfig :: Bool -> InternalConfig
[$sel:internalConfig'dataRecPMatchOptimization:InternalConfig] :: InternalConfig -> Bool

-- | How to trace.
data TracingMode
DetTracing :: TracingMode
DoTracing :: TracingMode
DoTracingAndBinds :: TracingMode

-- | What logging level we want to use.
data LogLevel
LogInfo :: LogLevel
LogDebug :: LogLevel

-- | If the config indicates that we want to trace, get its mode.
tracingMode :: Config -> Maybe TracingMode

-- | If the config indicates that we want to trace, get its log level.
logLevel :: Config -> Maybe LogLevel
pgetConfig :: (Config -> Term s a) -> Term s a
pgetInternalConfig :: (InternalConfig -> Term s a) -> Term s a
pwithInternalConfig :: InternalConfig -> Term s a -> Term s a
newtype TermMonad m
TermMonad :: ReaderT (InternalConfig, Config) (Either Text) m -> TermMonad m
[$sel:runTermMonad:TermMonad] :: TermMonad m -> ReaderT (InternalConfig, Config) (Either Text) m

-- | High precedence infixl synonym of <a>papp</a>, to be used like
--   function juxtaposition. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x # y
--   f x y
--   </pre>
(#) :: Term s (a :--> b) -> Term s a -> Term s b
infixl 8 #

-- | Low precedence infixr synonym of <a>papp</a>, to be used like
--   <a>$</a>, in combination with <a>#</a>. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x #$ g # y # z
--   f x (g y z)
--   </pre>
(#$) :: Term s (a :--> b) -> Term s a -> Term s b
infixr 0 #$
instance GHC.Show.Show Plutarch.Internal.Term.HoistedTerm
instance GHC.Show.Show Plutarch.Internal.Term.RawTerm
instance GHC.Show.Show Plutarch.Internal.Term.TracingMode
instance GHC.Classes.Eq Plutarch.Internal.Term.TracingMode
instance GHC.Show.Show Plutarch.Internal.Term.LogLevel
instance GHC.Classes.Eq Plutarch.Internal.Term.LogLevel
instance GHC.Show.Show Plutarch.Internal.Term.Config
instance GHC.Classes.Eq Plutarch.Internal.Term.Config
instance GHC.Classes.Eq Plutarch.Internal.Term.InternalConfig
instance GHC.Show.Show Plutarch.Internal.Term.InternalConfig
instance GHC.Base.Monad Plutarch.Internal.Term.TermMonad
instance GHC.Base.Applicative Plutarch.Internal.Term.TermMonad
instance GHC.Base.Functor Plutarch.Internal.Term.TermMonad
instance GHC.Base.Semigroup Plutarch.Internal.Term.Config
instance GHC.Base.Monoid Plutarch.Internal.Term.Config
instance Prettyprinter.Internal.Pretty Plutarch.Internal.Term.Config
instance Data.Aeson.Types.ToJSON.ToJSON Plutarch.Internal.Term.Config
instance Data.Aeson.Types.FromJSON.FromJSON Plutarch.Internal.Term.Config
instance GHC.Classes.Ord Plutarch.Internal.Term.LogLevel
instance GHC.Base.Semigroup Plutarch.Internal.Term.LogLevel
instance Prettyprinter.Internal.Pretty Plutarch.Internal.Term.LogLevel
instance Data.Aeson.Types.ToJSON.ToJSON Plutarch.Internal.Term.LogLevel
instance Data.Aeson.Types.FromJSON.FromJSON Plutarch.Internal.Term.LogLevel
instance GHC.Classes.Ord Plutarch.Internal.Term.TracingMode
instance GHC.Base.Semigroup Plutarch.Internal.Term.TracingMode
instance Prettyprinter.Internal.Pretty Plutarch.Internal.Term.TracingMode
instance Data.Aeson.Types.ToJSON.ToJSON Plutarch.Internal.Term.TracingMode
instance Data.Aeson.Types.FromJSON.FromJSON Plutarch.Internal.Term.TracingMode

module Plutarch.Reducible

-- | This class provides a work-around for partially applying type families
--   of kind <tt>a</tt>, where <tt>a</tt> is either <a>Type</a> or <tt>b
--   -&gt; c</tt> where <tt>c</tt> satisfies the same constraint.
--   
--   Given a type family <tt>F : A -&gt; Type</tt>, you can make the
--   following <tt> type F' :: A -&gt; Type newtype F' (a :: A) = F'
--   (NoReduce (F a)) deriving stock Generic </tt> It is then true that
--   <tt>forall a. Reduce (F' a) ~ F a</tt>.
type family Reduce (x :: Type) :: Type
newtype NoReduce a
NoReduce :: a -> NoReduce a
reduce :: Coercible a (Reduce a) => a -> Reduce a

module Plutarch.Internal.TypeFamily

-- | Convert a list of `Term s a` to a list of <tt>a</tt>.
type family ToPType as
type family ToPType2 as
type family UnTerm x
type family Snd ab

module Plutarch.Internal.Quantification
newtype PForall (b :: a -> PType) s
PForall :: (forall (x :: a). Term s (b x)) -> PForall (b :: a -> PType) s

module Plutarch.Internal.Generic

-- | <a>Generic</a> constraint extended to work with Plutarch types.
class (forall s. PGeneric' a s) => PGeneric a
class (Generic (a s), GFrom (a s), GTo (a s), All2 Top (PCode a), All2 Top (GCode (a s)), GDatatypeInfo (a s)) => PGeneric' a s

-- | Like <tt>Code</tt> but for Plutarch types
type PCode a = ToPType2 (GCode (a Any))
gpfrom :: forall a s. PGeneric a => a s -> SOP (Term s) (PCode a)
gpto :: forall a s. PGeneric a => SOP (Term s) (PCode a) -> a s
instance forall (a :: Plutarch.Internal.Term.PType). (forall (s :: Plutarch.Internal.Term.S). Plutarch.Internal.Generic.PGeneric' a s) => Plutarch.Internal.Generic.PGeneric a
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). (GHC.Generics.Generic (a s), Generics.SOP.GGP.GFrom (a s), Generics.SOP.GGP.GTo (a s), Data.SOP.Constraint.All2 @{Plutarch.Internal.Term.PType} (Data.SOP.Constraint.Top @{Plutarch.Internal.Term.PType}) (Plutarch.Internal.Generic.PCode a), Data.SOP.Constraint.All2 @{GHC.Types.Type} (Data.SOP.Constraint.Top @{GHC.Types.Type}) (Generics.SOP.GGP.GCode (a s)), Generics.SOP.GGP.GDatatypeInfo (a s)) => Plutarch.Internal.Generic.PGeneric' a s
instance forall a. Generics.SOP.GGP.GTo a => Plutarch.Internal.Generic.GTo' a
instance forall a. Generics.SOP.GGP.GFrom a => Plutarch.Internal.Generic.GFrom' a

module Plutarch.Builtin.Unit
data PUnit (s :: S)
PUnit :: PUnit (s :: S)
punit :: Term s PUnit
instance forall (s :: Plutarch.Internal.Term.S). GHC.Base.Semigroup (Plutarch.Internal.Term.Term s Plutarch.Builtin.Unit.PUnit)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Base.Monoid (Plutarch.Internal.Term.Term s Plutarch.Builtin.Unit.PUnit)

module Plutarch.Builtin.Opaque

-- | An Arbitrary Term with an unknown type
newtype POpaque s
POpaque :: Term s POpaque -> POpaque s

-- | Erase the type of a Term
popaque :: Term s a -> Term s POpaque

module Plutarch.Internal.Fix

-- | Fixpoint recursion. Used to encode recursive functions.
--   
--   Example:
--   
--   <pre>
--   iterateN' ::
--    Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a) -&gt;
--    Term s PInteger -&gt;
--    Term s (a :--&gt; a) -&gt;
--    Term s a
--   iterateN' self n f x =
--     pif (n #== 0) x (self # n - 1 #$ f x)
--   
--   iterateN :: Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a)
--   iterateN = pfix #$ plam iterateN'
--   </pre>
--   
--   Further examples can be found in examples/Recursion.hs
pfix :: Term s (((a :--> b) :--> (a :--> b)) :--> (a :--> b))

module Plutarch.Builtin.Bool

-- | Builtin Plutus boolean.
data PBool (s :: S)
PTrue :: PBool (s :: S)
PFalse :: PBool (s :: S)

pbuiltinIfThenElse :: forall (a :: S -> Type) (s :: S). Term s (PBool :--> (a :--> (a :--> PDelayed a)))

-- | Strict if-then-else. Emits slightly less code than the lazy version.
pif' :: forall (a :: S -> Type) (s :: S). Term s (PBool :--> (a :--> (a :--> a)))

-- | Lazy if-then-else.
pif :: forall (a :: S -> Type) (s :: S). Term s PBool -> Term s a -> Term s a -> Term s a

-- | Boolean negation.
pnot :: forall (s :: S). Term s (PBool :--> PBool)

-- | Lazy AND for terms.
(#&&) :: forall (s :: S). Term s PBool -> Term s PBool -> Term s PBool
infixr 3 #&&

-- | Lazy OR for terms.
(#||) :: forall (s :: S). Term s PBool -> Term s PBool -> Term s PBool
infixr 2 #||

-- | Hoisted lazy OR at the Plutarch level.
por :: forall (s :: S). Term s (PBool :--> (PDelayed PBool :--> PDelayed PBool))

-- | Hoisted lazy AND at the Plutarch level.
pand :: forall (s :: S). Term s (PBool :--> (PDelayed PBool :--> PDelayed PBool))

-- | As <a>pand</a>, but strict.
pand' :: forall (s :: S). Term s (PBool :--> (PBool :--> PBool))

-- | As <a>por</a>, but strict.
por' :: Term s (PBool :--> (PBool :--> PBool))

-- | Essentially multi-way <a>pif</a>. More precisely, given a list of
--   condition-action pairs, and an 'action of last resort', construct a
--   left-to-right 'chain' of <tt>pif</tt>s, using the conditions to
--   determine which action gets taken. The 'action of last resort'
--   finishes the 'chain'. For example:
--   
--   <pre>
--   pcond [(cond1, act1), (cond2, act2)] act3
--   </pre>
--   
--   does the same thing as
--   
--   <pre>
--   pif cond1 act1 (pif cond2 act2 act3)
--   </pre>
pcond :: forall (a :: S -> Type) (s :: S). [(Term s PBool, Term s a)] -> Term s a -> Term s a
ptrue :: Term (s :: S) PBool
pfalse :: Term (s :: S) PBool
instance forall (s :: Plutarch.Internal.Term.S). GHC.Show.Show (Plutarch.Builtin.Bool.PBool s)

module Plutarch.Builtin.Integer

-- | A builtin Plutus integer.
data PInteger s

-- | Performs modulo exponentiation. More precisely, <tt>pexpModInteger b e
--   m</tt> performs <tt>b</tt> to the power of <tt>e</tt>, modulo
--   <tt>m</tt>. The result is always non-negative.
--   
--   <h1>Note</h1>
--   
--   This will error if the modulus is zero. When given a negative
--   exponent, this will try to find a modular multiplicative inverse, and
--   will error if none exists.
pexpModInteger :: forall (s :: S). Term s (PInteger :--> (PInteger :--> (PInteger :--> PInteger)))
peqInteger :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PBool))
pleInteger :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PBool))
pltInteger :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PBool))
paddInteger :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))
psubtractInteger :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))
pmultiplyInteger :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))
pconstantInteger :: forall (s :: S). Integer -> Term s PInteger
pquotientInteger :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))
premainderInteger :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Builtin.Integer.PInteger s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Builtin.Integer.PInteger s)

module Plutarch.Builtin.ByteString

-- | Plutus <tt>BuiltinByteString</tt>
newtype PByteString s
PByteString :: Term s POpaque -> PByteString s

-- | A Plutarch-level representation of bytes.
--   
--   <h1>Note =</h1>
--   
--   This type is intentionally quite restrictive, as it's not really meant
--   to be computed with. Instead, it ensures certain operations' type
--   safety while also allowing more sensible signatures. If you want to do
--   anything with <a>PByte</a>s, we recommend converting them to
--   <a>PInteger</a>s first.
newtype PByte (s :: S)
PByte :: Term s POpaque -> PByte (s :: S)

-- | Type designating whether logical operations should use padding or
--   truncation semantics. See <a>CIP-122</a> for more details on this.
newtype PLogicOpSemantics (s :: S)
PLogicOpSemantics :: Term s PBool -> PLogicOpSemantics (s :: S)

-- | Type designating whether a conversion should be most-significant-first
--   or most-significant-last. See <a>CIP-121</a> for more details on this.
newtype PEndianness (s :: S)
PEndianness :: Term s PBool -> PEndianness (s :: S)

-- | Indicates that padding semantics should be used.
ppadding :: forall (s :: S). Term s PLogicOpSemantics

-- | Indicates that truncation semantics should be used.
ptruncation :: forall (s :: S). Term s PLogicOpSemantics

-- | Indicates the conversion should be most-significant-first.
pmostSignificantFirst :: forall (s :: S). Term s PEndianness

-- | Indicates the conversion should be most-significant-last.
pmostSignificantLast :: forall (s :: S). Term s PEndianness

-- | Perform the logical AND of two <a>PByteString</a>s, as per
--   <a>CIP-122</a>. The <a>PLogicOpSemantics</a> argument specifies what
--   should be done if the lengths of the two <a>PByteString</a> arguments
--   do not match.
pandBS :: forall (s :: S). Term s (PLogicOpSemantics :--> (PByteString :--> (PByteString :--> PByteString)))

-- | Perform the logical OR of two <a>PByteString</a>s, as per
--   <a>CIP-122</a>. The <a>PLogicOpSemantics</a> argument specifies what
--   should be done if the lengths of the two <a>PByteString</a> arguments
--   do not match.
porBS :: forall (s :: S). Term s (PLogicOpSemantics :--> (PByteString :--> (PByteString :--> PByteString)))

-- | Perform the logical XOR of two <a>PByteString</a>s, as per
--   <a>CIP-122</a>. The <a>PLogicOpSemantics</a> argument specifies what
--   should be done if the lengths of the two <a>PByteString</a> arguments
--   do not match.
pxorBS :: forall (s :: S). Term s (PLogicOpSemantics :--> (PByteString :--> (PByteString :--> PByteString)))

-- | Perform the logical complement of a <a>PByteString</a>, as per
--   <a>CIP-122</a>.
pcomplementBS :: forall (s :: S). Term s (PByteString :--> PByteString)

-- | Given a desired length and a <a>PByte</a>, construct a
--   <a>PByteString</a> of the specified length (0 if negative) consisting
--   entirely of that <a>PByte</a>.
preplicateBS :: forall (s :: S). Term s (PInteger :--> (PByte :--> PByteString))

-- | Prepend a <a>PByte</a> to a 'PByteString.
pconsBS :: Term s (PByte :--> (PByteString :--> PByteString))

-- | Convert a <a>PByte</a> into its corresponding <a>PInteger</a>.
pbyteToInteger :: Term s (PByte :--> PInteger)

-- | Try to convert a <a>PInteger</a> into its corresponding <a>PByte</a>.
--   This operation unchecked: use with care.
pintegerToByte :: Term s (PInteger :--> PByte)

-- | Slice a <a>PByteString</a> with given start index and slice length.
--   
--   <pre>
--   &gt;&gt;&gt; (pslice # 2 # 3 phexByteStr "4102afde5b2a") #== phexByteStr "afde5b"
--   </pre>
psliceBS :: Term s (PInteger :--> (PInteger :--> (PByteString :--> PByteString)))

-- | Find the length of a <a>PByteString</a>.
plengthBS :: Term s (PByteString :--> PInteger)

-- | Given a valid index into a <a>PByteString</a>, returns the
--   <a>PByte</a> at that index. Will crash if given an out-of-bounds
--   index.
pindexBS :: Term s (PByteString :--> (PInteger :--> PByte))

-- | Interpret a hex string as a PByteString.
phexByteStr :: HasCallStack => String -> Term s PByteString

-- | Convert a <a>PByteString</a> into a <a>PInteger</a>, as per
--   <a>CIP-121</a>.
pbyteStringToInteger :: forall (s :: S). Term s (PEndianness :--> (PByteString :--> PInteger))

-- | Converts a <a>PInteger</a> into a <a>PByteString</a>, given a desired
--   endianness and target length. For more details, see <a>CIP-121</a>.
--   
--   <h1>Note</h1>
--   
--   This conversion is unsafe. It will fail if any of the following occur:
--   
--   <ol>
--   <li>The size is negative.</li>
--   <li>The size is too large (currently if over 8196 bytes).</li>
--   <li>The size won't fit the integer to convert.</li>
--   </ol>
pintegerToByteString :: forall (s :: S). Term s (PEndianness :--> (PInteger :--> (PInteger :--> PByteString)))
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Builtin.ByteString.PByteString s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Builtin.ByteString.PByteString s)
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Builtin.ByteString.PByte s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Builtin.ByteString.PByte s)
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Builtin.ByteString.PEndianness s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Builtin.ByteString.PEndianness s)
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Builtin.ByteString.PLogicOpSemantics s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Builtin.ByteString.PLogicOpSemantics s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Base.Semigroup (Plutarch.Internal.Term.Term s Plutarch.Builtin.ByteString.PByteString)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Base.Monoid (Plutarch.Internal.Term.Term s Plutarch.Builtin.ByteString.PByteString)

module Plutarch.Builtin.String

-- | Plutus <tt>BuiltinString</tt> values
newtype PString s
PString :: Term s POpaque -> PString s

-- | Decode a <a>PByteString</a> using UTF-8.
pdecodeUtf8 :: Term s (PByteString :--> PString)

-- | Encode a <a>PString</a> using UTF-8.
pencodeUtf8 :: Term s (PString :--> PByteString)
ptrace' :: Term s (PString :--> (a :--> a))

-- | Trace the given message at the info level before evaluating the given
--   argument.
ptraceInfo :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Builtin.String.PString s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Builtin.String.PString s)
instance forall (s :: Plutarch.Internal.Term.S). Data.String.IsString (Plutarch.Internal.Term.Term s Plutarch.Builtin.String.PString)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Base.Semigroup (Plutarch.Internal.Term.Term s Plutarch.Builtin.String.PString)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Base.Monoid (Plutarch.Internal.Term.Term s Plutarch.Builtin.String.PString)

module Plutarch.Internal.Trace

-- | Trace the given message at the info level before evaluating the given
--   argument.
ptraceInfo :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

-- | Trace the given message at the debug level before evaluating the given
--   argument.
ptraceDebug :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a
ptrace' :: Term s (PString :--> (a :--> a))

-- | Backward compatibility synonym for <a>ptraceInfo</a>.

-- | <i>Deprecated: Use ptraceInfo</i>
ptrace :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

module Plutarch.Internal.TermCont
hashOpenTerm :: Term s a -> TermCont s Dig
newtype TermCont :: forall (r :: PType). S -> Type -> Type
[TermCont] :: forall r s a. ((a -> Term s r) -> Term s r) -> TermCont @r s a
($sel:runTermCont:TermCont) :: TermCont @r s a -> (a -> Term s r) -> Term s r
unTermCont :: TermCont @a s (Term s a) -> Term s a
tcont :: ((a -> Term s r) -> Term s r) -> TermCont @r s a

-- | Given a term, and an integer tag, this function checks if the term
--   holds and <tt>PPlaceholder</tt> with the given integer tag.
pfindPlaceholder :: Integer -> Term s a -> TermCont s Bool

-- | Finds all placeholder ids and returns it
pfindAllPlaceholders :: Term s a -> TermCont s [Integer]
instance forall (r :: Plutarch.Internal.Term.PType) (s :: Plutarch.Internal.Term.S). GHC.Base.Functor (Plutarch.Internal.TermCont.TermCont @r s)
instance forall (r :: Plutarch.Internal.Term.PType) (s :: Plutarch.Internal.Term.S). GHC.Base.Applicative (Plutarch.Internal.TermCont.TermCont @r s)
instance forall (r :: Plutarch.Internal.Term.PType) (s :: Plutarch.Internal.Term.S). GHC.Base.Monad (Plutarch.Internal.TermCont.TermCont @r s)
instance forall (r :: Plutarch.Internal.Term.PType) (s :: Plutarch.Internal.Term.S). Control.Monad.Fail.MonadFail (Plutarch.Internal.TermCont.TermCont @r s)

module Plutarch.Internal.PLam
class PLamN (a :: Type) (b :: PType) (s :: S) | a -> b, s b -> a
plam :: forall c. (PLamN a b s, HasCallStack) => (Term s c -> a) -> Term s (c :--> b)
pinl :: Term s a -> (Term s a -> Term s b) -> Term s b
instance forall a' (s :: Plutarch.Internal.Term.S) (a :: Plutarch.Internal.Term.PType). ((a' :: GHC.Types.Type) GHC.Types.~ (Plutarch.Internal.Term.Term s a :: GHC.Types.Type)) => Plutarch.Internal.PLam.PLamN a' a s
instance forall a' (s :: Plutarch.Internal.Term.S) (a :: Plutarch.Internal.Term.PType) b' (b :: Plutarch.Internal.Term.PType). ((a' :: GHC.Types.Type) GHC.Types.~ (Plutarch.Internal.Term.Term s a :: GHC.Types.Type), Plutarch.Internal.PLam.PLamN b' b s) => Plutarch.Internal.PLam.PLamN (a' -> b') (a Plutarch.Internal.Term.:--> b) s

module Plutarch.Builtin.Data
newtype PData (s :: S)
PData :: Term s PData -> PData (s :: S)
newtype PAsData (a :: S -> Type) (s :: S)
PAsData :: Term s a -> PAsData (a :: S -> Type) (s :: S)
pchooseData :: Term s (PData :--> (a :--> (a :--> (a :--> (a :--> (a :--> a))))))
pasConstr :: Term s (PData :--> PBuiltinPair PInteger (PBuiltinList PData))
pasMap :: Term s (PData :--> PBuiltinList (PBuiltinPair PData PData))
plistData :: Term s (PBuiltinList PData :--> PData)
pasList :: Term s (PData :--> PBuiltinList PData)
pasInt :: Term s (PData :--> PInteger)
pasByteStr :: Term s (PData :--> PByteString)

-- | Serialise any builtin data to its cbor represented by a builtin
--   bytestring
pserialiseData :: Term s (PData :--> PByteString)
pconstrBuiltin :: Term s (PInteger :--> (PBuiltinList PData :--> PAsData (PBuiltinPair PInteger (PBuiltinList PData))))
newtype PBuiltinPair (a :: S -> Type) (b :: S -> Type) (s :: S)
PBuiltinPair :: Term s (PBuiltinPair a b) -> PBuiltinPair (a :: S -> Type) (b :: S -> Type) (s :: S)
pfstBuiltin :: Term s (PBuiltinPair a b :--> a)
psndBuiltin :: Term s (PBuiltinPair a b :--> b)

-- | Construct a builtin pair of <a>PData</a> elements.
--   
--   Uses <a>PAsData</a> to preserve more information about the underlying
--   <a>PData</a>.
ppairDataBuiltin :: Term s (PAsData a :--> (PAsData b :--> PBuiltinPair (PAsData a) (PAsData b)))

-- | Plutus <tt>BuiltinList</tt>
data PBuiltinList (a :: S -> Type) (s :: S)
PCons :: Term s a -> Term s (PBuiltinList a) -> PBuiltinList (a :: S -> Type) (s :: S)
PNil :: PBuiltinList (a :: S -> Type) (s :: S)
pheadBuiltin :: Term s (PBuiltinList a :--> a)
ptailBuiltin :: Term s (PBuiltinList a :--> PBuiltinList a)
pchooseListBuiltin :: Term s (PBuiltinList a :--> (b :--> (b :--> b)))
pnullBuiltin :: Term s (PBuiltinList a :--> PBool)
pconsBuiltin :: Term s (a :--> (PBuiltinList a :--> PBuiltinList a))

module Plutarch.Builtin.BLS

-- | A point on the BLS12-381 G1 curve.
newtype PBuiltinBLS12_381_G1_Element s
PBuiltinBLS12_381_G1_Element :: Term s POpaque -> PBuiltinBLS12_381_G1_Element s

newtype PBuiltinBLS12_381_G2_Element s
PBuiltinBLS12_381_G2_Element :: Term s POpaque -> PBuiltinBLS12_381_G2_Element s

-- | Represents the result of a Miller loop operation in BLS12-381 pairing.
newtype PBuiltinBLS12_381_MlResult s
PBuiltinBLS12_381_MlResult :: Term s POpaque -> PBuiltinBLS12_381_MlResult s

-- | Add two points on the BLS12-381 G1 curve.
pbls12_381_G1_add :: Term s (PBuiltinBLS12_381_G1_Element :--> (PBuiltinBLS12_381_G1_Element :--> PBuiltinBLS12_381_G1_Element))

-- | Multiply a point on the BLS12-381 G1 curve by a scalar.
pbls12_381_G1_scalarMul :: Term s (PInteger :--> (PBuiltinBLS12_381_G1_Element :--> PBuiltinBLS12_381_G1_Element))

-- | Negate a point on the BLS12-381 G1 curve.
pbls12_381_G1_neg :: Term s (PBuiltinBLS12_381_G1_Element :--> PBuiltinBLS12_381_G1_Element)

-- | Compress a point on the BLS12-381 G1 curve to a byte string.
pbls12_381_G1_compress :: Term s (PBuiltinBLS12_381_G1_Element :--> PByteString)

-- | Uncompress a byte string to a point on the BLS12-381 G1 curve.
pbls12_381_G1_uncompress :: Term s (PByteString :--> PBuiltinBLS12_381_G1_Element)

-- | Hash a message to a point on the BLS12-381 G1 curve.
pbls12_381_G1_hashToGroup :: Term s (PByteString :--> (PByteString :--> PBuiltinBLS12_381_G1_Element))

-- | The compressed representation of the zero point on the BLS12-381 G1
--   curve.
pbls12_381_G1_compressed_zero :: Term s PByteString

-- | The compressed representation of the generator point on the BLS12-381
--   G1 curve.
pbls12_381_G1_compressed_generator :: Term s PByteString

-- | Add two points on the BLS12-381 G2 curve.
pbls12_381_G2_add :: Term s (PBuiltinBLS12_381_G2_Element :--> (PBuiltinBLS12_381_G2_Element :--> PBuiltinBLS12_381_G2_Element))

-- | Multiply a point on the BLS12-381 G2 curve by a scalar.
pbls12_381_G2_scalarMul :: Term s (PInteger :--> (PBuiltinBLS12_381_G2_Element :--> PBuiltinBLS12_381_G2_Element))

-- | Negate a point on the BLS12-381 G2 curve.
pbls12_381_G2_neg :: Term s (PBuiltinBLS12_381_G2_Element :--> PBuiltinBLS12_381_G2_Element)

-- | Compress a point on the BLS12-381 G2 curve to a byte string.
pbls12_381_G2_compress :: Term s (PBuiltinBLS12_381_G2_Element :--> PByteString)

-- | Uncompress a byte string to a point on the BLS12-381 G2 curve.
pbls12_381_G2_uncompress :: Term s (PByteString :--> PBuiltinBLS12_381_G2_Element)

-- | Hash a message to a point on the BLS12-381 G2 curve.
pbls12_381_G2_hashToGroup :: Term s (PByteString :--> (PByteString :--> PBuiltinBLS12_381_G2_Element))

-- | The compressed representation of the zero point on the BLS12-381 G2
--   curve.
pbls12_381_G2_compressed_zero :: Term s PByteString

-- | The compressed representation of the generator point on the BLS12-381
--   G2 curve.
pbls12_381_G2_compressed_generator :: Term s PByteString

-- | Perform a Miller loop operation on a G1 and G2 element.
pbls12_381_millerLoop :: Term s (PBuiltinBLS12_381_G1_Element :--> (PBuiltinBLS12_381_G2_Element :--> PBuiltinBLS12_381_MlResult))

-- | Multiply two Miller loop results.
pbls12_381_mulMlResult :: Term s (PBuiltinBLS12_381_MlResult :--> (PBuiltinBLS12_381_MlResult :--> PBuiltinBLS12_381_MlResult))

-- | Perform the final verification step in BLS12-381 pairing.
pbls12_381_finalVerify :: Term s (PBuiltinBLS12_381_MlResult :--> (PBuiltinBLS12_381_MlResult :--> PBool))
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Builtin.BLS.PBuiltinBLS12_381_G1_Element s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Builtin.BLS.PBuiltinBLS12_381_G1_Element s)
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Builtin.BLS.PBuiltinBLS12_381_G2_Element s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Builtin.BLS.PBuiltinBLS12_381_G2_Element s)
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Builtin.BLS.PBuiltinBLS12_381_MlResult s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Builtin.BLS.PBuiltinBLS12_381_MlResult s)

module Plutarch.Internal.PlutusType
class PlutusType (a :: PType)
type PInnermost a = PInnermost' (PInner a) a

-- | <i>Deprecated: Use PlutusType</i>
type PCon = PlutusType

-- | <i>Deprecated: Use PlutusType</i>
type PMatch = PlutusType
pcon' :: forall s. PlutusType a => a s -> Term s (PInner a)
pmatch' :: forall s b. PlutusType a => Term s (PInner a) -> (a s -> Term s b) -> Term s b

-- | Pattern match over Plutarch Terms via a Haskell datatype
pmatch :: PlutusType a => Term s a -> (a s -> Term s b) -> Term s b

-- | Construct a Plutarch Term via a Haskell datatype
pcon :: PlutusType a => a s -> Term s a
type PInner a :: PType
class (forall t. PVariant'' t => PVariant'' (a t)) => PVariant a
class (forall t. PCovariant'' t => PCovariant'' (a t)) => PCovariant a
class (forall t. PCovariant'' t => PContravariant'' (a t)) => PContravariant a
type PVariant' a :: Constraint
type PCovariant' a :: Constraint
type PContravariant' a :: Constraint
class PVariant' a => PVariant'' a
class PCovariant' a => PCovariant'' a
class PContravariant' a => PContravariant'' a

newtype DeriveNewtypePlutusType (a :: S -> Type) s
DeriveNewtypePlutusType :: a s -> DeriveNewtypePlutusType (a :: S -> Type) s

[$sel:unDeriveNewtypePlutusType:DeriveNewtypePlutusType] :: DeriveNewtypePlutusType (a :: S -> Type) s -> a s

-- | This is a cursed derivation strategy that will give you
--   <tt>PlutusType</tt> with no questions asked. This is occasionally
--   helpful for deriving <tt>PlutusType</tt> for another derivation
--   strategy wrapper whose target instance requires <tt>PlutusType</tt> as
--   superclass.
--   
--   See <tt>PLiftable</tt>
newtype DeriveFakePlutusType (a :: S -> Type) (s :: S)
DeriveFakePlutusType :: a s -> DeriveFakePlutusType (a :: S -> Type) (s :: S)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.ByteString.PByteString
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.ByteString.PByte
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.ByteString.PLogicOpSemantics
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.String.PString
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.BLS.PBuiltinBLS12_381_G1_Element
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.BLS.PBuiltinBLS12_381_G2_Element
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.BLS.PBuiltinBLS12_381_MlResult
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.ByteString.PEndianness
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.PlutusType.DeriveFakePlutusType a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S) (pt :: Plutarch.Internal.Term.PType). (Generics.SOP.Universe.Generic (a s), (Generics.SOP.Universe.Code (a s) :: [[GHC.Types.Type]]) GHC.Types.~ ((':) @[GHC.Types.Type] ((':) @GHC.Types.Type (Plutarch.Internal.Term.Term s pt) ('[] @GHC.Types.Type)) ('[] @[GHC.Types.Type]) :: [[GHC.Types.Type]])) => Plutarch.Internal.PlutusType.H s a pt
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (pt :: Plutarch.Internal.Term.S -> GHC.Types.Type). ((pt :: (Plutarch.Internal.Term.S -> GHC.Types.Type)) GHC.Types.~ (Plutarch.Internal.PlutusType.UnTermSingle (Data.SOP.Constraint.Head @GHC.Types.Type (Data.SOP.Constraint.Head @[GHC.Types.Type] (Generics.SOP.Universe.Code (a (GHC.Types.Any @Plutarch.Internal.Term.S))))) :: (Plutarch.Internal.Term.S -> GHC.Types.Type)), forall (s :: Plutarch.Internal.Term.S). Plutarch.Internal.PlutusType.H s a pt) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.PlutusType.DeriveNewtypePlutusType a)
instance forall (a :: Plutarch.Internal.Term.PType). (Plutarch.Internal.Generic.PGeneric a, (Plutarch.Internal.Generic.PCode a :: [[Plutarch.Internal.Term.PType]]) GHC.Types.~ ((':) @[Plutarch.Internal.Term.PType] ((':) @Plutarch.Internal.Term.PType (Plutarch.Internal.PlutusType.GetPNewtype a) ('[] @Plutarch.Internal.Term.PType)) ('[] @[Plutarch.Internal.Term.PType]) :: [[Plutarch.Internal.Term.PType]])) => Plutarch.Internal.PlutusType.Helper a
instance forall (a :: Plutarch.Internal.Term.PType -> Plutarch.Internal.Term.PType). (forall (t :: Plutarch.Internal.Term.PType). Plutarch.Internal.PlutusType.PVariant'' t => Plutarch.Internal.PlutusType.PVariant'' (a t)) => Plutarch.Internal.PlutusType.PVariant a
instance forall (a :: Plutarch.Internal.Term.PType -> Plutarch.Internal.Term.PType). (forall (t :: Plutarch.Internal.Term.PType). Plutarch.Internal.PlutusType.PCovariant'' t => Plutarch.Internal.PlutusType.PContravariant'' (a t)) => Plutarch.Internal.PlutusType.PContravariant a
instance forall (a :: Plutarch.Internal.Term.PType -> Plutarch.Internal.Term.PType). (forall (t :: Plutarch.Internal.Term.PType). Plutarch.Internal.PlutusType.PCovariant'' t => Plutarch.Internal.PlutusType.PCovariant'' (a t)) => Plutarch.Internal.PlutusType.PCovariant a
instance forall (a :: Plutarch.Internal.Term.PType). Plutarch.Internal.PlutusType.PCovariant' a => Plutarch.Internal.PlutusType.PCovariant'' a
instance forall (a :: Plutarch.Internal.Term.PType). Plutarch.Internal.PlutusType.PContravariant' a => Plutarch.Internal.PlutusType.PContravariant'' a
instance forall (a :: Plutarch.Internal.Term.PType). Plutarch.Internal.PlutusType.PVariant' a => Plutarch.Internal.PlutusType.PVariant'' a
instance forall (a :: Plutarch.Internal.Term.PType) (b :: Plutarch.Internal.Term.PType). Plutarch.Internal.PlutusType.PlutusType (a Plutarch.Internal.Term.:--> b)
instance forall a (f :: a -> Plutarch.Internal.Term.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Quantification.PForall @a f)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.Opaque.POpaque
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.Bool.PBool
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.Data.PData
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.Data.PBuiltinPair a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Universe.Core.Contains @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni (Plutarch.Internal.Lift.PlutusRepr a) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.Data.PBuiltinList a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.IsData.PIsData a => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.Data.PAsData a)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.Unit.PUnit

module Plutarch.Repr.Newtype

newtype DeriveNewtypePlutusType (a :: S -> Type) s
DeriveNewtypePlutusType :: a s -> DeriveNewtypePlutusType (a :: S -> Type) s

[$sel:unDeriveNewtypePlutusType:DeriveNewtypePlutusType] :: DeriveNewtypePlutusType (a :: S -> Type) s -> a s
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S) (pt :: Plutarch.Internal.Term.PType). (Generics.SOP.Universe.Generic (a s), (Generics.SOP.Universe.Code (a s) :: [[GHC.Types.Type]]) GHC.Types.~ ((':) @[GHC.Types.Type] ((':) @GHC.Types.Type (Plutarch.Internal.Term.Term s pt) ('[] @GHC.Types.Type)) ('[] @[GHC.Types.Type]) :: [[GHC.Types.Type]])) => Plutarch.Repr.Newtype.H s a pt
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (pt :: Plutarch.Internal.Term.S -> GHC.Types.Type). ((pt :: (Plutarch.Internal.Term.S -> GHC.Types.Type)) GHC.Types.~ (Plutarch.Repr.Newtype.UnTermSingle (Data.SOP.Constraint.Head @GHC.Types.Type (Data.SOP.Constraint.Head @[GHC.Types.Type] (Generics.SOP.Universe.Code (a (GHC.Types.Any @Plutarch.Internal.Term.S))))) :: (Plutarch.Internal.Term.S -> GHC.Types.Type)), forall (s :: Plutarch.Internal.Term.S). Plutarch.Repr.Newtype.H s a pt) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Newtype.DeriveNewtypePlutusType a)

module Plutarch.Internal.Subtype
data PSubtypeRelation
PSubtypeRelation :: PSubtypeRelation
PNoSubtypeRelation :: PSubtypeRelation
type family PSubtype (a :: PType) (b :: PType) :: Constraint
type family PSubtype' (a :: PType) (b :: PType) :: PSubtypeRelation
pupcast :: forall a b s. PSubtype a b => Term s b -> Term s a
pupcastF :: forall a b (p :: PType -> PType) s. (PSubtype a b, PCovariant p) => Proxy p -> Term s (p b) -> Term s (p a)
pdowncastF :: forall a b (p :: PType -> PType) s. (PSubtype a b, PContravariant p) => Proxy p -> Term s (p a) -> Term s (p b)

module Plutarch.Internal.Other

-- | Prettyprint a Term via the PLC pretty printer
--   
--   TODO: Heavily improve. It's unreadable right now.
--   
--   We could convert the de Bruijn indices into names with:
--   
--   <pre>
--   show . prettyPlcReadableDef . (\(Right p) -&gt; p) . Scripts.mkTermToEvaluate . compile $ term
--   </pre>
printTerm :: HasCallStack => Config -> ClosedTerm a -> String

-- | Prettyprint a compiled Script via the PLC pretty printer
printScript :: Script -> String

-- | Safely coerce from a Term to it's <a>PInner</a> representation.
pto :: Term s a -> Term s (PInner a)

module Plutarch.Internal.ListLike

-- | 'PIsListLike list a' constraints <tt>list</tt> be a <a>PListLike</a>
--   with valid element type, <tt>a</tt>.
type PIsListLike list a = (PListLike list, PElemConstraint list a)

-- | Plutarch types that behave like lists.
class PListLike (list :: (S -> Type) -> S -> Type)
type PElemConstraint list (a :: S -> Type) :: Constraint

-- | Canonical eliminator for list-likes.
pelimList :: (PListLike list, PElemConstraint list a) => (Term s a -> Term s (list a) -> Term s r) -> Term s r -> Term s (list a) -> Term s r

-- | Cons an element onto an existing list.
pcons :: (PListLike list, PElemConstraint list a) => Term s (a :--> (list a :--> list a))

-- | The empty list
pnil :: (PListLike list, PElemConstraint list a) => Term s (list a)

-- | Return the first element of a list. Partial, throws an error upon
--   encountering an empty list.
phead :: (PListLike list, PElemConstraint list a) => Term s (list a :--> a)

-- | Take the tail of a list, meaning drop its head. Partial, throws an
--   error upon encountering an empty list.
ptail :: (PListLike list, PElemConstraint list a) => Term s (list a :--> list a)

-- | <i> O(1) </i>. Check if a list is empty
pnull :: (PListLike list, PElemConstraint list a) => Term s (list a :--> PBool)

-- | <i> O(n) </i>. Convert from any ListLike to any ListLike, provided
--   both lists' element constraints are met.
pconvertLists :: forall f g a s. (PIsListLike f a, PIsListLike g a) => Term s (f a :--> g a)

-- | Like <a>pelimList</a>, but with a fixpoint recursion hatch.
precList :: PIsListLike list a => (Term s (list a :--> r) -> Term s a -> Term s (list a) -> Term s r) -> (Term s (list a :--> r) -> Term s r) -> Term s (list a :--> r)

-- | <i> O(1) </i>. Create a singleton list from an element
psingleton :: PIsListLike list a => Term s (a :--> list a)

-- | <i> O(n) </i>. Count the number of elements in the list
plength :: PIsListLike list a => Term s (list a :--> PInteger)

-- | Index a BuiltinList, throwing an error if the index is out of bounds.
ptryIndex :: PIsListLike list a => Natural -> Term s (list a) -> Term s a

-- | Drop the first n fields of a List.
--   
--   The term will be statically generated as repeated applications of
--   <a>ptail</a>, which will be more efficient in many circumstances.
pdrop :: PIsListLike list a => Natural -> Term s (list a) -> Term s (list a)

-- | The same as <a>pfoldl</a>, but with Haskell-level reduction function.
pfoldl' :: PIsListLike list a => (forall s. Term s b -> Term s a -> Term s b) -> Term s (b :--> (list a :--> b))

-- | <i> O(n) </i>. Fold on a list left-associatively.
pfoldl :: PIsListLike list a => Term s ((b :--> (a :--> b)) :--> (b :--> (list a :--> b)))

-- | The same as <a>pfoldr'</a>, but with Haskell-level reduction function.
pfoldr' :: PIsListLike list a => (forall s. Term s a -> Term s b -> Term s b) -> Term s (b :--> (list a :--> b))

-- | <i> O(n) </i>. Fold on a list right-associatively.
pfoldr :: PIsListLike list a => Term s ((a :--> (b :--> b)) :--> (b :--> (list a :--> b)))

-- | <i> O(n) </i>. Fold on a list right-associatively, with opportunity
--   for short circuting.
--   
--   May short circuit when given reducer function is lazy in its second
--   argument.
pfoldrLazy :: PIsListLike list a => Term s ((a :--> (PDelayed b :--> b)) :--> (b :--> (list a :--> b)))

-- | <i> O(n) </i>. Check that predicate holds for all elements in a list.
pall :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> PBool))

-- | <i> O(n) </i>. Check that predicate holds for any element in a list.
pany :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> PBool))

-- | <i> O(n) </i>. Map a function over a list of elements
pmap :: (PListLike list, PElemConstraint list a, PElemConstraint list b) => Term s ((a :--> b) :--> (list a :--> list b))

-- | <i> O(n) </i>. Filter elements from a list that don't match the
--   predicate.
pfilter :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> list a))

-- | <i> O(n) </i>. Concatenate two lists
--   
--   Example: &gt; pconcat # psingleton x # psingleton y == plistLiteral
--   [x, y]
--   
--   pconcat exhibits identities with empty lists such that &gt; forall x.
--   pconcat # pnil # x == x &gt; forall x. pconcat # x # pnil == x
pconcat :: PIsListLike list a => Term s (list a :--> (list a :--> list a))

-- | <i> O(min(n, m)) </i>. Zip two lists together with a passed function.
--   
--   If the lists are of differing lengths, cut to the shortest.
pzipWith :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list c) => Term s ((a :--> (b :--> c)) :--> (list a :--> (list b :--> list c)))

-- | Like <a>pzipWith</a> but with Haskell-level merge function.
pzipWith' :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list c) => (Term s a -> Term s b -> Term s c) -> Term s (list a :--> (list b :--> list c))
instance Plutarch.Internal.ListLike.PListLike Plutarch.Builtin.Data.PBuiltinList

module Plutarch.Evaluate

-- | Evaluate a script with a big budget, returning the trace log and term
--   result.
evalScript :: Script -> (Either EvalError Script, ExBudget, [Text])

-- | Evaluate a script with a huge budget, returning the trace log and term
--   result.
evalScriptHuge :: Script -> (Either EvalError Script, ExBudget, [Text])

-- | Evaluate a script with a specific budget, returning the trace log and
--   term result.
evalScript' :: ExBudget -> Script -> (Either (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun) Script, ExBudget, [Text])

-- | Evaluate a script without budget limit
evalScriptUnlimited :: Script -> (Either (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun) Script, ExBudget, [Text])
type EvalError = (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun)

-- | Compile and evaluate term.
evalTerm :: Config -> ClosedTerm a -> Either Text (Either EvalError (ClosedTerm a), ExBudget, [Text])

-- | Same as <a>evalTerm</a> but without error handling
evalTerm' :: Config -> ClosedTerm a -> ClosedTerm a

-- | Compile and evaluate a ClosedTerm Useful for pre-evaluating terms so
--   that they can be used as constants in an onchain script. Consider the
--   following:
--   _________________________________________________________________________
--   term :: Term _ PInteger term = unsafeEvalTerm NoTracing foo
--   
--   foo :: Term s PInteger foo = (pconstant 1 #+ pconstant 5) #* pconstant
--   3
--   
--   bar :: Term s (PInteger :--&gt; PInteger) bar = plam x -&gt; x + foo
--   
--   bar2 :: Term s (PInteger :--&gt; PInteger) bar2 = plam x -&gt; x +
--   term
--   
--   PI.compile PI.NoTracing bar Right (Script {unScript = Program
--   {_progAnn = (), _progVer = Version {_versionMajor = 1, _versionMinor =
--   0, _versionPatch = 0}, _progTerm = LamAbs () (DeBruijn {dbnIndex = 0})
--   (Apply () (Apply () (Builtin () AddInteger) (Var () (DeBruijn
--   {dbnIndex = 1}))) (Apply () (Apply () (Builtin () MultiplyInteger)
--   (Apply () (Apply () (Builtin () AddInteger) (Constant () (Some
--   (ValueOf DefaultUniInteger 1)))) (Constant () (Some (ValueOf
--   DefaultUniInteger 5))))) (Constant () (Some (ValueOf DefaultUniInteger
--   3)))))}}) PI.compile PI.NoTracing bar2 Right (Script {unScript =
--   Program {_progAnn = (), _progVer = Version {_versionMajor = 1,
--   _versionMinor = 0, _versionPatch = 0}, _progTerm = LamAbs () (DeBruijn
--   {dbnIndex = 0}) (Apply () (Apply () (Builtin () AddInteger) (Var ()
--   (DeBruijn {dbnIndex = 1}))) (Constant () (Some (ValueOf
--   DefaultUniInteger 18))))}})
--   _________________________________________________________________________
--   
--   In bar, foo is an unevaluated term and thus must be evaluated. In
--   bar2, foo has been pre-evaluated with <a>unsafeEvalTerm</a> and thus
--   appears as a constant.
--   
--   Error if the compilation or evaluation fails.
unsafeEvalTerm :: Config -> ClosedTerm a -> ClosedTerm a

-- | Given a compiled <a>Script</a> representing a function that takes
--   arguments, and a list of those <a>Data</a>-encoded arguments, produce
--   a new script with those arguments applied.
applyArguments :: Script -> [Data] -> Script

module Plutarch.Pretty

-- | Prettify a Plutarch term.
--   
--   This will call <a>error</a> if there's a compilation failure. Use
--   <a>prettyTerm'</a> for a non-partial version.
--   
--   <h2>Example ==</h2>
--   
--   <pre>
--   import Plutarch.Prelude
--   import Plutarch.Api.V1
--   
--   checkSignatory :: Term s (PPubKeyHash :--&gt; PScriptContext :--&gt; PUnit)
--   checkSignatory = plam $ ph ctx' -&gt; unTermCont $ do
--     ctx &lt;- pletFieldsC <tt>["txInfo", "purpose"] ctx'
--     purph &lt;- pmatchC ctx.purpose
--     pure $ case purph of
--       PSpending _ -&gt;
--         let signatories = pfield </tt>"signatories" # ctx.txInfo
--         in pif
--             (pelem # pdata ph # pfromData signatories)
--             -- Success!
--             (pconstant ())
--             -- Signature not present.
--             perror
--       _ -&gt; ptraceError "checkSignatoryCont: not a spending tx"
--   </pre>
--   
--   Prettification result:
--   
--   <pre>
--   let frSndPair = !!sndPair
--       unDataSum = (xF -&gt; frSndPair (unConstrData xF))
--       frTailList = !tailList
--       frHeadList = !headList
--       frIfThenElse = !ifThenElse
--   in (oP4ECBT qsrxlF0Y7 -&gt;
--         let cjlB6yrGk = unDataSum qsrxlF0Y7
--             cRFO = unConstrData (frHeadList (frTailList cjlB6yrGk))
--             cs9iR = !!fstPair cRFO
--             w4 = frSndPair cRFO
--         in if equalsInteger 1 cs9iR
--              then if (vModHwqYB -&gt;
--                         let blM6d67 =
--                               (x5sad ePDSInSEC -&gt;
--                                  !(!!chooseList
--                                      ePDSInSEC
--                                      ~False
--                                      ~(if equalsData
--                                             (frHeadList ePDSInSEC)
--                                             vModHwqYB
--                                          then True
--                                          else x5sad (frTailList ePDSInSEC))))
--                             mC = (jfZs -&gt; blM6d67 (itzT -&gt; jfZs jfZs itzT))
--                         in blM6d67 (ispwp_oeT -&gt; mC mC ispwp_oeT))
--                        (bData oP4ECBT)
--                        (unListData
--                           let q6X3 = frHeadList cjlB6yrGk
--                           in frHeadList
--                                let olbZ = unDataSum q6X3
--                                in frTailList
--                                     (frTailList
--                                        (frTailList
--                                           (frTailList
--                                              (frTailList
--                                                 (frTailList
--                                                    (frTailList olbZ)))))))
--                     then ()
--                     else ERROR
--              else !(!trace "checkSignatoryCont: not a spending tx" ~ERROR))
--   </pre>
--   
--   <h2>Semantics ==</h2>
--   
--   <h3>Constants ===</h3>
--   
--   <ul>
--   <li>Builtin integers are printed as regular integers. [0-9]+</li>
--   <li>Builtin bytestrings are printed in hex notation, prefixed by `0x`.
--   0x[0-9a-f]+/i</li>
--   <li>Builtin strings are printed as is.</li>
--   <li>Builtin unit is printed as the unit literal. ()</li>
--   <li>Builtin booleans are printed as the literal <a>True</a> or
--   <a>False</a>.</li>
--   <li>Builtin lists are prettified as list literals, i.e delimited with
--   `[` and `]`.</li>
--   <li>Builtin pairs are prettified as 2-ary tuple literals, e.g. `(a,
--   b)`.</li>
--   <li><tt>I</tt> data (i.e data encoded integers) are prettified like
--   builtin integers with a <tt>#</tt> prefix. #[0-9]+</li>
--   <li><tt>B</tt> data (i.e data encoded bytestrings) are prettified like
--   builtin bytestrings with a <tt>#</tt> prefix. #0x[0-9a-f]+/i</li>
--   <li><tt>List</tt> data (i.e data encoded lists) are prettified like
--   builtin lists with a <tt>#</tt> prefix.</li>
--   <li><tt>Map</tt> data is printed like record literals. Delimited by
--   `{` and `}`.</li>
--   </ul>
--   
--   Each key value pair is prettified like <a>key</a> = <a>value</a> and
--   multiple pairs are joined with `,`.
--   
--   For example, `Map [(I 42, I 0), (I 100, I 1)]` is prettified as `{ #42
--   = #0, #100 = #1 }` - Constr data has two core elements in its
--   prettified form:
--   
--   <ul>
--   <li>The constructor index, prettified as an integer prefixed with
--   <tt></tt> (sigma).</li>
--   <li>Its fields, prettified as a list.</li>
--   </ul>
--   
--   These two elements are then joined with a <a>.</a> (period).
--   
--   For example, `Constr 1 [I 42]` is prettified as "1.[#42]".
--   
--   <h3>Builtin functions ===</h3>
--   
--   Builtin functions are prettified into their name, in title case.
--   
--   <h3>Forced term ===</h3>
--   
--   Forced terms are prefixed with a <tt>!</tt>. The unary operator
--   <tt>!</tt> has higher fixity than function application.
--   
--   <h3>Delayed term ===</h3>
--   
--   Delayed terms are prefixed with a <a>~</a>. The unary operator
--   <a>~</a> has higher fixity than function application.
--   
--   <h3>Var ===</h3>
--   
--   Random names are generated for all variable bindings, and these names
--   are used to refer to them.
--   
--   Names are always unique, between 1 and 8 characters in length, and
--   begin with a lowercase letter.
--   
--   Names may consist of alphanumeric characters, underscore, or single
--   quotes.
--   
--   <h3>LamAbs ===</h3>
--   
--   Lambdas are prettified similar to haskell lambdas, i.e `x -&gt; ...`.
--   
--   Lambdas with multiple arguments are detected and simplified: `x y z
--   -&gt; ...`.
--   
--   <h3>Apply ===</h3>
--   
--   Application is, simply, a space - just like haskell. `f x`.
--   
--   Multi arg applications to the same function are detected and
--   simplified: `f x y`.
--   
--   <h3>Error term ===</h3>
--   
--   <tt>perror</tt> is represented by the literal <tt>ERROR</tt>.
--   
--   <h3>Special handling ===</h3>
--   
--   To achieve better prettification, certain AST structures are given
--   special handling logic.
--   
--   <ul>
--   <li>The AST structure produced by <tt>plet</tt> (Single <a>Apply</a> +
--   <a>LamAbs</a> pair) is prettified into Haskell-like let bindings.</li>
--   <li>Lazy if<i>then</i>else (<tt>pif</tt> in particular, not
--   <tt>pif'</tt>) is detected and prettified into Haskell-like syntax:
--   `if cond then expr1 else expr2`.</li>
--   </ul>
--   
--   Chains of if<i>then</i>else are nested:
--   
--   <pre>
--   if cond
--     then expr1
--     else if cond
--       then expr2
--       else expr3
--   
--   </pre>
--   
--   <ul>
--   <li>When generating names for bindings, well known structures are
--   identified and given special names.</li>
--   </ul>
--   
--   This machinery is made to be extensible in the future.
--   
--   For example, the structure of the <tt>pfix</tt> function is well known
--   and constant - so it is simply called <tt>fix</tt> in the output.
--   
--   Bindings to forced builtin functions inherit the builtin function
--   name, prefixed with a <tt>fr</tt>.
prettyTerm :: Config -> ClosedTerm a -> Doc ()

-- | Same as <a>prettyTerm</a> but also includes the execution budget and
--   script size
prettyTermAndCost :: forall a. Config -> ClosedTerm a -> Doc ()

-- | Non-partial <a>prettyTerm</a>.
prettyTerm' :: Config -> ClosedTerm p -> Either Text (Doc ())

-- | <a>prettyTerm</a> for pre-compiled <a>Script</a>s.
prettyScript :: Script -> Doc ()


-- | Unrolling a recursive function involves explicitly laying out some or
--   all of the recursive steps, rather than relying on recursion via a
--   fixed-point combinator. In UPLC, the typical <a>pfix</a>
--   implementation uses a Y-combinator under the hood. Each recursive step
--   incurs additional evaluation costs (CPU and memory) due to the
--   execution of the Y-combinator. By eliminating these costs in each
--   recursive step, unrolled functions reduce execution overhead. However,
--   since each recursive step is explicitly laid out, unrolled functions
--   consume more script size.
--   
--   There are various unrolling strategies available. It is important to
--   carefully study the implications of each strategy, as they may impose
--   different requirements, such as hard limit on recursion depth.
--   
--   Generally for all strategies, calling the "recursion step"--that is
--   <tt>r</tt> in <tt>fix $ r a b ... -&gt; ...</tt>--multiple times will
--   result in exponential increase of the script size in each step of
--   unrolling. This is because everytime the recursion step is called, it
--   generates UPLC code for that specific branch(and all the subsequent
--   branches down the unrolling!). To prevent this, it is possible to have
--   <tt>plet r $ r' -&gt; <a>can be used multiple times..</a></tt>.
--   
--   Also, due to some of the other optimization performed; specifically
--   <tt>pmatch</tt>'s branch detection which requires hashing terms of all
--   subsequent deconstruction branches, only tail-call recursion would
--   perform fast enough to be used for large unrolling.
module Plutarch.Unroll

-- | This is simplified version of <tt>punrollBound'</tt> without doing
--   additional recursion on Haskell level value.
punrollBound :: forall a b s. Integer -> Term s (a :--> b) -> (Term s (a :--> b) -> Term s (a :--> b)) -> Term s (a :--> b)

-- | The first argument specifies the unrolling depth. The second argument
--   defines the fallback behavior when the recursion depth exceeds the
--   provided unrolling depth.
--   
--   The fixed-point implementation provided requires a Haskell-level value
--   <tt>c</tt> and a Plutarch function of type `Term s (a :--&gt; b)`. The
--   functional for the recursion is passed as a Haskell function. The
--   inclusion of the additional, arbitrary Haskell value (typed
--   <tt>c</tt>) enables further optimization by allowing pre-computation
--   of constant values that depend only on the recursion depth.
--   
--   This function will be used in a very niche situations. Using
--   Haskell-level value for constant replacement is only practical on a
--   single branch recursion with constant value that needs to be added on
--   each step. <tt>plength</tt> is one of the niche use case.
punrollBound' :: forall a b c s. Integer -> (c -> Term s (a :--> b)) -> ((c -> Term s (a :--> b)) -> c -> Term s (a :--> b)) -> c -> Term s (a :--> b)

-- | Unroll given amount of steps, and for rest, uses <a>pfix</a> to
--   support unbound recursion.
punrollUnbound :: forall a b s. Integer -> (Term s (a :--> b) -> Term s (a :--> b)) -> Term s (a :--> b)

-- | Uses <a>pfix</a> to recurse unrolled function itself. Unlike
--   <tt>punrollUnbound</tt>, this function uses unrolled instructions
--   within <a>pfix</a> recursions.
--   
--   This should perform better than <tt>punrollUnbound</tt> when a
--   function requires a large recursion depth.
punrollUnboundWhole :: forall a b s. Integer -> (Term s (a :--> b) -> Term s (a :--> b)) -> Term s (a :--> b)

module Plutarch.Unsafe
punsafeBuiltin :: DefaultFun -> Term s a

-- | Unsafely coerce the type-tag of a Term.
--   
--   This should mostly be avoided, though it can be safely used to assert
--   known types of Datums, Redeemers or ScriptContext.
punsafeCoerce :: forall b a s. Term s a -> Term s b

-- | <i>Deprecated: Use <tt>pconstant</tt> instead.</i>
punsafeConstant :: Some (ValueOf DefaultUni) -> Term s a

-- | Unsafely coerce from the <a>PInner</a> representation of a Term,
--   assuming that the value is a safe construction of the Term.
punsafeDowncast :: Term s (PInner a) -> Term s a

module Plutarch.Internal.Lift

-- | Indicates that the given Plutarch type has an equivalent in Haskell
--   (and Plutus by extension), and we have the ability to move between
--   them.
--   
--   <h1>Important note</h1>
--   
--   Calling methods of <a>PLiftable</a> directly should rarely, if ever,
--   be a thing you do, unless defining your own instances without
--   <tt>via</tt>-deriving helpers (below). Prefer using <a>pconstant</a>
--   and <a>plift</a>, as these handle some of the oddities required
--   without you having to think about them.
--   
--   You should rarely, if ever, need to define <a>PLiftable</a> instances
--   by hand. Whenever possible, prefer using
--   <a>DeriveBuiltinPLiftable</a>, <a>DeriveDataPLiftable</a>, and
--   <a>DeriveNewtypePLiftable</a> as they have fewer complexities and
--   caveats. See their documentation for when to use them.
--   
--   If you do want to define the methods yourself, there's a few key
--   factors to keep in mind:
--   
--   <ol>
--   <li>You still shouldn't write every method by hand, there are helpers
--   <tt>plutToReprUni</tt> and <tt>reprToPlutUni</tt> to cover common
--   cases.</li>
--   <li>If defining <a>plutToRepr</a> and <a>reprToPlut</a> for Scott
--   encoded types you need to set <tt><a>PlutusRepr</a> PMyType =
--   <a>PLiftedClosed</a> PMyType</tt></li>
--   <li>When choosing a type for <a>AsHaskell</a>, <i>any</i> value of
--   that type <i>must</i> be representable in Plutarch. If you have
--   internal invariants to maintain on the Haskell side, make sure you do
--   so with great care.</li>
--   </ol>
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt><a>reprToHask</a> <a>.</a> <a>haskToRepr</a></tt> <tt>=</tt>
--   <tt><a>Right</a></tt></li>
--   <li><tt><a>plutToRepr</a> <a>.</a> <a>reprToPlut</a></tt> <tt>=</tt>
--   <tt><a>Right</a></tt></li>
--   </ol>
--   
--   Any derivations via <a>DeriveBuiltinPLiftable</a>,
--   <a>DeriveDataPLiftable</a>, and <a>DeriveNewtypePLiftable</a>
--   automatically follow these laws.
--   
--   Together, these imply <tt>plift . pconstant = id</tt>.
class PlutusType a => PLiftable (a :: S -> Type) where {
    type AsHaskell a :: Type;
    type PlutusRepr a :: Type;
}

-- | Transform <tt>a</tt>'s Haskell equivalent to its Plutus universe
--   representation.
haskToRepr :: PLiftable a => AsHaskell a -> PlutusRepr a

-- | Given <tt>a</tt>'s Plutus universe representation, turn it back into
--   its (true) Haskell equivalent if possible.
reprToHask :: PLiftable a => PlutusRepr a -> Either LiftError (AsHaskell a)

-- | Given <tt>a</tt>'s Plutus universe representation, lift it into
--   Plutarch.
reprToPlut :: forall (s :: S). PLiftable a => PlutusRepr a -> PLifted s a

-- | Given a closed Plutarch term, evaluate it back into its Plutus
--   universe representation, or fail.
plutToRepr :: PLiftable a => (forall (s :: S). PLifted s a) -> Either LiftError (PlutusRepr a)

-- | Used with <tt>fromPlutarch</tt> methods to give additional information
--   about why evaluating a Plutarch term into a Haskell value went wrong.
data LiftError

-- | Evaluation failed for some reason.
CouldNotEvaluate :: EvalError -> LiftError

-- | We tried to use a builtin not part of the Plutus universe.
TypeError :: BuiltinError -> LiftError

-- | Compiling the term into a script failed.
CouldNotCompile :: Text -> LiftError

-- | <tt>Data</tt> encoding was invalid for our type.
CouldNotDecodeData :: LiftError

-- | Something else went wrong.
OtherLiftError :: Text -> LiftError

-- | Given a Haskell-level representation of a Plutarch term, transform it
--   into its equivalent term.
pconstant :: forall (a :: S -> Type) (s :: S). PLiftable a => AsHaskell a -> Term s a

-- | Given a closed Plutarch term, compile and evaluate it, then produce
--   the corresponding Haskell value. If compilation or evaluation fails
--   somehow, this will call <a>error</a>: if you need to 'trap' these
--   outcomes and handle them differently somehow, use <a>reprToPlut</a>
--   and <a>reprToHask</a> manually.
plift :: forall (a :: S -> Type). PLiftable a => (forall (s :: S). Term s a) -> AsHaskell a

-- | <tt>via</tt>-deriving helper, indicating that <tt>a</tt> has a
--   Haskell-level equivalent <tt>h</tt> that is directly part of the
--   Plutus default universe (instead of by way of an encoding).
newtype DeriveBuiltinPLiftable (a :: S -> Type) (h :: Type) (s :: S)
DeriveBuiltinPLiftable :: a s -> DeriveBuiltinPLiftable (a :: S -> Type) (h :: Type) (s :: S)

-- | <tt>via</tt>-deriving helper, indicating that <tt>a</tt> has a
--   Haskell-level equivalent <tt>h</tt> by way of its <tt>Data</tt>
--   encoding, rather than by <tt>h</tt> being directly part of the Plutus
--   default universe.
newtype DeriveDataPLiftable (a :: S -> Type) (h :: Type) (s :: S)
DeriveDataPLiftable :: a s -> DeriveDataPLiftable (a :: S -> Type) (h :: Type) (s :: S)

-- | <tt>via</tt>-deriving helper, indicating that <tt>wrapper</tt> has a
--   Haskell-level equivalent <tt>h</tt> by way <tt>PInner wrapper</tt>, up
--   to coercibility.
newtype DeriveNewtypePLiftable (wrapper :: S -> Type) (h :: Type) (s :: S)
DeriveNewtypePLiftable :: wrapper s -> DeriveNewtypePLiftable (wrapper :: S -> Type) (h :: Type) (s :: S)

-- | Helper that bypasses <a>PlutusRepr</a> and lifts the Haskell
--   equivalent directly. This is unsafe: we cannot verify (in general)
--   that <tt>h</tt> can be represented sensibly as an <tt>a</tt>, so use
--   this with care.
unsafeHaskToUni :: forall (h :: Type) (a :: S -> Type) (s :: S). DefaultUni `Includes` h => h -> PLifted s a

-- | Valid definition of <a>reprToPlut</a> if <tt>PlutusRepr a</tt> is in
--   the Plutus universe.
reprToPlutUni :: forall (a :: S -> Type) (s :: S). (PLiftable a, DefaultUni `Includes` PlutusRepr a) => PlutusRepr a -> PLifted s a

-- | Valid definition of <a>plutToRepr</a> if <tt>PlutusRepr a</tt> is in
--   the Plutus universe.
plutToReprUni :: forall (a :: S -> Type). (PLiftable a, DefaultUni `Includes` PlutusRepr a) => (forall (s :: S). PLifted s a) -> Either LiftError (PlutusRepr a)

-- | Similar to <tt>Identity</tt>, but at the level of Plutarch. Only
--   needed when writing manual instances of <a>PLiftable</a>, or if you
--   want to use <a>reprToPlut</a> and <a>plutToRepr</a> directly.
--   
--   This is used for coercing Plutarch terms at Haskell level with `coerce
--   :: PLifted s a -&gt; PLifted s b` for <tt>via</tt>-deriving helpers.
newtype PLifted (s :: S) (a :: S -> Type)
PLifted :: Term s POpaque -> PLifted (s :: S) (a :: S -> Type)

mkPLifted :: Term s a -> PLifted s a

getPLifted :: PLifted s a -> Term s a

-- | Use this as <a>PlutusRepr</a> when defining <a>PLiftable</a> instances
--   for Scott encoded types.
newtype PLiftedClosed (a :: S -> Type)
PLiftedClosed :: (forall (s :: S). Term s POpaque) -> PLiftedClosed (a :: S -> Type)
[$sel:unPLiftedClosed:PLiftedClosed] :: PLiftedClosed (a :: S -> Type) -> forall (s :: S). Term s POpaque

getPLiftedClosed :: forall (a :: S -> Type). PLiftedClosed a -> forall (s :: S). Term s a

mkPLiftedClosed :: forall (a :: S -> Type). (forall (s :: S). Term s a) -> PLiftedClosed a

pliftedToClosed :: forall (a :: S -> Type). (forall (s :: S). PLifted s a) -> PLiftedClosed a

pliftedFromClosed :: forall (a :: S -> Type) (s :: S). PLiftedClosed a -> PLifted s a

punsafeCoercePLifted :: PLifted s a -> PLifted s b
instance GHC.Show.Show Plutarch.Internal.Lift.LiftError
instance GHC.Classes.Eq Plutarch.Internal.Lift.LiftError
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) h. Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Lift.DeriveBuiltinPLiftable a h)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) h (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Internal.Lift.DeriveBuiltinPLiftable a h s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) h (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Internal.Lift.DeriveBuiltinPLiftable a h s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) h. Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Lift.DeriveDataPLiftable a h)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) h (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Internal.Lift.DeriveDataPLiftable a h s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) h (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Internal.Lift.DeriveDataPLiftable a h s)
instance forall (wrapper :: Plutarch.Internal.Term.S -> GHC.Types.Type) h. Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Lift.DeriveNewtypePLiftable wrapper h)
instance forall (wrapper :: Plutarch.Internal.Term.S -> GHC.Types.Type) h (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Internal.Lift.DeriveNewtypePLiftable wrapper h s)
instance forall (wrapper :: Plutarch.Internal.Term.S -> GHC.Types.Type) h (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Internal.Lift.DeriveNewtypePLiftable wrapper h s)
instance Plutarch.Internal.Lift.PLiftable Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.Lift.PLiftable Plutarch.Builtin.Bool.PBool
instance Plutarch.Internal.Lift.PLiftable Plutarch.Builtin.Unit.PUnit
instance Plutarch.Internal.Lift.PLiftable Plutarch.Builtin.String.PString
instance Plutarch.Internal.Lift.PLiftable Plutarch.Builtin.BLS.PBuiltinBLS12_381_G1_Element
instance Plutarch.Internal.Lift.PLiftable Plutarch.Builtin.BLS.PBuiltinBLS12_381_G2_Element
instance Plutarch.Internal.Lift.PLiftable Plutarch.Builtin.BLS.PBuiltinBLS12_381_MlResult
instance forall (a :: Plutarch.Internal.Term.PType) h. (Plutarch.Internal.PlutusType.PlutusType a, Universe.Core.Includes @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni h) => Plutarch.Internal.Lift.PLiftable (Plutarch.Internal.Lift.DeriveBuiltinPLiftable a h)
instance forall (a :: Plutarch.Internal.Term.PType) h. (Plutarch.Internal.PlutusType.PlutusType a, Plutarch.Internal.Subtype.PSubtype Plutarch.Builtin.Data.PData a, PlutusTx.IsData.Class.ToData h, PlutusTx.IsData.Class.FromData h) => Plutarch.Internal.Lift.PLiftable (Plutarch.Internal.Lift.DeriveDataPLiftable a h)
instance forall (wrapper :: Plutarch.Internal.Term.PType) h. (Plutarch.Internal.Lift.PLiftable (Plutarch.Internal.PlutusType.PInner wrapper), GHC.Types.Coercible @GHC.Types.Type h (Plutarch.Internal.Lift.AsHaskell (Plutarch.Internal.PlutusType.PInner wrapper)), Universe.Core.Includes @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni (Plutarch.Internal.Lift.PlutusRepr (Plutarch.Internal.PlutusType.PInner wrapper))) => Plutarch.Internal.Lift.PLiftable (Plutarch.Internal.Lift.DeriveNewtypePLiftable wrapper h)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (PlutusTx.IsData.Class.ToData (Plutarch.Internal.Lift.AsHaskell a), PlutusTx.IsData.Class.FromData (Plutarch.Internal.Lift.AsHaskell a), Plutarch.Internal.IsData.PIsData a) => Plutarch.Internal.Lift.PLiftable (Plutarch.Builtin.Data.PAsData a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Lift.PLiftable a, Universe.Core.Includes @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni (Plutarch.Internal.Lift.PlutusRepr a), Plutarch.Internal.Lift.PLiftable b, Universe.Core.Includes @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni (Plutarch.Internal.Lift.PlutusRepr b)) => Plutarch.Internal.Lift.PLiftable (Plutarch.Builtin.Data.PBuiltinPair a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Lift.PLiftable a, Universe.Core.Includes @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni (Plutarch.Internal.Lift.PlutusRepr a)) => Plutarch.Internal.Lift.PLiftable (Plutarch.Builtin.Data.PBuiltinList a)
instance Plutarch.Internal.Lift.PLiftable Plutarch.Builtin.ByteString.PByteString
instance Plutarch.Internal.Lift.PLiftable Plutarch.Builtin.Data.PData
instance Plutarch.Internal.Lift.PLiftable Plutarch.Builtin.ByteString.PByte

module Plutarch.Internal.Eq
class PEq t
(#==) :: PEq t => Term s t -> Term s t -> Term s PBool
(#==) :: (PEq t, PGeneric t, PlutusType t, All2 PEq (PCode t)) => Term s t -> Term s t -> Term s PBool
infix 4 #==
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.ByteString.PLogicOpSemantics
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.ByteString.PEndianness
instance forall (a :: Plutarch.Internal.Term.PType). (Plutarch.Internal.Eq.PEq a, Universe.Core.Contains @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni (Plutarch.Internal.Lift.PlutusRepr a)) => Plutarch.Internal.Eq.Fc 'GHC.Types.False a
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.IsData.PIsData (Plutarch.Builtin.Data.PBuiltinList a) => Plutarch.Internal.Eq.Fc 'GHC.Types.True a
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Eq.Fc (Plutarch.Internal.Eq.F a) a => Plutarch.Internal.Eq.PEq (Plutarch.Builtin.Data.PBuiltinList a)
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.Bool.PBool
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.Data.PData
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Eq.PEq (Plutarch.Builtin.Data.PAsData a)
instance forall (a :: Plutarch.Internal.Term.PType) (b :: Plutarch.Internal.Term.PType). (Plutarch.Internal.Eq.PEq a, Plutarch.Internal.Eq.PEq b) => Plutarch.Internal.Eq.PEq (Plutarch.Builtin.Data.PBuiltinPair a b)
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.ByteString.PByteString
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.ByteString.PByte
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.Unit.PUnit
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.String.PString
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.BLS.PBuiltinBLS12_381_G1_Element
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.BLS.PBuiltinBLS12_381_G2_Element

module Plutarch.Repr.Internal
type family RecAsHaskell (x :: [S -> Type])
type family StructAsHaskell (x :: [[S -> Type]])

newtype PStruct (struct :: [[S -> Type]]) (s :: S)
PStruct :: SOP (Term s) struct -> PStruct (struct :: [[S -> Type]]) (s :: S)

[$sel:unPStruct:PStruct] :: PStruct (struct :: [[S -> Type]]) (s :: S) -> SOP (Term s) struct

newtype PRec (struct :: [S -> Type]) (s :: S)
PRec :: NP (Term s) struct -> PRec (struct :: [S -> Type]) (s :: S)

[$sel:unPRec:PRec] :: PRec (struct :: [S -> Type]) (s :: S) -> NP (Term s) struct

pletL :: All SListI as => SOP (Term s) as -> (SOP (Term s) as -> Term s r) -> Term s r

grecEq :: forall (s :: S) (struct :: [S -> Type]). All PEq struct => NP (Term s) struct -> NP (Term s) struct -> Term s PBool

gstructEq :: forall (s :: S) (struct :: [[S -> Type]]). All2 PEq struct => SOP (Term s) struct -> SOP (Term s) struct -> Term s PBool

-- | This function handles optimization of function that require multiple
--   handlers by checking hashes of each | handler item and merging them in
--   a way it will minimize size and cost of all computation
groupHandlers :: forall (s :: S) (r :: S -> Type). [(Integer, Term s r)] -> Term s PInteger -> Term s r

class (Generic (a s), AllZipN @Type (Prod SOP) (LiftedCoercible I (Term s)) (Code (a s)) struct, AllZipN @Type (Prod SOP) (LiftedCoercible (Term s) I) struct (Code (a s))) => StructSameRepr s a struct

type family UnTermRec (struct :: [Type]) :: [S -> Type]

type UnTermStruct x = UnTermStruct' (Code x)
type family UnTermStruct' (struct :: [[Type]]) :: [[S -> Type]]

type RecTypePrettyError struct = RecTypePrettyError' struct ~ 'True
instance forall l1 (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S) (struct :: l1). (Generics.SOP.Universe.Generic (a s), Data.SOP.Constraint.AllZipN @GHC.Types.Type @[[GHC.Types.Type]] @GHC.Types.Type @Plutarch.Internal.Term.PType @[[GHC.Types.Type]] @l1 (Data.SOP.Classes.Prod @GHC.Types.Type @[[GHC.Types.Type]] (Data.SOP.NS.SOP @GHC.Types.Type)) (Data.SOP.Constraint.LiftedCoercible @{GHC.Types.Type} @{GHC.Types.Type} @{Plutarch.Internal.Term.PType} Data.SOP.BasicFunctors.I (Plutarch.Internal.Term.Term s)) (Generics.SOP.Universe.Code (a s)) struct, Data.SOP.Constraint.AllZipN @GHC.Types.Type @[[GHC.Types.Type]] @Plutarch.Internal.Term.PType @GHC.Types.Type @l1 @[[GHC.Types.Type]] (Data.SOP.Classes.Prod @GHC.Types.Type @[[GHC.Types.Type]] (Data.SOP.NS.SOP @GHC.Types.Type)) (Data.SOP.Constraint.LiftedCoercible @{Plutarch.Internal.Term.PType} @{GHC.Types.Type} @{GHC.Types.Type} (Plutarch.Internal.Term.Term s) Data.SOP.BasicFunctors.I) struct (Generics.SOP.Universe.Code (a s))) => Plutarch.Repr.Internal.StructSameRepr @{l1} s a struct

module Plutarch.Repr.Scott

newtype PScottStruct (struct :: [[S -> Type]]) (s :: S)
PScottStruct :: PStruct struct s -> PScottStruct (struct :: [[S -> Type]]) (s :: S)

[$sel:unPScottStruct:PScottStruct] :: PScottStruct (struct :: [[S -> Type]]) (s :: S) -> PStruct struct s

newtype PScottRec (struct :: [S -> Type]) (s :: S)
PScottRec :: PRec struct s -> PScottRec (struct :: [S -> Type]) (s :: S)

[$sel:unPScottRec:PScottRec] :: PScottRec (struct :: [S -> Type]) (s :: S) -> PRec struct s

newtype PScottStructInner a r s
PScottStructInner :: Term s (ScottFn (ScottList a r) r) -> PScottStructInner a r s

newtype PScottRecInner a r s
PScottRecInner :: Term s (ScottFn a r) -> PScottRecInner a r s

newtype DeriveAsScottStruct (a :: S -> Type) s
DeriveAsScottStruct :: a s -> DeriveAsScottStruct (a :: S -> Type) s

[$sel:unDeriveAsScottStruct:DeriveAsScottStruct] :: DeriveAsScottStruct (a :: S -> Type) s -> a s

newtype DeriveAsScottRec (a :: S -> Type) s
DeriveAsScottRec :: a s -> DeriveAsScottRec (a :: S -> Type) s

[$sel:unDeriveAsScottRec:DeriveAsScottRec] :: DeriveAsScottRec (a :: S -> Type) s -> a s
instance forall (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). (Data.SOP.Constraint.SListI2 @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct, Plutarch.Repr.Scott.PScottStructConstraint struct) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Scott.PScottStruct struct)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). (Generics.SOP.Universe.Generic (a (GHC.Types.Any @Plutarch.Internal.Term.S)), (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]) GHC.Types.~ (Plutarch.Repr.Internal.UnTermStruct (a (GHC.Types.Any @Plutarch.Internal.Term.S)) :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]), Data.SOP.Constraint.SListI2 @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct, forall (s :: Plutarch.Internal.Term.S). Plutarch.Repr.Internal.StructSameRepr @{[[Plutarch.Internal.Term.S -> GHC.Types.Type]]} s a struct, Plutarch.Repr.Scott.PScottStructConstraint struct) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Scott.DeriveAsScottStruct a)
instance forall (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). (Data.SOP.Constraint.SListI @{[Plutarch.Internal.Term.S -> GHC.Types.Type]} struct, forall (r :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Repr.Scott.PScottStructConstraint' struct r) => Plutarch.Repr.Scott.PScottStructConstraint struct
instance forall (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]) (r :: Plutarch.Internal.Term.S -> GHC.Types.Type). Data.SOP.Constraint.SListI @{Plutarch.Internal.Term.S -> GHC.Types.Type} (Plutarch.Repr.Scott.ScottList struct r) => Plutarch.Repr.Scott.PScottStructConstraint' struct r
instance forall (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]). Data.SOP.Constraint.SListI @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Scott.PScottRec struct)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (struct' :: [GHC.Types.Type]) (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]). (Generics.SOP.Universe.Generic (a (GHC.Types.Any @Plutarch.Internal.Term.S)), ((':) @[GHC.Types.Type] struct' ('[] @[GHC.Types.Type]) :: [[GHC.Types.Type]]) GHC.Types.~ (Generics.SOP.Universe.Code (a (GHC.Types.Any @Plutarch.Internal.Term.S)) :: [[GHC.Types.Type]]), (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]) GHC.Types.~ (Plutarch.Repr.Internal.UnTermRec struct' :: [Plutarch.Internal.Term.S -> GHC.Types.Type]), Data.SOP.Constraint.SListI @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct, forall (s :: Plutarch.Internal.Term.S). Plutarch.Repr.Internal.StructSameRepr @{[[Plutarch.Internal.Term.S -> GHC.Types.Type]]} s a ((':) @[Plutarch.Internal.Term.S -> GHC.Types.Type] struct ('[] @[Plutarch.Internal.Term.S -> GHC.Types.Type])), Plutarch.Repr.Internal.RecTypePrettyError @{GHC.Types.Type} (Generics.SOP.Universe.Code (a (GHC.Types.Any @Plutarch.Internal.Term.S)))) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Scott.DeriveAsScottRec a)
instance forall (struct :: [Plutarch.Internal.Term.PType]). Data.SOP.Constraint.All @Plutarch.Internal.Term.PType Plutarch.Internal.Eq.PEq struct => Plutarch.Internal.Eq.PEq (Plutarch.Repr.Scott.PScottRec struct)
instance forall (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). (Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Scott.PScottStruct struct), Data.SOP.Constraint.SListI2 @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct, Data.SOP.Constraint.All2 @{Plutarch.Internal.Term.PType} Plutarch.Internal.Eq.PEq struct) => Plutarch.Internal.Eq.PEq (Plutarch.Repr.Scott.PScottStruct struct)

module Plutarch.Repr.SOP

newtype PSOPStruct (struct :: [[S -> Type]]) (s :: S)
PSOPStruct :: PStruct struct s -> PSOPStruct (struct :: [[S -> Type]]) (s :: S)

[$sel:unPSOPStruct:PSOPStruct] :: PSOPStruct (struct :: [[S -> Type]]) (s :: S) -> PStruct struct s

newtype PSOPRec (struct :: [S -> Type]) (s :: S)
PSOPRec :: PRec struct s -> PSOPRec (struct :: [S -> Type]) (s :: S)

[$sel:unPSOPRec:PSOPRec] :: PSOPRec (struct :: [S -> Type]) (s :: S) -> PRec struct s

-- | <tt>via</tt>-derivation helper to derive <a>PlutusType</a> instance
--   using SoP encoding. If your type has only one constructor prefer using
--   <a>DeriveAsSOPRec</a> instead.
newtype DeriveAsSOPStruct (a :: S -> Type) s
DeriveAsSOPStruct :: a s -> DeriveAsSOPStruct (a :: S -> Type) s

[$sel:unDeriveAsSOPStruct:DeriveAsSOPStruct] :: DeriveAsSOPStruct (a :: S -> Type) s -> a s

-- | <tt>via</tt>-derivation helper for SOP encoding, currently behaves
--   exactly like <a>DeriveAsSOPStruct</a> but can be used only on types
--   with a single constructor. It is separate to leave a room for future
--   optimizations.
newtype DeriveAsSOPRec (a :: S -> Type) s
DeriveAsSOPRec :: a s -> DeriveAsSOPRec (a :: S -> Type) s

[$sel:unDeriveAsSOPRec:DeriveAsSOPRec] :: DeriveAsSOPRec (a :: S -> Type) s -> a s
instance forall (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]) (hstruct :: [[GHC.Types.Type]]). (Data.SOP.Constraint.SListI2 @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct, (hstruct :: [[GHC.Types.Type]]) GHC.Types.~ (Plutarch.Repr.Internal.StructAsHaskell struct :: [[GHC.Types.Type]]), Data.SOP.Constraint.AllZip2 @{GHC.Types.Type} @{Plutarch.Internal.Term.S -> GHC.Types.Type} Plutarch.Repr.SOP.ToAsHaskell hstruct struct, Data.SOP.Constraint.All2 @{Plutarch.Internal.Term.S -> GHC.Types.Type} Plutarch.Internal.Lift.PLiftable struct, Plutarch.Repr.SOP.MyAll @[Plutarch.Internal.Term.S -> GHC.Types.Type] Plutarch.Repr.SOP.SOPEntryConstraints Plutarch.Repr.SOP.SOPRestConstraint struct, Plutarch.Repr.SOP.PSOPStructConstraint struct) => Plutarch.Internal.Lift.PLiftable (Plutarch.Repr.SOP.PSOPStruct struct)
instance forall k (c :: k -> GHC.Types.Constraint) (d :: [k] -> GHC.Types.Constraint). Plutarch.Repr.SOP.MyAll @k c d ('[] @k)
instance forall a (c :: a -> GHC.Types.Constraint) (x :: a) (d :: [a] -> GHC.Types.Constraint) (xs :: [a]). (c x, d xs, Plutarch.Repr.SOP.MyAll @a c d xs) => Plutarch.Repr.SOP.MyAll @a c d ((':) @a x xs)
instance forall (ys :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). (Data.SOP.Constraint.SListI2 @{Plutarch.Internal.Term.S -> GHC.Types.Type} ys, Plutarch.Repr.SOP.PSOPStructConstraint ys) => Plutarch.Repr.SOP.SOPRestConstraint ys
instance forall (y :: [Plutarch.Internal.Term.S -> GHC.Types.Type]). (Data.SOP.Constraint.AllZip @GHC.Types.Type @(Plutarch.Internal.Term.S -> GHC.Types.Type) Plutarch.Repr.SOP.ToAsHaskell (Plutarch.Repr.Internal.RecAsHaskell y) y, Data.SOP.Constraint.All @(Plutarch.Internal.Term.S -> GHC.Types.Type) Plutarch.Internal.Lift.PLiftable y) => Plutarch.Repr.SOP.SOPEntryConstraints y
instance forall (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]) (hstruct :: [GHC.Types.Type]). (Data.SOP.Constraint.SListI @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct, (hstruct :: [GHC.Types.Type]) GHC.Types.~ (Plutarch.Repr.Internal.RecAsHaskell struct :: [GHC.Types.Type]), Data.SOP.Constraint.AllZip @GHC.Types.Type @(Plutarch.Internal.Term.S -> GHC.Types.Type) Plutarch.Repr.SOP.ToAsHaskell hstruct struct, Data.SOP.Constraint.All @(Plutarch.Internal.Term.S -> GHC.Types.Type) Plutarch.Internal.Lift.PLiftable struct) => Plutarch.Internal.Lift.PLiftable (Plutarch.Repr.SOP.PSOPRec struct)
instance forall a (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). ((a :: GHC.Types.Type) GHC.Types.~ (Plutarch.Internal.Lift.AsHaskell b :: GHC.Types.Type), Plutarch.Internal.Lift.PLiftable b) => Plutarch.Repr.SOP.ToAsHaskell a b
instance forall (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). (Data.SOP.Constraint.SListI2 @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct, Plutarch.Repr.SOP.PSOPStructConstraint struct) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.SOP.PSOPStruct struct)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). (Generics.SOP.Universe.Generic (a (GHC.Types.Any @Plutarch.Internal.Term.S)), (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]) GHC.Types.~ (Plutarch.Repr.Internal.UnTermStruct (a (GHC.Types.Any @Plutarch.Internal.Term.S)) :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]), Data.SOP.Constraint.SListI2 @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct, forall (s :: Plutarch.Internal.Term.S). Plutarch.Repr.Internal.StructSameRepr @{[[Plutarch.Internal.Term.S -> GHC.Types.Type]]} s a struct, Plutarch.Repr.SOP.PSOPStructConstraint struct) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.SOP.DeriveAsSOPStruct a)
instance forall (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). (Data.SOP.Constraint.SListI @{[Plutarch.Internal.Term.S -> GHC.Types.Type]} struct, forall (r :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Repr.SOP.PSOPStructConstraint' struct r) => Plutarch.Repr.SOP.PSOPStructConstraint struct
instance forall (r :: Plutarch.Internal.Term.S -> GHC.Types.Type) (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). Data.SOP.Constraint.SListI @{Plutarch.Internal.Term.S -> GHC.Types.Type} (Plutarch.Repr.SOP.PCaseTy r struct) => Plutarch.Repr.SOP.PSOPStructConstraint' struct r
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (struct' :: [GHC.Types.Type]) (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]). (Generics.SOP.Universe.Generic (a (GHC.Types.Any @Plutarch.Internal.Term.S)), ((':) @[GHC.Types.Type] struct' ('[] @[GHC.Types.Type]) :: [[GHC.Types.Type]]) GHC.Types.~ (Generics.SOP.Universe.Code (a (GHC.Types.Any @Plutarch.Internal.Term.S)) :: [[GHC.Types.Type]]), (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]) GHC.Types.~ (Plutarch.Repr.Internal.UnTermRec struct' :: [Plutarch.Internal.Term.S -> GHC.Types.Type]), Data.SOP.Constraint.SListI @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct, forall (s :: Plutarch.Internal.Term.S). Plutarch.Repr.Internal.StructSameRepr @{[[Plutarch.Internal.Term.S -> GHC.Types.Type]]} s a ((':) @[Plutarch.Internal.Term.S -> GHC.Types.Type] struct ('[] @[Plutarch.Internal.Term.S -> GHC.Types.Type])), Plutarch.Repr.Internal.RecTypePrettyError @{GHC.Types.Type} (Generics.SOP.Universe.Code (a (GHC.Types.Any @Plutarch.Internal.Term.S)))) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.SOP.DeriveAsSOPRec a)
instance forall (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]). Data.SOP.Constraint.SListI @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.SOP.PSOPRec struct)
instance forall (struct :: [Plutarch.Internal.Term.PType]). Data.SOP.Constraint.All @Plutarch.Internal.Term.PType Plutarch.Internal.Eq.PEq struct => Plutarch.Internal.Eq.PEq (Plutarch.Repr.SOP.PSOPRec struct)
instance forall (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). (Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.SOP.PSOPStruct struct), Data.SOP.Constraint.All2 @{Plutarch.Internal.Term.PType} Plutarch.Internal.Eq.PEq struct) => Plutarch.Internal.Eq.PEq (Plutarch.Repr.SOP.PSOPStruct struct)

module Plutarch.Repr.Derive

-- | This is <tt>PLiftable</tt> derivation helper for user-defined
--   datatypes like Data/SOP encoded types. Please consult example below.
--   
--   @@ data PBobData (a :: S -&gt; Type) (s :: S) = PBobData (Term s
--   (PAsData a)) (Term s (PAsData PBool)) deriving stock (Generic)
--   deriving anyclass (SOP.Generic) deriving PlutusType via
--   (DeriveAsDataRec (PBobData a)) -- SOP encoding works as well.
--   
--   deriving via DerivePLiftableAsRepr (PBobData a) (Bob (AsHaskell a))
--   instance PLiftable (PAsData a) =&gt; PLiftable (PBobData a) @@
--   
--   @since WIP
newtype DerivePLiftableAsRepr (wrapper :: S -> Type) (h :: Type) (s :: S)
DerivePLiftableAsRepr :: wrapper s -> DerivePLiftableAsRepr (wrapper :: S -> Type) (h :: Type) (s :: S)
instance forall (wrapper :: Plutarch.Internal.Term.S -> GHC.Types.Type) h. Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Derive.DerivePLiftableAsRepr wrapper h)
instance forall (wrapper :: Plutarch.Internal.Term.S -> GHC.Types.Type) h (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Repr.Derive.DerivePLiftableAsRepr wrapper h s)
instance forall (wrapper :: Plutarch.Internal.Term.S -> GHC.Types.Type) h (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Repr.Derive.DerivePLiftableAsRepr wrapper h s)
instance forall (wrapper :: Plutarch.Internal.Term.PType) h (struct' :: [[GHC.Types.Type]]) (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]) (hstruct :: [[GHC.Types.Type]]). (Plutarch.Internal.Lift.PLiftable (Plutarch.Internal.PlutusType.PInner wrapper), Generics.SOP.Universe.Generic (wrapper (GHC.Types.Any @Plutarch.Internal.Term.S)), Generics.SOP.Universe.Generic h, (hstruct :: [[GHC.Types.Type]]) GHC.Types.~ (Generics.SOP.Universe.Code h :: [[GHC.Types.Type]]), (struct' :: [[GHC.Types.Type]]) GHC.Types.~ (Generics.SOP.Universe.Code (wrapper (GHC.Types.Any @Plutarch.Internal.Term.S)) :: [[GHC.Types.Type]]), (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]) GHC.Types.~ (Plutarch.Repr.Internal.UnTermStruct' struct' :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]), (hstruct :: [[GHC.Types.Type]]) GHC.Types.~ (Plutarch.Repr.Internal.StructAsHaskell struct :: [[GHC.Types.Type]]), (Plutarch.Internal.Lift.AsHaskell (Plutarch.Internal.PlutusType.PInner wrapper) :: GHC.Types.Type) GHC.Types.~ (Data.SOP.NS.SOP @GHC.Types.Type Data.SOP.BasicFunctors.I hstruct :: GHC.Types.Type)) => Plutarch.Internal.Lift.PLiftable (Plutarch.Repr.Derive.DerivePLiftableAsRepr wrapper h)

module Plutarch.Maybe

data PMaybe (a :: S -> Type) (s :: S)
PJust :: Term s a -> PMaybe (a :: S -> Type) (s :: S)
PNothing :: PMaybe (a :: S -> Type) (s :: S)

-- | Construct a <a>PJust</a> value.
pjust :: forall (a :: S -> Type) (s :: S). Term s (a :--> PMaybe a)

-- | Construct a <a>PNothing</a> value.
pnothing :: forall (a :: S -> Type) (s :: S). Term s (PMaybe a)

-- | Yields true if the given <a>PMaybe</a> value is of form
--   <tt><a>PJust</a> _</tt>.
pisJust :: forall (a :: S -> Type) (s :: S). Term s (PMaybe a :--> PBool)

-- | Extracts the element out of a <a>PJust</a> and throws an error if its
--   argument is <a>PNothing</a>.
pfromJust :: forall (a :: S -> Type) (s :: S). Term s (PMaybe a :--> a)

-- | Extracts the element out of a <a>PJust</a> and throws a custom error
--   if it's given a <a>PNothing</a>.
ptraceIfNothing :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s (PMaybe a) -> Term s a

-- | Extract a <a>PMaybe</a> by providing a default value in case of
--   <a>PJust</a>.
pfromMaybe :: forall (a :: S -> Type) (s :: S). Term s (a :--> (PMaybe a :--> a))

-- | Given a default value, a function and a <a>PMaybe</a> value, yields
--   the default value if the <a>PMaybe</a> value is <a>PNothing</a> and
--   applies the function to the value stored in the <a>PJust</a>
--   otherwise.
pmaybe :: forall (b :: S -> Type) (a :: S -> Type) (s :: S). Term s (b :--> ((a :--> b) :--> (PMaybe a :--> b)))

-- | Extract the value stored in a <a>PMaybe</a> container. If there's no
--   value, throw an error with the given message.
passertPJust :: forall (a :: S -> Type) (s :: S). Term s (PString :--> (PMaybe a :--> a))

-- | Map underlying value if <a>PMaybe</a> is <a>PJust</a>, do nothing if
--   it is <a>PNothing</a>
pmapMaybe :: Term s ((a :--> b) :--> (PMaybe a :--> PMaybe b))
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Eq.PEq a => Plutarch.Internal.Eq.PEq (Plutarch.Maybe.PMaybe a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Maybe.PMaybe a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Maybe.PMaybe a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Maybe.PMaybe a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Lift.PLiftable a => Plutarch.Internal.Lift.PLiftable (Plutarch.Maybe.PMaybe a)

module Plutarch.Internal.Ord

-- | Total ordering relation.
--   
--   <h1>Laws</h1>
--   
--   <a>#&lt;=</a> must form a total order. More precisely:
--   
--   <ol>
--   <li><tt>x #&lt;= x</tt> <tt>=</tt> <tt>pcon PTrue</tt>
--   (reflexivity)</li>
--   <li><tt>(y #&lt; x) #|| (z #&lt; y) #|| (x #&lt;= z)</tt> <tt>=</tt>
--   <tt>pcon PTrue</tt> (transitivity)</li>
--   <li><tt>(x #&lt;= y) #|| (y #&lt;= x)</tt> <tt>=</tt> <tt>pcon
--   PTrue</tt> (totality)</li>
--   </ol>
--   
--   Furthermore, <a>#&lt;</a> must be an equivalent strict total order to
--   <a>#&lt;=</a>:
--   
--   <ol>
--   <li><tt>x #&lt; x</tt> <tt>=</tt> <tt>pcon PFalse</tt>
--   (irreflexivity)</li>
--   <li><tt>(y #&lt;= x) #|| (z #&lt;= y) #|| (x #&lt; z)</tt> <tt>=</tt>
--   <tt>pcon PTrue</tt> (transitivity)</li>
--   <li><tt>(x #&lt; y) #|| (y #&lt; x) #|| (x #== z)</tt> <tt>=</tt>
--   <tt>pcon PTrue</tt> (trichotomy)</li>
--   <li><tt>x #&lt;= y</tt> <tt>=</tt> <tt>(x #&lt; y) #|| (x #== y)</tt>
--   (strict equivalence)</li>
--   </ol>
--   
--   If you define <a>pmax</a> or <a>pmin</a>, ensure the following also
--   hold:
--   
--   <ol>
--   <li><tt>pmax # x # y</tt> <tt>=</tt> <tt>pmax # y # x</tt>
--   (commutativity, also for @pmin)</li>
--   <li><tt>pmax # x #$ pmax y z</tt> <tt>=</tt> <tt>pmax # (pmax # x # y)
--   # z</tt> (associativity, also for @pmin)</li>
--   <li><tt>pmax # x #$ pmin # y # z</tt> <tt>=</tt> <tt>pmin # (pmax # x
--   # y) # (pmax # x # z)</tt> (<a>pmax</a> distributes over <a>pmin</a>,
--   also equivalent for <a>pmin</a>)</li>
--   <li><tt>pmin x y</tt> <tt>=</tt> <tt>pif' (x #&lt;= y) x y</tt></li>
--   <li><tt>pmax x y</tt> <tt>=</tt> <tt>pif' (x #&lt;= y) y x</tt></li>
--   </ol>
--   
--   Laws 8-12 hold if you use the defaults provided by this type class.
class PEq t => POrd t

(#<=) :: POrd t => Term s t -> Term s t -> Term s PBool

(#<=) :: (POrd t, POrd (PInner t)) => Term s t -> Term s t -> Term s PBool

(#<) :: POrd t => Term s t -> Term s t -> Term s PBool

(#<) :: (POrd t, POrd (PInner t)) => Term s t -> Term s t -> Term s PBool

pmax :: forall (s :: S). POrd t => Term s t -> Term s t -> Term s t

pmin :: forall (s :: S). POrd t => Term s t -> Term s t -> Term s t
infix 4 #<=
infix 4 #<

(#>) :: forall (a :: S -> Type) (s :: S). POrd a => Term s a -> Term s a -> Term s PBool
infix 4 #>

(#>=) :: forall (a :: S -> Type) (s :: S). POrd a => Term s a -> Term s a -> Term s PBool
infix 4 #>=
instance Plutarch.Internal.Ord.POrd Plutarch.Builtin.ByteString.PLogicOpSemantics
instance Plutarch.Internal.Ord.POrd Plutarch.Builtin.ByteString.PEndianness
instance Plutarch.Internal.Ord.POrd Plutarch.Builtin.Bool.PBool
instance Plutarch.Internal.Ord.POrd Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.Ord.POrd Plutarch.Builtin.ByteString.PByteString
instance Plutarch.Internal.Ord.POrd Plutarch.Builtin.ByteString.PByte
instance Plutarch.Internal.Ord.POrd Plutarch.Builtin.Unit.PUnit

module Plutarch.Internal.IsData
class (PInnermostIsData' msg a (PInnermost a), PInnermost a ~ PData) => PInnermostIsData msg a

-- | Laws: - If <tt>PSubtype PData a</tt>, then <tt>pdataImpl a</tt> must
--   be <a>pupcast</a>. - pdataImpl . pupcast . pfromDataImpl  id -
--   pfromDataImpl . punsafeDowncast . pdataImpl  id
class PIsData a
pfromDataImpl :: PIsData a => Term s (PAsData a) -> Term s a
pdataImpl :: PIsData a => Term s a -> Term s PData
pdata :: PIsData a => Term s a -> Term s (PAsData a)
pfromData :: PIsData a => Term s (PAsData a) -> Term s a
pforgetData :: forall s a. Term s (PAsData a) -> Term s PData

-- | Inverse of <a>pforgetData'</a>.
prememberData :: forall (p :: (S -> Type) -> S -> Type) (s :: S). PVariant p => Proxy p -> Term s (p PData) -> Term s (p (PAsData PData))

-- | Like <a>pforgetData</a>, except it works for complex types. Equivalent
--   to <a>pupcastF</a>.
pforgetData' :: forall a (p :: (S -> Type) -> S -> Type) (s :: S). PCovariant p => Proxy p -> Term s (p (PAsData a)) -> Term s (p PData)

-- | Like <a>prememberData</a> but generalised.
prememberData' :: forall a (p :: (S -> Type) -> S -> Type) (s :: S). (PInnermostIsData 'Nothing a, PSubtype PData a, PVariant p) => Proxy p -> Term s (p a) -> Term s (p (PAsData a))
instance Plutarch.Internal.IsData.PIsData Plutarch.Builtin.Data.PData
instance Plutarch.Internal.IsData.PIsData Plutarch.Builtin.Bool.PBool
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.IsData.PIsData (Plutarch.Builtin.Data.PBuiltinPair (Plutarch.Builtin.Data.PAsData a) (Plutarch.Builtin.Data.PAsData b))
instance Plutarch.Internal.IsData.PIsData (Plutarch.Builtin.Data.PBuiltinPair Plutarch.Builtin.Data.PData Plutarch.Builtin.Data.PData)
instance Plutarch.Internal.IsData.PIsData (Plutarch.Builtin.Data.PBuiltinPair Plutarch.Builtin.Integer.PInteger (Plutarch.Builtin.Data.PBuiltinList Plutarch.Builtin.Data.PData))
instance Plutarch.Internal.IsData.PIsData Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.IsData.PIsData Plutarch.Builtin.ByteString.PByteString
instance Plutarch.Internal.IsData.PIsData Plutarch.Builtin.Unit.PUnit
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.IsData.PInnermostIsData ('GHC.Maybe.Just @GHC.Types.Symbol "PBuiltinList only implements PIsData when inner most type of its elements are PData") a, Plutarch.Internal.Subtype.PSubtype Plutarch.Builtin.Data.PData a) => Plutarch.Internal.IsData.PIsData (Plutarch.Builtin.Data.PBuiltinList a)
instance forall (msg :: GHC.Maybe.Maybe GHC.Types.Symbol) (a :: Plutarch.Internal.Term.PType). (Plutarch.Internal.IsData.PInnermostIsData' @{Plutarch.Internal.Term.PType} msg a (Plutarch.Internal.PlutusType.PInnermost a), (Plutarch.Internal.PlutusType.PInnermost a :: (Plutarch.Internal.Term.S -> GHC.Types.Type)) GHC.Types.~ (Plutarch.Builtin.Data.PData :: (Plutarch.Internal.Term.S -> GHC.Types.Type))) => Plutarch.Internal.IsData.PInnermostIsData msg a

module Plutarch.Internal.Numeric

data PPositive (s :: S)

data Positive

data PNatural (s :: S)

-- | The addition operation, and the notion of scaling by a positive.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>x #+ y</tt> <tt>=</tt> <tt>y #+ x</tt> (commutativity of
--   <tt>#+</tt>)</li>
--   <li><tt>x #+ (y #+ z)</tt> <tt>=</tt> <tt>(x #+ y) #+ z</tt>
--   (associativity of <tt>#+</tt>)</li>
--   </ol>
--   
--   If you define a custom <tt>pscalePositive</tt>, ensure the following
--   also hold:
--   
--   <ol>
--   <li><tt>pscalePositive x pone</tt> <tt>=</tt> <tt>x</tt></li>
--   <li><tt>(pscalePositive x n) #+ (pscalePositive x m)</tt> <tt>=</tt>
--   <tt>pscalePositive x (n #+ m)</tt></li>
--   <li><tt>pscalePositive (pscalePositive x n) m</tt> <tt>=</tt>
--   <tt>pscalePositive x (n #* m)</tt></li>
--   </ol>
--   
--   The default implementation ensures these laws are satisfied.
class PAdditiveSemigroup (a :: S -> Type)
(#+) :: forall (s :: S). PAdditiveSemigroup a => Term s a -> Term s a -> Term s a
(#+) :: forall (s :: S). (PAdditiveSemigroup a, PAdditiveSemigroup (PInner a)) => Term s a -> Term s a -> Term s a

-- | This defaults to exponentiation-by-squaring, which in general is the
--   best we can do.
pscalePositive :: forall (s :: S). PAdditiveSemigroup a => Term s a -> Term s PPositive -> Term s a
infix 6 #+

-- | The notion of zero, as well as a way to scale by naturals.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>pzero #+ x</tt> <tt>=</tt> <tt>x</tt> (<tt>pzero</tt> is the
--   identity of <tt>#+</tt>)</li>
--   <li><tt>pscalePositive pzero n</tt> <tt>=</tt> <tt>pzero</tt>
--   (<tt>pzero</tt> does not scale up)</li>
--   </ol>
--   
--   If you define <a>pscaleNatural</a>, ensure the following as well:
--   
--   <ol>
--   <li><tt>pscaleNatural x (ppositiveToNatural # p)</tt> <tt>=</tt>
--   <tt>pscalePositive x p</tt></li>
--   <li><tt>pscaleNatural x pzero</tt> <tt>=</tt> <tt>pzero</tt></li>
--   </ol>
--   
--   The default implementation of <a>pscaleNatural</a> ensures these laws
--   hold.
class PAdditiveSemigroup a => PAdditiveMonoid (a :: S -> Type)
pzero :: forall (s :: S). PAdditiveMonoid a => Term s a
pscaleNatural :: forall (s :: S). PAdditiveMonoid a => Term s a -> Term s PNatural -> Term s a

-- | The notion of additive inverses, and the subtraction operation.
--   
--   <h1>Laws</h1>
--   
--   If you define <tt>pnegate</tt>, the following laws must hold:
--   
--   <ol>
--   <li><tt>(pnegate # x) #+ x</tt> <tt>=</tt> <tt>pzero</tt>
--   (<tt>pnegate</tt> is an additive inverse)</li>
--   <li><tt>pnegate #$ pnegate # x</tt> <tt>=</tt> <tt>x</tt>
--   (<tt>pnegate</tt> is self-inverting)</li>
--   </ol>
--   
--   If you define <tt>#-</tt>, the following law must hold:
--   
--   <ol>
--   <li><tt>x #- x</tt> <tt>=</tt> <tt>pzero</tt></li>
--   </ol>
--   
--   Additionally, the following 'consistency laws' must hold. Default
--   implementations of both <tt>pnegate</tt> and <tt>#-</tt> uphold these.
--   
--   <ol>
--   <li><tt>pnegate # x</tt> <tt>=</tt> <tt>pzero #- x</tt></li>
--   <li><tt>x #- y</tt> <tt>=</tt> <tt>x #+ (pnegate # y)</tt></li>
--   </ol>
--   
--   Lastly, if you define a custom <tt>pscaleInteger</tt>, the following
--   laws must hold:
--   
--   <ol>
--   <li><tt>pscaleInteger x pzero</tt> <tt>=</tt> <tt>pzero</tt></li>
--   <li><tt>pscaleInteger x (pnegate # y)</tt> <tt>=</tt> <tt>pnegate #
--   (pscaleInteger x y)</tt></li>
--   </ol>
class PAdditiveMonoid a => PAdditiveGroup (a :: S -> Type)
pnegate :: forall (s :: S). PAdditiveGroup a => Term s (a :--> a)
(#-) :: forall (s :: S). PAdditiveGroup a => Term s a -> Term s a -> Term s a
pscaleInteger :: forall (s :: S). PAdditiveGroup a => Term s a -> Term s PInteger -> Term s a
infix 6 #-

-- | The multiplication operation.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>x #* (y #* z)</tt> <tt>=</tt> <tt>(x #* y) #* z</tt>
--   (associativity of <tt>#*</tt>)</li>
--   </ol>
--   
--   If you define a custom <tt>ppowPositive</tt>, ensure the following
--   also hold:
--   
--   <ol>
--   <li><tt>ppowPositive x pone</tt> <tt>=</tt> <tt>x</tt></li>
--   <li><tt>(ppowPositive x n) #* (ppowPositive x m)</tt> <tt>=</tt>
--   <tt>ppowPositive x (n #+ m)</tt></li>
--   <li><tt>ppowPositive (ppowPositive x n) m</tt> <tt>=</tt>
--   <tt>ppowPositive x (n #* m)</tt></li>
--   </ol>
--   
--   The default implementation ensures these laws are satisfied.
--   
--   <h1>Note</h1>
--   
--   Unlike <a>PAdditiveSemigroup</a>, the multiplication operation doesn't
--   need to be commutative. Currently, all Plutarch-provided instances
--   are, but this need not be true for other instances.
class PMultiplicativeSemigroup (a :: S -> Type)
(#*) :: forall (s :: S). PMultiplicativeSemigroup a => Term s a -> Term s a -> Term s a
(#*) :: forall (s :: S). (PMultiplicativeSemigroup a, PMultiplicativeSemigroup (PInner a)) => Term s a -> Term s a -> Term s a
ppowPositive :: forall (s :: S). PMultiplicativeSemigroup a => Term s a -> Term s PPositive -> Term s a
infix 6 #*

-- | The notion of one (multiplicative identity), and exponentiation by -
--   naturals.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>pone #* x</tt> <tt>=</tt> <tt>x</tt> (<tt>pone</tt> is the
--   left identity of <tt>#*</tt>)</li>
--   <li><tt>x #* pone</tt> <tt>=</tt> <tt>x</tt> (<tt>pone</tt> is the
--   right identity of <tt>#*</tt>)</li>
--   <li><tt>ppowPositive pone p</tt> <tt>=</tt> <tt>pone</tt>
--   (<tt>pone</tt> does not scale up)</li>
--   </ol>
--   
--   If you define <a>ppowNatural</a>, ensure the following as well:
--   
--   <ol>
--   <li><tt>ppowNatural x (ppositiveToNatural # p)</tt> <tt>=</tt>
--   <tt>ppowPositive x p</tt></li>
--   <li><tt>ppowNatural x pzero</tt> <tt>=</tt> <tt>pone</tt></li>
--   </ol>
class PMultiplicativeSemigroup a => PMultiplicativeMonoid (a :: S -> Type)
pone :: forall (s :: S). PMultiplicativeMonoid a => Term s a
ppowNatural :: forall (s :: S). PMultiplicativeMonoid a => Term s a -> Term s PNatural -> Term s a

-- | <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>pfromInteger 0</tt> <tt>=</tt> <tt>pzero</tt></li>
--   <li><tt>pfromInteger 1</tt> <tt>=</tt> <tt>pone</tt></li>
--   <li><tt>pfromInteger (x + y)</tt> <tt>=</tt> <tt>pfromInteger x #+
--   pfromInteger y</tt></li>
--   <li><tt>pfromInteger (x * y)</tt> <tt>=</tt> <tt>pfromInteger x #*
--   pfromInteger y</tt></li>
--   </ol>
--   
--   Additionally, the following 'interaction laws' must hold between the
--   instances of <a>PAdditiveGroup</a> and <a>PMultiplicativeMonoid</a>
--   for <tt>a</tt>:
--   
--   <ol>
--   <li><tt>x #* (y #+ z)</tt> <tt>=</tt> <tt>(x #* y) #+ (x #* z)</tt>
--   (<tt>#*</tt> left-distributes over <tt>#+</tt>)</li>
--   <li><tt>(y #+ z) #* x</tt> <tt>=</tt> <tt>(y #* x) #+ (z #* x)</tt>
--   (<tt>#*</tt> right-distributes over <tt>#+</tt>)</li>
--   </ol>
class (PAdditiveGroup a, PMultiplicativeMonoid a) => PRing (a :: S -> Type)
pfromInteger :: forall (s :: S). PRing a => Integer -> Term s a
pfromInteger :: forall (s :: S). (PRing a, PRing (PInner a)) => Integer -> Term s a

-- | <h1>Laws</h1>
--   
--   <h1>Pedantry note</h1>
--   
--   Technically, the requirements here are too strong: we demand an
--   <i>ordered</i> ring, which integral domains don't necessarily have to
--   be. However, in our case, our hand is forced by expected semantics: in
--   abstract algebra, both the absolute value and the signum are real
--   numbers (which are always totally ordered) but in our case, both must
--   be elements of the integral domain itself. Thus, in order for the laws
--   to make any sense, we have to ensure a total order on the integral
--   domain. Since all of our integral domains are 'at least as big' as the
--   integers, this doesn't pose a huge problem.
class (PRing a, POrd a) => PIntegralDomain (a :: S -> Type)
psignum :: forall (s :: S). PIntegralDomain a => Term s (a :--> a)
psignum :: forall (s :: S). PIntegralDomain a => Term s (a :--> a)
pabs :: forall (s :: S). PIntegralDomain a => Term s (a :--> a)
pabs :: forall (s :: S). PIntegralDomain a => Term s (a :--> a)

positiveToInteger :: Positive -> Integer

-- | Converts negative <a>Integer</a>s into their absolute values, positive
--   <a>Integer</a>s into their <a>Positive</a> equivalents. Errors on 0.
toPositiveAbs :: Integer -> Positive

-- | Partial version of <a>ppositive</a>. Errors if argument is not
--   positive.
ptryPositive :: forall (s :: S). Term s (PInteger :--> PPositive)

-- | Build a <a>PPositive</a> from a <a>PInteger</a>. Yields
--   <a>PNothing</a> if argument is not positive.
ppositive :: Term s (PInteger :--> PMaybe PPositive)

-- | Partial version of <a>pnatural</a>. Errors if argument is negative.
ptryNatural :: forall (s :: S). Term s (PInteger :--> PNatural)

-- | Build a <a>PNatural</a> from a <a>PInteger</a>. Yields <a>PNothing</a>
--   if given a negative value.
pnatural :: forall (s :: S). Term s (PInteger :--> PMaybe PNatural)

-- | 'Relax' a <a>PPositive</a> to <a>PNatural</a>. This uses
--   <a>punsafeCoerce</a> underneath, but because any positive is also a
--   natural, is safe.
ppositiveToNatural :: forall (s :: S). Term s (PPositive :--> PNatural)

-- | Specialized form of <tt>pmaybe</tt> for <a>PNatural</a>. Given a
--   default, and a way to turn a <a>PPositive</a> into an answer, produce
--   the default when given <a>pzero</a>, and apply the function otherwise.
pnaturalToPositiveCPS :: forall (a :: S -> Type) (s :: S). Term s a -> (Term s PPositive -> Term s a) -> Term s PNatural -> Term s a

-- | A default implementation of exponentiation-by-squaring with a
--   strictly-positive exponent.
--   
--   <h1>Important note</h1>
--   
--   This implementation assumes that the operation argument is
--   associative.
pbySquaringDefault :: forall (a :: S -> Type) (s :: S). (forall (s' :: S). Term s' a -> Term s' a -> Term s' a) -> Term s a -> Term s PPositive -> Term s a

pdiv :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))

pmod :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))

pquot :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))

prem :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Internal.Numeric.PPositive
instance Plutarch.Internal.Ord.POrd Plutarch.Internal.Numeric.PPositive
instance Plutarch.Internal.Eq.PEq Plutarch.Internal.Numeric.PPositive
instance Plutarch.Internal.IsData.PIsData Plutarch.Internal.Numeric.PPositive
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Internal.Numeric.PPositive s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Internal.Numeric.PPositive s)
instance Prettyprinter.Internal.Pretty Plutarch.Internal.Numeric.Positive
instance Test.QuickCheck.Arbitrary.CoArbitrary Plutarch.Internal.Numeric.Positive
instance Test.QuickCheck.Arbitrary.Arbitrary Plutarch.Internal.Numeric.Positive
instance GHC.Classes.Ord Plutarch.Internal.Numeric.Positive
instance GHC.Classes.Eq Plutarch.Internal.Numeric.Positive
instance GHC.Show.Show Plutarch.Internal.Numeric.Positive
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Internal.Numeric.PNatural
instance Plutarch.Internal.Ord.POrd Plutarch.Internal.Numeric.PNatural
instance Plutarch.Internal.Eq.PEq Plutarch.Internal.Numeric.PNatural
instance Plutarch.Internal.IsData.PIsData Plutarch.Internal.Numeric.PNatural
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Internal.Numeric.PNatural s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Internal.Numeric.PNatural s)
instance Plutarch.Internal.Lift.PLiftable Plutarch.Internal.Numeric.PPositive
instance Plutarch.Internal.Numeric.PIntegralDomain Plutarch.Builtin.Integer.PInteger
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). Plutarch.Internal.Numeric.PIntegralDomain a => GHC.Num.Num (Plutarch.Internal.Term.Term s a)
instance Plutarch.Internal.Numeric.PRing Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.Numeric.PMultiplicativeMonoid Plutarch.Internal.Numeric.PPositive
instance Plutarch.Internal.Numeric.PMultiplicativeMonoid Plutarch.Internal.Numeric.PNatural
instance Plutarch.Internal.Numeric.PMultiplicativeMonoid Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.Numeric.PAdditiveSemigroup Plutarch.Internal.Numeric.PPositive
instance Plutarch.Internal.Numeric.PAdditiveSemigroup Plutarch.Internal.Numeric.PNatural
instance Plutarch.Internal.Numeric.PAdditiveSemigroup Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.Numeric.PAdditiveMonoid Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.Numeric.PAdditiveMonoid Plutarch.Internal.Numeric.PNatural
instance Plutarch.Internal.Numeric.PAdditiveGroup Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.Numeric.PMultiplicativeSemigroup Plutarch.Internal.Numeric.PPositive
instance Plutarch.Internal.Numeric.PMultiplicativeSemigroup Plutarch.Internal.Numeric.PNatural
instance Plutarch.Internal.Numeric.PMultiplicativeSemigroup Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.Numeric.PMultiplicativeSemigroup Plutarch.Builtin.BLS.PBuiltinBLS12_381_MlResult
instance Plutarch.Internal.Numeric.PAdditiveGroup Plutarch.Builtin.BLS.PBuiltinBLS12_381_G1_Element
instance Plutarch.Internal.Numeric.PAdditiveGroup Plutarch.Builtin.BLS.PBuiltinBLS12_381_G2_Element
instance Plutarch.Internal.Numeric.PAdditiveMonoid Plutarch.Builtin.BLS.PBuiltinBLS12_381_G1_Element
instance Plutarch.Internal.Numeric.PAdditiveMonoid Plutarch.Builtin.BLS.PBuiltinBLS12_381_G2_Element
instance Plutarch.Internal.Numeric.PAdditiveSemigroup Plutarch.Builtin.BLS.PBuiltinBLS12_381_G1_Element
instance Plutarch.Internal.Numeric.PAdditiveSemigroup Plutarch.Builtin.BLS.PBuiltinBLS12_381_G2_Element
instance Plutarch.Internal.Lift.PLiftable Plutarch.Internal.Numeric.PNatural
instance Test.QuickCheck.Function.Function Plutarch.Internal.Numeric.Positive

module Plutarch.String

-- | Plutus <tt>BuiltinString</tt> values
data PString s

-- | Verify if the given argument is the ASCII encoding of a hex digit.
--   This includes specifically the following ASCII ranges (inclusively):
--   
--   <ul>
--   <li>48-54 (digits 0 through 9)</li>
--   <li>65-70 (upper-case A through upper-case F)</li>
--   <li>97-102 (lower-case a through lower-case f)</li>
--   </ul>
pisHexDigit :: forall (s :: S). Term s (PInteger :--> PBool)

-- | Encode a <a>PString</a> using UTF-8.
pencodeUtf8 :: Term s (PString :--> PByteString)

-- | Decode a <a>PByteString</a> using UTF-8.
pdecodeUtf8 :: Term s (PByteString :--> PString)

module Plutarch.Internal.TryFrom

-- | <tt>PTryFrom a b</tt> represents a subtyping relationship between
--   <tt>a</tt> and <tt>b</tt>, and a way to go from <tt>a</tt> to
--   <tt>b</tt>. Laws: - <tt>(punsafeCoerce . fst) <a>$</a> tcont (ptryFrom
--   x)  pure x</tt>
class PSubtype a b => PTryFrom (a :: PType) (b :: PType)
type PTryFromExcess a b :: PType
ptryFrom' :: forall s r. PTryFrom a b => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r
ptryFrom :: forall b a s r. PTryFrom a b => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r
data PSubtypeRelation
PSubtypeRelation :: PSubtypeRelation
PNoSubtypeRelation :: PSubtypeRelation
type family PSubtype (a :: PType) (b :: PType) :: Constraint
type family PSubtype' (a :: PType) (b :: PType) :: PSubtypeRelation
pupcast :: forall a b s. PSubtype a b => Term s b -> Term s a
pupcastF :: forall a b (p :: PType -> PType) s. (PSubtype a b, PCovariant p) => Proxy p -> Term s (p b) -> Term s (p a)
pdowncastF :: forall a b (p :: PType -> PType) s. (PSubtype a b, PContravariant p) => Proxy p -> Term s (p a) -> Term s (p b)
instance forall k1 k2 (f :: k2 -> k1 -> GHC.Types.Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.Internal.TryFrom.Flip @{k2} @{k1} f a b)
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData Plutarch.Builtin.Integer.PInteger)
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData Plutarch.Builtin.ByteString.PByteString)
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData (Plutarch.Builtin.Data.PBuiltinList Plutarch.Builtin.Data.PData))
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData a), Plutarch.Internal.IsData.PIsData a) => Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData (Plutarch.Builtin.Data.PBuiltinList (Plutarch.Builtin.Data.PAsData a)))
instance forall (a :: Plutarch.Internal.Term.PType) (a' :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.PType) (b' :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData a, (a :: Plutarch.Internal.Term.PType) GHC.Types.~ (Plutarch.Builtin.Data.PAsData a' :: Plutarch.Internal.Term.PType), Plutarch.Internal.IsData.PIsData a', Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData b, (b :: Plutarch.Internal.Term.PType) GHC.Types.~ (Plutarch.Builtin.Data.PAsData b' :: Plutarch.Internal.Term.PType), Plutarch.Internal.IsData.PIsData b') => Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData (Plutarch.Builtin.Data.PBuiltinPair a b))
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData Plutarch.Internal.Numeric.PPositive)
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData Plutarch.Builtin.Bool.PBool)
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData Plutarch.Builtin.Data.PData)
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData Plutarch.Builtin.Data.PData
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Integer.PInteger Plutarch.Internal.Numeric.PPositive

module Plutarch.Internal.Show
class PShow t

-- | Return the string representation of a Plutarch value
--   
--   If the wrap argument is True, optionally wrap the output in `(..)` if
--   it represents multiple parameters.
pshow' :: PShow t => Bool -> Term s t -> Term s PString

-- | Return the string representation of a Plutarch value
--   
--   If the wrap argument is True, optionally wrap the output in `(..)` if
--   it represents multiple parameters.
pshow' :: (PShow t, PGeneric t, PlutusType t, All2 PShow (PCode t)) => Bool -> Term s t -> Term s PString

-- | Return the string representation of a Plutarch value
pshow :: PShow a => Term s a -> Term s PString

-- | Causes an error where the input is shown in the message. Works for all
--   types.
pshowAndErr :: Term s a -> Term s b
pshowList :: forall list a s. (PShow a, PIsListLike list a) => Term s (list a :--> PString)
instance Plutarch.Internal.Show.PShow Plutarch.Builtin.Unit.PUnit
instance Plutarch.Internal.Show.PShow Plutarch.Builtin.String.PString
instance Plutarch.Internal.Show.PShow Plutarch.Builtin.Bool.PBool
instance Plutarch.Internal.Show.PShow Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.Show.PShow Plutarch.Builtin.ByteString.PByteString
instance Plutarch.Internal.Show.PShow Plutarch.Builtin.Data.PData
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.IsData.PIsData a, Plutarch.Internal.Show.PShow a) => Plutarch.Internal.Show.PShow (Plutarch.Builtin.Data.PAsData a)
instance forall (a :: Plutarch.Internal.Term.PType). (Plutarch.Internal.Show.PShow a, Universe.Core.Contains @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni (Plutarch.Internal.Lift.PlutusRepr a)) => Plutarch.Internal.Show.PShow (Plutarch.Builtin.Data.PBuiltinList a)
instance forall (a :: Plutarch.Internal.Term.PType) (b :: Plutarch.Internal.Term.PType). (Plutarch.Internal.Show.PShow a, Plutarch.Internal.Show.PShow b) => Plutarch.Internal.Show.PShow (Plutarch.Builtin.Data.PBuiltinPair a b)
instance Plutarch.Internal.Show.PShow Plutarch.Internal.Numeric.PPositive
instance forall (a :: Plutarch.Internal.Term.PType). Plutarch.Internal.Show.PShow a => Plutarch.Internal.Show.PShow (Plutarch.Maybe.PMaybe a)

module Plutarch.Trace

-- | Trace the given message at the info level before evaluating the given
--   argument.
ptraceInfo :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

-- | Like Haskell's <tt>traceShowId</tt> but for Plutarch, at the info
--   level.
ptraceInfoShowId :: forall (a :: S -> Type) (s :: S). PShow a => Term s a -> Term s a

-- | Trace the given message at the info level, then terminate with
--   <a>perror</a>.
ptraceInfoError :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a

-- | Trace the given message at the info level if the argument is true.
ptraceInfoIfTrue :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the info level if the argument is false.
ptraceInfoIfFalse :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the debug level before evaluating the given
--   argument.
ptraceDebug :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

-- | Like Haskell's <tt>traceShowId</tt> but for Plutarch, at the debug
--   level.
ptraceDebugShowId :: forall (a :: S -> Type) (s :: S). PShow a => Term s a -> Term s a

-- | Trace the given message at the debug level if the argument is true.
ptraceDebugIfTrue :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the debug level if the argument is false.
ptraceDebugIfFalse :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the debug level, then terminate with
--   <a>perror</a>.
ptraceDebugError :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a

-- | Backward compatibility synonym for <a>ptraceInfo</a>.

-- | <i>Deprecated: Use ptraceInfo</i>
ptrace :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

-- | Synonym for <a>ptraceInfoShowId</a>.

-- | <i>Deprecated: Use ptraceInfoShowId</i>
ptraceShowId :: forall (a :: S -> Type) (s :: S). PShow a => Term s a -> Term s a

-- | Synonym for <a>ptraceInfoError</a>.

-- | <i>Deprecated: Use ptraceInfoError</i>
ptraceError :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a

-- | Synonym for <a>ptraceInfoIfTrue</a>.

-- | <i>Deprecated: Use ptraceInfoIfTrue</i>
ptraceIfTrue :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Synonym for <a>ptraceInfoIfFalse</a>.

-- | <i>Deprecated: Use ptraceInfoIfFalse</i>
ptraceIfFalse :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

module Plutarch.TermCont
hashOpenTerm :: Term s a -> TermCont s Dig
newtype TermCont :: forall (r :: PType). S -> Type -> Type
[TermCont] :: forall r s a. ((a -> Term s r) -> Term s r) -> TermCont @r s a
($sel:runTermCont:TermCont) :: TermCont @r s a -> (a -> Term s r) -> Term s r
unTermCont :: TermCont @a s (Term s a) -> Term s a
tcont :: ((a -> Term s r) -> Term s r) -> TermCont @r s a

-- | Given a term, and an integer tag, this function checks if the term
--   holds and <tt>PPlaceholder</tt> with the given integer tag.
pfindPlaceholder :: Integer -> Term s a -> TermCont s Bool

-- | Finds all placeholder ids and returns it
pfindAllPlaceholders :: Term s a -> TermCont s [Integer]

-- | Like <a>plet</a> but works in a <a>TermCont</a> monad
pletC :: Term s a -> TermCont s (Term s a)

-- | Like <a>pmatch</a> but works in a <a>TermCont</a> monad
pmatchC :: PlutusType a => Term s a -> TermCont s (a s)

-- | Like <tt>ptrace</tt> but works in a <a>TermCont</a> monad.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   foo :: Term s PUnit
--   foo = unTermCont $ do
--     ptraceC "returning unit!"
--     pure $ pconstant ()
--   </pre>
ptraceC :: Term s PString -> TermCont s ()

-- | Trace a message and raise error if <tt>cond</tt> is false. Otherwise,
--   continue.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   onlyAllow42 :: Term s (PInteger :--&gt; PUnit)
--   onlyAllow42 = plam $ i -&gt; unTermCont $ do
--     pguardC "expected 42" $ i #== 42
--     pure $ pconstant ()
--   </pre>
pguardC :: Term s PString -> Term s PBool -> TermCont s ()

-- | Stop computation and return given term if <tt>cond</tt> is false.
--   Otherwise, continue.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   is42 :: Term s (PInteger :--&gt; PBool)
--   is42 = plam $ i -&gt; unTermCont $ do
--     pguardC' (pconstant False) $ i #== 42
--     pure $ pconstant True
--   </pre>
pguardC' :: Term s a -> Term s PBool -> TermCont @a s ()

-- | <a>TermCont</a> producing version of <a>ptryFrom</a>.
ptryFromC :: forall b r a s. PTryFrom a b => Term s a -> TermCont @r s (Term s b, Reduce (PTryFromExcess a b s))

-- | Escape with a particular value on expecting <a>PJust</a>. For use in
--   monadic context.
pexpectJustC :: forall (a :: S -> Type) (r :: S -> Type) (s :: S). Term s r -> Term s (PMaybe a) -> TermCont @r s (Term s a)

module Plutarch.Repr.Tag

newtype PTag (struct :: [S -> Type]) (s :: S)
PTag :: Term s PInteger -> PTag (struct :: [S -> Type]) (s :: S)

[$sel:unPTag:PTag] :: PTag (struct :: [S -> Type]) (s :: S) -> Term s PInteger

newtype TagLiftHelper r struct
TagLiftHelper :: (Integer -> (SOP I struct -> r) -> r) -> TagLiftHelper r struct

[$sel:unTagLiftHelper:TagLiftHelper] :: TagLiftHelper r struct -> Integer -> (SOP I struct -> r) -> r

-- | @since IWP
newtype DeriveTagPlutusType (a :: S -> Type) s
DeriveTagPlutusType :: a s -> DeriveTagPlutusType (a :: S -> Type) s

-- | @since WIP
[$sel:unDeriveTagPlutusType:DeriveTagPlutusType] :: DeriveTagPlutusType (a :: S -> Type) s -> a s

-- | @since WIP
newtype DeriveTagPLiftable (a :: S -> Type) (h :: Type) s
DeriveTagPLiftable :: a s -> DeriveTagPLiftable (a :: S -> Type) (h :: Type) s

-- | @since WIP
[$sel:unDeriveTagPLiftable:DeriveTagPLiftable] :: DeriveTagPLiftable (a :: S -> Type) (h :: Type) s -> a s
instance forall (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Repr.Tag.PTag struct s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) h. Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Tag.DeriveTagPLiftable a h)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) h (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Repr.Tag.DeriveTagPLiftable a h s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) h (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Repr.Tag.DeriveTagPLiftable a h s)
instance forall (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Tag.PTag struct)
instance forall (a :: Plutarch.Internal.Term.PType) h. (Plutarch.Internal.PlutusType.PlutusType a, Generics.SOP.Universe.Generic h, Plutarch.Repr.Tag.TagTypeConstraints @{Plutarch.Internal.Term.S} (GHC.Types.Any @Plutarch.Internal.Term.S) a (Generics.SOP.Universe.Code h)) => Plutarch.Internal.Lift.PLiftable (Plutarch.Repr.Tag.DeriveTagPLiftable a h)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (struct :: [[GHC.Types.Type]]). (forall (s :: Plutarch.Internal.Term.S). Plutarch.Repr.Tag.TagTypeConstraints @{Plutarch.Internal.Term.S} s a struct) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Tag.DeriveTagPlutusType a)
instance forall k (a :: k -> GHC.Types.Type) (s :: k) (struct :: [[GHC.Types.Type]]). (Generics.SOP.Universe.Generic (a s), Plutarch.Repr.Tag.TagTypePrettyError (Generics.SOP.Universe.Code (a s)), (Generics.SOP.Universe.Code (a s) :: [[GHC.Types.Type]]) GHC.Types.~ (struct :: [[GHC.Types.Type]]), Data.SOP.Constraint.All @[GHC.Types.Type] (Plutarch.Repr.Tag.IsEmpty @GHC.Types.Type) struct) => Plutarch.Repr.Tag.TagTypeConstraints @{k} s a struct
instance forall k1 k2 (x :: [k1]). ((x :: [k1]) GHC.Types.~ ('[] @k1 :: [k1])) => Plutarch.Repr.Tag.IsEmpty @k2 ('[] @k2)
instance forall (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]) (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Repr.Tag.PTag struct s)

module Plutarch.Repr.Data

newtype PDataStruct (struct :: [[S -> Type]]) (s :: S)
PDataStruct :: PStruct struct s -> PDataStruct (struct :: [[S -> Type]]) (s :: S)
[$sel:unPDataStruct:PDataStruct] :: PDataStruct (struct :: [[S -> Type]]) (s :: S) -> PStruct struct s

newtype PDataRec (struct :: [S -> Type]) (s :: S)
PDataRec :: PRec struct s -> PDataRec (struct :: [S -> Type]) (s :: S)
[$sel:unPDataRec:PDataRec] :: PDataRec (struct :: [S -> Type]) (s :: S) -> PRec struct s

-- | <tt>DeriveAsDataRec</tt> derives <tt>PlutusType</tt> instances for
--   given type as builtin list of Data. Unlike <tt>PDataAsDataStruct</tt>
--   above, this will encode data as <tt>List</tt>. Similarly, only types
--   with its innermost representation <tt>PData</tt> is allowed for its
--   fields.
--   
--   One major difference is that <tt>DeriveAsDataRec</tt> only allows
--   single constructor as it does not encode the constructor index. When
--   attempted to use this strategy to a type with more than one
--   constructor will result in type error with detailed explanation of the
--   issue.
--   
--   <tt>PInner</tt> of defined type will be <tt>PDataRec (struct :: [S
--   -&gt; Type])</tt> where <tt>struct</tt> is product type of its
--   structure. <tt>PInner</tt> of <tt>PDataRec struct</tt> is
--   <tt>PBuiltinList PData</tt>.
--   
--   It is almost always better to use <tt>DeriveAsDataRec</tt> over
--   <tt>DeriveAsDataStruct</tt> when data type only have one constructor
--   as it is more efficient to work with on-chain. However,
--   Plith(previously PlutusTx), by default, derives every datatype to use
--   <tt>Constr</tt>. So, if a Plutarch type needs to remain compatible
--   with type defined in Plith, one needs to use
--   <tt>DeriveAsDataStruct</tt>. This is why many single-constructor types
--   are derived using <tt>DeriveAsDataStruct</tt> on plutarch-ledger-api.
--   
--   Consult example below for defining custom data-encoded datatype: @@
--   data PBobData (a :: S -&gt; Type) (s :: S) = PBobData (Term s (PAsData
--   a)) (Term s (PAsData PBool)) deriving stock (Generic) deriving
--   anyclass (SOP.Generic) deriving PlutusType via (DeriveAsDataRec
--   (PBobData a))
--   
--   pcon $ PBobData (pdata 10) (pdata pfalse) -- [#10, #false] @@
newtype DeriveAsDataRec (a :: S -> Type) s
DeriveAsDataRec :: a s -> DeriveAsDataRec (a :: S -> Type) s
[$sel:unDeriveAsDataRec:DeriveAsDataRec] :: DeriveAsDataRec (a :: S -> Type) s -> a s

-- | <tt>DeriveAsDataStruct</tt> derives <tt>PlutusType</tt> instances for
--   the given type as Data structure, namely, using <tt>Constr</tt>
--   constructor of the <tt>Data</tt> type. Each constructor of the given
--   type will have matching constructor index in the order of its
--   definition.
--   
--   Also, it is important to note that each fields can only contain term
--   that has innermost representation of Data. Hence, <tt>PInteger</tt> is
--   not allowed but <tt>PAsData PInteger</tt> is allowed. Failure to
--   follow this requirement will result in type error with detailed
--   explanation of the issue.
--   
--   <tt>PInner</tt> of defined type will be <tt>PDataStruct (struct :: [[S
--   -&gt; Type]])</tt> where <tt>struct</tt> is SOP type of its structure.
--   Since <tt>PInner</tt> of <tt>PDataStruct</tt> is <tt>PData</tt>,
--   multiple data encoded structure can be nested without being wrapped in
--   <tt>PAsData</tt>.
--   
--   Consult example below for defining custom data-encoded datatype: @@
--   data PBobData (a :: S -&gt; Type) (s :: S) = PBobData (Term s (PAsData
--   a)) (Term s (PAsData PBool)) | PRobData (Term s (PAsData PByteString))
--   deriving stock (Generic) deriving anyclass (SOP.Generic) deriving
--   PlutusType via (DeriveAsDataStruct (PBobData a))
--   
--   pcon $ PBobData (pdata 10) (pdata pfalse) -- Constr 0 [#10, #false]
--   pcon $ PRobData "hello" -- Constr 1 [#"hello"] @@
newtype DeriveAsDataStruct (a :: S -> Type) s
DeriveAsDataStruct :: a s -> DeriveAsDataStruct (a :: S -> Type) s
[$sel:unDeriveAsDataStruct:DeriveAsDataStruct] :: DeriveAsDataStruct (a :: S -> Type) s -> a s
instance forall (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]) (hstruct :: [GHC.Types.Type]). (Data.SOP.Constraint.SListI @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct, Data.SOP.Constraint.All @(Plutarch.Internal.Term.S -> GHC.Types.Type) Plutarch.Repr.Data.EachDataLiftable struct, Data.SOP.Constraint.All @Plutarch.Internal.Term.PType Plutarch.Repr.Data.PInnermostIsDataDataRepr struct, (hstruct :: [GHC.Types.Type]) GHC.Types.~ (Plutarch.Repr.Internal.RecAsHaskell struct :: [GHC.Types.Type]), Data.SOP.Constraint.AllZip @GHC.Types.Type @(Plutarch.Internal.Term.S -> GHC.Types.Type) Plutarch.Repr.Data.ToAsHaskell hstruct struct) => Plutarch.Internal.Lift.PLiftable (Plutarch.Repr.Data.PDataRec struct)
instance forall a (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). ((a :: GHC.Types.Type) GHC.Types.~ (Plutarch.Internal.Lift.AsHaskell b :: GHC.Types.Type), Plutarch.Internal.Lift.PLiftable b, (Plutarch.Internal.Lift.PlutusRepr b :: GHC.Types.Type) GHC.Types.~ (PlutusCore.Data.Data :: GHC.Types.Type)) => Plutarch.Repr.Data.ToAsHaskell a b
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Lift.PLiftable a, (Plutarch.Internal.Lift.PlutusRepr a :: GHC.Types.Type) GHC.Types.~ (PlutusCore.Data.Data :: GHC.Types.Type)) => Plutarch.Repr.Data.EachDataLiftable a
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). (Generics.SOP.Universe.Generic (a (GHC.Types.Any @Plutarch.Internal.Term.S)), (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]) GHC.Types.~ (Plutarch.Repr.Internal.UnTermStruct (a (GHC.Types.Any @Plutarch.Internal.Term.S)) :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]), Data.SOP.Constraint.All2 @{Plutarch.Internal.Term.PType} Plutarch.Repr.Data.PInnermostIsDataDataRepr struct, Data.SOP.Constraint.SListI2 @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct, forall (s :: Plutarch.Internal.Term.S). Plutarch.Repr.Internal.StructSameRepr @{[[Plutarch.Internal.Term.S -> GHC.Types.Type]]} s a struct) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Data.DeriveAsDataStruct a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (struct' :: [GHC.Types.Type]) (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]). (Generics.SOP.Universe.Generic (a (GHC.Types.Any @Plutarch.Internal.Term.S)), ((':) @[GHC.Types.Type] struct' ('[] @[GHC.Types.Type]) :: [[GHC.Types.Type]]) GHC.Types.~ (Generics.SOP.Universe.Code (a (GHC.Types.Any @Plutarch.Internal.Term.S)) :: [[GHC.Types.Type]]), (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]) GHC.Types.~ (Plutarch.Repr.Internal.UnTermRec struct' :: [Plutarch.Internal.Term.S -> GHC.Types.Type]), Data.SOP.Constraint.All @Plutarch.Internal.Term.PType Plutarch.Repr.Data.PInnermostIsDataDataRepr struct, Data.SOP.Constraint.SListI @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct, forall (s :: Plutarch.Internal.Term.S). Plutarch.Repr.Internal.StructSameRepr @{[[Plutarch.Internal.Term.S -> GHC.Types.Type]]} s a ((':) @[Plutarch.Internal.Term.S -> GHC.Types.Type] struct ('[] @[Plutarch.Internal.Term.S -> GHC.Types.Type])), Plutarch.Repr.Internal.RecTypePrettyError @{GHC.Types.Type} (Generics.SOP.Universe.Code (a (GHC.Types.Any @Plutarch.Internal.Term.S)))) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Data.DeriveAsDataRec a)
instance forall (struct :: [Plutarch.Internal.Term.PType]). (Data.SOP.Constraint.SListI @{Plutarch.Internal.Term.PType} struct, Data.SOP.Constraint.All @Plutarch.Internal.Term.PType Plutarch.Repr.Data.PInnermostIsDataDataRepr struct) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Data.PDataRec struct)
instance forall (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]). Plutarch.Internal.Eq.PEq (Plutarch.Repr.Data.PDataRec struct)
instance forall (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]). Plutarch.Internal.IsData.PIsData (Plutarch.Repr.Data.PDataRec struct)
instance forall (struct :: [[Plutarch.Internal.Term.PType]]). (Data.SOP.Constraint.SListI2 @{Plutarch.Internal.Term.PType} struct, Data.SOP.Constraint.All2 @{Plutarch.Internal.Term.PType} Plutarch.Repr.Data.PInnermostIsDataDataRepr struct) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Data.PDataStruct struct)
instance forall (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). Plutarch.Internal.Eq.PEq (Plutarch.Repr.Data.PDataStruct struct)
instance forall (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). Plutarch.Internal.IsData.PIsData (Plutarch.Repr.Data.PDataStruct struct)

module Plutarch.Monadic

-- | Bind function used within do syntax.
--   
--   Enables elegant usage of <tt>pmatch</tt> and similar. <tt>P.do { y
--   &lt;- x ; z }</tt> is equivalent to <tt>x $ y -&gt; z</tt>.
--   
--   <pre>
--   import qualified Plutarch.Monadic as P
--   
--   f :: Term s (PTxInfo :--&gt; PBuiltinList (PAsData PTxInInfo))
--   f = plam $ x -&gt; P.do
--     PTxInfo txInfoFields &lt;- pmatch x
--     pfromData $ pdhead # txInfoFields
--   </pre>
(>>=) :: (x -> Term s a) -> x -> Term s a

-- | Forgetful bind function used within do syntax.
--   
--   Enables elegant usage of <tt>ptrace</tt> and similar. <tt>P.do { x ; y
--   }</tt> is equivalent to <tt>x y</tt>.
--   
--   <pre>
--   import qualified Plutarch.Monadic as P
--   
--   P.do
--     ptrace "yielding unit"
--     pconstant ()
--   </pre>
(>>) :: (x -> Term s a) -> x -> Term s a

-- | Implicitly invoked upon pattern match failure within do syntax.
--   
--   <pre>
--   import qualified Plutarch.Monadic as P
--   
--   P.do
--     -- calls <a>fail</a>, traces an error message, and invokes <tt>perror</tt>.
--     PTrue &lt;- pconstant False
--   </pre>
fail :: String -> Term s a

module Plutarch.Internal.Semigroup

-- | <h1>Laws</h1>
--   
--   The only mandatory law is that <a>#&lt;&gt;</a> must be associative:
--   
--   <tt>x #&lt;&gt; (y #&lt;&gt; z)</tt> <tt>=</tt> <tt>(x #&lt;&gt; y)
--   #&lt;&gt; z</tt>
--   
--   If you define <a>pstimes</a>, ensure the following also hold:
--   
--   <ol>
--   <li><tt>pstimes pone x</tt> <tt>=</tt> <tt>x</tt></li>
--   <li><tt>(pstimes p1 x) #&lt;&gt; (pstimes p2 x)</tt> <tt>=</tt>
--   <tt>pstimes (p1 #+ p2) x</tt></li>
--   <li><tt>pstimes p1 (pstimes p2 x)</tt> <tt>=</tt> <tt>pstimes (p1 #*
--   p2) x</tt></li>
--   </ol>
--   
--   The default implementation automatically ensures these laws hold.
class PSemigroup (a :: S -> Type)
(#<>) :: forall (s :: S). PSemigroup a => Term s a -> Term s a -> Term s a
(#<>) :: forall (s :: S). (PSemigroup a, PSemigroup (PInner a)) => Term s a -> Term s a -> Term s a
pstimes :: forall (s :: S). PSemigroup a => Term s PPositive -> Term s a -> Term s a
infixr 6 #<>

-- | <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>pmempty #&lt;&gt; x</tt> <tt>=</tt> <tt>x #&lt;&gt;
--   pmempty</tt> <tt>=</tt> <tt>x</tt></li>
--   <li><tt>pstimes n pmempty</tt> <tt>=</tt> <tt>pmempty</tt></li>
--   </ol>
--   
--   If you define <a>pmtimes</a>, ensure the following as well:
--   
--   <ol>
--   <li><tt>pmtimes (ppositiveToNatural # p) x</tt> <tt>=</tt> <tt>pstimes
--   p x</tt></li>
--   <li><tt>pmtimes pzero x</tt> <tt>=</tt> <tt>pmempty</tt></li>
--   </ol>
--   
--   The default implementation of <a>pmtimes</a> ensures these laws hold.
class PSemigroup a => PMonoid (a :: S -> Type)
pmempty :: forall (s :: S). PMonoid a => Term s a
pmempty :: forall (s :: S). (PMonoid a, PMonoid (PInner a)) => Term s a
pmtimes :: forall (s :: S). PMonoid a => Term s PNatural -> Term s a -> Term s a

-- | Wrapper for types which have logical AND semantics somehow.
newtype PAnd (a :: S -> Type) (s :: S)
PAnd :: Term s a -> PAnd (a :: S -> Type) (s :: S)

-- | Wrapper for types which have logical OR semantics somehow.
newtype POr (a :: S -> Type) (s :: S)
POr :: Term s a -> POr (a :: S -> Type) (s :: S)

-- | Wrapper for types which have logical XOR semantics somehow.
newtype PXor (a :: S -> Type) (s :: S)
PXor :: Term s a -> PXor (a :: S -> Type) (s :: S)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Semigroup.PAnd a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Ord.POrd a => Plutarch.Internal.Ord.POrd (Plutarch.Internal.Semigroup.PAnd a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Eq.PEq a => Plutarch.Internal.Eq.PEq (Plutarch.Internal.Semigroup.PAnd a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Internal.Semigroup.PAnd a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Internal.Semigroup.PAnd a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Semigroup.POr a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Ord.POrd a => Plutarch.Internal.Ord.POrd (Plutarch.Internal.Semigroup.POr a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Eq.PEq a => Plutarch.Internal.Eq.PEq (Plutarch.Internal.Semigroup.POr a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Internal.Semigroup.POr a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Internal.Semigroup.POr a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Semigroup.PXor a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Ord.POrd a => Plutarch.Internal.Ord.POrd (Plutarch.Internal.Semigroup.PXor a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Eq.PEq a => Plutarch.Internal.Eq.PEq (Plutarch.Internal.Semigroup.PXor a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Internal.Semigroup.PXor a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Internal.Semigroup.PXor a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Lift.PLiftable a, Universe.Core.Includes @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni (Plutarch.Internal.Lift.PlutusRepr a)) => Plutarch.Internal.Lift.PLiftable (Plutarch.Internal.Semigroup.PAnd a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Lift.PLiftable a, Universe.Core.Includes @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni (Plutarch.Internal.Lift.PlutusRepr a)) => Plutarch.Internal.Lift.PLiftable (Plutarch.Internal.Semigroup.POr a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Lift.PLiftable a, Universe.Core.Includes @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni (Plutarch.Internal.Lift.PlutusRepr a)) => Plutarch.Internal.Lift.PLiftable (Plutarch.Internal.Semigroup.PXor a)
instance Plutarch.Internal.Semigroup.PSemigroup (Plutarch.Internal.Semigroup.PXor Plutarch.Builtin.Bool.PBool)
instance Plutarch.Internal.Semigroup.PMonoid (Plutarch.Internal.Semigroup.PXor Plutarch.Builtin.Bool.PBool)
instance Plutarch.Internal.Semigroup.PSemigroup (Plutarch.Internal.Semigroup.PXor Plutarch.Builtin.ByteString.PByteString)
instance Plutarch.Internal.Semigroup.PMonoid (Plutarch.Internal.Semigroup.PXor Plutarch.Builtin.ByteString.PByteString)
instance Plutarch.Internal.Semigroup.PSemigroup (Plutarch.Internal.Semigroup.POr Plutarch.Builtin.Bool.PBool)
instance Plutarch.Internal.Semigroup.PMonoid (Plutarch.Internal.Semigroup.POr Plutarch.Builtin.Bool.PBool)
instance Plutarch.Internal.Semigroup.PSemigroup (Plutarch.Internal.Semigroup.POr Plutarch.Builtin.ByteString.PByteString)
instance Plutarch.Internal.Semigroup.PMonoid (Plutarch.Internal.Semigroup.POr Plutarch.Builtin.ByteString.PByteString)
instance Plutarch.Internal.Semigroup.PSemigroup (Plutarch.Internal.Semigroup.PAnd Plutarch.Builtin.Bool.PBool)
instance Plutarch.Internal.Semigroup.PMonoid (Plutarch.Internal.Semigroup.PAnd Plutarch.Builtin.Bool.PBool)
instance Plutarch.Internal.Semigroup.PSemigroup (Plutarch.Internal.Semigroup.PAnd Plutarch.Builtin.ByteString.PByteString)
instance Plutarch.Internal.Semigroup.PMonoid (Plutarch.Internal.Semigroup.PAnd Plutarch.Builtin.ByteString.PByteString)
instance Plutarch.Internal.Semigroup.PMonoid Plutarch.Builtin.Unit.PUnit
instance Plutarch.Internal.Semigroup.PMonoid Plutarch.Builtin.String.PString
instance Plutarch.Internal.Semigroup.PMonoid Plutarch.Builtin.ByteString.PByteString
instance Plutarch.Internal.Semigroup.PMonoid Plutarch.Builtin.BLS.PBuiltinBLS12_381_G1_Element
instance Plutarch.Internal.Semigroup.PMonoid Plutarch.Builtin.BLS.PBuiltinBLS12_381_G2_Element
instance Plutarch.Internal.Semigroup.PSemigroup Plutarch.Builtin.Unit.PUnit
instance Plutarch.Internal.Semigroup.PSemigroup Plutarch.Builtin.String.PString
instance Plutarch.Internal.Semigroup.PSemigroup Plutarch.Builtin.ByteString.PByteString
instance Plutarch.Internal.Semigroup.PSemigroup Plutarch.Builtin.BLS.PBuiltinBLS12_381_G1_Element
instance Plutarch.Internal.Semigroup.PSemigroup Plutarch.Builtin.BLS.PBuiltinBLS12_381_G2_Element
instance Plutarch.Internal.Semigroup.PSemigroup Plutarch.Builtin.BLS.PBuiltinBLS12_381_MlResult

module Plutarch.Pair

-- | Plutus encoding of Pairs.
--   
--   Note: This is represented differently than <tt>BuiltinPair</tt>. It is
--   SoP encoded.
data PPair (a :: S -> Type) (b :: S -> Type) (s :: S)
PPair :: Term s a -> Term s b -> PPair (a :: S -> Type) (b :: S -> Type) (s :: S)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Show.PShow a, Plutarch.Internal.Show.PShow b) => Plutarch.Internal.Show.PShow (Plutarch.Pair.PPair a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Eq.PEq a, Plutarch.Internal.Eq.PEq b) => Plutarch.Internal.Eq.PEq (Plutarch.Pair.PPair a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Pair.PPair a b s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Pair.PPair a b s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Pair.PPair a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Semigroup.PSemigroup a, Plutarch.Internal.Semigroup.PSemigroup b) => Plutarch.Internal.Semigroup.PSemigroup (Plutarch.Pair.PPair a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Semigroup.PMonoid a, Plutarch.Internal.Semigroup.PMonoid b) => Plutarch.Internal.Semigroup.PMonoid (Plutarch.Pair.PPair a b)

module Plutarch.Rational

-- | A Scott-encoded rational number, with a guaranteed positive
--   denominator (and thus, a canonical form).
--   
--   <h1>Note</h1>
--   
--   This is not the Plutarch equivalent of a Plutus <tt>Rational</tt>; for
--   this, you want <tt>PRationalData</tt> from
--   <tt>plutarch-ledger-api</tt>. <a>PRational</a> is designed to optimize
--   for computation: if you want to do any serious work with rational
--   numbers that isn't just passing them around, you want to use (or
--   convert to) <a>PRational</a>.
data PRational s
PRational :: Term s PInteger -> Term s PPositive -> PRational s
preduce :: Term s (PRational :--> PRational)
pnumerator :: Term s (PRational :--> PInteger)
pdenominator :: Term s (PRational :--> PPositive)
pfromInteger :: Term s (PInteger :--> PRational)
pround :: Term s (PRational :--> PInteger)
ptruncate :: Term s (PRational :--> PInteger)
pproperFraction :: Term s (PRational :--> PPair PInteger PRational)
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Rational.PRational s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Rational.PRational s)
instance forall k1 k2 (f :: k2 -> k1 -> GHC.Types.Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.Rational.Flip @{k2} @{k1} f a b)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Rational.PRational
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData Plutarch.Rational.PRational)
instance Plutarch.Internal.Lift.PLiftable Plutarch.Rational.PRational
instance Plutarch.Internal.Eq.PEq Plutarch.Rational.PRational
instance Plutarch.Internal.Ord.POrd Plutarch.Rational.PRational
instance Plutarch.Internal.Numeric.PAdditiveSemigroup Plutarch.Rational.PRational
instance Plutarch.Internal.Numeric.PAdditiveMonoid Plutarch.Rational.PRational
instance Plutarch.Internal.Numeric.PAdditiveGroup Plutarch.Rational.PRational
instance Plutarch.Internal.Numeric.PMultiplicativeSemigroup Plutarch.Rational.PRational
instance Plutarch.Internal.Numeric.PMultiplicativeMonoid Plutarch.Rational.PRational
instance Plutarch.Internal.Numeric.PRing Plutarch.Rational.PRational
instance Plutarch.Internal.Numeric.PIntegralDomain Plutarch.Rational.PRational
instance forall (s :: Plutarch.Internal.Term.S). GHC.Real.Fractional (Plutarch.Internal.Term.Term s Plutarch.Rational.PRational)
instance Plutarch.Internal.Show.PShow Plutarch.Rational.PRational


-- | Scott-encoded lists and ListLike typeclass
module Plutarch.List

-- | SOP-encoded list.
data PList (a :: S -> Type) (s :: S)
PSCons :: Term s a -> Term s (PList a) -> PList (a :: S -> Type) (s :: S)
PSNil :: PList (a :: S -> Type) (s :: S)

-- | Extract head and tail of the list, throws error if list is empty.
ptryUncons :: PIsListLike list a => Term s (list a :--> PPair a (list a))

-- | Extract head and tail of the list, if list is not empty.
puncons :: PIsListLike list a => Term s (list a :--> PMaybe (PPair a (list a)))

-- | <i> O(min(n, m)) </i>. Zip two lists together, creating pairs of the
--   elements.
--   
--   If the lists are of differing lengths, cut to the shortest.
pzip :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list (PPair a b)) => Term s (list a :--> (list b :--> list (PPair a b)))

-- | <i> O(n) </i>. like haskell level <tt>find</tt> but on plutarch level
pfind :: PIsListLike l a => Term s ((a :--> PBool) :--> (l a :--> PMaybe a))

-- | <i> O(n) </i>. Reverse a list-like structure.
preverse :: forall (l :: (S -> Type) -> S -> Type) (a :: S -> Type) (s :: S). PIsListLike l a => Term s (l a :--> l a)

-- | <i> O(n) </i>. Checks if a list-list structure is sorted.
pcheckSorted :: forall (l :: (S -> Type) -> S -> Type) (a :: S -> Type) (s :: S). (PIsListLike l a, POrd a) => Term s (l a :--> PBool)

-- | <i> O(n) </i>. Check if element is in the list
pelem :: (PIsListLike list a, PEq a) => Term s (a :--> (list a :--> PBool))

-- | <i> O(n) </i>. Like Haskell level <a>(!!)</a> but on the plutarch
--   level
(#!!) :: PIsListLike l a => Term s (l a) -> Term s PInteger -> Term s a

-- | <i> O(n) </i>. Like Haskell level <a>(!!)</a> but on the Plutarch
--   level, not infix and with arguments reversed, errors if the specified
--   index is greater than or equal to the lists length
pelemAt :: PIsListLike l a => Term s (PInteger :--> (l a :--> a))

-- | <i> O(n) </i>. like <a>pelemAt</a> but doesn't fail on negative
--   indexes
pelemAt' :: PIsListLike l a => Term s (PInteger :--> (l a :--> a))

-- | <i> O(min(n, m)) </i>. Check if two lists are equal.
plistEquals :: (PIsListLike list a, PEq a) => Term s (list a :--> (list a :--> PBool))

-- | Match first N elements from the list. It's is better to use
--   <tt>pmatchList</tt> if number of elements that needs to be match does
--   not need to be dynamically determined. It is important to understand
--   each element given in Haskell list is "computation" to get nth
--   element. If those need to be referenced multiple times, it needs to be
--   pletted to prevent duplication of computation.
--   
--   @since WIP
pmatchListN :: forall b li a s. PIsListLike li a => Integer -> Term s (li a) -> ([Term s a] -> Term s (li a) -> Term s b) -> Term s b

-- | Same functionality to <tt>pmatchListN</tt> but each matched value will
--   be given in <tt>NP</tt> for better typing. Same performance
--   implications as <tt>pmatchListN</tt>.
--   
--   @since WIP
pmatchList :: forall n r li a s. (PIsListLike li a, KnownNat (Length (Replicate n a)), UnsafeConstrNP (Replicate n a)) => Term s (li a) -> (NP (Term s) (Replicate n a) -> Term s (li a) -> Term s r) -> Term s r

-- | Same as <tt>pmatchList</tt> but allows matching each element to
--   arbitrary type. Essentially, this is <tt>pmatchList</tt> combined with
--   <tt>punsafeCoerce</tt>; therefore, this is unsafe and will require
--   careful attention when using this.
--   
--   This function is especially helpful when matching on <tt>PBuiltinList
--   (PData)</tt> when user knows the type of each elements. If first two
--   elements are Data Integers, one can use <tt>pmatchListUnsafe
--   </tt>'[PAsData PInteger, PAsData PInteger] li@ and have everything
--   already coerced when it's being matched.
--   
--   @since WIP
pmatchListUnsafe :: forall (struct :: [S -> Type]) r li a s. (PIsListLike li a, KnownNat (Length struct), UnsafeConstrNP struct) => Term s (li a) -> (NP (Term s) struct -> Term s (li a) -> Term s r) -> Term s r
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.List.PList a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.List.PList a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.List.PList a)
instance forall (xs :: [Plutarch.Internal.Term.PType]) (x :: Plutarch.Internal.Term.PType). Plutarch.List.UnsafeConstrNP xs => Plutarch.List.UnsafeConstrNP ((':) @Plutarch.Internal.Term.PType x xs)
instance Plutarch.List.UnsafeConstrNP ('[] @Plutarch.Internal.Term.PType)
instance forall (a :: Plutarch.Internal.Term.PType). Plutarch.Internal.Show.PShow a => Plutarch.Internal.Show.PShow (Plutarch.List.PList a)
instance forall (a :: Plutarch.Internal.Term.PType). Plutarch.Internal.Eq.PEq a => Plutarch.Internal.Eq.PEq (Plutarch.List.PList a)
instance Plutarch.Internal.ListLike.PListLike Plutarch.List.PList

module Plutarch.Enum

-- | A notion of 'next' value. More formally, instances of this type class
--   are discrete linear orders with no maximal element.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><pre>x /= psuccessor x</pre></li>
--   <li><tt>y &lt; x</tt> <tt>=</tt> <tt>psuccessor y &lt;= x</tt></li>
--   <li><tt>x &lt; psuccessor y</tt> <tt>=</tt> <tt>x &lt;= y</tt></li>
--   </ol>
--   
--   If you define <a>psuccessorN</a>, you must also ensure the following
--   hold; the default implementation ensures this.
--   
--   <ol>
--   <li><tt>psuccessorN 1</tt> <tt>=</tt> <tt>psuccessor</tt></li>
--   <li><tt>psuccessorN n . psuccessorN m</tt> <tt>=</tt> <tt>psuccessorN
--   (n + m)</tt></li>
--   </ol>
--   
--   Law 1 ensures no value is its own successor. Laws 2 and 3 ensure that
--   there are no 'gaps': every value is 'reachable' from any lower value
--   by a finite number of applications of <tt>successor</tt>.
class POrd a => PCountable (a :: S -> Type)

psuccessor :: forall (s :: S). PCountable a => Term s (a :--> a)

-- | The default implementation of this function is inefficient: if at all
--   possible, give instances an optimized version that doesn't require
--   recursion.
psuccessorN :: forall (s :: S). PCountable a => Term s (PPositive :--> (a :--> a))

-- | Similar to <a>PCountable</a>, but has the ability to get a 'previous'
--   value as well. More formally, instances of this type class are
--   discrete linear orders with no maximal or minimal element.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>ppredecessor . psuccessor</tt> <tt>=</tt> <tt>psuccessor .
--   ppredecessor</tt> <tt>=</tt> <tt>id</tt></li>
--   </ol>
--   
--   If you define <a>ppredecessorN</a>, you must also ensure the following
--   hold; the default implementation ensures this.
--   
--   <ol>
--   <li><tt>ppredecessorN 1</tt> <tt>=</tt> <tt>ppredecessor</tt></li>
--   <li><tt>ppredecessorN n . ppredecessorN m</tt> <tt>=</tt>
--   <tt>ppredecessorN (n + m)</tt></li>
--   </ol>
--   
--   From Law 1, we obtain the following theorem:
--   
--   <ul>
--   <li><pre>x /= predecessor x</pre></li>
--   </ul>
class PCountable a => PEnumerable (a :: S -> Type)

ppredecessor :: forall (s :: S). PEnumerable a => Term s (a :--> a)

-- | The default implementation of this function is inefficient: if at all
--   possible, give instances an optimized version that doesn't require
--   recursion.
ppredecessorN :: forall (s :: S). PEnumerable a => Term s (PPositive :--> (a :--> a))
instance Plutarch.Enum.PEnumerable Plutarch.Builtin.Integer.PInteger
instance Plutarch.Enum.PCountable Plutarch.Builtin.Integer.PInteger
instance Plutarch.Enum.PCountable Plutarch.Internal.Numeric.PPositive

module Plutarch.BitString

-- | A wrapper around <a>PByteString</a> for CIP-122 and CIP-123 bitwise
--   operations.
--   
--   <h1>Note</h1>
--   
--   This type exists because <i>bit</i> and <i>byte</i> indexes work in
--   different directions. To avoid confusing behaviour, we require an
--   explicit wrapping of <a>PByteString</a>s to use bitwise functionality:
--   this way, it's clear where which scheme applies.
newtype PBitString (s :: S)
PBitString :: Term s PByteString -> PBitString (s :: S)

-- | Bit access operation, as defined in <a>CIP-122</a>.
preadBit :: forall (s :: S). Term s (PBitString :--> (PInteger :--> PBool))

-- | Given a list of positions, set the bits at those positions.
--   
--   This works similarly to the <tt>writeBits</tt> operation in
--   <a>CIP-122</a> with regard to the list of indexes. Effectively,
--   <tt>psetBits b ixes</tt> is equivalent to <tt>writeBits b . map (,
--   True) $ ixes</tt>. All caveats that this entails from the CIP-122
--   description apply.
--   
--   Sets bits, as per <a>CIP-122</a>.
pwriteBits :: forall (s :: S). Term s (PBitString :--> (PBuiltinList PInteger :--> (PBool :--> PBitString)))

-- | Performs a shift, as per <a>CIP-123</a>.
pshift :: forall (s :: S). Term s (PBitString :--> (PInteger :--> PBitString))

-- | Performs a rotation, as per <a>CIP-123</a>.
protate :: forall (s :: S). Term s (PBitString :--> (PInteger :--> PBitString))

-- | Counts the number of set bits, as per <a>CIP-123</a>.
pcountSetBits :: forall (s :: S). Term s (PBitString :--> PInteger)

-- | As <tt>pfindFirstSetBit'</tt>, but produces <a>PNothing</a> if the
--   argument is empty, or contains no set bits.
pfindFirstSetBit :: forall (s :: S). Term s (PBitString :--> PMaybe PInteger)

-- | Finds the index of the first set bit, as per <a>CIP-123</a>.
--   
--   <h1>Note</h1>
--   
--   This returns <tt>-1</tt> if the argument is either empty, or contains
--   no set bits.
pfindFirstSetBit' :: forall (s :: S). Term s (PBitString :--> PInteger)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.BitString.PBitString
instance Plutarch.Internal.Semigroup.PMonoid Plutarch.BitString.PBitString
instance Plutarch.Internal.Semigroup.PSemigroup Plutarch.BitString.PBitString
instance Plutarch.Internal.Ord.POrd Plutarch.BitString.PBitString
instance Plutarch.Internal.Eq.PEq Plutarch.BitString.PBitString
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.BitString.PBitString s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.BitString.PBitString s)
instance Plutarch.Internal.Lift.PLiftable Plutarch.BitString.PBitString

module Plutarch.Either

-- | SOP-encoded <a>Either</a>.
data PEither (a :: S -> Type) (b :: S -> Type) (s :: S)
PLeft :: Term s a -> PEither (a :: S -> Type) (b :: S -> Type) (s :: S)
PRight :: Term s b -> PEither (a :: S -> Type) (b :: S -> Type) (s :: S)

-- | <tt>Data</tt>-encoded <a>Either</a>.
data PEitherData (a :: S -> Type) (b :: S -> Type) (s :: S)
PDLeft :: Term s (PAsData a) -> PEitherData (a :: S -> Type) (b :: S -> Type) (s :: S)
PDRight :: Term s (PAsData b) -> PEitherData (a :: S -> Type) (b :: S -> Type) (s :: S)

pisLeft :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). Term s (PEither a b :--> PBool)

pfromLeft :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). Term s (PEither a b :--> a)

pfromRight :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). Term s (PEither a b :--> b)

-- | Make a <tt>Data</tt>-encoded <tt>Left</tt>.
pdleft :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). PIsData a => Term s (a :--> PEitherData a b)

-- | Make a <tt>Data</tt>-encoded <tt>Right</tt>.
pdright :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). PIsData b => Term s (b :--> PEitherData a b)

-- | Eliminator for <a>PEitherData</a>.
peitherData :: forall (a :: S -> Type) (b :: S -> Type) (r :: S -> Type) (s :: S). (PIsData a, PIsData b) => Term s ((a :--> r) :--> ((b :--> r) :--> (PEitherData a b :--> r)))

-- | Verifies if a <a>PEitherData</a> is a <a>PDLeft</a>. Less code than
--   using <a>peitherData</a>, as it doesn't need to inspect the contents.
pdisLeft :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). Term s (PEitherData a b :--> PBool)

-- | As <a>pdisLeft</a>, except verifies whether we have a <a>PDRight</a>.
pdisRight :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). Term s (PEitherData a b :--> PBool)

-- | Return the value inside a <tt>PDEither</tt> if it's a <a>PDLeft</a>,
--   error otherwise.
pdfromLeft :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). PIsData a => Term s (PEitherData a b :--> a)

-- | As <a>pdfromLeft</a>, but yields a value if given a <a>PDRight</a>
--   instead.
pdfromRight :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). PIsData b => Term s (PEitherData a b :--> b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Show.PShow a, Plutarch.Internal.Show.PShow b) => Plutarch.Internal.Show.PShow (Plutarch.Either.PEither a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Eq.PEq a, Plutarch.Internal.Eq.PEq b) => Plutarch.Internal.Eq.PEq (Plutarch.Either.PEither a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Either.PEither a b s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Either.PEither a b s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.IsData.PIsData a, Plutarch.Internal.IsData.PIsData b, Plutarch.Internal.Show.PShow a, Plutarch.Internal.Show.PShow b) => Plutarch.Internal.Show.PShow (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Eq.PEq (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Either.PEitherData a b s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Either.PEither a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). (PlutusTx.IsData.Class.ToData (Plutarch.Internal.Lift.AsHaskell a), PlutusTx.IsData.Class.FromData (Plutarch.Internal.Lift.AsHaskell a), PlutusTx.IsData.Class.ToData (Plutarch.Internal.Lift.AsHaskell b), PlutusTx.IsData.Class.FromData (Plutarch.Internal.Lift.AsHaskell b)) => Plutarch.Internal.Lift.PLiftable (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.Term.PType) (b :: Plutarch.Internal.Term.PType). (Plutarch.Internal.Ord.POrd a, Plutarch.Internal.Ord.POrd b, Plutarch.Internal.IsData.PIsData a, Plutarch.Internal.IsData.PIsData b) => Plutarch.Internal.Ord.POrd (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.IsData.PIsData (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.Term.PType) (b :: Plutarch.Internal.Term.PType). (Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData a, Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData b) => Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.Term.PType) (b :: Plutarch.Internal.Term.PType). (Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData a, Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData b) => Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData (Plutarch.Either.PEitherData a b))
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Lift.PLiftable a, Plutarch.Internal.Lift.PLiftable b) => Plutarch.Internal.Lift.PLiftable (Plutarch.Either.PEither a b)

module Plutarch.Builtin.Crypto

-- | Hash a <a>PByteString</a> using SHA-256.
psha2_256 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using SHA3-256.
psha3_256 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using Blake2B-224.
pblake2b_224 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using Blake2B-256.
pblake2b_256 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using Keccak-256.
pkeccak_256 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using Ripemd_160.
pripemd_160 :: Term s (PByteString :--> PByteString)

-- | Verify the signature against the public key and message.

-- | <i>Deprecated: use one of the Ed25519, Schnorr- or ECDSA Secp256k1
--   signature verification functions</i>
pverifySignature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))

-- | Verify an ED25519 signature arguments are in this order: pubkey,
--   message, signature
pverifyEd25519Signature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))

-- | Verify an ECDSA SECP256k1 signature arguments are in this order:
--   pubkey, message, signature
pverifyEcdsaSecp256k1Signature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))

-- | Verify a Schnorr SECP256k1 signature arguments are in this order:
--   pubkey, message, signature
pverifySchnorrSecp256k1Signature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))

module Plutarch.Builtin

newtype PDataNewtype (a :: S -> Type) (s :: S)
PDataNewtype :: Term s (PAsData a) -> PDataNewtype (a :: S -> Type) (s :: S)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Builtin.PDataNewtype a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.PDataNewtype a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.IsData.PIsData (Plutarch.Builtin.PDataNewtype a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Eq.PEq (Plutarch.Builtin.PDataNewtype a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.IsData.PIsData a, Plutarch.Internal.Ord.POrd a) => Plutarch.Internal.Ord.POrd (Plutarch.Builtin.PDataNewtype a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.IsData.PIsData a, Plutarch.Internal.Show.PShow a) => Plutarch.Internal.Show.PShow (Plutarch.Builtin.PDataNewtype a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.IsData.PIsData a, Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData a)) => Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.PDataNewtype a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData (Plutarch.Builtin.PDataNewtype a))

module Plutarch.Prelude

newtype PDataNewtype (a :: S -> Type) (s :: S)
PDataNewtype :: Term s (PAsData a) -> PDataNewtype (a :: S -> Type) (s :: S)

-- | Builtin Plutus boolean.
data PBool (s :: S)
PTrue :: PBool (s :: S)
PFalse :: PBool (s :: S)

-- | As <a>pand</a>, but strict.
pand' :: forall (s :: S). Term s (PBool :--> (PBool :--> PBool))

-- | Essentially multi-way <a>pif</a>. More precisely, given a list of
--   condition-action pairs, and an 'action of last resort', construct a
--   left-to-right 'chain' of <tt>pif</tt>s, using the conditions to
--   determine which action gets taken. The 'action of last resort'
--   finishes the 'chain'. For example:
--   
--   <pre>
--   pcond [(cond1, act1), (cond2, act2)] act3
--   </pre>
--   
--   does the same thing as
--   
--   <pre>
--   pif cond1 act1 (pif cond2 act2 act3)
--   </pre>
pcond :: forall (a :: S -> Type) (s :: S). [(Term s PBool, Term s a)] -> Term s a -> Term s a

-- | Lazy if-then-else.
pif :: forall (a :: S -> Type) (s :: S). Term s PBool -> Term s a -> Term s a -> Term s a

-- | Strict if-then-else. Emits slightly less code than the lazy version.
pif' :: forall (a :: S -> Type) (s :: S). Term s (PBool :--> (a :--> (a :--> a)))

-- | Boolean negation.
pnot :: forall (s :: S). Term s (PBool :--> PBool)

-- | As <a>por</a>, but strict.
por' :: Term s (PBool :--> (PBool :--> PBool))

-- | Lazy AND for terms.
(#&&) :: forall (s :: S). Term s PBool -> Term s PBool -> Term s PBool
infixr 3 #&&

-- | Lazy OR for terms.
(#||) :: forall (s :: S). Term s PBool -> Term s PBool -> Term s PBool
infixr 2 #||

-- | A Plutarch-level representation of bytes.
--   
--   <h1>Note =</h1>
--   
--   This type is intentionally quite restrictive, as it's not really meant
--   to be computed with. Instead, it ensures certain operations' type
--   safety while also allowing more sensible signatures. If you want to do
--   anything with <a>PByte</a>s, we recommend converting them to
--   <a>PInteger</a>s first.
data PByte (s :: S)

-- | Plutus <tt>BuiltinByteString</tt>
data PByteString s

-- | Type designating whether logical operations should use padding or
--   truncation semantics. See <a>CIP-122</a> for more details on this.
data PLogicOpSemantics (s :: S)

-- | Perform the logical AND of two <a>PByteString</a>s, as per
--   <a>CIP-122</a>. The <a>PLogicOpSemantics</a> argument specifies what
--   should be done if the lengths of the two <a>PByteString</a> arguments
--   do not match.
pandBS :: forall (s :: S). Term s (PLogicOpSemantics :--> (PByteString :--> (PByteString :--> PByteString)))

-- | Convert a <a>PByte</a> into its corresponding <a>PInteger</a>.
pbyteToInteger :: Term s (PByte :--> PInteger)

-- | Perform the logical complement of a <a>PByteString</a>, as per
--   <a>CIP-122</a>.
pcomplementBS :: forall (s :: S). Term s (PByteString :--> PByteString)

-- | Prepend a <a>PByte</a> to a 'PByteString.
pconsBS :: Term s (PByte :--> (PByteString :--> PByteString))

-- | Interpret a hex string as a PByteString.
phexByteStr :: HasCallStack => String -> Term s PByteString

-- | Given a valid index into a <a>PByteString</a>, returns the
--   <a>PByte</a> at that index. Will crash if given an out-of-bounds
--   index.
pindexBS :: Term s (PByteString :--> (PInteger :--> PByte))

-- | Try to convert a <a>PInteger</a> into its corresponding <a>PByte</a>.
--   This operation unchecked: use with care.
pintegerToByte :: Term s (PInteger :--> PByte)

-- | Find the length of a <a>PByteString</a>.
plengthBS :: Term s (PByteString :--> PInteger)

-- | Perform the logical OR of two <a>PByteString</a>s, as per
--   <a>CIP-122</a>. The <a>PLogicOpSemantics</a> argument specifies what
--   should be done if the lengths of the two <a>PByteString</a> arguments
--   do not match.
porBS :: forall (s :: S). Term s (PLogicOpSemantics :--> (PByteString :--> (PByteString :--> PByteString)))

-- | Indicates that padding semantics should be used.
ppadding :: forall (s :: S). Term s PLogicOpSemantics

-- | Given a desired length and a <a>PByte</a>, construct a
--   <a>PByteString</a> of the specified length (0 if negative) consisting
--   entirely of that <a>PByte</a>.
preplicateBS :: forall (s :: S). Term s (PInteger :--> (PByte :--> PByteString))

-- | Slice a <a>PByteString</a> with given start index and slice length.
--   
--   <pre>
--   &gt;&gt;&gt; (pslice # 2 # 3 phexByteStr "4102afde5b2a") #== phexByteStr "afde5b"
--   </pre>
psliceBS :: Term s (PInteger :--> (PInteger :--> (PByteString :--> PByteString)))

-- | Indicates that truncation semantics should be used.
ptruncation :: forall (s :: S). Term s PLogicOpSemantics

-- | Perform the logical XOR of two <a>PByteString</a>s, as per
--   <a>CIP-122</a>. The <a>PLogicOpSemantics</a> argument specifies what
--   should be done if the lengths of the two <a>PByteString</a> arguments
--   do not match.
pxorBS :: forall (s :: S). Term s (PLogicOpSemantics :--> (PByteString :--> (PByteString :--> PByteString)))

-- | Hash a <a>PByteString</a> using SHA-256.
psha2_256 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using SHA3-256.
psha3_256 :: Term s (PByteString :--> PByteString)

-- | Verify the signature against the public key and message.

-- | <i>Deprecated: use one of the Ed25519, Schnorr- or ECDSA Secp256k1
--   signature verification functions</i>
pverifySignature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))
newtype PAsData (a :: S -> Type) (s :: S)
PAsData :: Term s a -> PAsData (a :: S -> Type) (s :: S)

-- | Plutus <tt>BuiltinList</tt>
data PBuiltinList (a :: S -> Type) (s :: S)
PCons :: Term s a -> Term s (PBuiltinList a) -> PBuiltinList (a :: S -> Type) (s :: S)
PNil :: PBuiltinList (a :: S -> Type) (s :: S)
newtype PBuiltinPair (a :: S -> Type) (b :: S -> Type) (s :: S)
PBuiltinPair :: Term s (PBuiltinPair a b) -> PBuiltinPair (a :: S -> Type) (b :: S -> Type) (s :: S)
newtype PData (s :: S)
PData :: Term s PData -> PData (s :: S)
pasByteStr :: Term s (PData :--> PByteString)
pasConstr :: Term s (PData :--> PBuiltinPair PInteger (PBuiltinList PData))
pasInt :: Term s (PData :--> PInteger)
pasList :: Term s (PData :--> PBuiltinList PData)
pasMap :: Term s (PData :--> PBuiltinList (PBuiltinPair PData PData))
pchooseData :: Term s (PData :--> (a :--> (a :--> (a :--> (a :--> (a :--> a))))))
pchooseListBuiltin :: Term s (PBuiltinList a :--> (b :--> (b :--> b)))
pconsBuiltin :: Term s (a :--> (PBuiltinList a :--> PBuiltinList a))
pconstrBuiltin :: Term s (PInteger :--> (PBuiltinList PData :--> PAsData (PBuiltinPair PInteger (PBuiltinList PData))))
pfstBuiltin :: Term s (PBuiltinPair a b :--> a)
pheadBuiltin :: Term s (PBuiltinList a :--> a)
plistData :: Term s (PBuiltinList PData :--> PData)
pnullBuiltin :: Term s (PBuiltinList a :--> PBool)

-- | Construct a builtin pair of <a>PData</a> elements.
--   
--   Uses <a>PAsData</a> to preserve more information about the underlying
--   <a>PData</a>.
ppairDataBuiltin :: Term s (PAsData a :--> (PAsData b :--> PBuiltinPair (PAsData a) (PAsData b)))

-- | Serialise any builtin data to its cbor represented by a builtin
--   bytestring
pserialiseData :: Term s (PData :--> PByteString)
psndBuiltin :: Term s (PBuiltinPair a b :--> b)
ptailBuiltin :: Term s (PBuiltinList a :--> PBuiltinList a)

-- | A builtin Plutus integer.
data PInteger s

-- | An Arbitrary Term with an unknown type
newtype POpaque s
POpaque :: Term s POpaque -> POpaque s

-- | Erase the type of a Term
popaque :: Term s a -> Term s POpaque

-- | Plutus <tt>BuiltinString</tt> values
data PString s

-- | Decode a <a>PByteString</a> using UTF-8.
pdecodeUtf8 :: Term s (PByteString :--> PString)

-- | Encode a <a>PString</a> using UTF-8.
pencodeUtf8 :: Term s (PString :--> PByteString)
data PUnit (s :: S)
PUnit :: PUnit (s :: S)

-- | SOP-encoded <a>Either</a>.
data PEither (a :: S -> Type) (b :: S -> Type) (s :: S)
PLeft :: Term s a -> PEither (a :: S -> Type) (b :: S -> Type) (s :: S)
PRight :: Term s b -> PEither (a :: S -> Type) (b :: S -> Type) (s :: S)

-- | A notion of 'next' value. More formally, instances of this type class
--   are discrete linear orders with no maximal element.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><pre>x /= psuccessor x</pre></li>
--   <li><tt>y &lt; x</tt> <tt>=</tt> <tt>psuccessor y &lt;= x</tt></li>
--   <li><tt>x &lt; psuccessor y</tt> <tt>=</tt> <tt>x &lt;= y</tt></li>
--   </ol>
--   
--   If you define <a>psuccessorN</a>, you must also ensure the following
--   hold; the default implementation ensures this.
--   
--   <ol>
--   <li><tt>psuccessorN 1</tt> <tt>=</tt> <tt>psuccessor</tt></li>
--   <li><tt>psuccessorN n . psuccessorN m</tt> <tt>=</tt> <tt>psuccessorN
--   (n + m)</tt></li>
--   </ol>
--   
--   Law 1 ensures no value is its own successor. Laws 2 and 3 ensure that
--   there are no 'gaps': every value is 'reachable' from any lower value
--   by a finite number of applications of <tt>successor</tt>.
class POrd a => PCountable (a :: S -> Type)

psuccessor :: forall (s :: S). PCountable a => Term s (a :--> a)

-- | The default implementation of this function is inefficient: if at all
--   possible, give instances an optimized version that doesn't require
--   recursion.
psuccessorN :: forall (s :: S). PCountable a => Term s (PPositive :--> (a :--> a))

-- | Similar to <a>PCountable</a>, but has the ability to get a 'previous'
--   value as well. More formally, instances of this type class are
--   discrete linear orders with no maximal or minimal element.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>ppredecessor . psuccessor</tt> <tt>=</tt> <tt>psuccessor .
--   ppredecessor</tt> <tt>=</tt> <tt>id</tt></li>
--   </ol>
--   
--   If you define <a>ppredecessorN</a>, you must also ensure the following
--   hold; the default implementation ensures this.
--   
--   <ol>
--   <li><tt>ppredecessorN 1</tt> <tt>=</tt> <tt>ppredecessor</tt></li>
--   <li><tt>ppredecessorN n . ppredecessorN m</tt> <tt>=</tt>
--   <tt>ppredecessorN (n + m)</tt></li>
--   </ol>
--   
--   From Law 1, we obtain the following theorem:
--   
--   <ul>
--   <li><pre>x /= predecessor x</pre></li>
--   </ul>
class PCountable a => PEnumerable (a :: S -> Type)

ppredecessor :: forall (s :: S). PEnumerable a => Term s (a :--> a)

-- | The default implementation of this function is inefficient: if at all
--   possible, give instances an optimized version that doesn't require
--   recursion.
ppredecessorN :: forall (s :: S). PEnumerable a => Term s (PPositive :--> (a :--> a))
class PEq t
(#==) :: PEq t => Term s t -> Term s t -> Term s PBool
(#==) :: (PEq t, PGeneric t, PlutusType t, All2 PEq (PCode t)) => Term s t -> Term s t -> Term s PBool
infix 4 #==

-- | Total ordering relation.
--   
--   <h1>Laws</h1>
--   
--   <a>#&lt;=</a> must form a total order. More precisely:
--   
--   <ol>
--   <li><tt>x #&lt;= x</tt> <tt>=</tt> <tt>pcon PTrue</tt>
--   (reflexivity)</li>
--   <li><tt>(y #&lt; x) #|| (z #&lt; y) #|| (x #&lt;= z)</tt> <tt>=</tt>
--   <tt>pcon PTrue</tt> (transitivity)</li>
--   <li><tt>(x #&lt;= y) #|| (y #&lt;= x)</tt> <tt>=</tt> <tt>pcon
--   PTrue</tt> (totality)</li>
--   </ol>
--   
--   Furthermore, <a>#&lt;</a> must be an equivalent strict total order to
--   <a>#&lt;=</a>:
--   
--   <ol>
--   <li><tt>x #&lt; x</tt> <tt>=</tt> <tt>pcon PFalse</tt>
--   (irreflexivity)</li>
--   <li><tt>(y #&lt;= x) #|| (z #&lt;= y) #|| (x #&lt; z)</tt> <tt>=</tt>
--   <tt>pcon PTrue</tt> (transitivity)</li>
--   <li><tt>(x #&lt; y) #|| (y #&lt; x) #|| (x #== z)</tt> <tt>=</tt>
--   <tt>pcon PTrue</tt> (trichotomy)</li>
--   <li><tt>x #&lt;= y</tt> <tt>=</tt> <tt>(x #&lt; y) #|| (x #== y)</tt>
--   (strict equivalence)</li>
--   </ol>
--   
--   If you define <a>pmax</a> or <a>pmin</a>, ensure the following also
--   hold:
--   
--   <ol>
--   <li><tt>pmax # x # y</tt> <tt>=</tt> <tt>pmax # y # x</tt>
--   (commutativity, also for @pmin)</li>
--   <li><tt>pmax # x #$ pmax y z</tt> <tt>=</tt> <tt>pmax # (pmax # x # y)
--   # z</tt> (associativity, also for @pmin)</li>
--   <li><tt>pmax # x #$ pmin # y # z</tt> <tt>=</tt> <tt>pmin # (pmax # x
--   # y) # (pmax # x # z)</tt> (<a>pmax</a> distributes over <a>pmin</a>,
--   also equivalent for <a>pmin</a>)</li>
--   <li><tt>pmin x y</tt> <tt>=</tt> <tt>pif' (x #&lt;= y) x y</tt></li>
--   <li><tt>pmax x y</tt> <tt>=</tt> <tt>pif' (x #&lt;= y) y x</tt></li>
--   </ol>
--   
--   Laws 8-12 hold if you use the defaults provided by this type class.
class PEq t => POrd t

(#<=) :: POrd t => Term s t -> Term s t -> Term s PBool

(#<=) :: (POrd t, POrd (PInner t)) => Term s t -> Term s t -> Term s PBool

(#<) :: POrd t => Term s t -> Term s t -> Term s PBool

(#<) :: (POrd t, POrd (PInner t)) => Term s t -> Term s t -> Term s PBool

pmax :: forall (s :: S). POrd t => Term s t -> Term s t -> Term s t

pmin :: forall (s :: S). POrd t => Term s t -> Term s t -> Term s t
infix 4 #<=
infix 4 #<

(#>) :: forall (a :: S -> Type) (s :: S). POrd a => Term s a -> Term s a -> Term s PBool
infix 4 #>

(#>=) :: forall (a :: S -> Type) (s :: S). POrd a => Term s a -> Term s a -> Term s PBool
infix 4 #>=

-- | Fixpoint recursion. Used to encode recursive functions.
--   
--   Example:
--   
--   <pre>
--   iterateN' ::
--    Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a) -&gt;
--    Term s PInteger -&gt;
--    Term s (a :--&gt; a) -&gt;
--    Term s a
--   iterateN' self n f x =
--     pif (n #== 0) x (self # n - 1 #$ f x)
--   
--   iterateN :: Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a)
--   iterateN = pfix #$ plam iterateN'
--   </pre>
--   
--   Further examples can be found in examples/Recursion.hs
pfix :: Term s (((a :--> b) :--> (a :--> b)) :--> (a :--> b))

-- | Laws: - If <tt>PSubtype PData a</tt>, then <tt>pdataImpl a</tt> must
--   be <a>pupcast</a>. - pdataImpl . pupcast . pfromDataImpl  id -
--   pfromDataImpl . punsafeDowncast . pdataImpl  id
class PIsData a
pfromDataImpl :: PIsData a => Term s (PAsData a) -> Term s a
pfromDataImpl :: (PIsData a, PIsData (PInner a)) => Term s (PAsData a) -> Term s a
pdataImpl :: PIsData a => Term s a -> Term s PData
pdataImpl :: (PIsData a, PIsData (PInner a)) => Term s a -> Term s PData
pdata :: PIsData a => Term s a -> Term s (PAsData a)
pforgetData :: forall s a. Term s (PAsData a) -> Term s PData
pfromData :: PIsData a => Term s (PAsData a) -> Term s a

-- | Indicates that the given Plutarch type has an equivalent in Haskell
--   (and Plutus by extension), and we have the ability to move between
--   them.
--   
--   <h1>Important note</h1>
--   
--   Calling methods of <a>PLiftable</a> directly should rarely, if ever,
--   be a thing you do, unless defining your own instances without
--   <tt>via</tt>-deriving helpers (below). Prefer using <a>pconstant</a>
--   and <a>plift</a>, as these handle some of the oddities required
--   without you having to think about them.
--   
--   You should rarely, if ever, need to define <a>PLiftable</a> instances
--   by hand. Whenever possible, prefer using
--   <a>DeriveBuiltinPLiftable</a>, <a>DeriveDataPLiftable</a>, and
--   <a>DeriveNewtypePLiftable</a> as they have fewer complexities and
--   caveats. See their documentation for when to use them.
--   
--   If you do want to define the methods yourself, there's a few key
--   factors to keep in mind:
--   
--   <ol>
--   <li>You still shouldn't write every method by hand, there are helpers
--   <tt>plutToReprUni</tt> and <tt>reprToPlutUni</tt> to cover common
--   cases.</li>
--   <li>If defining <a>plutToRepr</a> and <a>reprToPlut</a> for Scott
--   encoded types you need to set <tt><a>PlutusRepr</a> PMyType =
--   <a>PLiftedClosed</a> PMyType</tt></li>
--   <li>When choosing a type for <a>AsHaskell</a>, <i>any</i> value of
--   that type <i>must</i> be representable in Plutarch. If you have
--   internal invariants to maintain on the Haskell side, make sure you do
--   so with great care.</li>
--   </ol>
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt><a>reprToHask</a> <a>.</a> <a>haskToRepr</a></tt> <tt>=</tt>
--   <tt><a>Right</a></tt></li>
--   <li><tt><a>plutToRepr</a> <a>.</a> <a>reprToPlut</a></tt> <tt>=</tt>
--   <tt><a>Right</a></tt></li>
--   </ol>
--   
--   Any derivations via <a>DeriveBuiltinPLiftable</a>,
--   <a>DeriveDataPLiftable</a>, and <a>DeriveNewtypePLiftable</a>
--   automatically follow these laws.
--   
--   Together, these imply <tt>plift . pconstant = id</tt>.
class PlutusType a => PLiftable (a :: S -> Type) where {
    type AsHaskell a :: Type;
    type PlutusRepr a :: Type;
}

-- | Transform <tt>a</tt>'s Haskell equivalent to its Plutus universe
--   representation.
haskToRepr :: PLiftable a => AsHaskell a -> PlutusRepr a

-- | Given <tt>a</tt>'s Plutus universe representation, turn it back into
--   its (true) Haskell equivalent if possible.
reprToHask :: PLiftable a => PlutusRepr a -> Either LiftError (AsHaskell a)

-- | Given <tt>a</tt>'s Plutus universe representation, lift it into
--   Plutarch.
reprToPlut :: forall (s :: S). PLiftable a => PlutusRepr a -> PLifted s a

-- | Given a closed Plutarch term, evaluate it back into its Plutus
--   universe representation, or fail.
plutToRepr :: PLiftable a => (forall (s :: S). PLifted s a) -> Either LiftError (PlutusRepr a)

-- | <tt>via</tt>-deriving helper, indicating that <tt>a</tt> has a
--   Haskell-level equivalent <tt>h</tt> by way of its <tt>Data</tt>
--   encoding, rather than by <tt>h</tt> being directly part of the Plutus
--   default universe.
newtype DeriveDataPLiftable (a :: S -> Type) (h :: Type) (s :: S)
DeriveDataPLiftable :: a s -> DeriveDataPLiftable (a :: S -> Type) (h :: Type) (s :: S)

-- | <tt>via</tt>-deriving helper, indicating that <tt>wrapper</tt> has a
--   Haskell-level equivalent <tt>h</tt> by way <tt>PInner wrapper</tt>, up
--   to coercibility.
newtype DeriveNewtypePLiftable (wrapper :: S -> Type) (h :: Type) (s :: S)
DeriveNewtypePLiftable :: wrapper s -> DeriveNewtypePLiftable (wrapper :: S -> Type) (h :: Type) (s :: S)

-- | @since WIP
newtype DeriveTagPLiftable (a :: S -> Type) (h :: Type) s
DeriveTagPLiftable :: a s -> DeriveTagPLiftable (a :: S -> Type) (h :: Type) s

-- | @since WIP
[$sel:unDeriveTagPLiftable:DeriveTagPLiftable] :: DeriveTagPLiftable (a :: S -> Type) (h :: Type) s -> a s

-- | Similar to <tt>Identity</tt>, but at the level of Plutarch. Only
--   needed when writing manual instances of <a>PLiftable</a>, or if you
--   want to use <a>reprToPlut</a> and <a>plutToRepr</a> directly.
--   
--   This is used for coercing Plutarch terms at Haskell level with `coerce
--   :: PLifted s a -&gt; PLifted s b` for <tt>via</tt>-deriving helpers.
newtype PLifted (s :: S) (a :: S -> Type)
PLifted :: Term s POpaque -> PLifted (s :: S) (a :: S -> Type)

-- | Valid definition of <a>reprToPlut</a> if <tt>PlutusRepr a</tt> is in
--   the Plutus universe.
reprToPlutUni :: forall (a :: S -> Type) (s :: S). (PLiftable a, DefaultUni `Includes` PlutusRepr a) => PlutusRepr a -> PLifted s a

-- | Valid definition of <a>plutToRepr</a> if <tt>PlutusRepr a</tt> is in
--   the Plutus universe.
plutToReprUni :: forall (a :: S -> Type). (PLiftable a, DefaultUni `Includes` PlutusRepr a) => (forall (s :: S). PLifted s a) -> Either LiftError (PlutusRepr a)

-- | Given a Haskell-level representation of a Plutarch term, transform it
--   into its equivalent term.
pconstant :: forall (a :: S -> Type) (s :: S). PLiftable a => AsHaskell a -> Term s a

-- | Given a closed Plutarch term, compile and evaluate it, then produce
--   the corresponding Haskell value. If compilation or evaluation fails
--   somehow, this will call <a>error</a>: if you need to 'trap' these
--   outcomes and handle them differently somehow, use <a>reprToPlut</a>
--   and <a>reprToHask</a> manually.
plift :: forall (a :: S -> Type). PLiftable a => (forall (s :: S). Term s a) -> AsHaskell a
type PElemConstraint list (a :: S -> Type) :: Constraint

-- | 'PIsListLike list a' constraints <tt>list</tt> be a <a>PListLike</a>
--   with valid element type, <tt>a</tt>.
type PIsListLike list a = (PListLike list, PElemConstraint list a)

-- | Plutarch types that behave like lists.
class PListLike (list :: (S -> Type) -> S -> Type)

-- | SOP-encoded list.
data PList (a :: S -> Type) (s :: S)
PSCons :: Term s a -> Term s (PList a) -> PList (a :: S -> Type) (s :: S)
PSNil :: PList (a :: S -> Type) (s :: S)

-- | <i> O(n) </i>. Check if element is in the list
pelem :: (PIsListLike list a, PEq a) => Term s (a :--> (list a :--> PBool))

-- | <i> O(n) </i>. Like Haskell level <a>(!!)</a> but on the Plutarch
--   level, not infix and with arguments reversed, errors if the specified
--   index is greater than or equal to the lists length
pelemAt :: PIsListLike l a => Term s (PInteger :--> (l a :--> a))

-- | <i> O(n) </i>. like haskell level <tt>find</tt> but on plutarch level
pfind :: PIsListLike l a => Term s ((a :--> PBool) :--> (l a :--> PMaybe a))

-- | <i> O(min(n, m)) </i>. Check if two lists are equal.
plistEquals :: (PIsListLike list a, PEq a) => Term s (list a :--> (list a :--> PBool))

-- | Extract head and tail of the list, if list is not empty.
puncons :: PIsListLike list a => Term s (list a :--> PMaybe (PPair a (list a)))

-- | <i> O(min(n, m)) </i>. Zip two lists together, creating pairs of the
--   elements.
--   
--   If the lists are of differing lengths, cut to the shortest.
pzip :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list (PPair a b)) => Term s (list a :--> (list b :--> list (PPair a b)))

-- | <i> O(n) </i>. Like Haskell level <a>(!!)</a> but on the plutarch
--   level
(#!!) :: PIsListLike l a => Term s (l a) -> Term s PInteger -> Term s a

-- | <i> O(n) </i>. Check that predicate holds for all elements in a list.
pall :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> PBool))

-- | <i> O(n) </i>. Check that predicate holds for any element in a list.
pany :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> PBool))

-- | <i> O(n) </i>. Concatenate two lists
--   
--   Example: &gt; pconcat # psingleton x # psingleton y == plistLiteral
--   [x, y]
--   
--   pconcat exhibits identities with empty lists such that &gt; forall x.
--   pconcat # pnil # x == x &gt; forall x. pconcat # x # pnil == x
pconcat :: PIsListLike list a => Term s (list a :--> (list a :--> list a))

-- | Cons an element onto an existing list.
pcons :: (PListLike list, PElemConstraint list a) => Term s (a :--> (list a :--> list a))

-- | Drop the first n fields of a List.
--   
--   The term will be statically generated as repeated applications of
--   <a>ptail</a>, which will be more efficient in many circumstances.
pdrop :: PIsListLike list a => Natural -> Term s (list a) -> Term s (list a)

-- | Canonical eliminator for list-likes.
pelimList :: (PListLike list, PElemConstraint list a) => (Term s a -> Term s (list a) -> Term s r) -> Term s r -> Term s (list a) -> Term s r

-- | <i> O(n) </i>. Filter elements from a list that don't match the
--   predicate.
pfilter :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> list a))

-- | <i> O(n) </i>. Fold on a list left-associatively.
pfoldl :: PIsListLike list a => Term s ((b :--> (a :--> b)) :--> (b :--> (list a :--> b)))

-- | <i> O(n) </i>. Fold on a list right-associatively.
pfoldr :: PIsListLike list a => Term s ((a :--> (b :--> b)) :--> (b :--> (list a :--> b)))

-- | <i> O(n) </i>. Fold on a list right-associatively, with opportunity
--   for short circuting.
--   
--   May short circuit when given reducer function is lazy in its second
--   argument.
pfoldrLazy :: PIsListLike list a => Term s ((a :--> (PDelayed b :--> b)) :--> (b :--> (list a :--> b)))

-- | Return the first element of a list. Partial, throws an error upon
--   encountering an empty list.
phead :: (PListLike list, PElemConstraint list a) => Term s (list a :--> a)

-- | <i> O(n) </i>. Count the number of elements in the list
plength :: PIsListLike list a => Term s (list a :--> PInteger)

-- | <i> O(n) </i>. Map a function over a list of elements
pmap :: (PListLike list, PElemConstraint list a, PElemConstraint list b) => Term s ((a :--> b) :--> (list a :--> list b))

-- | The empty list
pnil :: (PListLike list, PElemConstraint list a) => Term s (list a)

-- | <i> O(1) </i>. Check if a list is empty
pnull :: (PListLike list, PElemConstraint list a) => Term s (list a :--> PBool)

-- | Like <a>pelimList</a>, but with a fixpoint recursion hatch.
precList :: PIsListLike list a => (Term s (list a :--> r) -> Term s a -> Term s (list a) -> Term s r) -> (Term s (list a :--> r) -> Term s r) -> Term s (list a :--> r)

-- | <i> O(1) </i>. Create a singleton list from an element
psingleton :: PIsListLike list a => Term s (a :--> list a)

-- | Take the tail of a list, meaning drop its head. Partial, throws an
--   error upon encountering an empty list.
ptail :: (PListLike list, PElemConstraint list a) => Term s (list a :--> list a)

-- | Index a BuiltinList, throwing an error if the index is out of bounds.
ptryIndex :: PIsListLike list a => Natural -> Term s (list a) -> Term s a

-- | <i> O(min(n, m)) </i>. Zip two lists together with a passed function.
--   
--   If the lists are of differing lengths, cut to the shortest.
pzipWith :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list c) => Term s ((a :--> (b :--> c)) :--> (list a :--> (list b :--> list c)))

-- | Like <a>pzipWith</a> but with Haskell-level merge function.
pzipWith' :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list c) => (Term s a -> Term s b -> Term s c) -> Term s (list a :--> (list b :--> list c))

-- | <i>Deprecated: Use PlutusType</i>
type PCon = PlutusType

-- | <i>Deprecated: Use PlutusType</i>
type PMatch = PlutusType
class PlutusType (a :: PType) where {
    type PInner a :: PType;
    type PCovariant' a = All2 PCovariant'' (PCode a);
    type PContravariant' a = All2 PContravariant'' (PCode a);
    type PVariant' a = All2 PVariant'' (PCode a);
}

-- | Construct a Plutarch Term via a Haskell datatype
pcon :: PlutusType a => a s -> Term s a

-- | Pattern match over Plutarch Terms via a Haskell datatype
pmatch :: PlutusType a => Term s a -> (a s -> Term s b) -> Term s b

newtype DeriveNewtypePlutusType (a :: S -> Type) s
DeriveNewtypePlutusType :: a s -> DeriveNewtypePlutusType (a :: S -> Type) s

-- | This is a cursed derivation strategy that will give you
--   <tt>PlutusType</tt> with no questions asked. This is occasionally
--   helpful for deriving <tt>PlutusType</tt> for another derivation
--   strategy wrapper whose target instance requires <tt>PlutusType</tt> as
--   superclass.
--   
--   See <tt>PLiftable</tt>
newtype DeriveFakePlutusType (a :: S -> Type) (s :: S)
DeriveFakePlutusType :: a s -> DeriveFakePlutusType (a :: S -> Type) (s :: S)

-- | <tt>DeriveAsDataStruct</tt> derives <tt>PlutusType</tt> instances for
--   the given type as Data structure, namely, using <tt>Constr</tt>
--   constructor of the <tt>Data</tt> type. Each constructor of the given
--   type will have matching constructor index in the order of its
--   definition.
--   
--   Also, it is important to note that each fields can only contain term
--   that has innermost representation of Data. Hence, <tt>PInteger</tt> is
--   not allowed but <tt>PAsData PInteger</tt> is allowed. Failure to
--   follow this requirement will result in type error with detailed
--   explanation of the issue.
--   
--   <tt>PInner</tt> of defined type will be <tt>PDataStruct (struct :: [[S
--   -&gt; Type]])</tt> where <tt>struct</tt> is SOP type of its structure.
--   Since <tt>PInner</tt> of <tt>PDataStruct</tt> is <tt>PData</tt>,
--   multiple data encoded structure can be nested without being wrapped in
--   <tt>PAsData</tt>.
--   
--   Consult example below for defining custom data-encoded datatype: @@
--   data PBobData (a :: S -&gt; Type) (s :: S) = PBobData (Term s (PAsData
--   a)) (Term s (PAsData PBool)) | PRobData (Term s (PAsData PByteString))
--   deriving stock (Generic) deriving anyclass (SOP.Generic) deriving
--   PlutusType via (DeriveAsDataStruct (PBobData a))
--   
--   pcon $ PBobData (pdata 10) (pdata pfalse) -- Constr 0 [#10, #false]
--   pcon $ PRobData "hello" -- Constr 1 [#"hello"] @@
newtype DeriveAsDataStruct (a :: S -> Type) s
DeriveAsDataStruct :: a s -> DeriveAsDataStruct (a :: S -> Type) s

-- | <tt>DeriveAsDataRec</tt> derives <tt>PlutusType</tt> instances for
--   given type as builtin list of Data. Unlike <tt>PDataAsDataStruct</tt>
--   above, this will encode data as <tt>List</tt>. Similarly, only types
--   with its innermost representation <tt>PData</tt> is allowed for its
--   fields.
--   
--   One major difference is that <tt>DeriveAsDataRec</tt> only allows
--   single constructor as it does not encode the constructor index. When
--   attempted to use this strategy to a type with more than one
--   constructor will result in type error with detailed explanation of the
--   issue.
--   
--   <tt>PInner</tt> of defined type will be <tt>PDataRec (struct :: [S
--   -&gt; Type])</tt> where <tt>struct</tt> is product type of its
--   structure. <tt>PInner</tt> of <tt>PDataRec struct</tt> is
--   <tt>PBuiltinList PData</tt>.
--   
--   It is almost always better to use <tt>DeriveAsDataRec</tt> over
--   <tt>DeriveAsDataStruct</tt> when data type only have one constructor
--   as it is more efficient to work with on-chain. However,
--   Plith(previously PlutusTx), by default, derives every datatype to use
--   <tt>Constr</tt>. So, if a Plutarch type needs to remain compatible
--   with type defined in Plith, one needs to use
--   <tt>DeriveAsDataStruct</tt>. This is why many single-constructor types
--   are derived using <tt>DeriveAsDataStruct</tt> on plutarch-ledger-api.
--   
--   Consult example below for defining custom data-encoded datatype: @@
--   data PBobData (a :: S -&gt; Type) (s :: S) = PBobData (Term s (PAsData
--   a)) (Term s (PAsData PBool)) deriving stock (Generic) deriving
--   anyclass (SOP.Generic) deriving PlutusType via (DeriveAsDataRec
--   (PBobData a))
--   
--   pcon $ PBobData (pdata 10) (pdata pfalse) -- [#10, #false] @@
newtype DeriveAsDataRec (a :: S -> Type) s
DeriveAsDataRec :: a s -> DeriveAsDataRec (a :: S -> Type) s

-- | <tt>via</tt>-derivation helper to derive <a>PlutusType</a> instance
--   using SoP encoding. If your type has only one constructor prefer using
--   <a>DeriveAsSOPRec</a> instead.
newtype DeriveAsSOPStruct (a :: S -> Type) s
DeriveAsSOPStruct :: a s -> DeriveAsSOPStruct (a :: S -> Type) s

-- | <tt>via</tt>-derivation helper for SOP encoding, currently behaves
--   exactly like <a>DeriveAsSOPStruct</a> but can be used only on types
--   with a single constructor. It is separate to leave a room for future
--   optimizations.
newtype DeriveAsSOPRec (a :: S -> Type) s
DeriveAsSOPRec :: a s -> DeriveAsSOPRec (a :: S -> Type) s

-- | @since IWP
newtype DeriveTagPlutusType (a :: S -> Type) s
DeriveTagPlutusType :: a s -> DeriveTagPlutusType (a :: S -> Type) s

data Positive

data PPositive (s :: S)

data PNatural (s :: S)

-- | The addition operation, and the notion of scaling by a positive.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>x #+ y</tt> <tt>=</tt> <tt>y #+ x</tt> (commutativity of
--   <tt>#+</tt>)</li>
--   <li><tt>x #+ (y #+ z)</tt> <tt>=</tt> <tt>(x #+ y) #+ z</tt>
--   (associativity of <tt>#+</tt>)</li>
--   </ol>
--   
--   If you define a custom <tt>pscalePositive</tt>, ensure the following
--   also hold:
--   
--   <ol>
--   <li><tt>pscalePositive x pone</tt> <tt>=</tt> <tt>x</tt></li>
--   <li><tt>(pscalePositive x n) #+ (pscalePositive x m)</tt> <tt>=</tt>
--   <tt>pscalePositive x (n #+ m)</tt></li>
--   <li><tt>pscalePositive (pscalePositive x n) m</tt> <tt>=</tt>
--   <tt>pscalePositive x (n #* m)</tt></li>
--   </ol>
--   
--   The default implementation ensures these laws are satisfied.
class PAdditiveSemigroup (a :: S -> Type)
(#+) :: forall (s :: S). PAdditiveSemigroup a => Term s a -> Term s a -> Term s a
(#+) :: forall (s :: S). (PAdditiveSemigroup a, PAdditiveSemigroup (PInner a)) => Term s a -> Term s a -> Term s a

-- | This defaults to exponentiation-by-squaring, which in general is the
--   best we can do.
pscalePositive :: forall (s :: S). PAdditiveSemigroup a => Term s a -> Term s PPositive -> Term s a
infix 6 #+

-- | The notion of zero, as well as a way to scale by naturals.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>pzero #+ x</tt> <tt>=</tt> <tt>x</tt> (<tt>pzero</tt> is the
--   identity of <tt>#+</tt>)</li>
--   <li><tt>pscalePositive pzero n</tt> <tt>=</tt> <tt>pzero</tt>
--   (<tt>pzero</tt> does not scale up)</li>
--   </ol>
--   
--   If you define <a>pscaleNatural</a>, ensure the following as well:
--   
--   <ol>
--   <li><tt>pscaleNatural x (ppositiveToNatural # p)</tt> <tt>=</tt>
--   <tt>pscalePositive x p</tt></li>
--   <li><tt>pscaleNatural x pzero</tt> <tt>=</tt> <tt>pzero</tt></li>
--   </ol>
--   
--   The default implementation of <a>pscaleNatural</a> ensures these laws
--   hold.
class PAdditiveSemigroup a => PAdditiveMonoid (a :: S -> Type)
pzero :: forall (s :: S). PAdditiveMonoid a => Term s a
pscaleNatural :: forall (s :: S). PAdditiveMonoid a => Term s a -> Term s PNatural -> Term s a

-- | The notion of additive inverses, and the subtraction operation.
--   
--   <h1>Laws</h1>
--   
--   If you define <tt>pnegate</tt>, the following laws must hold:
--   
--   <ol>
--   <li><tt>(pnegate # x) #+ x</tt> <tt>=</tt> <tt>pzero</tt>
--   (<tt>pnegate</tt> is an additive inverse)</li>
--   <li><tt>pnegate #$ pnegate # x</tt> <tt>=</tt> <tt>x</tt>
--   (<tt>pnegate</tt> is self-inverting)</li>
--   </ol>
--   
--   If you define <tt>#-</tt>, the following law must hold:
--   
--   <ol>
--   <li><tt>x #- x</tt> <tt>=</tt> <tt>pzero</tt></li>
--   </ol>
--   
--   Additionally, the following 'consistency laws' must hold. Default
--   implementations of both <tt>pnegate</tt> and <tt>#-</tt> uphold these.
--   
--   <ol>
--   <li><tt>pnegate # x</tt> <tt>=</tt> <tt>pzero #- x</tt></li>
--   <li><tt>x #- y</tt> <tt>=</tt> <tt>x #+ (pnegate # y)</tt></li>
--   </ol>
--   
--   Lastly, if you define a custom <tt>pscaleInteger</tt>, the following
--   laws must hold:
--   
--   <ol>
--   <li><tt>pscaleInteger x pzero</tt> <tt>=</tt> <tt>pzero</tt></li>
--   <li><tt>pscaleInteger x (pnegate # y)</tt> <tt>=</tt> <tt>pnegate #
--   (pscaleInteger x y)</tt></li>
--   </ol>
class PAdditiveMonoid a => PAdditiveGroup (a :: S -> Type)
pnegate :: forall (s :: S). PAdditiveGroup a => Term s (a :--> a)
(#-) :: forall (s :: S). PAdditiveGroup a => Term s a -> Term s a -> Term s a
pscaleInteger :: forall (s :: S). PAdditiveGroup a => Term s a -> Term s PInteger -> Term s a
infix 6 #-

-- | The multiplication operation.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>x #* (y #* z)</tt> <tt>=</tt> <tt>(x #* y) #* z</tt>
--   (associativity of <tt>#*</tt>)</li>
--   </ol>
--   
--   If you define a custom <tt>ppowPositive</tt>, ensure the following
--   also hold:
--   
--   <ol>
--   <li><tt>ppowPositive x pone</tt> <tt>=</tt> <tt>x</tt></li>
--   <li><tt>(ppowPositive x n) #* (ppowPositive x m)</tt> <tt>=</tt>
--   <tt>ppowPositive x (n #+ m)</tt></li>
--   <li><tt>ppowPositive (ppowPositive x n) m</tt> <tt>=</tt>
--   <tt>ppowPositive x (n #* m)</tt></li>
--   </ol>
--   
--   The default implementation ensures these laws are satisfied.
--   
--   <h1>Note</h1>
--   
--   Unlike <a>PAdditiveSemigroup</a>, the multiplication operation doesn't
--   need to be commutative. Currently, all Plutarch-provided instances
--   are, but this need not be true for other instances.
class PMultiplicativeSemigroup (a :: S -> Type)
(#*) :: forall (s :: S). PMultiplicativeSemigroup a => Term s a -> Term s a -> Term s a
(#*) :: forall (s :: S). (PMultiplicativeSemigroup a, PMultiplicativeSemigroup (PInner a)) => Term s a -> Term s a -> Term s a
ppowPositive :: forall (s :: S). PMultiplicativeSemigroup a => Term s a -> Term s PPositive -> Term s a
infix 6 #*

-- | The notion of one (multiplicative identity), and exponentiation by -
--   naturals.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>pone #* x</tt> <tt>=</tt> <tt>x</tt> (<tt>pone</tt> is the
--   left identity of <tt>#*</tt>)</li>
--   <li><tt>x #* pone</tt> <tt>=</tt> <tt>x</tt> (<tt>pone</tt> is the
--   right identity of <tt>#*</tt>)</li>
--   <li><tt>ppowPositive pone p</tt> <tt>=</tt> <tt>pone</tt>
--   (<tt>pone</tt> does not scale up)</li>
--   </ol>
--   
--   If you define <a>ppowNatural</a>, ensure the following as well:
--   
--   <ol>
--   <li><tt>ppowNatural x (ppositiveToNatural # p)</tt> <tt>=</tt>
--   <tt>ppowPositive x p</tt></li>
--   <li><tt>ppowNatural x pzero</tt> <tt>=</tt> <tt>pone</tt></li>
--   </ol>
class PMultiplicativeSemigroup a => PMultiplicativeMonoid (a :: S -> Type)
pone :: forall (s :: S). PMultiplicativeMonoid a => Term s a
ppowNatural :: forall (s :: S). PMultiplicativeMonoid a => Term s a -> Term s PNatural -> Term s a

-- | <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>pfromInteger 0</tt> <tt>=</tt> <tt>pzero</tt></li>
--   <li><tt>pfromInteger 1</tt> <tt>=</tt> <tt>pone</tt></li>
--   <li><tt>pfromInteger (x + y)</tt> <tt>=</tt> <tt>pfromInteger x #+
--   pfromInteger y</tt></li>
--   <li><tt>pfromInteger (x * y)</tt> <tt>=</tt> <tt>pfromInteger x #*
--   pfromInteger y</tt></li>
--   </ol>
--   
--   Additionally, the following 'interaction laws' must hold between the
--   instances of <a>PAdditiveGroup</a> and <a>PMultiplicativeMonoid</a>
--   for <tt>a</tt>:
--   
--   <ol>
--   <li><tt>x #* (y #+ z)</tt> <tt>=</tt> <tt>(x #* y) #+ (x #* z)</tt>
--   (<tt>#*</tt> left-distributes over <tt>#+</tt>)</li>
--   <li><tt>(y #+ z) #* x</tt> <tt>=</tt> <tt>(y #* x) #+ (z #* x)</tt>
--   (<tt>#*</tt> right-distributes over <tt>#+</tt>)</li>
--   </ol>
class (PAdditiveGroup a, PMultiplicativeMonoid a) => PRing (a :: S -> Type)
pfromInteger :: forall (s :: S). PRing a => Integer -> Term s a
pfromInteger :: forall (s :: S). (PRing a, PRing (PInner a)) => Integer -> Term s a

-- | <h1>Laws</h1>
--   
--   <h1>Pedantry note</h1>
--   
--   Technically, the requirements here are too strong: we demand an
--   <i>ordered</i> ring, which integral domains don't necessarily have to
--   be. However, in our case, our hand is forced by expected semantics: in
--   abstract algebra, both the absolute value and the signum are real
--   numbers (which are always totally ordered) but in our case, both must
--   be elements of the integral domain itself. Thus, in order for the laws
--   to make any sense, we have to ensure a total order on the integral
--   domain. Since all of our integral domains are 'at least as big' as the
--   integers, this doesn't pose a huge problem.
class (PRing a, POrd a) => PIntegralDomain (a :: S -> Type)
psignum :: forall (s :: S). PIntegralDomain a => Term s (a :--> a)
psignum :: forall (s :: S). PIntegralDomain a => Term s (a :--> a)
pabs :: forall (s :: S). PIntegralDomain a => Term s (a :--> a)
pabs :: forall (s :: S). PIntegralDomain a => Term s (a :--> a)

pquot :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))

prem :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))

pdiv :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))

pmod :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))

-- | Build a <a>PPositive</a> from a <a>PInteger</a>. Yields
--   <a>PNothing</a> if argument is not positive.
ppositive :: Term s (PInteger :--> PMaybe PPositive)

-- | Partial version of <a>ppositive</a>. Errors if argument is not
--   positive.
ptryPositive :: forall (s :: S). Term s (PInteger :--> PPositive)

-- | Build a <a>PNatural</a> from a <a>PInteger</a>. Yields <a>PNothing</a>
--   if given a negative value.
pnatural :: forall (s :: S). Term s (PInteger :--> PMaybe PNatural)

-- | Partial version of <a>pnatural</a>. Errors if argument is negative.
ptryNatural :: forall (s :: S). Term s (PInteger :--> PNatural)

-- | 'Relax' a <a>PPositive</a> to <a>PNatural</a>. This uses
--   <a>punsafeCoerce</a> underneath, but because any positive is also a
--   natural, is safe.
ppositiveToNatural :: forall (s :: S). Term s (PPositive :--> PNatural)

-- | Safely coerce from a Term to it's <a>PInner</a> representation.
pto :: Term s a -> Term s (PInner a)
pinl :: Term s a -> (Term s a -> Term s b) -> Term s b
plam :: forall c. (PLamN a b s, HasCallStack) => (Term s c -> a) -> Term s (c :--> b)
newtype PForall (b :: a -> PType) s
PForall :: (forall (x :: a). Term s (b x)) -> PForall (b :: a -> PType) s
class PShow t

-- | Return the string representation of a Plutarch value
pshow :: PShow a => Term s a -> Term s PString
data Term (s :: S) (a :: PType)
data S

-- | <ul>
--   <li>Closed* terms with no free variables.</li>
--   </ul>
type ClosedTerm (a :: PType) = forall (s :: S). Term s a
data PDelayed (a :: PType) (s :: S)

-- | Lambda Application.
papp :: Term s (a :--> b) -> Term s a -> Term s b

-- | Plutus 'delay', used for laziness.
pdelay :: Term s a -> Term s (PDelayed a)

-- | Plutus 'force', used to force evaluation of <a>PDelayed</a> terms.
pforce :: Term s (PDelayed a) -> Term s a

-- | Plutus 'error'.
--   
--   When using this explicitly, it should be ensured that the containing
--   term is delayed, avoiding premature evaluation.
perror :: Term s a
phoistAcyclic :: HasCallStack => ClosedTerm a -> Term s a

-- | Let bindings.
--   
--   This is approximately a shorthand for a lambda and application:
--   
--   <tt>plet v f</tt> == <tt> papp (plam f) v</tt>
--   
--   But sufficiently small terms in WHNF may be inlined for efficiency.
plet :: Term s a -> (Term s a -> Term s b) -> Term s b
pthrow :: HasCallStack => Text -> Term s a

-- | High precedence infixl synonym of <a>papp</a>, to be used like
--   function juxtaposition. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x # y
--   f x y
--   </pre>
(#) :: Term s (a :--> b) -> Term s a -> Term s b
infixl 8 #

-- | Low precedence infixr synonym of <a>papp</a>, to be used like
--   <a>$</a>, in combination with <a>#</a>. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x #$ g # y # z
--   f x (g y z)
--   </pre>
(#$) :: Term s (a :--> b) -> Term s a -> Term s b
infixr 0 #$
data (:-->) (a :: PType) (b :: PType) (s :: S)
infixr 0 :-->
type family PSubtype (a :: PType) (b :: PType) :: Constraint

-- | <tt>PTryFrom a b</tt> represents a subtyping relationship between
--   <tt>a</tt> and <tt>b</tt>, and a way to go from <tt>a</tt> to
--   <tt>b</tt>. Laws: - <tt>(punsafeCoerce . fst) <a>$</a> tcont (ptryFrom
--   x)  pure x</tt>
class PSubtype a b => PTryFrom (a :: PType) (b :: PType) where {
    type PTryFromExcess a b :: PType;
    type PTryFromExcess a b = PTryFromExcess a (PInner b);
}
ptryFrom' :: forall s r. PTryFrom a b => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r
ptryFrom' :: forall s r. (PTryFrom a b, PTryFrom a (PInner b), PTryFromExcess a b ~ PTryFromExcess a (PInner b)) => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r
ptryFrom :: forall b a s r. PTryFrom a b => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r
pupcast :: forall a b s. PSubtype a b => Term s b -> Term s a

data PMaybe (a :: S -> Type) (s :: S)
PJust :: Term s a -> PMaybe (a :: S -> Type) (s :: S)
PNothing :: PMaybe (a :: S -> Type) (s :: S)

-- | Plutus encoding of Pairs.
--   
--   Note: This is represented differently than <tt>BuiltinPair</tt>. It is
--   SoP encoded.
data PPair (a :: S -> Type) (b :: S -> Type) (s :: S)
PPair :: Term s a -> Term s b -> PPair (a :: S -> Type) (b :: S -> Type) (s :: S)

-- | A Scott-encoded rational number, with a guaranteed positive
--   denominator (and thus, a canonical form).
--   
--   <h1>Note</h1>
--   
--   This is not the Plutarch equivalent of a Plutus <tt>Rational</tt>; for
--   this, you want <tt>PRationalData</tt> from
--   <tt>plutarch-ledger-api</tt>. <a>PRational</a> is designed to optimize
--   for computation: if you want to do any serious work with rational
--   numbers that isn't just passing them around, you want to use (or
--   convert to) <a>PRational</a>.
data PRational s
PRational :: Term s PInteger -> Term s PPositive -> PRational s
pdenominator :: Term s (PRational :--> PPositive)
pnumerator :: Term s (PRational :--> PInteger)
pround :: Term s (PRational :--> PInteger)
newtype TermCont :: forall (r :: PType). S -> Type -> Type
[TermCont] :: forall r s a. ((a -> Term s r) -> Term s r) -> TermCont @r s a

-- | Trace a message and raise error if <tt>cond</tt> is false. Otherwise,
--   continue.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   onlyAllow42 :: Term s (PInteger :--&gt; PUnit)
--   onlyAllow42 = plam $ i -&gt; unTermCont $ do
--     pguardC "expected 42" $ i #== 42
--     pure $ pconstant ()
--   </pre>
pguardC :: Term s PString -> Term s PBool -> TermCont s ()

-- | Stop computation and return given term if <tt>cond</tt> is false.
--   Otherwise, continue.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   is42 :: Term s (PInteger :--&gt; PBool)
--   is42 = plam $ i -&gt; unTermCont $ do
--     pguardC' (pconstant False) $ i #== 42
--     pure $ pconstant True
--   </pre>
pguardC' :: Term s a -> Term s PBool -> TermCont @a s ()

-- | Like <a>plet</a> but works in a <a>TermCont</a> monad
pletC :: Term s a -> TermCont s (Term s a)

-- | Like <a>pmatch</a> but works in a <a>TermCont</a> monad
pmatchC :: PlutusType a => Term s a -> TermCont s (a s)

-- | Like <tt>ptrace</tt> but works in a <a>TermCont</a> monad.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   foo :: Term s PUnit
--   foo = unTermCont $ do
--     ptraceC "returning unit!"
--     pure $ pconstant ()
--   </pre>
ptraceC :: Term s PString -> TermCont s ()

-- | <a>TermCont</a> producing version of <a>ptryFrom</a>.
ptryFromC :: forall b r a s. PTryFrom a b => Term s a -> TermCont @r s (Term s b, Reduce (PTryFromExcess a b s))
unTermCont :: TermCont @a s (Term s a) -> Term s a
tcont :: ((a -> Term s r) -> Term s r) -> TermCont @r s a

-- | Backward compatibility synonym for <a>ptraceInfo</a>.

-- | <i>Deprecated: Use ptraceInfo</i>
ptrace :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

-- | Trace the given message at the debug level before evaluating the given
--   argument.
ptraceDebug :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

-- | Trace the given message at the debug level, then terminate with
--   <a>perror</a>.
ptraceDebugError :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a

-- | Trace the given message at the debug level if the argument is false.
ptraceDebugIfFalse :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the debug level if the argument is true.
ptraceDebugIfTrue :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Like Haskell's <tt>traceShowId</tt> but for Plutarch, at the debug
--   level.
ptraceDebugShowId :: forall (a :: S -> Type) (s :: S). PShow a => Term s a -> Term s a

-- | Synonym for <a>ptraceInfoError</a>.

-- | <i>Deprecated: Use ptraceInfoError</i>
ptraceError :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a

-- | Synonym for <a>ptraceInfoIfFalse</a>.

-- | <i>Deprecated: Use ptraceInfoIfFalse</i>
ptraceIfFalse :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the info level before evaluating the given
--   argument.
ptraceInfo :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

-- | Trace the given message at the info level, then terminate with
--   <a>perror</a>.
ptraceInfoError :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a

-- | Trace the given message at the info level if the argument is false.
ptraceInfoIfFalse :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the info level if the argument is true.
ptraceInfoIfTrue :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Like Haskell's <tt>traceShowId</tt> but for Plutarch, at the info
--   level.
ptraceInfoShowId :: forall (a :: S -> Type) (s :: S). PShow a => Term s a -> Term s a

-- | Synonym for <a>ptraceInfoShowId</a>.

-- | <i>Deprecated: Use ptraceInfoShowId</i>
ptraceShowId :: forall (a :: S -> Type) (s :: S). PShow a => Term s a -> Term s a

-- | <h1>Laws</h1>
--   
--   The only mandatory law is that <a>#&lt;&gt;</a> must be associative:
--   
--   <tt>x #&lt;&gt; (y #&lt;&gt; z)</tt> <tt>=</tt> <tt>(x #&lt;&gt; y)
--   #&lt;&gt; z</tt>
--   
--   If you define <a>pstimes</a>, ensure the following also hold:
--   
--   <ol>
--   <li><tt>pstimes pone x</tt> <tt>=</tt> <tt>x</tt></li>
--   <li><tt>(pstimes p1 x) #&lt;&gt; (pstimes p2 x)</tt> <tt>=</tt>
--   <tt>pstimes (p1 #+ p2) x</tt></li>
--   <li><tt>pstimes p1 (pstimes p2 x)</tt> <tt>=</tt> <tt>pstimes (p1 #*
--   p2) x</tt></li>
--   </ol>
--   
--   The default implementation automatically ensures these laws hold.
class PSemigroup (a :: S -> Type)
(#<>) :: forall (s :: S). PSemigroup a => Term s a -> Term s a -> Term s a
(#<>) :: forall (s :: S). (PSemigroup a, PSemigroup (PInner a)) => Term s a -> Term s a -> Term s a
pstimes :: forall (s :: S). PSemigroup a => Term s PPositive -> Term s a -> Term s a
infixr 6 #<>

-- | <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>pmempty #&lt;&gt; x</tt> <tt>=</tt> <tt>x #&lt;&gt;
--   pmempty</tt> <tt>=</tt> <tt>x</tt></li>
--   <li><tt>pstimes n pmempty</tt> <tt>=</tt> <tt>pmempty</tt></li>
--   </ol>
--   
--   If you define <a>pmtimes</a>, ensure the following as well:
--   
--   <ol>
--   <li><tt>pmtimes (ppositiveToNatural # p) x</tt> <tt>=</tt> <tt>pstimes
--   p x</tt></li>
--   <li><tt>pmtimes pzero x</tt> <tt>=</tt> <tt>pmempty</tt></li>
--   </ol>
--   
--   The default implementation of <a>pmtimes</a> ensures these laws hold.
class PSemigroup a => PMonoid (a :: S -> Type)
pmempty :: forall (s :: S). PMonoid a => Term s a
pmempty :: forall (s :: S). (PMonoid a, PMonoid (PInner a)) => Term s a
pmtimes :: forall (s :: S). PMonoid a => Term s PNatural -> Term s a -> Term s a

-- | Wrapper for types which have logical AND semantics somehow.
newtype PAnd (a :: S -> Type) (s :: S)
PAnd :: Term s a -> PAnd (a :: S -> Type) (s :: S)

-- | Wrapper for types which have logical OR semantics somehow.
newtype POr (a :: S -> Type) (s :: S)
POr :: Term s a -> POr (a :: S -> Type) (s :: S)

-- | Wrapper for types which have logical XOR semantics somehow.
newtype PXor (a :: S -> Type) (s :: S)
PXor :: Term s a -> PXor (a :: S -> Type) (s :: S)

-- | This is simplified version of <tt>punrollBound'</tt> without doing
--   additional recursion on Haskell level value.
punrollBound :: forall a b s. Integer -> Term s (a :--> b) -> (Term s (a :--> b) -> Term s (a :--> b)) -> Term s (a :--> b)

-- | The first argument specifies the unrolling depth. The second argument
--   defines the fallback behavior when the recursion depth exceeds the
--   provided unrolling depth.
--   
--   The fixed-point implementation provided requires a Haskell-level value
--   <tt>c</tt> and a Plutarch function of type `Term s (a :--&gt; b)`. The
--   functional for the recursion is passed as a Haskell function. The
--   inclusion of the additional, arbitrary Haskell value (typed
--   <tt>c</tt>) enables further optimization by allowing pre-computation
--   of constant values that depend only on the recursion depth.
--   
--   This function will be used in a very niche situations. Using
--   Haskell-level value for constant replacement is only practical on a
--   single branch recursion with constant value that needs to be added on
--   each step. <tt>plength</tt> is one of the niche use case.
punrollBound' :: forall a b c s. Integer -> (c -> Term s (a :--> b)) -> ((c -> Term s (a :--> b)) -> c -> Term s (a :--> b)) -> c -> Term s (a :--> b)

-- | Unroll given amount of steps, and for rest, uses <a>pfix</a> to
--   support unbound recursion.
punrollUnbound :: forall a b s. Integer -> (Term s (a :--> b) -> Term s (a :--> b)) -> Term s (a :--> b)

-- | Uses <a>pfix</a> to recurse unrolled function itself. Unlike
--   <tt>punrollUnbound</tt>, this function uses unrolled instructions
--   within <a>pfix</a> recursions.
--   
--   This should perform better than <tt>punrollUnbound</tt> when a
--   function requires a large recursion depth.
punrollUnboundWhole :: forall a b s. Integer -> (Term s (a :--> b) -> Term s (a :--> b)) -> Term s (a :--> b)
