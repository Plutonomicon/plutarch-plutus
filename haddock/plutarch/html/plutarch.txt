-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package plutarch
@version 1.9.0

module Plutarch.DataRepr.Internal.HList.Utils
newtype Labeled sym a
Labeled :: a -> Labeled sym a
[$sel:unLabeled:Labeled] :: Labeled sym a -> a

-- | GADT proof-witness of HList membership, usable as an index
data Elem (a :: k) (as :: [k])
[Here] :: Elem a (a ': as)
[There] :: Elem a as -> Elem a (b ': as)

-- | Indexing type-level lists
type family IndexList (n :: Nat) (l :: [k]) :: k

-- | Indexing list of labeled pairs by label
type family IndexLabel name as

-- | Return the single item from a singleton list
type family SingleItem (as :: [k]) :: k

-- | Drop first n fields of a list
type family Drop (n :: Nat) (as :: [k]) :: [k]

module Plutarch.Internal.PrettyStack
prettyStack :: Text -> CallStack -> Text

module Plutarch.Internal.Witness
witness :: c => Proxy c -> ()

module Plutarch.Pretty.Internal.Config
keywords :: Set Text
indentWidth :: Int

-- | Prefix to use for naming forced builtin functions.
forcedPrefix :: Text

module Plutarch.Pretty.Internal.BuiltinConstant
prettyConstant :: Some (ValueOf DefaultUni) -> Doc ()

module Plutarch.Pretty.Internal.TermUtils
unwrapLamAbs :: Index -> Term name uni fun ann -> (Index, Term name uni fun ann)
unwrapBindings :: [Term name uni fun ann] -> Term name uni fun ann -> ([Term name uni fun ann], Term name uni fun ann)
unwrapApply :: [Term name uni fun ann] -> Term name uni fun ann -> ([Term name uni fun ann], Term name uni fun ann)

-- | Increment the debruijn index of a <a>Var</a>, leave any other AST node
--   unchanged.
incrVar :: Term DeBruijn uni fun () -> Term DeBruijn uni fun ()
pattern PFixAst :: Term name uni fun ()
pattern ComposeAST :: Term DeBruijn uni fun () -> Term DeBruijn uni fun () -> Term DeBruijn uni fun ()
pattern IfThenElseLikeAST :: Term name uni fun () -> Term name uni fun () -> Term name uni fun () -> Term name uni fun () -> Term name uni fun ()

module Plutarch.Pretty.Internal.Types

-- | Notifies the prettifier what "state" the cursor currently is, so it
--   can decide whether or not to wrap the target expression in parens.
--   
--   Normal indicates no parens wrapping is necessary, even for complex
--   expressions.
--   
--   Special indicates complex expressions should be wrapped in parens.
--   
--   Usually, <a>Special</a> just hints at one of three states:
--   
--   <ol>
--   <li>Applying - The expression is being applied like a function.</li>
--   <li>Applied - The expression is being applied as a function
--   argument.</li>
--   <li>Unary arg - The expression is being used as an argument to a high
--   arity unary operator (~ and !).</li>
--   </ol>
data PrettyCursor
Normal :: PrettyCursor
Special :: PrettyCursor
data PrettyState
PrettyState :: Map Index Text -> Set Text -> PrettyCursor -> PrettyState
[$sel:ps'nameMap:PrettyState] :: PrettyState -> Map Index Text
[$sel:ps'names:PrettyState] :: PrettyState -> Set Text
[$sel:ps'cursor:PrettyState] :: PrettyState -> PrettyCursor
type PrettyMonad s = ReaderT (STGenM StdGen s) (StateT PrettyState (ST s))
forkState :: MonadState s m => m b -> m b
normalizeCursor :: PrettyState -> PrettyState
specializeCursor :: PrettyState -> PrettyState
memorizeName :: Text -> PrettyState -> PrettyState

-- | Insert a fresh binding onto the name map, i.e a name at index 0 -
--   incrementing all other indices.
insertName :: Text -> PrettyState -> PrettyState
insertBindings :: [Text] -> PrettyState -> PrettyState
builtinFunAtRef :: Map Index Text -> Index -> Maybe DefaultFun
nameOfRef :: Index -> Map Index Text -> Maybe Text
instance GHC.Show.Show Plutarch.Pretty.Internal.Types.PrettyCursor
instance GHC.Classes.Eq Plutarch.Pretty.Internal.Types.PrettyCursor
instance GHC.Enum.Enum Plutarch.Pretty.Internal.Types.PrettyCursor
instance GHC.Enum.Bounded Plutarch.Pretty.Internal.Types.PrettyCursor

module Plutarch.Pretty.Internal.Name
smartName :: Term DeBruijn uni DefaultFun () -> PrettyMonad s Text
freshVarName :: PrettyMonad s Text

module Plutarch.Script
newtype Script
Script :: Program DeBruijn DefaultUni DefaultFun () -> Script
[$sel:unScript:Script] :: Script -> Program DeBruijn DefaultUni DefaultFun ()
serialiseScript :: Script -> ShortByteString
deserialiseScript :: ShortByteString -> Script
instance GHC.Generics.Generic Plutarch.Script.Script
instance GHC.Show.Show Plutarch.Script.Script
instance GHC.Classes.Eq Plutarch.Script.Script

module Plutarch.Internal.Evaluate
uplcVersion :: Version

-- | Evaluate a script with a big budget, returning the trace log and term
--   result.
evalScript :: Script -> (Either EvalError Script, ExBudget, [Text])

-- | Evaluate a script with a huge budget, returning the trace log and term
--   result.
evalScriptHuge :: Script -> (Either EvalError Script, ExBudget, [Text])

-- | Evaluate a script without budget limit
--   
--   @since WIP
evalScriptUnlimited :: Script -> (Either (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun) Script, ExBudget, [Text])

-- | Evaluate a script with a specific budget, returning the trace log and
--   term result.
evalScript' :: ExBudget -> Script -> (Either (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun) Script, ExBudget, [Text])
type EvalError = (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun)

module Plutarch.Internal.Term
newtype (:-->) (a :: PType) (b :: PType) (s :: S)
PLam :: (Term s a -> Term s b) -> (:-->) (a :: PType) (b :: PType) (s :: S)
infixr 0 :-->
data PDelayed (a :: PType) (s :: S)
newtype Term (s :: S) (a :: PType)
Term :: (Word64 -> TermMonad TermResult) -> Term (s :: S) (a :: PType)
[$sel:asRawTerm:Term] :: Term (s :: S) (a :: PType) -> Word64 -> TermMonad TermResult
asClosedRawTerm :: ClosedTerm a -> TermMonad TermResult
newtype Script
Script :: Program DeBruijn DefaultUni DefaultFun () -> Script
mapTerm :: (RawTerm -> RawTerm) -> TermResult -> TermResult

-- | Lambda abstraction.
--   
--   Only works with a single argument. Use <tt>plam</tt> instead, to
--   support currying.
plam' :: (Term s a -> Term s b) -> Term s (a :--> b)

-- | Let bindings.
--   
--   This is approximately a shorthand for a lambda and application:
--   
--   <tt>plet v f</tt> == <tt> papp (plam f) v</tt>
--   
--   But sufficiently small terms in WHNF may be inlined for efficiency.
plet :: Term s a -> (Term s a -> Term s b) -> Term s b

-- | Lambda Application.
papp :: Term s (a :--> b) -> Term s a -> Term s b

-- | Plutus 'delay', used for laziness.
pdelay :: Term s a -> Term s (PDelayed a)

-- | Plutus 'force', used to force evaluation of <a>PDelayed</a> terms.
pforce :: Term s (PDelayed a) -> Term s a
phoistAcyclic :: HasCallStack => ClosedTerm a -> Term s a

-- | Plutus 'error'.
--   
--   When using this explicitly, it should be ensured that the containing
--   term is delayed, avoiding premature evaluation.
perror :: Term s a

-- | Same as <tt>perror</tt> except this holds integer id for AST
--   look-ahead.
--   
--   This can be used to "tag" branch and generate AST first to see if that
--   branch is actually used or not, allowing optimization cutting unused
--   branches. For more detailed uscases, check <tt>pmatchDataRec</tt>.
pplaceholder :: Integer -> Term s a

-- | Unsafely coerce the type-tag of a Term.
--   
--   This should mostly be avoided, though it can be safely used to assert
--   known types of Datums, Redeemers or ScriptContext.
punsafeCoerce :: forall b a s. Term s a -> Term s b
punsafeBuiltin :: DefaultFun -> Term s a

-- | <i>Deprecated: Use <tt>pconstant</tt> instead.</i>
punsafeConstant :: Some (ValueOf DefaultUni) -> Term s a
punsafeConstantInternal :: Some (ValueOf DefaultUni) -> Term s a

-- | Compile a (closed) Plutus Term to a usable script
compile :: Config -> ClosedTerm a -> Either Text Script

-- | As <a>compile</a>, but performs UPLC optimizations. Furthermore, this
--   will always elide tracing (as if with <a>NoTracing</a>).
--   
--   @since WIP
compileOptimized :: forall (a :: S -> Type). (forall (s :: S). Term s a) -> Either Text Script
compile' :: TermResult -> UTerm

-- | Given a closed <a>Term</a>, run the UPLC optimizer on it.
--   
--   <h1>Important note</h1>
--   
--   If the input term has any hoisted dependencies, these are completely
--   erased by this process. Thus, if the resulting <a>Term</a> is used as
--   part of a larger computation with the same dependencies, the Plutarch
--   compiler will not be aware of them, and will not be able to optimize
--   them properly. More concretely, in a case like this:
--   
--   @<tt> padd # optimizeTerm (f # pexpensive) # optimizeTerm (g #
--   pexpensive) </tt>@
--   
--   <tt>pexpensive</tt> will end up being duplicated entirely into each
--   'arm' of the <tt>padd</tt>, even though under normal circumstances it
--   could be shared.
--   
--   Thus, if you plan to use this, ensure that it is done 'as late as
--   possible'; embedding <a>Term</a>s produced by <a>optimizeTerm</a> into
--   larger computations can lead to size blowout if not done carefully.
optimizeTerm :: forall (a :: S -> Type). (forall (s :: S). Term s a) -> forall (s :: S). Term s a

-- | <ul>
--   <li>Closed* terms with no free variables.</li>
--   </ul>
type ClosedTerm (a :: PType) = forall (s :: S). Term s a
type Dig = Digest Blake2b_160
hashTerm :: Config -> ClosedTerm a -> Either Text Dig
hashRawTerm :: RawTerm -> Dig
data RawTerm
RVar :: Word64 -> RawTerm
RLamAbs :: Word64 -> RawTerm -> RawTerm
RApply :: RawTerm -> [RawTerm] -> RawTerm
RForce :: RawTerm -> RawTerm
RDelay :: RawTerm -> RawTerm
RConstant :: Some (ValueOf DefaultUni) -> RawTerm
RBuiltin :: DefaultFun -> RawTerm
RCompiled :: UTerm -> RawTerm
RError :: RawTerm
RHoisted :: HoistedTerm -> RawTerm
RPlaceHolder :: Integer -> RawTerm
RConstr :: Word64 -> [RawTerm] -> RawTerm
RCase :: RawTerm -> [RawTerm] -> RawTerm
data HoistedTerm
HoistedTerm :: Dig -> RawTerm -> HoistedTerm
data TermResult
TermResult :: RawTerm -> [HoistedTerm] -> TermResult
[$sel:getTerm:TermResult] :: TermResult -> RawTerm
[$sel:getDeps:TermResult] :: TermResult -> [HoistedTerm]
data S
SI :: S

-- | Shorthand for Plutarch types.
type PType = S -> Type
pthrow :: HasCallStack => Text -> Term s a

-- | Configuration for Plutarch scripts at compile time. This indicates
--   whether we want to trace, and if so, under what log level and mode.
data Config

-- | Pattern for the config that does no tracing (also the default).
pattern NoTracing :: Config

-- | Pattern for a tracing config, with both its log level and mode.
pattern Tracing :: LogLevel -> TracingMode -> Config

-- | How to trace.
data TracingMode
DetTracing :: TracingMode
DoTracing :: TracingMode
DoTracingAndBinds :: TracingMode

-- | What logging level we want to use.
data LogLevel
LogInfo :: LogLevel
LogDebug :: LogLevel

-- | If the config indicates that we want to trace, get its mode.
tracingMode :: Config -> Maybe TracingMode

-- | If the config indicates that we want to trace, get its log level.
logLevel :: Config -> Maybe LogLevel
pgetConfig :: (Config -> Term s a) -> Term s a
newtype TermMonad m
TermMonad :: ReaderT Config (Either Text) m -> TermMonad m
[$sel:runTermMonad:TermMonad] :: TermMonad m -> ReaderT Config (Either Text) m

-- | High precedence infixl synonym of <a>papp</a>, to be used like
--   function juxtaposition. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x # y
--   f x y
--   </pre>
(#) :: Term s (a :--> b) -> Term s a -> Term s b
infixl 8 #

-- | Low precedence infixr synonym of <a>papp</a>, to be used like
--   <a>$</a>, in combination with <a>#</a>. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x #$ g # y # z
--   f x (g y z)
--   </pre>
(#$) :: Term s (a :--> b) -> Term s a -> Term s b
infixr 0 #$
instance GHC.Show.Show Plutarch.Internal.Term.HoistedTerm
instance GHC.Show.Show Plutarch.Internal.Term.RawTerm
instance GHC.Show.Show Plutarch.Internal.Term.TracingMode
instance GHC.Classes.Eq Plutarch.Internal.Term.TracingMode
instance GHC.Show.Show Plutarch.Internal.Term.LogLevel
instance GHC.Classes.Eq Plutarch.Internal.Term.LogLevel
instance GHC.Show.Show Plutarch.Internal.Term.Config
instance GHC.Classes.Eq Plutarch.Internal.Term.Config
instance GHC.Base.Monoid Plutarch.Internal.Term.Config
instance GHC.Base.Semigroup Plutarch.Internal.Term.Config
instance GHC.Base.Monad Plutarch.Internal.Term.TermMonad
instance GHC.Base.Applicative Plutarch.Internal.Term.TermMonad
instance GHC.Base.Functor Plutarch.Internal.Term.TermMonad
instance Prettyprinter.Internal.Pretty Plutarch.Internal.Term.Config
instance Data.Aeson.Types.ToJSON.ToJSON Plutarch.Internal.Term.Config
instance Data.Aeson.Types.FromJSON.FromJSON Plutarch.Internal.Term.Config
instance GHC.Classes.Ord Plutarch.Internal.Term.LogLevel
instance GHC.Base.Semigroup Plutarch.Internal.Term.LogLevel
instance Prettyprinter.Internal.Pretty Plutarch.Internal.Term.LogLevel
instance Data.Aeson.Types.ToJSON.ToJSON Plutarch.Internal.Term.LogLevel
instance Data.Aeson.Types.FromJSON.FromJSON Plutarch.Internal.Term.LogLevel
instance GHC.Classes.Ord Plutarch.Internal.Term.TracingMode
instance GHC.Base.Semigroup Plutarch.Internal.Term.TracingMode
instance Prettyprinter.Internal.Pretty Plutarch.Internal.Term.TracingMode
instance Data.Aeson.Types.ToJSON.ToJSON Plutarch.Internal.Term.TracingMode
instance Data.Aeson.Types.FromJSON.FromJSON Plutarch.Internal.Term.TracingMode

module Plutarch.Reducible

-- | This class provides a work-around for partially applying type families
--   of kind <tt>a</tt>, where <tt>a</tt> is either <a>Type</a> or <tt>b
--   -&gt; c</tt> where <tt>c</tt> satisfies the same constraint.
--   
--   Given a type family <tt>F : A -&gt; Type</tt>, you can make the
--   following <tt> type F' :: A -&gt; Type newtype F' (a :: A) = F'
--   (NoReduce (F a)) deriving stock Generic </tt> It is then true that
--   <tt>forall a. Reduce (F' a) ~ F a</tt>.
type family Reduce (x :: Type) :: Type
newtype NoReduce a
NoReduce :: a -> NoReduce a
reduce :: Coercible a (Reduce a) => a -> Reduce a

module Plutarch.Internal.TypeFamily

-- | Convert a list of `Term s a` to a list of <tt>a</tt>.
type family ToPType as
type family ToPType2 as
type family UnTerm x
type family Snd ab

module Plutarch.Internal.Quantification
newtype PForall (b :: a -> PType) s
PForall :: (forall (x :: a). Term s (b x)) -> PForall (b :: a -> PType) s
data PSome (b :: a -> PType) s
PSome :: Term s (b x) -> PSome (b :: a -> PType) s
newtype PFix f s
PFix :: Term s (f (PFix f)) -> PFix f s

module Plutarch.Internal.Generic

-- | <a>Generic</a> constraint extended to work with Plutarch types.
class (forall s. PGeneric' a s) => PGeneric a
class (Generic (a s), GFrom (a s), GTo (a s), All2 Top (PCode a), All2 Top (GCode (a s)), GDatatypeInfo (a s)) => PGeneric' a s

-- | Like <tt>Code</tt> but for Plutarch types
type PCode a = ToPType2 (GCode (a Any))
gpfrom :: forall a s. PGeneric a => a s -> SOP (Term s) (PCode a)
gpto :: forall a s. PGeneric a => SOP (Term s) (PCode a) -> a s
instance forall (a :: Plutarch.Internal.Term.PType). (forall (s :: Plutarch.Internal.Term.S). Plutarch.Internal.Generic.PGeneric' a s) => Plutarch.Internal.Generic.PGeneric a
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). (GHC.Generics.Generic (a s), Generics.SOP.GGP.GFrom (a s), Generics.SOP.GGP.GTo (a s), Data.SOP.Constraint.All2 @{Plutarch.Internal.Term.PType} (Data.SOP.Constraint.Top @{Plutarch.Internal.Term.PType}) (Plutarch.Internal.Generic.PCode a), Data.SOP.Constraint.All2 @{GHC.Types.Type} (Data.SOP.Constraint.Top @{GHC.Types.Type}) (Generics.SOP.GGP.GCode (a s)), Generics.SOP.GGP.GDatatypeInfo (a s)) => Plutarch.Internal.Generic.PGeneric' a s
instance forall a. Generics.SOP.GGP.GTo a => Plutarch.Internal.Generic.GTo' a
instance forall a. Generics.SOP.GGP.GFrom a => Plutarch.Internal.Generic.GFrom' a

module Plutarch.Builtin.Unit
data PUnit (s :: S)
PUnit :: PUnit (s :: S)
punit :: Term s PUnit
instance forall (s :: Plutarch.Internal.Term.S). GHC.Base.Semigroup (Plutarch.Internal.Term.Term s Plutarch.Builtin.Unit.PUnit)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Base.Monoid (Plutarch.Internal.Term.Term s Plutarch.Builtin.Unit.PUnit)

module Plutarch.Builtin.Opaque

-- | An Arbitrary Term with an unknown type
newtype POpaque s
POpaque :: Term s POpaque -> POpaque s

-- | Erase the type of a Term
popaque :: Term s a -> Term s POpaque

module Plutarch.Internal.Fix

-- | Fixpoint recursion. Used to encode recursive functions.
--   
--   Example:
--   
--   <pre>
--   iterateN' ::
--    Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a) -&gt;
--    Term s PInteger -&gt;
--    Term s (a :--&gt; a) -&gt;
--    Term s a
--   iterateN' self n f x =
--     pif (n #== 0) x (self # n - 1 #$ f x)
--   
--   iterateN :: Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a)
--   iterateN = pfix #$ plam iterateN'
--   </pre>
--   
--   Further examples can be found in examples/Recursion.hs
pfix :: Term s (((a :--> b) :--> (a :--> b)) :--> (a :--> b))

module Plutarch.Builtin.Bool

-- | Builtin Plutus boolean.
--   
--   @since WIP
data PBool (s :: S)
PTrue :: PBool (s :: S)
PFalse :: PBool (s :: S)

-- | @since WIP
pbuiltinIfThenElse :: forall (a :: S -> Type) (s :: S). Term s (PBool :--> (a :--> (a :--> PDelayed a)))

-- | Strict if-then-else. Emits slightly less code than the lazy version.
--   
--   @since WIP
pif' :: forall (a :: S -> Type) (s :: S). Term s (PBool :--> (a :--> (a :--> a)))

-- | Lazy if-then-else.
--   
--   @since WIP
pif :: forall (a :: S -> Type) (s :: S). Term s PBool -> Term s a -> Term s a -> Term s a

-- | Boolean negation.
--   
--   @since WIP
pnot :: forall (s :: S). Term s (PBool :--> PBool)

-- | Lazy AND for terms.
--   
--   @since WIP
(#&&) :: forall (s :: S). Term s PBool -> Term s PBool -> Term s PBool
infixr 3 #&&

-- | Lazy OR for terms.
--   
--   @since WIP
(#||) :: forall (s :: S). Term s PBool -> Term s PBool -> Term s PBool
infixr 2 #||

-- | Hoisted lazy OR at the Plutarch level.
--   
--   @since WIP
por :: forall (s :: S). Term s (PBool :--> (PDelayed PBool :--> PDelayed PBool))

-- | Hoisted lazy AND at the Plutarch level.
--   
--   @since WIP
pand :: forall (s :: S). Term s (PBool :--> (PDelayed PBool :--> PDelayed PBool))

-- | As <a>pand</a>, but strict.
--   
--   @since WIP
pand' :: forall (s :: S). Term s (PBool :--> (PBool :--> PBool))

-- | As <a>por</a>, but strict.
--   
--   @since WIP
por' :: Term s (PBool :--> (PBool :--> PBool))

-- | Essentially multi-way <a>pif</a>. More precisely, given a list of
--   condition-action pairs, and an 'action of last resort', construct a
--   left-to-right 'chain' of <tt>pif</tt>s, using the conditions to
--   determine which action gets taken. The 'action of last resort'
--   finishes the 'chain'. For example:
--   
--   <pre>
--   pcond [(cond1, act1), (cond2, act2)] act3
--   </pre>
--   
--   does the same thing as
--   
--   <pre>
--   pif cond1 act1 (pif cond2 act2 act3)
--   </pre>
--   
--   @since WIP
pcond :: forall (a :: S -> Type) (s :: S). [(Term s PBool, Term s a)] -> Term s a -> Term s a
ptrue :: Term (s :: S) PBool
pfalse :: Term (s :: S) PBool
instance forall (s :: Plutarch.Internal.Term.S). GHC.Show.Show (Plutarch.Builtin.Bool.PBool s)

module Plutarch.Builtin.Integer

-- | A builtin Plutus integer.
--   
--   @since WIP
data PInteger s

-- | Performs modulo exponentiation. More precisely, <tt>pexpModInteger b e
--   m</tt> performs <tt>b</tt> to the power of <tt>e</tt>, modulo
--   <tt>m</tt>. The result is always non-negative.
--   
--   <h1>Note</h1>
--   
--   This will error if the modulus is zero. When given a negative
--   exponent, this will try to find a modular multiplicative inverse, and
--   will error if none exists.
--   
--   @since WIP
pexpModInteger :: forall (s :: S). Term s (PInteger :--> (PInteger :--> (PInteger :--> PInteger)))
peqInteger :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PBool))
pleInteger :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PBool))
pltInteger :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PBool))
paddInteger :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))
psubtractInteger :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))
pmultiplyInteger :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))
pconstantInteger :: forall (s :: S). Integer -> Term s PInteger
pquotientInteger :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))
premainderInteger :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Builtin.Integer.PInteger s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Builtin.Integer.PInteger s)

module Plutarch.Builtin.ByteString

-- | Plutus <tt>BuiltinByteString</tt>
newtype PByteString s
PByteString :: Term s POpaque -> PByteString s

-- | A Plutarch-level representation of bytes.
--   
--   <h1>Note =</h1>
--   
--   This type is intentionally quite restrictive, as it's not really meant
--   to be computed with. Instead, it ensures certain operations' type
--   safety while also allowing more sensible signatures. If you want to do
--   anything with <a>PByte</a>s, we recommend converting them to
--   <a>PInteger</a>s first.
--   
--   @since WIP
newtype PByte (s :: S)
PByte :: Term s POpaque -> PByte (s :: S)

-- | Type designating whether logical operations should use padding or
--   truncation semantics. See <a>CIP-122</a> for more details on this.
--   
--   @since WIP
newtype PLogicOpSemantics (s :: S)
PLogicOpSemantics :: Term s PBool -> PLogicOpSemantics (s :: S)

-- | Type designating whether a conversion should be most-significant-first
--   or most-significant-last. See <a>CIP-121</a> for more details on this.
--   
--   @since WIP
newtype PEndianness (s :: S)
PEndianness :: Term s PBool -> PEndianness (s :: S)

-- | Indicates that padding semantics should be used.
--   
--   @since WIP
ppadding :: forall (s :: S). Term s PLogicOpSemantics

-- | Indicates that truncation semantics should be used.
--   
--   @since WIP
ptruncation :: forall (s :: S). Term s PLogicOpSemantics

-- | Indicates the conversion should be most-significant-first.
--   
--   @since WIP
pmostSignificantFirst :: forall (s :: S). Term s PEndianness

-- | Indicates the conversion should be most-significant-last.
--   
--   @since WIP
pmostSignificantLast :: forall (s :: S). Term s PEndianness

-- | Perform the logical AND of two <a>PByteString</a>s, as per
--   <a>CIP-122</a>. The <a>PLogicOpSemantics</a> argument specifies what
--   should be done if the lengths of the two <a>PByteString</a> arguments
--   do not match.
--   
--   @since WIP
pandBS :: forall (s :: S). Term s (PLogicOpSemantics :--> (PByteString :--> (PByteString :--> PByteString)))

-- | Perform the logical OR of two <a>PByteString</a>s, as per
--   <a>CIP-122</a>. The <a>PLogicOpSemantics</a> argument specifies what
--   should be done if the lengths of the two <a>PByteString</a> arguments
--   do not match.
--   
--   @since WIP
porBS :: forall (s :: S). Term s (PLogicOpSemantics :--> (PByteString :--> (PByteString :--> PByteString)))

-- | Perform the logical XOR of two <a>PByteString</a>s, as per
--   <a>CIP-122</a>. The <a>PLogicOpSemantics</a> argument specifies what
--   should be done if the lengths of the two <a>PByteString</a> arguments
--   do not match.
--   
--   @since WIP
pxorBS :: forall (s :: S). Term s (PLogicOpSemantics :--> (PByteString :--> (PByteString :--> PByteString)))

-- | Perform the logical complement of a <a>PByteString</a>, as per
--   <a>CIP-122</a>.
--   
--   @since WIP
pcomplementBS :: forall (s :: S). Term s (PByteString :--> PByteString)

-- | Given a desired length and a <a>PByte</a>, construct a
--   <a>PByteString</a> of the specified length (0 if negative) consisting
--   entirely of that <a>PByte</a>.
--   
--   @since WIP
preplicateBS :: forall (s :: S). Term s (PInteger :--> (PByte :--> PByteString))

-- | Prepend a <a>PByte</a> to a 'PByteString.
--   
--   @since WIP
pconsBS :: Term s (PByte :--> (PByteString :--> PByteString))

-- | Convert a <a>PByte</a> into its corresponding <a>PInteger</a>.
--   
--   @since WIP
pbyteToInteger :: Term s (PByte :--> PInteger)

-- | Try to convert a <a>PInteger</a> into its corresponding <a>PByte</a>.
--   This operation unchecked: use with care.
--   
--   @since WIP
pintegerToByte :: Term s (PInteger :--> PByte)

-- | Slice a <a>PByteString</a> with given start index and slice length.
--   
--   <pre>
--   &gt;&gt;&gt; (pslice # 2 # 3 phexByteStr "4102afde5b2a") #== phexByteStr "afde5b"
--   </pre>
psliceBS :: Term s (PInteger :--> (PInteger :--> (PByteString :--> PByteString)))

-- | Find the length of a <a>PByteString</a>.
plengthBS :: Term s (PByteString :--> PInteger)

-- | Given a valid index into a <a>PByteString</a>, returns the
--   <a>PByte</a> at that index. Will crash if given an out-of-bounds
--   index.
--   
--   @since WIP
pindexBS :: Term s (PByteString :--> (PInteger :--> PByte))

-- | Interpret a hex string as a PByteString.
phexByteStr :: HasCallStack => String -> Term s PByteString

-- | Convert a <a>PByteString</a> into a <a>PInteger</a>, as per
--   <a>CIP-121</a>.
--   
--   @since WIP
pbyteStringToInteger :: forall (s :: S). Term s (PEndianness :--> (PByteString :--> PInteger))

-- | Converts a <a>PInteger</a> into a <a>PByteString</a>, given a desired
--   endianness and target length. For more details, see <a>CIP-121</a>.
--   
--   <h1>Note</h1>
--   
--   This conversion is unsafe. It will fail if any of the following occur:
--   
--   <ol>
--   <li>The size is negative.</li>
--   <li>The size is too large (currently if over 8196 bytes).</li>
--   <li>The size won't fit the integer to convert.</li>
--   </ol>
pintegerToByteString :: forall (s :: S). Term s (PEndianness :--> (PInteger :--> (PInteger :--> PByteString)))
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Builtin.ByteString.PByteString s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Builtin.ByteString.PByteString s)
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Builtin.ByteString.PByte s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Builtin.ByteString.PByte s)
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Builtin.ByteString.PEndianness s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Builtin.ByteString.PEndianness s)
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Builtin.ByteString.PLogicOpSemantics s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Builtin.ByteString.PLogicOpSemantics s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Base.Semigroup (Plutarch.Internal.Term.Term s Plutarch.Builtin.ByteString.PByteString)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Base.Monoid (Plutarch.Internal.Term.Term s Plutarch.Builtin.ByteString.PByteString)

module Plutarch.Builtin.String

-- | Plutus <tt>BuiltinString</tt> values
newtype PString s
PString :: Term s POpaque -> PString s

-- | Decode a <a>PByteString</a> using UTF-8.
pdecodeUtf8 :: Term s (PByteString :--> PString)

-- | Encode a <a>PString</a> using UTF-8.
pencodeUtf8 :: Term s (PString :--> PByteString)
ptrace' :: Term s (PString :--> (a :--> a))

-- | Trace the given message at the info level before evaluating the given
--   argument.
ptraceInfo :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Builtin.String.PString s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Builtin.String.PString s)
instance forall (s :: Plutarch.Internal.Term.S). Data.String.IsString (Plutarch.Internal.Term.Term s Plutarch.Builtin.String.PString)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Base.Semigroup (Plutarch.Internal.Term.Term s Plutarch.Builtin.String.PString)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Base.Monoid (Plutarch.Internal.Term.Term s Plutarch.Builtin.String.PString)

module Plutarch.Internal.Trace

-- | Trace the given message at the info level before evaluating the given
--   argument.
ptraceInfo :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

-- | Trace the given message at the debug level before evaluating the given
--   argument.
ptraceDebug :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a
ptrace' :: Term s (PString :--> (a :--> a))

-- | Backward compatibility synonym for <a>ptraceInfo</a>.

-- | <i>Deprecated: Use ptraceInfo</i>
ptrace :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

module Plutarch.Internal.TermCont
hashOpenTerm :: Term s a -> TermCont s Dig
newtype TermCont :: forall (r :: PType). S -> Type -> Type
[TermCont] :: forall r s a. ((a -> Term s r) -> Term s r) -> TermCont @r s a
($sel:runTermCont:TermCont) :: TermCont @r s a -> (a -> Term s r) -> Term s r
unTermCont :: TermCont @a s (Term s a) -> Term s a
tcont :: ((a -> Term s r) -> Term s r) -> TermCont @r s a

-- | Given a term, and an integer tag, this function checks if the term
--   holds and <tt>PPlaceholder</tt> with the given integer tag.
pfindPlaceholder :: Integer -> Term s a -> TermCont s Bool
instance forall (r :: Plutarch.Internal.Term.PType) (s :: Plutarch.Internal.Term.S). GHC.Base.Functor (Plutarch.Internal.TermCont.TermCont @r s)
instance forall (r :: Plutarch.Internal.Term.PType) (s :: Plutarch.Internal.Term.S). GHC.Base.Applicative (Plutarch.Internal.TermCont.TermCont @r s)
instance forall (r :: Plutarch.Internal.Term.PType) (s :: Plutarch.Internal.Term.S). GHC.Base.Monad (Plutarch.Internal.TermCont.TermCont @r s)
instance forall (r :: Plutarch.Internal.Term.PType) (s :: Plutarch.Internal.Term.S). Control.Monad.Fail.MonadFail (Plutarch.Internal.TermCont.TermCont @r s)

module Plutarch.Internal.PLam
class PLamN (a :: Type) (b :: PType) (s :: S) | a -> b, s b -> a
plam :: forall c. (PLamN a b s, HasCallStack) => (Term s c -> a) -> Term s (c :--> b)
pinl :: Term s a -> (Term s a -> Term s b) -> Term s b
instance forall a' (s :: Plutarch.Internal.Term.S) (a :: Plutarch.Internal.Term.PType). ((a' :: GHC.Types.Type) GHC.Types.~ (Plutarch.Internal.Term.Term s a :: GHC.Types.Type)) => Plutarch.Internal.PLam.PLamN a' a s
instance forall a' (s :: Plutarch.Internal.Term.S) (a :: Plutarch.Internal.Term.PType) b' (b :: Plutarch.Internal.Term.PType). ((a' :: GHC.Types.Type) GHC.Types.~ (Plutarch.Internal.Term.Term s a :: GHC.Types.Type), Plutarch.Internal.PLam.PLamN b' b s) => Plutarch.Internal.PLam.PLamN (a' -> b') (a Plutarch.Internal.Term.:--> b) s

module Plutarch.Builtin.Data
newtype PData (s :: S)
PData :: Term s PData -> PData (s :: S)
newtype PAsData (a :: S -> Type) (s :: S)
PAsData :: Term s a -> PAsData (a :: S -> Type) (s :: S)
pchooseData :: Term s (PData :--> (a :--> (a :--> (a :--> (a :--> (a :--> a))))))
pasConstr :: Term s (PData :--> PBuiltinPair PInteger (PBuiltinList PData))
pasMap :: Term s (PData :--> PBuiltinList (PBuiltinPair PData PData))
plistData :: Term s (PBuiltinList PData :--> PData)
pasList :: Term s (PData :--> PBuiltinList PData)
pasInt :: Term s (PData :--> PInteger)
pasByteStr :: Term s (PData :--> PByteString)

-- | Serialise any builtin data to its cbor represented by a builtin
--   bytestring
pserialiseData :: Term s (PData :--> PByteString)
pconstrBuiltin :: Term s (PInteger :--> (PBuiltinList PData :--> PAsData (PBuiltinPair PInteger (PBuiltinList PData))))
newtype PBuiltinPair (a :: S -> Type) (b :: S -> Type) (s :: S)
PBuiltinPair :: Term s (PBuiltinPair a b) -> PBuiltinPair (a :: S -> Type) (b :: S -> Type) (s :: S)
pfstBuiltin :: Term s (PBuiltinPair a b :--> a)
psndBuiltin :: Term s (PBuiltinPair a b :--> b)

-- | Construct a builtin pair of <a>PData</a> elements.
--   
--   Uses <a>PAsData</a> to preserve more information about the underlying
--   <a>PData</a>.
ppairDataBuiltin :: Term s (PAsData a :--> (PAsData b :--> PBuiltinPair (PAsData a) (PAsData b)))

-- | Plutus <tt>BuiltinList</tt>
data PBuiltinList (a :: S -> Type) (s :: S)
PCons :: Term s a -> Term s (PBuiltinList a) -> PBuiltinList (a :: S -> Type) (s :: S)
PNil :: PBuiltinList (a :: S -> Type) (s :: S)
pheadBuiltin :: Term s (PBuiltinList a :--> a)
ptailBuiltin :: Term s (PBuiltinList a :--> PBuiltinList a)
pchooseListBuiltin :: Term s (PBuiltinList a :--> (b :--> (b :--> b)))
pnullBuiltin :: Term s (PBuiltinList a :--> PBool)
pconsBuiltin :: Term s (a :--> (PBuiltinList a :--> PBuiltinList a))

module Plutarch.Builtin.BLS

-- | A point on the BLS12-381 G1 curve.
newtype PBuiltinBLS12_381_G1_Element s
PBuiltinBLS12_381_G1_Element :: Term s POpaque -> PBuiltinBLS12_381_G1_Element s

newtype PBuiltinBLS12_381_G2_Element s
PBuiltinBLS12_381_G2_Element :: Term s POpaque -> PBuiltinBLS12_381_G2_Element s

-- | Represents the result of a Miller loop operation in BLS12-381 pairing.
newtype PBuiltinBLS12_381_MlResult s
PBuiltinBLS12_381_MlResult :: Term s POpaque -> PBuiltinBLS12_381_MlResult s

-- | Add two points on the BLS12-381 G1 curve.
pbls12_381_G1_add :: Term s (PBuiltinBLS12_381_G1_Element :--> (PBuiltinBLS12_381_G1_Element :--> PBuiltinBLS12_381_G1_Element))

-- | Multiply a point on the BLS12-381 G1 curve by a scalar.
pbls12_381_G1_scalarMul :: Term s (PInteger :--> (PBuiltinBLS12_381_G1_Element :--> PBuiltinBLS12_381_G1_Element))

-- | Negate a point on the BLS12-381 G1 curve.
pbls12_381_G1_neg :: Term s (PBuiltinBLS12_381_G1_Element :--> PBuiltinBLS12_381_G1_Element)

-- | Compress a point on the BLS12-381 G1 curve to a byte string.
pbls12_381_G1_compress :: Term s (PBuiltinBLS12_381_G1_Element :--> PByteString)

-- | Uncompress a byte string to a point on the BLS12-381 G1 curve.
pbls12_381_G1_uncompress :: Term s (PByteString :--> PBuiltinBLS12_381_G1_Element)

-- | Hash a message to a point on the BLS12-381 G1 curve.
pbls12_381_G1_hashToGroup :: Term s (PByteString :--> (PByteString :--> PBuiltinBLS12_381_G1_Element))

-- | The compressed representation of the zero point on the BLS12-381 G1
--   curve.
pbls12_381_G1_compressed_zero :: Term s PByteString

-- | The compressed representation of the generator point on the BLS12-381
--   G1 curve.
pbls12_381_G1_compressed_generator :: Term s PByteString

-- | Add two points on the BLS12-381 G2 curve.
pbls12_381_G2_add :: Term s (PBuiltinBLS12_381_G2_Element :--> (PBuiltinBLS12_381_G2_Element :--> PBuiltinBLS12_381_G2_Element))

-- | Multiply a point on the BLS12-381 G2 curve by a scalar.
pbls12_381_G2_scalarMul :: Term s (PInteger :--> (PBuiltinBLS12_381_G2_Element :--> PBuiltinBLS12_381_G2_Element))

-- | Negate a point on the BLS12-381 G2 curve.
pbls12_381_G2_neg :: Term s (PBuiltinBLS12_381_G2_Element :--> PBuiltinBLS12_381_G2_Element)

-- | Compress a point on the BLS12-381 G2 curve to a byte string.
pbls12_381_G2_compress :: Term s (PBuiltinBLS12_381_G2_Element :--> PByteString)

-- | Uncompress a byte string to a point on the BLS12-381 G2 curve.
pbls12_381_G2_uncompress :: Term s (PByteString :--> PBuiltinBLS12_381_G2_Element)

-- | Hash a message to a point on the BLS12-381 G2 curve.
pbls12_381_G2_hashToGroup :: Term s (PByteString :--> (PByteString :--> PBuiltinBLS12_381_G2_Element))

-- | The compressed representation of the zero point on the BLS12-381 G2
--   curve.
pbls12_381_G2_compressed_zero :: Term s PByteString

-- | The compressed representation of the generator point on the BLS12-381
--   G2 curve.
pbls12_381_G2_compressed_generator :: Term s PByteString

-- | Perform a Miller loop operation on a G1 and G2 element.
pbls12_381_millerLoop :: Term s (PBuiltinBLS12_381_G1_Element :--> (PBuiltinBLS12_381_G2_Element :--> PBuiltinBLS12_381_MlResult))

-- | Multiply two Miller loop results.
pbls12_381_mulMlResult :: Term s (PBuiltinBLS12_381_MlResult :--> (PBuiltinBLS12_381_MlResult :--> PBuiltinBLS12_381_MlResult))

-- | Perform the final verification step in BLS12-381 pairing.
pbls12_381_finalVerify :: Term s (PBuiltinBLS12_381_MlResult :--> (PBuiltinBLS12_381_MlResult :--> PBool))
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Builtin.BLS.PBuiltinBLS12_381_G1_Element s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Builtin.BLS.PBuiltinBLS12_381_G1_Element s)
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Builtin.BLS.PBuiltinBLS12_381_G2_Element s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Builtin.BLS.PBuiltinBLS12_381_G2_Element s)
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Builtin.BLS.PBuiltinBLS12_381_MlResult s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Builtin.BLS.PBuiltinBLS12_381_MlResult s)

module Plutarch.Internal.PlutusType
class PlutusType (a :: PType)
type PlutusTypeStratConstraint strategy :: PType -> Constraint

-- | <i>Deprecated: Use PlutusType</i>
type PCon = PlutusType

-- | <i>Deprecated: Use PlutusType</i>
type PMatch = PlutusType
pcon' :: forall s. PlutusType a => a s -> Term s (PInner a)
pmatch' :: forall s b. PlutusType a => Term s (PInner a) -> (a s -> Term s b) -> Term s b

-- | Pattern match over Plutarch Terms via a Haskell datatype
pmatch :: PlutusType a => Term s a -> (a s -> Term s b) -> Term s b

-- | Construct a Plutarch Term via a Haskell datatype
pcon :: PlutusType a => a s -> Term s a
type PInner a :: PType
class PlutusTypeStrat (strategy :: Type)
class (PInner a ~ DerivedPInner (DPTStrat a) a, PlutusTypeStrat (DPTStrat a), PlutusTypeStratConstraint (DPTStrat a) a, PlutusType a) => DerivePlutusType (a :: PType)
type DPTStrat a :: Type
type DerivedPInner strategy (a :: PType) :: PType
derivedPCon :: forall a s. (PlutusTypeStrat strategy, DerivePlutusType a, DPTStrat a ~ strategy) => a s -> Term s (DerivedPInner strategy a)
derivedPMatch :: forall a s b. (PlutusTypeStrat strategy, DerivePlutusType a, DPTStrat a ~ strategy) => Term s (DerivedPInner strategy a) -> (a s -> Term s b) -> Term s b
class (forall t. PVariant'' t => PVariant'' (a t)) => PVariant a
class (forall t. PCovariant'' t => PCovariant'' (a t)) => PCovariant a
class (forall t. PCovariant'' t => PContravariant'' (a t)) => PContravariant a
type PVariant' a :: Constraint
type PCovariant' a :: Constraint
type PContravariant' a :: Constraint
class PVariant' a => PVariant'' a
class PCovariant' a => PCovariant'' a
class PContravariant' a => PContravariant'' a

-- | @since WIP
newtype DeriveNewtypePlutusType (a :: S -> Type) s
DeriveNewtypePlutusType :: a s -> DeriveNewtypePlutusType (a :: S -> Type) s

-- | @since WIP
[$sel:unDeriveNewtypePlutusType:DeriveNewtypePlutusType] :: DeriveNewtypePlutusType (a :: S -> Type) s -> a s

-- | This is a cursed derivation strategy that will give you
--   <tt>PlutusType</tt> with no questions asked. This is occasionally
--   helpful for deriving <tt>PlutusType</tt> for another derivation
--   strategy wrapper whose target instance requires <tt>PlutusType</tt> as
--   superclass.
--   
--   See <tt>PLiftable</tt>
newtype DeriveFakePlutusType (a :: S -> Type) (s :: S)
DeriveFakePlutusType :: a s -> DeriveFakePlutusType (a :: S -> Type) (s :: S)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.ByteString.PByteString
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.ByteString.PByte
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.ByteString.PLogicOpSemantics
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.String.PString
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.BLS.PBuiltinBLS12_381_G1_Element
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.BLS.PBuiltinBLS12_381_G2_Element
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.BLS.PBuiltinBLS12_381_MlResult
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.ByteString.PEndianness
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.PlutusType.DeriveFakePlutusType a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S) (pt :: Plutarch.Internal.Term.PType). (Generics.SOP.Universe.Generic (a s), (Generics.SOP.Universe.Code (a s) :: [[GHC.Types.Type]]) GHC.Types.~ ((':) @[GHC.Types.Type] ((':) @GHC.Types.Type (Plutarch.Internal.Term.Term s pt) ('[] @GHC.Types.Type)) ('[] @[GHC.Types.Type]) :: [[GHC.Types.Type]])) => Plutarch.Internal.PlutusType.H s a pt
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (pt :: Plutarch.Internal.Term.S -> GHC.Types.Type). ((pt :: (Plutarch.Internal.Term.S -> GHC.Types.Type)) GHC.Types.~ (Plutarch.Internal.PlutusType.UnTermSingle (Data.SOP.Constraint.Head @GHC.Types.Type (Data.SOP.Constraint.Head @[GHC.Types.Type] (Generics.SOP.Universe.Code (a (GHC.Types.Any @Plutarch.Internal.Term.S))))) :: (Plutarch.Internal.Term.S -> GHC.Types.Type)), forall (s :: Plutarch.Internal.Term.S). Plutarch.Internal.PlutusType.H s a pt) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.PlutusType.DeriveNewtypePlutusType a)
instance forall (a :: Plutarch.Internal.Term.PType). (Plutarch.Internal.Generic.PGeneric a, (Plutarch.Internal.Generic.PCode a :: [[Plutarch.Internal.Term.PType]]) GHC.Types.~ ((':) @[Plutarch.Internal.Term.PType] ((':) @Plutarch.Internal.Term.PType (Plutarch.Internal.PlutusType.GetPNewtype a) ('[] @Plutarch.Internal.Term.PType)) ('[] @[Plutarch.Internal.Term.PType]) :: [[Plutarch.Internal.Term.PType]])) => Plutarch.Internal.PlutusType.Helper a
instance Plutarch.Internal.PlutusType.PlutusTypeStrat Plutarch.Internal.PlutusType.PlutusTypeNewtype
instance forall (a :: Plutarch.Internal.Term.PType -> Plutarch.Internal.Term.PType). (forall (t :: Plutarch.Internal.Term.PType). Plutarch.Internal.PlutusType.PVariant'' t => Plutarch.Internal.PlutusType.PVariant'' (a t)) => Plutarch.Internal.PlutusType.PVariant a
instance forall (a :: Plutarch.Internal.Term.PType -> Plutarch.Internal.Term.PType). (forall (t :: Plutarch.Internal.Term.PType). Plutarch.Internal.PlutusType.PCovariant'' t => Plutarch.Internal.PlutusType.PContravariant'' (a t)) => Plutarch.Internal.PlutusType.PContravariant a
instance forall (a :: Plutarch.Internal.Term.PType -> Plutarch.Internal.Term.PType). (forall (t :: Plutarch.Internal.Term.PType). Plutarch.Internal.PlutusType.PCovariant'' t => Plutarch.Internal.PlutusType.PCovariant'' (a t)) => Plutarch.Internal.PlutusType.PCovariant a
instance forall (a :: Plutarch.Internal.Term.PType). Plutarch.Internal.PlutusType.PCovariant' a => Plutarch.Internal.PlutusType.PCovariant'' a
instance forall (a :: Plutarch.Internal.Term.PType). Plutarch.Internal.PlutusType.PContravariant' a => Plutarch.Internal.PlutusType.PContravariant'' a
instance forall (a :: Plutarch.Internal.Term.PType). Plutarch.Internal.PlutusType.PVariant' a => Plutarch.Internal.PlutusType.PVariant'' a
instance forall (a :: Plutarch.Internal.Term.PType) (b :: Plutarch.Internal.Term.PType). Plutarch.Internal.PlutusType.PlutusType (a Plutarch.Internal.Term.:--> b)
instance forall a (f :: a -> Plutarch.Internal.Term.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Quantification.PForall @a f)
instance forall a (f :: a -> Plutarch.Internal.Term.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Quantification.PSome @a f)
instance forall (f :: Plutarch.Internal.Term.PType -> Plutarch.Internal.Term.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Quantification.PFix f)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.Opaque.POpaque
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.Bool.PBool
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.Data.PData
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.Data.PBuiltinPair a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Universe.Core.Contains @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni (Plutarch.Internal.Lift.PlutusRepr a) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.Data.PBuiltinList a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.IsData.PIsData a => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.Data.PAsData a)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.Unit.PUnit

module Plutarch.Repr.Newtype

-- | @since WIP
newtype DeriveNewtypePlutusType (a :: S -> Type) s
DeriveNewtypePlutusType :: a s -> DeriveNewtypePlutusType (a :: S -> Type) s

-- | @since WIP
[$sel:unDeriveNewtypePlutusType:DeriveNewtypePlutusType] :: DeriveNewtypePlutusType (a :: S -> Type) s -> a s
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S) (pt :: Plutarch.Internal.Term.PType). (Generics.SOP.Universe.Generic (a s), (Generics.SOP.Universe.Code (a s) :: [[GHC.Types.Type]]) GHC.Types.~ ((':) @[GHC.Types.Type] ((':) @GHC.Types.Type (Plutarch.Internal.Term.Term s pt) ('[] @GHC.Types.Type)) ('[] @[GHC.Types.Type]) :: [[GHC.Types.Type]])) => Plutarch.Repr.Newtype.H s a pt
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (pt :: Plutarch.Internal.Term.S -> GHC.Types.Type). ((pt :: (Plutarch.Internal.Term.S -> GHC.Types.Type)) GHC.Types.~ (Plutarch.Repr.Newtype.UnTermSingle (Data.SOP.Constraint.Head @GHC.Types.Type (Data.SOP.Constraint.Head @[GHC.Types.Type] (Generics.SOP.Universe.Code (a (GHC.Types.Any @Plutarch.Internal.Term.S))))) :: (Plutarch.Internal.Term.S -> GHC.Types.Type)), forall (s :: Plutarch.Internal.Term.S). Plutarch.Repr.Newtype.H s a pt) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Newtype.DeriveNewtypePlutusType a)

module Plutarch.Internal.Subtype
data PSubtypeRelation
PSubtypeRelation :: PSubtypeRelation
PNoSubtypeRelation :: PSubtypeRelation
type family PSubtype (a :: PType) (b :: PType) :: Constraint
type family PSubtype' (a :: PType) (b :: PType) :: PSubtypeRelation
pupcast :: forall a b s. PSubtype a b => Term s b -> Term s a
pupcastF :: forall a b (p :: PType -> PType) s. (PSubtype a b, PCovariant p) => Proxy p -> Term s (p b) -> Term s (p a)
pdowncastF :: forall a b (p :: PType -> PType) s. (PSubtype a b, PContravariant p) => Proxy p -> Term s (p a) -> Term s (p b)

module Plutarch.Internal.ScottEncoding
data PlutusTypeScott
newtype PScottEncoded a r s
PScottEncoded :: Term s (ScottFn (ScottList a r) r) -> PScottEncoded a r s
instance forall (a :: Plutarch.Internal.Term.PType). (forall (r :: Plutarch.Internal.Term.PType). Plutarch.Internal.ScottEncoding.SListIScottList a r, Data.SOP.Constraint.SListI2 @{Plutarch.Internal.Term.PType} (Plutarch.Internal.Generic.PCode a), Plutarch.Internal.Generic.PGeneric a) => Plutarch.Internal.ScottEncoding.PlutusTypeScottConstraint a
instance Plutarch.Internal.PlutusType.PlutusTypeStrat Plutarch.Internal.ScottEncoding.PlutusTypeScott
instance forall (a :: Plutarch.Internal.Term.PType) (r :: Plutarch.Internal.Term.PType). Data.SOP.Constraint.SListI @{Plutarch.Internal.Term.PType} (Plutarch.Internal.ScottEncoding.ScottList (Plutarch.Internal.Generic.PCode a) r) => Plutarch.Internal.ScottEncoding.SListIScottList a r
instance forall (a :: [[Plutarch.Internal.Term.PType]]) (r :: Plutarch.Internal.Term.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.ScottEncoding.PScottEncoded a r)

module Plutarch.Internal.Other

-- | Prettyprint a Term via the PLC pretty printer
--   
--   TODO: Heavily improve. It's unreadable right now.
--   
--   We could convert the de Bruijn indices into names with:
--   
--   <pre>
--   show . prettyPlcReadableDef . (\(Right p) -&gt; p) . Scripts.mkTermToEvaluate . compile $ term
--   </pre>
printTerm :: HasCallStack => Config -> ClosedTerm a -> String

-- | Prettyprint a compiled Script via the PLC pretty printer
printScript :: Script -> String

-- | Safely coerce from a Term to it's <a>PInner</a> representation.
pto :: Term s a -> Term s (PInner a)

module Plutarch.Internal.Newtype
data PlutusTypeNewtype
instance forall (a :: Plutarch.Internal.Term.PType). (Plutarch.Internal.Generic.PGeneric a, (Plutarch.Internal.Generic.PCode a :: [[Plutarch.Internal.Term.PType]]) GHC.Types.~ ((':) @[Plutarch.Internal.Term.PType] ((':) @Plutarch.Internal.Term.PType (Plutarch.Internal.Newtype.GetPNewtype a) ('[] @Plutarch.Internal.Term.PType)) ('[] @[Plutarch.Internal.Term.PType]) :: [[Plutarch.Internal.Term.PType]])) => Plutarch.Internal.Newtype.Helper a
instance Plutarch.Internal.PlutusType.PlutusTypeStrat Plutarch.Internal.Newtype.PlutusTypeNewtype

module Plutarch.Internal.ListLike

-- | 'PIsListLike list a' constraints <tt>list</tt> be a <a>PListLike</a>
--   with valid element type, <tt>a</tt>.
type PIsListLike list a = (PListLike list, PElemConstraint list a)

-- | Plutarch types that behave like lists.
class PListLike (list :: (S -> Type) -> S -> Type)
type PElemConstraint list (a :: S -> Type) :: Constraint

-- | Canonical eliminator for list-likes.
pelimList :: (PListLike list, PElemConstraint list a) => (Term s a -> Term s (list a) -> Term s r) -> Term s r -> Term s (list a) -> Term s r

-- | Cons an element onto an existing list.
pcons :: (PListLike list, PElemConstraint list a) => Term s (a :--> (list a :--> list a))

-- | The empty list
pnil :: (PListLike list, PElemConstraint list a) => Term s (list a)

-- | Return the first element of a list. Partial, throws an error upon
--   encountering an empty list.
phead :: (PListLike list, PElemConstraint list a) => Term s (list a :--> a)

-- | Take the tail of a list, meaning drop its head. Partial, throws an
--   error upon encountering an empty list.
ptail :: (PListLike list, PElemConstraint list a) => Term s (list a :--> list a)

-- | <i> O(1) </i>. Check if a list is empty
pnull :: (PListLike list, PElemConstraint list a) => Term s (list a :--> PBool)

-- | <i> O(n) </i>. Convert from any ListLike to any ListLike, provided
--   both lists' element constraints are met.
pconvertLists :: forall f g a s. (PIsListLike f a, PIsListLike g a) => Term s (f a :--> g a)

-- | Like <a>pelimList</a>, but with a fixpoint recursion hatch.
precList :: PIsListLike list a => (Term s (list a :--> r) -> Term s a -> Term s (list a) -> Term s r) -> (Term s (list a :--> r) -> Term s r) -> Term s (list a :--> r)

-- | <i> O(1) </i>. Create a singleton list from an element
psingleton :: PIsListLike list a => Term s (a :--> list a)

-- | <i> O(n) </i>. Count the number of elements in the list
plength :: PIsListLike list a => Term s (list a :--> PInteger)

-- | Index a BuiltinList, throwing an error if the index is out of bounds.
ptryIndex :: PIsListLike list a => Natural -> Term s (list a) -> Term s a

-- | Drop the first n fields of a List.
--   
--   The term will be statically generated as repeated applications of
--   <a>ptail</a>, which will be more efficient in many circumstances.
pdrop :: PIsListLike list a => Natural -> Term s (list a) -> Term s (list a)

-- | The same as <a>pfoldl</a>, but with Haskell-level reduction function.
pfoldl' :: PIsListLike list a => (forall s. Term s b -> Term s a -> Term s b) -> Term s (b :--> (list a :--> b))

-- | <i> O(n) </i>. Fold on a list left-associatively.
pfoldl :: PIsListLike list a => Term s ((b :--> (a :--> b)) :--> (b :--> (list a :--> b)))

-- | The same as <a>pfoldr'</a>, but with Haskell-level reduction function.
pfoldr' :: PIsListLike list a => (forall s. Term s a -> Term s b -> Term s b) -> Term s (b :--> (list a :--> b))

-- | <i> O(n) </i>. Fold on a list right-associatively.
pfoldr :: PIsListLike list a => Term s ((a :--> (b :--> b)) :--> (b :--> (list a :--> b)))

-- | <i> O(n) </i>. Fold on a list right-associatively, with opportunity
--   for short circuting.
--   
--   May short circuit when given reducer function is lazy in its second
--   argument.
pfoldrLazy :: PIsListLike list a => Term s ((a :--> (PDelayed b :--> b)) :--> (b :--> (list a :--> b)))

-- | <i> O(n) </i>. Check that predicate holds for all elements in a list.
pall :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> PBool))

-- | <i> O(n) </i>. Check that predicate holds for any element in a list.
pany :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> PBool))

-- | <i> O(n) </i>. Map a function over a list of elements
pmap :: (PListLike list, PElemConstraint list a, PElemConstraint list b) => Term s ((a :--> b) :--> (list a :--> list b))

-- | <i> O(n) </i>. Filter elements from a list that don't match the
--   predicate.
pfilter :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> list a))

-- | <i> O(n) </i>. Concatenate two lists
--   
--   Example: &gt; pconcat # psingleton x # psingleton y == plistLiteral
--   [x, y]
--   
--   pconcat exhibits identities with empty lists such that &gt; forall x.
--   pconcat # pnil # x == x &gt; forall x. pconcat # x # pnil == x
pconcat :: PIsListLike list a => Term s (list a :--> (list a :--> list a))

-- | <i> O(min(n, m)) </i>. Zip two lists together with a passed function.
--   
--   If the lists are of differing lengths, cut to the shortest.
pzipWith :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list c) => Term s ((a :--> (b :--> c)) :--> (list a :--> (list b :--> list c)))

-- | Like <a>pzipWith</a> but with Haskell-level merge function.
pzipWith' :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list c) => (Term s a -> Term s b -> Term s c) -> Term s (list a :--> (list b :--> list c))
instance Plutarch.Internal.ListLike.PListLike Plutarch.Builtin.Data.PBuiltinList

module Plutarch.Evaluate

-- | Evaluate a script with a big budget, returning the trace log and term
--   result.
evalScript :: Script -> (Either EvalError Script, ExBudget, [Text])

-- | Evaluate a script with a huge budget, returning the trace log and term
--   result.
evalScriptHuge :: Script -> (Either EvalError Script, ExBudget, [Text])

-- | Evaluate a script with a specific budget, returning the trace log and
--   term result.
evalScript' :: ExBudget -> Script -> (Either (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun) Script, ExBudget, [Text])

-- | Evaluate a script without budget limit
--   
--   @since WIP
evalScriptUnlimited :: Script -> (Either (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun) Script, ExBudget, [Text])
type EvalError = (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun)

-- | Compile and evaluate term.
evalTerm :: Config -> ClosedTerm a -> Either Text (Either EvalError (ClosedTerm a), ExBudget, [Text])

-- | Same as <a>evalTerm</a> but without error handling
evalTerm' :: Config -> ClosedTerm a -> ClosedTerm a

-- | Compile and evaluate a ClosedTerm Useful for pre-evaluating terms so
--   that they can be used as constants in an onchain script. Consider the
--   following:
--   _________________________________________________________________________
--   term :: Term _ PInteger term = unsafeEvalTerm NoTracing foo
--   
--   foo :: Term s PInteger foo = (pconstant 1 #+ pconstant 5) #* pconstant
--   3
--   
--   bar :: Term s (PInteger :--&gt; PInteger) bar = plam x -&gt; x + foo
--   
--   bar2 :: Term s (PInteger :--&gt; PInteger) bar2 = plam x -&gt; x +
--   term
--   
--   PI.compile PI.NoTracing bar Right (Script {unScript = Program
--   {_progAnn = (), _progVer = Version {_versionMajor = 1, _versionMinor =
--   0, _versionPatch = 0}, _progTerm = LamAbs () (DeBruijn {dbnIndex = 0})
--   (Apply () (Apply () (Builtin () AddInteger) (Var () (DeBruijn
--   {dbnIndex = 1}))) (Apply () (Apply () (Builtin () MultiplyInteger)
--   (Apply () (Apply () (Builtin () AddInteger) (Constant () (Some
--   (ValueOf DefaultUniInteger 1)))) (Constant () (Some (ValueOf
--   DefaultUniInteger 5))))) (Constant () (Some (ValueOf DefaultUniInteger
--   3)))))}}) PI.compile PI.NoTracing bar2 Right (Script {unScript =
--   Program {_progAnn = (), _progVer = Version {_versionMajor = 1,
--   _versionMinor = 0, _versionPatch = 0}, _progTerm = LamAbs () (DeBruijn
--   {dbnIndex = 0}) (Apply () (Apply () (Builtin () AddInteger) (Var ()
--   (DeBruijn {dbnIndex = 1}))) (Constant () (Some (ValueOf
--   DefaultUniInteger 18))))}})
--   _________________________________________________________________________
--   
--   In bar, foo is an unevaluated term and thus must be evaluated. In
--   bar2, foo has been pre-evaluated with <a>unsafeEvalTerm</a> and thus
--   appears as a constant.
--   
--   Error if the compilation or evaluation fails.
unsafeEvalTerm :: Config -> ClosedTerm a -> ClosedTerm a

-- | Given a compiled <a>Script</a> representing a function that takes
--   arguments, and a list of those <a>Data</a>-encoded arguments, produce
--   a new script with those arguments applied.
applyArguments :: Script -> [Data] -> Script

module Plutarch.Pretty

-- | Prettify a Plutarch term.
--   
--   This will call <a>error</a> if there's a compilation failure. Use
--   <a>prettyTerm'</a> for a non-partial version.
--   
--   <h2>Example ==</h2>
--   
--   <pre>
--   import Plutarch.Prelude
--   import Plutarch.Api.V1
--   
--   checkSignatory :: Term s (PPubKeyHash :--&gt; PScriptContext :--&gt; PUnit)
--   checkSignatory = plam $ ph ctx' -&gt; unTermCont $ do
--     ctx &lt;- pletFieldsC <tt>["txInfo", "purpose"] ctx'
--     purph &lt;- pmatchC ctx.purpose
--     pure $ case purph of
--       PSpending _ -&gt;
--         let signatories = pfield </tt>"signatories" # ctx.txInfo
--         in pif
--             (pelem # pdata ph # pfromData signatories)
--             -- Success!
--             (pconstant ())
--             -- Signature not present.
--             perror
--       _ -&gt; ptraceError "checkSignatoryCont: not a spending tx"
--   </pre>
--   
--   Prettification result:
--   
--   <pre>
--   let frSndPair = !!sndPair
--       unDataSum = (xF -&gt; frSndPair (unConstrData xF))
--       frTailList = !tailList
--       frHeadList = !headList
--       frIfThenElse = !ifThenElse
--   in (oP4ECBT qsrxlF0Y7 -&gt;
--         let cjlB6yrGk = unDataSum qsrxlF0Y7
--             cRFO = unConstrData (frHeadList (frTailList cjlB6yrGk))
--             cs9iR = !!fstPair cRFO
--             w4 = frSndPair cRFO
--         in if equalsInteger 1 cs9iR
--              then if (vModHwqYB -&gt;
--                         let blM6d67 =
--                               (x5sad ePDSInSEC -&gt;
--                                  !(!!chooseList
--                                      ePDSInSEC
--                                      ~False
--                                      ~(if equalsData
--                                             (frHeadList ePDSInSEC)
--                                             vModHwqYB
--                                          then True
--                                          else x5sad (frTailList ePDSInSEC))))
--                             mC = (jfZs -&gt; blM6d67 (itzT -&gt; jfZs jfZs itzT))
--                         in blM6d67 (ispwp_oeT -&gt; mC mC ispwp_oeT))
--                        (bData oP4ECBT)
--                        (unListData
--                           let q6X3 = frHeadList cjlB6yrGk
--                           in frHeadList
--                                let olbZ = unDataSum q6X3
--                                in frTailList
--                                     (frTailList
--                                        (frTailList
--                                           (frTailList
--                                              (frTailList
--                                                 (frTailList
--                                                    (frTailList olbZ)))))))
--                     then ()
--                     else ERROR
--              else !(!trace "checkSignatoryCont: not a spending tx" ~ERROR))
--   </pre>
--   
--   <h2>Semantics ==</h2>
--   
--   <h3>Constants ===</h3>
--   
--   <ul>
--   <li>Builtin integers are printed as regular integers. [0-9]+</li>
--   <li>Builtin bytestrings are printed in hex notation, prefixed by `0x`.
--   0x[0-9a-f]+/i</li>
--   <li>Builtin strings are printed as is.</li>
--   <li>Builtin unit is printed as the unit literal. ()</li>
--   <li>Builtin booleans are printed as the literal <a>True</a> or
--   <a>False</a>.</li>
--   <li>Builtin lists are prettified as list literals, i.e delimited with
--   `[` and `]`.</li>
--   <li>Builtin pairs are prettified as 2-ary tuple literals, e.g. `(a,
--   b)`.</li>
--   <li><tt>I</tt> data (i.e data encoded integers) are prettified like
--   builtin integers with a <tt>#</tt> prefix. #[0-9]+</li>
--   <li><tt>B</tt> data (i.e data encoded bytestrings) are prettified like
--   builtin bytestrings with a <tt>#</tt> prefix. #0x[0-9a-f]+/i</li>
--   <li><tt>List</tt> data (i.e data encoded lists) are prettified like
--   builtin lists with a <tt>#</tt> prefix.</li>
--   <li><tt>Map</tt> data is printed like record literals. Delimited by
--   `{` and `}`.</li>
--   </ul>
--   
--   Each key value pair is prettified like <a>key</a> = <a>value</a> and
--   multiple pairs are joined with `,`.
--   
--   For example, `Map [(I 42, I 0), (I 100, I 1)]` is prettified as `{ #42
--   = #0, #100 = #1 }` - Constr data has two core elements in its
--   prettified form:
--   
--   <ul>
--   <li>The constructor index, prettified as an integer prefixed with
--   <tt></tt> (sigma).</li>
--   <li>Its fields, prettified as a list.</li>
--   </ul>
--   
--   These two elements are then joined with a <a>.</a> (period).
--   
--   For example, `Constr 1 [I 42]` is prettified as "1.[#42]".
--   
--   <h3>Builtin functions ===</h3>
--   
--   Builtin functions are prettified into their name, in title case.
--   
--   <h3>Forced term ===</h3>
--   
--   Forced terms are prefixed with a <tt>!</tt>. The unary operator
--   <tt>!</tt> has higher fixity than function application.
--   
--   <h3>Delayed term ===</h3>
--   
--   Delayed terms are prefixed with a <a>~</a>. The unary operator
--   <a>~</a> has higher fixity than function application.
--   
--   <h3>Var ===</h3>
--   
--   Random names are generated for all variable bindings, and these names
--   are used to refer to them.
--   
--   Names are always unique, between 1 and 8 characters in length, and
--   begin with a lowercase letter.
--   
--   Names may consist of alphanumeric characters, underscore, or single
--   quotes.
--   
--   <h3>LamAbs ===</h3>
--   
--   Lambdas are prettified similar to haskell lambdas, i.e `x -&gt; ...`.
--   
--   Lambdas with multiple arguments are detected and simplified: `x y z
--   -&gt; ...`.
--   
--   <h3>Apply ===</h3>
--   
--   Application is, simply, a space - just like haskell. `f x`.
--   
--   Multi arg applications to the same function are detected and
--   simplified: `f x y`.
--   
--   <h3>Error term ===</h3>
--   
--   <tt>perror</tt> is represented by the literal <tt>ERROR</tt>.
--   
--   <h3>Special handling ===</h3>
--   
--   To achieve better prettification, certain AST structures are given
--   special handling logic.
--   
--   <ul>
--   <li>The AST structure produced by <tt>plet</tt> (Single <a>Apply</a> +
--   <a>LamAbs</a> pair) is prettified into Haskell-like let bindings.</li>
--   <li>Lazy if<i>then</i>else (<tt>pif</tt> in particular, not
--   <tt>pif'</tt>) is detected and prettified into Haskell-like syntax:
--   `if cond then expr1 else expr2`.</li>
--   </ul>
--   
--   Chains of if<i>then</i>else are nested:
--   
--   <pre>
--   if cond
--     then expr1
--     else if cond
--       then expr2
--       else expr3
--   
--   </pre>
--   
--   <ul>
--   <li>When generating names for bindings, well known structures are
--   identified and given special names.</li>
--   </ul>
--   
--   This machinery is made to be extensible in the future.
--   
--   For example, the structure of the <tt>pfix</tt> function is well known
--   and constant - so it is simply called <tt>fix</tt> in the output.
--   
--   Bindings to forced builtin functions inherit the builtin function
--   name, prefixed with a <tt>fr</tt>.
prettyTerm :: Config -> ClosedTerm a -> Doc ()

-- | Same as <a>prettyTerm</a> but also includes the execution budget and
--   script size
--   
--   @since WIP
prettyTermAndCost :: forall a. Config -> ClosedTerm a -> Doc ()

-- | Non-partial <a>prettyTerm</a>.
prettyTerm' :: Config -> ClosedTerm p -> Either Text (Doc ())

-- | <a>prettyTerm</a> for pre-compiled <a>Script</a>s.
prettyScript :: Script -> Doc ()


-- | Unrolling a recursive function involves explicitly laying out some or
--   all of the recursive steps, rather than relying on recursion via a
--   fixed-point combinator. In UPLC, the typical <a>pfix</a>
--   implementation uses a Y-combinator under the hood. Each recursive step
--   incurs additional evaluation costs (CPU and memory) due to the
--   execution of the Y-combinator. By eliminating these costs in each
--   recursive step, unrolled functions reduce execution overhead. However,
--   since each recursive step is explicitly laid out, unrolled functions
--   consume more script size.
--   
--   There are various unrolling strategies available. It is important to
--   carefully study the implications of each strategy, as they may impose
--   different requirements, such as hard limit on recursion depth.
--   
--   Generally for all strategies, calling the "recursion step"--that is
--   <tt>r</tt> in <tt>fix $ r a b ... -&gt; ...</tt>--multiple times will
--   result in exponential increase of the script size in each step of
--   unrolling. This is because everytime the recursion step is called, it
--   generates UPLC code for that specific branch(and all the subsequent
--   branches down the unrolling!). To prevent this, it is possible to have
--   <tt>plet r $ r' -&gt; <a>can be used multiple times..</a></tt>.
--   
--   Also, due to some of the other optimization performed; specifically
--   <tt>pmatch</tt>'s branch detection which requires hashing terms of all
--   subsequent deconstruction branches, only tail-call recursion would
--   perform fast enough to be used for large unrolling.
module Plutarch.Unroll

-- | This is simplified version of <tt>punrollBound'</tt> without doing
--   additional recursion on Haskell level value.
--   
--   @since WIP
punrollBound :: forall a b s. Integer -> Term s (a :--> b) -> (Term s (a :--> b) -> Term s (a :--> b)) -> Term s (a :--> b)

-- | The first argument specifies the unrolling depth. The second argument
--   defines the fallback behavior when the recursion depth exceeds the
--   provided unrolling depth.
--   
--   The fixed-point implementation provided requires a Haskell-level value
--   <tt>c</tt> and a Plutarch function of type `Term s (a :--&gt; b)`. The
--   functional for the recursion is passed as a Haskell function. The
--   inclusion of the additional, arbitrary Haskell value (typed
--   <tt>c</tt>) enables further optimization by allowing pre-computation
--   of constant values that depend only on the recursion depth.
--   
--   This function will be used in a very niche situations. Using
--   Haskell-level value for constant replacement is only practical on a
--   single branch recursion with constant value that needs to be added on
--   each step. <tt>plength</tt> is one of the niche use case.
--   
--   @since WIP
punrollBound' :: forall a b c s. Integer -> (c -> Term s (a :--> b)) -> ((c -> Term s (a :--> b)) -> c -> Term s (a :--> b)) -> c -> Term s (a :--> b)

-- | Unroll given amount of steps, and for rest, uses <a>pfix</a> to
--   support unbound recursion.
--   
--   @since WIP
punrollUnbound :: forall a b s. Integer -> (Term s (a :--> b) -> Term s (a :--> b)) -> Term s (a :--> b)

-- | Uses <a>pfix</a> to recurse unrolled function itself. Unlike
--   <tt>punrollUnbound</tt>, this function uses unrolled instructions
--   within <a>pfix</a> recursions.
--   
--   This should perform better than <tt>punrollUnbound</tt> when a
--   function requires a large recursion depth.
--   
--   @since WIP
punrollUnboundWhole :: forall a b s. Integer -> (Term s (a :--> b) -> Term s (a :--> b)) -> Term s (a :--> b)

module Plutarch.Unsafe
punsafeBuiltin :: DefaultFun -> Term s a

-- | Unsafely coerce the type-tag of a Term.
--   
--   This should mostly be avoided, though it can be safely used to assert
--   known types of Datums, Redeemers or ScriptContext.
punsafeCoerce :: forall b a s. Term s a -> Term s b

-- | <i>Deprecated: Use <tt>pconstant</tt> instead.</i>
punsafeConstant :: Some (ValueOf DefaultUni) -> Term s a

-- | Unsafely coerce from the <a>PInner</a> representation of a Term,
--   assuming that the value is a safe construction of the Term.
punsafeDowncast :: Term s (PInner a) -> Term s a

module Plutarch.Internal.Lift

-- | Indicates that the given Plutarch type has an equivalent in Haskell
--   (and Plutus by extension), and we have the ability to move between
--   them.
--   
--   <h1>Important note</h1>
--   
--   Calling methods of <a>PLiftable</a> directly should rarely, if ever,
--   be a thing you do, unless defining your own instances without
--   <tt>via</tt>-deriving helpers (below). Prefer using <a>pconstant</a>
--   and <a>plift</a>, as these handle some of the oddities required
--   without you having to think about them.
--   
--   You should rarely, if ever, need to define <a>PLiftable</a> instances
--   by hand. Whenever possible, prefer using
--   <a>DeriveBuiltinPLiftable</a>, <a>DeriveDataPLiftable</a>, and
--   <a>DeriveNewtypePLiftable</a> as they have fewer complexities and
--   caveats. See their documentation for when to use them.
--   
--   If you do want to define the methods yourself, there's a few key
--   factors to keep in mind:
--   
--   <ol>
--   <li>You still shouldn't write every method by hand, there are helpers
--   <tt>plutToReprUni</tt> and <tt>reprToPlutUni</tt> to cover common
--   cases.</li>
--   <li>If defining <a>plutToRepr</a> and <a>reprToPlut</a> for Scott
--   encoded types you need to set <tt><a>PlutusRepr</a> PMyType =
--   <a>PLiftedClosed</a> PMyType</tt></li>
--   <li>When choosing a type for <a>AsHaskell</a>, <i>any</i> value of
--   that type <i>must</i> be representable in Plutarch. If you have
--   internal invariants to maintain on the Haskell side, make sure you do
--   so with great care.</li>
--   </ol>
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt><a>reprToHask</a> <a>.</a> <a>haskToRepr</a></tt> <tt>=</tt>
--   <tt><a>Right</a></tt></li>
--   <li><tt><a>plutToRepr</a> <a>.</a> <a>reprToPlut</a></tt> <tt>=</tt>
--   <tt><a>Right</a></tt></li>
--   </ol>
--   
--   Any derivations via <a>DeriveBuiltinPLiftable</a>,
--   <a>DeriveDataPLiftable</a>, and <a>DeriveNewtypePLiftable</a>
--   automatically follow these laws.
--   
--   Together, these imply <tt>plift . pconstant = id</tt>.
--   
--   @since WIP
class PlutusType a => PLiftable (a :: S -> Type) where {
    type AsHaskell a :: Type;
    type PlutusRepr a :: Type;
}

-- | Transform <tt>a</tt>'s Haskell equivalent to its Plutus universe
--   representation.
haskToRepr :: PLiftable a => AsHaskell a -> PlutusRepr a

-- | Given <tt>a</tt>'s Plutus universe representation, turn it back into
--   its (true) Haskell equivalent if possible.
reprToHask :: PLiftable a => PlutusRepr a -> Either LiftError (AsHaskell a)

-- | Given <tt>a</tt>'s Plutus universe representation, lift it into
--   Plutarch.
reprToPlut :: forall (s :: S). PLiftable a => PlutusRepr a -> PLifted s a

-- | Given a closed Plutarch term, evaluate it back into its Plutus
--   universe representation, or fail.
plutToRepr :: PLiftable a => (forall (s :: S). PLifted s a) -> Either LiftError (PlutusRepr a)

-- | Used with <tt>fromPlutarch</tt> methods to give additional information
--   about why evaluating a Plutarch term into a Haskell value went wrong.
--   
--   @since WIP
data LiftError

-- | Evaluation failed for some reason.
CouldNotEvaluate :: EvalError -> LiftError

-- | We tried to use a builtin not part of the Plutus universe.
TypeError :: BuiltinError -> LiftError

-- | Compiling the term into a script failed.
CouldNotCompile :: Text -> LiftError

-- | <tt>Data</tt> encoding was invalid for our type.
CouldNotDecodeData :: LiftError

-- | Something else went wrong.
OtherLiftError :: Text -> LiftError

-- | Given a Haskell-level representation of a Plutarch term, transform it
--   into its equivalent term.
--   
--   @since WIP
pconstant :: forall (a :: S -> Type) (s :: S). PLiftable a => AsHaskell a -> Term s a

-- | Given a closed Plutarch term, compile and evaluate it, then produce
--   the corresponding Haskell value. If compilation or evaluation fails
--   somehow, this will call <a>error</a>: if you need to 'trap' these
--   outcomes and handle them differently somehow, use <a>reprToPlut</a>
--   and <a>reprToHask</a> manually.
--   
--   @since WIP
plift :: forall (a :: S -> Type). PLiftable a => (forall (s :: S). Term s a) -> AsHaskell a

-- | <tt>via</tt>-deriving helper, indicating that <tt>a</tt> has a
--   Haskell-level equivalent <tt>h</tt> that is directly part of the
--   Plutus default universe (instead of by way of an encoding).
--   
--   @since WIP
newtype DeriveBuiltinPLiftable (a :: S -> Type) (h :: Type) (s :: S)
DeriveBuiltinPLiftable :: a s -> DeriveBuiltinPLiftable (a :: S -> Type) (h :: Type) (s :: S)

-- | <tt>via</tt>-deriving helper, indicating that <tt>a</tt> has a
--   Haskell-level equivalent <tt>h</tt> by way of its <tt>Data</tt>
--   encoding, rather than by <tt>h</tt> being directly part of the Plutus
--   default universe.
--   
--   @since WIP
newtype DeriveDataPLiftable (a :: S -> Type) (h :: Type) (s :: S)
DeriveDataPLiftable :: a s -> DeriveDataPLiftable (a :: S -> Type) (h :: Type) (s :: S)

-- | <tt>via</tt>-deriving helper, indicating that <tt>wrapper</tt> has a
--   Haskell-level equivalent <tt>h</tt> by way <tt>PInner wrapper</tt>, up
--   to coercibility.
--   
--   @since WIP
newtype DeriveNewtypePLiftable (wrapper :: S -> Type) (h :: Type) (s :: S)
DeriveNewtypePLiftable :: wrapper s -> DeriveNewtypePLiftable (wrapper :: S -> Type) (h :: Type) (s :: S)

-- | Helper that bypasses <a>PlutusRepr</a> and lifts the Haskell
--   equivalent directly. This is unsafe: we cannot verify (in general)
--   that <tt>h</tt> can be represented sensibly as an <tt>a</tt>, so use
--   this with care.
--   
--   @since WIP
unsafeHaskToUni :: forall (h :: Type) (a :: S -> Type) (s :: S). DefaultUni `Includes` h => h -> PLifted s a

-- | Valid definition of <a>reprToPlut</a> if <tt>PlutusRepr a</tt> is in
--   the Plutus universe.
--   
--   @since WIP
reprToPlutUni :: forall (a :: S -> Type) (s :: S). (PLiftable a, DefaultUni `Includes` PlutusRepr a) => PlutusRepr a -> PLifted s a

-- | Valid definition of <a>plutToRepr</a> if <tt>PlutusRepr a</tt> is in
--   the Plutus universe.
--   
--   @since WIP
plutToReprUni :: forall (a :: S -> Type). (PLiftable a, DefaultUni `Includes` PlutusRepr a) => (forall (s :: S). PLifted s a) -> Either LiftError (PlutusRepr a)

-- | Similar to <tt>Identity</tt>, but at the level of Plutarch. Only
--   needed when writing manual instances of <a>PLiftable</a>, or if you
--   want to use <a>reprToPlut</a> and <a>plutToRepr</a> directly.
--   
--   This is used for coercing Plutarch terms at Haskell level with `coerce
--   :: PLifted s a -&gt; PLifted s b` for <tt>via</tt>-deriving helpers.
--   
--   @since WIP
newtype PLifted (s :: S) (a :: S -> Type)
PLifted :: Term s POpaque -> PLifted (s :: S) (a :: S -> Type)

-- | @since WIP
mkPLifted :: Term s a -> PLifted s a

-- | @since WIP
getPLifted :: PLifted s a -> Term s a

-- | Use this as <a>PlutusRepr</a> when defining <a>PLiftable</a> instances
--   for Scott encoded types.
--   
--   @since WIP
newtype PLiftedClosed (a :: S -> Type)
PLiftedClosed :: (forall (s :: S). Term s POpaque) -> PLiftedClosed (a :: S -> Type)
[$sel:unPLiftedClosed:PLiftedClosed] :: PLiftedClosed (a :: S -> Type) -> forall (s :: S). Term s POpaque

-- | @since WIP
getPLiftedClosed :: forall (a :: S -> Type). PLiftedClosed a -> forall (s :: S). Term s a

-- | @since WIP
mkPLiftedClosed :: forall (a :: S -> Type). (forall (s :: S). Term s a) -> PLiftedClosed a

-- | @since WIP
pliftedToClosed :: forall (a :: S -> Type). (forall (s :: S). PLifted s a) -> PLiftedClosed a

-- | @since WIP
pliftedFromClosed :: forall (a :: S -> Type) (s :: S). PLiftedClosed a -> PLifted s a

-- | @since WIP
punsafeCoercePLifted :: PLifted s a -> PLifted s b
instance GHC.Show.Show Plutarch.Internal.Lift.LiftError
instance GHC.Classes.Eq Plutarch.Internal.Lift.LiftError
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) h. Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Lift.DeriveBuiltinPLiftable a h)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) h (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Internal.Lift.DeriveBuiltinPLiftable a h s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) h (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Internal.Lift.DeriveBuiltinPLiftable a h s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) h. Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Lift.DeriveDataPLiftable a h)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) h (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Internal.Lift.DeriveDataPLiftable a h s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) h (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Internal.Lift.DeriveDataPLiftable a h s)
instance forall (wrapper :: Plutarch.Internal.Term.S -> GHC.Types.Type) h. Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Lift.DeriveNewtypePLiftable wrapper h)
instance forall (wrapper :: Plutarch.Internal.Term.S -> GHC.Types.Type) h (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Internal.Lift.DeriveNewtypePLiftable wrapper h s)
instance forall (wrapper :: Plutarch.Internal.Term.S -> GHC.Types.Type) h (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Internal.Lift.DeriveNewtypePLiftable wrapper h s)
instance Plutarch.Internal.Lift.PLiftable Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.Lift.PLiftable Plutarch.Builtin.Bool.PBool
instance Plutarch.Internal.Lift.PLiftable Plutarch.Builtin.Unit.PUnit
instance Plutarch.Internal.Lift.PLiftable Plutarch.Builtin.String.PString
instance Plutarch.Internal.Lift.PLiftable Plutarch.Builtin.BLS.PBuiltinBLS12_381_G1_Element
instance Plutarch.Internal.Lift.PLiftable Plutarch.Builtin.BLS.PBuiltinBLS12_381_G2_Element
instance Plutarch.Internal.Lift.PLiftable Plutarch.Builtin.BLS.PBuiltinBLS12_381_MlResult
instance forall (a :: Plutarch.Internal.Term.PType) h. (Plutarch.Internal.PlutusType.PlutusType a, Universe.Core.Includes @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni h) => Plutarch.Internal.Lift.PLiftable (Plutarch.Internal.Lift.DeriveBuiltinPLiftable a h)
instance forall (a :: Plutarch.Internal.Term.PType) h. (Plutarch.Internal.PlutusType.PlutusType a, Plutarch.Internal.Subtype.PSubtype Plutarch.Builtin.Data.PData a, PlutusTx.IsData.Class.ToData h, PlutusTx.IsData.Class.FromData h) => Plutarch.Internal.Lift.PLiftable (Plutarch.Internal.Lift.DeriveDataPLiftable a h)
instance forall (wrapper :: Plutarch.Internal.Term.PType) h. (Plutarch.Internal.Lift.PLiftable (Plutarch.Internal.PlutusType.PInner wrapper), GHC.Types.Coercible @GHC.Types.Type h (Plutarch.Internal.Lift.AsHaskell (Plutarch.Internal.PlutusType.PInner wrapper)), Universe.Core.Includes @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni (Plutarch.Internal.Lift.PlutusRepr (Plutarch.Internal.PlutusType.PInner wrapper))) => Plutarch.Internal.Lift.PLiftable (Plutarch.Internal.Lift.DeriveNewtypePLiftable wrapper h)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (PlutusTx.IsData.Class.ToData (Plutarch.Internal.Lift.AsHaskell a), PlutusTx.IsData.Class.FromData (Plutarch.Internal.Lift.AsHaskell a), Plutarch.Internal.IsData.PIsData a) => Plutarch.Internal.Lift.PLiftable (Plutarch.Builtin.Data.PAsData a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Lift.PLiftable a, Universe.Core.Includes @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni (Plutarch.Internal.Lift.PlutusRepr a), Plutarch.Internal.Lift.PLiftable b, Universe.Core.Includes @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni (Plutarch.Internal.Lift.PlutusRepr b)) => Plutarch.Internal.Lift.PLiftable (Plutarch.Builtin.Data.PBuiltinPair a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Lift.PLiftable a, Universe.Core.Includes @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni (Plutarch.Internal.Lift.PlutusRepr a)) => Plutarch.Internal.Lift.PLiftable (Plutarch.Builtin.Data.PBuiltinList a)
instance Plutarch.Internal.Lift.PLiftable Plutarch.Builtin.ByteString.PByteString
instance Plutarch.Internal.Lift.PLiftable Plutarch.Builtin.Data.PData
instance Plutarch.Internal.Lift.PLiftable Plutarch.Builtin.ByteString.PByte

module Plutarch.Internal.Eq
class PEq t
(#==) :: PEq t => Term s t -> Term s t -> Term s PBool
(#==) :: (PEq t, PGeneric t, PlutusType t, All2 PEq (PCode t)) => Term s t -> Term s t -> Term s PBool
infix 4 #==
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.ByteString.PLogicOpSemantics
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.ByteString.PEndianness
instance forall (a :: Plutarch.Internal.Term.PType). (Plutarch.Internal.Eq.PEq a, Universe.Core.Contains @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni (Plutarch.Internal.Lift.PlutusRepr a)) => Plutarch.Internal.Eq.Fc 'GHC.Types.False a
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.IsData.PIsData (Plutarch.Builtin.Data.PBuiltinList a) => Plutarch.Internal.Eq.Fc 'GHC.Types.True a
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Eq.Fc (Plutarch.Internal.Eq.F a) a => Plutarch.Internal.Eq.PEq (Plutarch.Builtin.Data.PBuiltinList a)
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.Bool.PBool
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.Data.PData
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Eq.PEq (Plutarch.Builtin.Data.PAsData a)
instance forall (a :: Plutarch.Internal.Term.PType) (b :: Plutarch.Internal.Term.PType). (Plutarch.Internal.Eq.PEq a, Plutarch.Internal.Eq.PEq b) => Plutarch.Internal.Eq.PEq (Plutarch.Builtin.Data.PBuiltinPair a b)
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.ByteString.PByteString
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.ByteString.PByte
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.Unit.PUnit
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.String.PString
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.BLS.PBuiltinBLS12_381_G1_Element
instance Plutarch.Internal.Eq.PEq Plutarch.Builtin.BLS.PBuiltinBLS12_381_G2_Element

module Plutarch.Repr.Internal

-- | @since WIP
newtype PStruct (struct :: [[S -> Type]]) (s :: S)
PStruct :: SOP (Term s) struct -> PStruct (struct :: [[S -> Type]]) (s :: S)

-- | @since WIP
[$sel:unPStruct:PStruct] :: PStruct (struct :: [[S -> Type]]) (s :: S) -> SOP (Term s) struct

-- | @since WIP
newtype PRec (struct :: [S -> Type]) (s :: S)
PRec :: NP (Term s) struct -> PRec (struct :: [S -> Type]) (s :: S)

-- | @since WIP
[$sel:unPRec:PRec] :: PRec (struct :: [S -> Type]) (s :: S) -> NP (Term s) struct

-- | @since WIP
pletL :: All SListI as => SOP (Term s) as -> (SOP (Term s) as -> Term s r) -> Term s r

-- | @since WIP
grecEq :: forall (s :: S) (struct :: [S -> Type]). All PEq struct => NP (Term s) struct -> NP (Term s) struct -> Term s PBool

-- | @since WIP
gstructEq :: forall (s :: S) (struct :: [[S -> Type]]). All2 PEq struct => SOP (Term s) struct -> SOP (Term s) struct -> Term s PBool

-- | This function handles optimization of function that require multiple
--   handlers by checking hashes of each | handler item and merging them in
--   a way it will minimize size and cost of all computation
--   
--   @since WIP
groupHandlers :: forall (s :: S) (r :: S -> Type). [(Integer, Term s r)] -> Term s PInteger -> Term s r

-- | @since WIP
class (Generic (a s), AllZipN @Type (Prod SOP) (LiftedCoercible I (Term s)) (Code (a s)) struct, AllZipN @Type (Prod SOP) (LiftedCoercible (Term s) I) struct (Code (a s))) => StructSameRepr s a struct

-- | @since WIP
type family UnTermRec (struct :: [Type]) :: [S -> Type]

-- | @since WIP
type UnTermStruct x = UnTermStruct' (Code x)

-- | @since WIP
type RecTypePrettyError struct = RecTypePrettyError' struct ~ 'True
instance forall l1 (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S) (struct :: l1). (Generics.SOP.Universe.Generic (a s), Data.SOP.Constraint.AllZipN @GHC.Types.Type @[[GHC.Types.Type]] @GHC.Types.Type @Plutarch.Internal.Term.PType @[[GHC.Types.Type]] @l1 (Data.SOP.Classes.Prod @GHC.Types.Type @[[GHC.Types.Type]] (Data.SOP.NS.SOP @GHC.Types.Type)) (Data.SOP.Constraint.LiftedCoercible @{GHC.Types.Type} @{GHC.Types.Type} @{Plutarch.Internal.Term.PType} Data.SOP.BasicFunctors.I (Plutarch.Internal.Term.Term s)) (Generics.SOP.Universe.Code (a s)) struct, Data.SOP.Constraint.AllZipN @GHC.Types.Type @[[GHC.Types.Type]] @Plutarch.Internal.Term.PType @GHC.Types.Type @l1 @[[GHC.Types.Type]] (Data.SOP.Classes.Prod @GHC.Types.Type @[[GHC.Types.Type]] (Data.SOP.NS.SOP @GHC.Types.Type)) (Data.SOP.Constraint.LiftedCoercible @{Plutarch.Internal.Term.PType} @{GHC.Types.Type} @{GHC.Types.Type} (Plutarch.Internal.Term.Term s) Data.SOP.BasicFunctors.I) struct (Generics.SOP.Universe.Code (a s))) => Plutarch.Repr.Internal.StructSameRepr @{l1} s a struct

module Plutarch.Repr.Scott

-- | @since WIP
newtype PScottStruct (struct :: [[S -> Type]]) (s :: S)
PScottStruct :: PStruct struct s -> PScottStruct (struct :: [[S -> Type]]) (s :: S)

-- | @since WIP
[$sel:unPScottStruct:PScottStruct] :: PScottStruct (struct :: [[S -> Type]]) (s :: S) -> PStruct struct s

-- | @since WIP
newtype PScottRec (struct :: [S -> Type]) (s :: S)
PScottRec :: PRec struct s -> PScottRec (struct :: [S -> Type]) (s :: S)

-- | @since WIP
[$sel:unPScottRec:PScottRec] :: PScottRec (struct :: [S -> Type]) (s :: S) -> PRec struct s

-- | @since WIP
newtype PScottStructInner a r s
PScottStructInner :: Term s (ScottFn (ScottList a r) r) -> PScottStructInner a r s

-- | @since WIP
newtype PScottRecInner a r s
PScottRecInner :: Term s (ScottFn a r) -> PScottRecInner a r s

-- | @since WIP
newtype DeriveAsScottStruct (a :: S -> Type) s
DeriveAsScottStruct :: a s -> DeriveAsScottStruct (a :: S -> Type) s

-- | @since WIP
[$sel:unDeriveAsScottStruct:DeriveAsScottStruct] :: DeriveAsScottStruct (a :: S -> Type) s -> a s

-- | @since WIP
newtype DeriveAsScottRec (a :: S -> Type) s
DeriveAsScottRec :: a s -> DeriveAsScottRec (a :: S -> Type) s

-- | @since WIP
[$sel:unDeriveAsScottRec:DeriveAsScottRec] :: DeriveAsScottRec (a :: S -> Type) s -> a s
instance forall (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). (Data.SOP.Constraint.SListI2 @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct, Plutarch.Repr.Scott.PScottStructConstraint struct) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Scott.PScottStruct struct)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). (Generics.SOP.Universe.Generic (a (GHC.Types.Any @Plutarch.Internal.Term.S)), (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]) GHC.Types.~ (Plutarch.Repr.Internal.UnTermStruct (a (GHC.Types.Any @Plutarch.Internal.Term.S)) :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]), Data.SOP.Constraint.SListI2 @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct, forall (s :: Plutarch.Internal.Term.S). Plutarch.Repr.Internal.StructSameRepr @{[[Plutarch.Internal.Term.S -> GHC.Types.Type]]} s a struct, Plutarch.Repr.Scott.PScottStructConstraint struct) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Scott.DeriveAsScottStruct a)
instance forall (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). (Data.SOP.Constraint.SListI @{[Plutarch.Internal.Term.S -> GHC.Types.Type]} struct, forall (r :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Repr.Scott.PScottStructConstraint' struct r) => Plutarch.Repr.Scott.PScottStructConstraint struct
instance forall (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]) (r :: Plutarch.Internal.Term.S -> GHC.Types.Type). Data.SOP.Constraint.SListI @{Plutarch.Internal.Term.S -> GHC.Types.Type} (Plutarch.Repr.Scott.ScottList struct r) => Plutarch.Repr.Scott.PScottStructConstraint' struct r
instance forall (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]). Data.SOP.Constraint.SListI @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Scott.PScottRec struct)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (struct' :: [GHC.Types.Type]) (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]). (Generics.SOP.Universe.Generic (a (GHC.Types.Any @Plutarch.Internal.Term.S)), ((':) @[GHC.Types.Type] struct' ('[] @[GHC.Types.Type]) :: [[GHC.Types.Type]]) GHC.Types.~ (Generics.SOP.Universe.Code (a (GHC.Types.Any @Plutarch.Internal.Term.S)) :: [[GHC.Types.Type]]), (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]) GHC.Types.~ (Plutarch.Repr.Internal.UnTermRec struct' :: [Plutarch.Internal.Term.S -> GHC.Types.Type]), Data.SOP.Constraint.SListI @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct, forall (s :: Plutarch.Internal.Term.S). Plutarch.Repr.Internal.StructSameRepr @{[[Plutarch.Internal.Term.S -> GHC.Types.Type]]} s a ((':) @[Plutarch.Internal.Term.S -> GHC.Types.Type] struct ('[] @[Plutarch.Internal.Term.S -> GHC.Types.Type])), Plutarch.Repr.Internal.RecTypePrettyError @{GHC.Types.Type} (Generics.SOP.Universe.Code (a (GHC.Types.Any @Plutarch.Internal.Term.S)))) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Scott.DeriveAsScottRec a)
instance forall (struct :: [Plutarch.Internal.Term.PType]). Data.SOP.Constraint.All @Plutarch.Internal.Term.PType Plutarch.Internal.Eq.PEq struct => Plutarch.Internal.Eq.PEq (Plutarch.Repr.Scott.PScottRec struct)
instance forall (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). (Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Scott.PScottStruct struct), Data.SOP.Constraint.SListI2 @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct, Data.SOP.Constraint.All2 @{Plutarch.Internal.Term.PType} Plutarch.Internal.Eq.PEq struct) => Plutarch.Internal.Eq.PEq (Plutarch.Repr.Scott.PScottStruct struct)

module Plutarch.Repr.SOP

-- | @since WIP
newtype PSOPStruct (struct :: [[S -> Type]]) (s :: S)
PSOPStruct :: PStruct struct s -> PSOPStruct (struct :: [[S -> Type]]) (s :: S)

-- | @since WIP
[$sel:unPSOPStruct:PSOPStruct] :: PSOPStruct (struct :: [[S -> Type]]) (s :: S) -> PStruct struct s

-- | @since WIP
newtype PSOPRec (struct :: [S -> Type]) (s :: S)
PSOPRec :: PRec struct s -> PSOPRec (struct :: [S -> Type]) (s :: S)

-- | @since WIP
[$sel:unPSOPRec:PSOPRec] :: PSOPRec (struct :: [S -> Type]) (s :: S) -> PRec struct s

-- | <tt>via</tt>-derivation helper to derive <a>PlutusType</a> instance
--   using SoP encoding. If your type has only one constructor prefer using
--   <a>DeriveAsSOPRec</a> instead.
--   
--   @since WIP
newtype DeriveAsSOPStruct (a :: S -> Type) s
DeriveAsSOPStruct :: a s -> DeriveAsSOPStruct (a :: S -> Type) s

-- | @since WIP
[$sel:unDeriveAsSOPStruct:DeriveAsSOPStruct] :: DeriveAsSOPStruct (a :: S -> Type) s -> a s

-- | <tt>via</tt>-derivation helper for SoP encoding, currently behaves
--   exactly like <a>DeriveAsSOPStruct</a> but can be used only on types
--   with a single constructor. It is separate to leave a room for future
--   optimizations
--   
--   @since WIP
newtype DeriveAsSOPRec (a :: S -> Type) s
DeriveAsSOPRec :: a s -> DeriveAsSOPRec (a :: S -> Type) s

-- | @since WIP
[$sel:unDeriveAsSOPRec:DeriveAsSOPRec] :: DeriveAsSOPRec (a :: S -> Type) s -> a s
instance forall (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). (Data.SOP.Constraint.SListI2 @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct, Plutarch.Repr.SOP.PSOPStructConstraint struct) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.SOP.PSOPStruct struct)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). (Generics.SOP.Universe.Generic (a (GHC.Types.Any @Plutarch.Internal.Term.S)), (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]) GHC.Types.~ (Plutarch.Repr.Internal.UnTermStruct (a (GHC.Types.Any @Plutarch.Internal.Term.S)) :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]), Data.SOP.Constraint.SListI2 @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct, forall (s :: Plutarch.Internal.Term.S). Plutarch.Repr.Internal.StructSameRepr @{[[Plutarch.Internal.Term.S -> GHC.Types.Type]]} s a struct, Plutarch.Repr.SOP.PSOPStructConstraint struct) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.SOP.DeriveAsSOPStruct a)
instance forall (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). (Data.SOP.Constraint.SListI @{[Plutarch.Internal.Term.S -> GHC.Types.Type]} struct, forall (r :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Repr.SOP.PSOPStructConstraint' struct r) => Plutarch.Repr.SOP.PSOPStructConstraint struct
instance forall (r :: Plutarch.Internal.Term.S -> GHC.Types.Type) (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). Data.SOP.Constraint.SListI @{Plutarch.Internal.Term.S -> GHC.Types.Type} (Plutarch.Repr.SOP.PCaseTy r struct) => Plutarch.Repr.SOP.PSOPStructConstraint' struct r
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (struct' :: [GHC.Types.Type]) (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]). (Generics.SOP.Universe.Generic (a (GHC.Types.Any @Plutarch.Internal.Term.S)), ((':) @[GHC.Types.Type] struct' ('[] @[GHC.Types.Type]) :: [[GHC.Types.Type]]) GHC.Types.~ (Generics.SOP.Universe.Code (a (GHC.Types.Any @Plutarch.Internal.Term.S)) :: [[GHC.Types.Type]]), (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]) GHC.Types.~ (Plutarch.Repr.Internal.UnTermRec struct' :: [Plutarch.Internal.Term.S -> GHC.Types.Type]), Data.SOP.Constraint.SListI @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct, forall (s :: Plutarch.Internal.Term.S). Plutarch.Repr.Internal.StructSameRepr @{[[Plutarch.Internal.Term.S -> GHC.Types.Type]]} s a ((':) @[Plutarch.Internal.Term.S -> GHC.Types.Type] struct ('[] @[Plutarch.Internal.Term.S -> GHC.Types.Type])), Plutarch.Repr.Internal.RecTypePrettyError @{GHC.Types.Type} (Generics.SOP.Universe.Code (a (GHC.Types.Any @Plutarch.Internal.Term.S)))) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.SOP.DeriveAsSOPRec a)
instance forall (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]). Data.SOP.Constraint.SListI @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.SOP.PSOPRec struct)
instance forall (struct :: [Plutarch.Internal.Term.PType]). Data.SOP.Constraint.All @Plutarch.Internal.Term.PType Plutarch.Internal.Eq.PEq struct => Plutarch.Internal.Eq.PEq (Plutarch.Repr.SOP.PSOPRec struct)
instance forall (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). (Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.SOP.PSOPStruct struct), Data.SOP.Constraint.All2 @{Plutarch.Internal.Term.PType} Plutarch.Internal.Eq.PEq struct) => Plutarch.Internal.Eq.PEq (Plutarch.Repr.SOP.PSOPStruct struct)

module Plutarch.Maybe

-- | @since WIP
data PMaybe (a :: S -> Type) (s :: S)
PJust :: Term s a -> PMaybe (a :: S -> Type) (s :: S)
PNothing :: PMaybe (a :: S -> Type) (s :: S)

-- | Construct a <a>PJust</a> value.
--   
--   @since WIP
pjust :: forall (a :: S -> Type) (s :: S). Term s (a :--> PMaybe a)

-- | Construct a <a>PNothing</a> value.
--   
--   @since WIP
pnothing :: forall (a :: S -> Type) (s :: S). Term s (PMaybe a)

-- | Yields true if the given <a>PMaybe</a> value is of form
--   <tt><a>PJust</a> _</tt>.
--   
--   @since WIP
pisJust :: forall (a :: S -> Type) (s :: S). Term s (PMaybe a :--> PBool)

-- | Extracts the element out of a <a>PJust</a> and throws an error if its
--   argument is <a>PNothing</a>.
pfromJust :: forall (a :: S -> Type) (s :: S). Term s (PMaybe a :--> a)

-- | Extracts the element out of a <a>PJust</a> and throws a custom error
--   if it's given a <a>PNothing</a>.
--   
--   @since WIP
ptraceIfNothing :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s (PMaybe a) -> Term s a

-- | Extract a <a>PMaybe</a> by providing a default value in case of
--   <a>PJust</a>.
--   
--   @since WIP
pfromMaybe :: forall (a :: S -> Type) (s :: S). Term s (a :--> (PMaybe a :--> a))

-- | Given a default value, a function and a <a>PMaybe</a> value, yields
--   the default value if the <a>PMaybe</a> value is <a>PNothing</a> and
--   applies the function to the value stored in the <a>PJust</a>
--   otherwise.
--   
--   @since WIP
pmaybe :: forall (b :: S -> Type) (a :: S -> Type) (s :: S). Term s (b :--> ((a :--> b) :--> (PMaybe a :--> b)))

-- | Extract the value stored in a <a>PMaybe</a> container. If there's no
--   value, throw an error with the given message.
--   
--   @since WIP
passertPJust :: forall (a :: S -> Type) (s :: S). Term s (PString :--> (PMaybe a :--> a))

-- | Map underlying value if <a>PMaybe</a> is <a>PJust</a>, do nothing if
--   it is <a>PNothing</a>
--   
--   @since WIP
pmapMaybe :: Term s ((a :--> b) :--> (PMaybe a :--> PMaybe b))
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Eq.PEq a => Plutarch.Internal.Eq.PEq (Plutarch.Maybe.PMaybe a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Maybe.PMaybe a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Maybe.PMaybe a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Maybe.PMaybe a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Lift.PLiftable a => Plutarch.Internal.Lift.PLiftable (Plutarch.Maybe.PMaybe a)

module Plutarch.Internal.Ord

-- | Total ordering relation.
--   
--   <h1>Laws</h1>
--   
--   <a>#&lt;=</a> must form a total order. More precisely:
--   
--   <ol>
--   <li><tt>x #&lt;= x</tt> <tt>=</tt> <tt>pcon PTrue</tt>
--   (reflexivity)</li>
--   <li><tt>(y #&lt; x) #|| (z #&lt; y) #|| (x #&lt;= z)</tt> <tt>=</tt>
--   <tt>pcon PTrue</tt> (transitivity)</li>
--   <li><tt>(x #&lt;= y) #|| (y #&lt;= x)</tt> <tt>=</tt> <tt>pcon
--   PTrue</tt> (totality)</li>
--   </ol>
--   
--   Furthermore, <a>#&lt;</a> must be an equivalent strict total order to
--   <a>#&lt;=</a>:
--   
--   <ol>
--   <li><tt>x #&lt; x</tt> <tt>=</tt> <tt>pcon PFalse</tt>
--   (irreflexivity)</li>
--   <li><tt>(y #&lt;= x) #|| (z #&lt;= y) #|| (x #&lt; z)</tt> <tt>=</tt>
--   <tt>pcon PTrue</tt> (transitivity)</li>
--   <li><tt>(x #&lt; y) #|| (y #&lt; x) #|| (x #== z)</tt> <tt>=</tt>
--   <tt>pcon PTrue</tt> (trichotomy)</li>
--   <li><tt>x #&lt;= y</tt> <tt>=</tt> <tt>(x #&lt; y) #|| (x #== y)</tt>
--   (strict equivalence)</li>
--   </ol>
--   
--   If you define <a>pmax</a> or <a>pmin</a>, ensure the following also
--   hold:
--   
--   <ol>
--   <li><tt>pmax # x # y</tt> <tt>=</tt> <tt>pmax # y # x</tt>
--   (commutativity, also for @pmin)</li>
--   <li><tt>pmax # x #$ pmax y z</tt> <tt>=</tt> <tt>pmax # (pmax # x # y)
--   # z</tt> (associativity, also for @pmin)</li>
--   <li><tt>pmax # x #$ pmin # y # z</tt> <tt>=</tt> <tt>pmin # (pmax # x
--   # y) # (pmax # x # z)</tt> (<a>pmax</a> distributes over <a>pmin</a>,
--   also equivalent for <a>pmin</a>)</li>
--   <li><tt>pmin x y</tt> <tt>=</tt> <tt>pif' (x #&lt;= y) x y</tt></li>
--   <li><tt>pmax x y</tt> <tt>=</tt> <tt>pif' (x #&lt;= y) y x</tt></li>
--   </ol>
--   
--   Laws 8-12 hold if you use the defaults provided by this type class.
--   
--   @since WIP
class PEq t => POrd t

-- | @since WIP
(#<=) :: POrd t => Term s t -> Term s t -> Term s PBool

-- | @since WIP
(#<=) :: (POrd t, POrd (PInner t)) => Term s t -> Term s t -> Term s PBool

-- | @since WIP
(#<) :: POrd t => Term s t -> Term s t -> Term s PBool

-- | @since WIP
(#<) :: (POrd t, POrd (PInner t)) => Term s t -> Term s t -> Term s PBool

-- | @since WIP
pmax :: forall (s :: S). POrd t => Term s t -> Term s t -> Term s t

-- | @since WIP
pmin :: forall (s :: S). POrd t => Term s t -> Term s t -> Term s t
infix 4 #<=
infix 4 #<

-- | @since WIP
(#>) :: forall (a :: S -> Type) (s :: S). POrd a => Term s a -> Term s a -> Term s PBool
infix 4 #>

-- | @since WIP
(#>=) :: forall (a :: S -> Type) (s :: S). POrd a => Term s a -> Term s a -> Term s PBool
infix 4 #>=
instance Plutarch.Internal.Ord.POrd Plutarch.Builtin.ByteString.PLogicOpSemantics
instance Plutarch.Internal.Ord.POrd Plutarch.Builtin.ByteString.PEndianness
instance Plutarch.Internal.Ord.POrd Plutarch.Builtin.Bool.PBool
instance Plutarch.Internal.Ord.POrd Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.Ord.POrd Plutarch.Builtin.ByteString.PByteString
instance Plutarch.Internal.Ord.POrd Plutarch.Builtin.ByteString.PByte
instance Plutarch.Internal.Ord.POrd Plutarch.Builtin.Unit.PUnit

module Plutarch.Internal.IsData

-- | Laws: - If <tt>PSubtype PData a</tt>, then <tt>pdataImpl a</tt> must
--   be <a>pupcast</a>. - pdataImpl . pupcast . pfromDataImpl  id -
--   pfromDataImpl . punsafeDowncast . pdataImpl  id
class PIsData a
pfromDataImpl :: PIsData a => Term s (PAsData a) -> Term s a
pdataImpl :: PIsData a => Term s a -> Term s PData
pdata :: PIsData a => Term s a -> Term s (PAsData a)
pfromData :: PIsData a => Term s (PAsData a) -> Term s a
pforgetData :: forall s a. Term s (PAsData a) -> Term s PData

-- | Inverse of <a>pforgetData'</a>.
prememberData :: forall (p :: (S -> Type) -> S -> Type) (s :: S). PVariant p => Proxy p -> Term s (p PData) -> Term s (p (PAsData PData))

-- | Like <a>pforgetData</a>, except it works for complex types. Equivalent
--   to <a>pupcastF</a>.
pforgetData' :: forall a (p :: (S -> Type) -> S -> Type) (s :: S). PCovariant p => Proxy p -> Term s (p (PAsData a)) -> Term s (p PData)

-- | Like <a>prememberData</a> but generalised.
prememberData' :: forall a (p :: (S -> Type) -> S -> Type) (s :: S). (PSubtype PData a, PVariant p) => Proxy p -> Term s (p a) -> Term s (p (PAsData a))
instance Plutarch.Internal.IsData.PIsData Plutarch.Builtin.Data.PData
instance Plutarch.Internal.IsData.PIsData Plutarch.Builtin.Bool.PBool
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.IsData.PIsData (Plutarch.Builtin.Data.PBuiltinPair (Plutarch.Builtin.Data.PAsData a) (Plutarch.Builtin.Data.PAsData b))
instance Plutarch.Internal.IsData.PIsData (Plutarch.Builtin.Data.PBuiltinPair Plutarch.Builtin.Data.PData Plutarch.Builtin.Data.PData)
instance Plutarch.Internal.IsData.PIsData (Plutarch.Builtin.Data.PBuiltinPair Plutarch.Builtin.Integer.PInteger (Plutarch.Builtin.Data.PBuiltinList Plutarch.Builtin.Data.PData))
instance Plutarch.Internal.IsData.PIsData Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.IsData.PIsData Plutarch.Builtin.ByteString.PByteString
instance Plutarch.Internal.IsData.PIsData Plutarch.Builtin.Unit.PUnit
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Subtype.PSubtype Plutarch.Builtin.Data.PData a => Plutarch.Internal.IsData.PIsData (Plutarch.Builtin.Data.PBuiltinList a)

module Plutarch.Internal.Numeric

-- | @since WIP
data PPositive (s :: S)

-- | @since WIP
data Positive

-- | @since WIP
data PNatural (s :: S)

-- | The addition operation, and the notion of scaling by a positive.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>x #+ y</tt> <tt>=</tt> <tt>y #+ x</tt> (commutativity of
--   <tt>#+</tt>)</li>
--   <li><tt>x #+ (y #+ z)</tt> <tt>=</tt> <tt>(x #+ y) #+ z</tt>
--   (associativity of <tt>#+</tt>)</li>
--   </ol>
--   
--   If you define a custom <tt>pscalePositive</tt>, ensure the following
--   also hold:
--   
--   <ol>
--   <li><tt>pscalePositive x pone</tt> <tt>=</tt> <tt>x</tt></li>
--   <li><tt>(pscalePositive x n) #+ (pscalePositive x m)</tt> <tt>=</tt>
--   <tt>pscalePositive x (n #+ m)</tt></li>
--   <li><tt>pscalePositive (pscalePositive x n) m</tt> <tt>=</tt>
--   <tt>pscalePositive x (n #* m)</tt></li>
--   </ol>
--   
--   The default implementation ensures these laws are satisfied.
--   
--   @since WIP
class PAdditiveSemigroup (a :: S -> Type)
(#+) :: forall (s :: S). PAdditiveSemigroup a => Term s a -> Term s a -> Term s a
(#+) :: forall (s :: S). (PAdditiveSemigroup a, PAdditiveSemigroup (PInner a)) => Term s a -> Term s a -> Term s a

-- | This defaults to exponentiation-by-squaring, which in general is the
--   best we can do.
pscalePositive :: forall (s :: S). PAdditiveSemigroup a => Term s a -> Term s PPositive -> Term s a
infix 6 #+

-- | The notion of zero, as well as a way to scale by naturals.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>pzero #+ x</tt> <tt>=</tt> <tt>x</tt> (<tt>pzero</tt> is the
--   identity of <tt>#+</tt>)</li>
--   <li><tt>pscalePositive pzero n</tt> <tt>=</tt> <tt>pzero</tt>
--   (<tt>pzero</tt> does not scale up)</li>
--   </ol>
--   
--   If you define <a>pscaleNatural</a>, ensure the following as well:
--   
--   <ol>
--   <li><tt>pscaleNatural x (ppositiveToNatural # p)</tt> <tt>=</tt>
--   <tt>pscalePositive x p</tt></li>
--   <li><tt>pscaleNatural x pzero</tt> <tt>=</tt> <tt>pzero</tt></li>
--   </ol>
--   
--   The default implementation of <a>pscaleNatural</a> ensures these laws
--   hold.
--   
--   @since WIP
class PAdditiveSemigroup a => PAdditiveMonoid (a :: S -> Type)
pzero :: forall (s :: S). PAdditiveMonoid a => Term s a
pscaleNatural :: forall (s :: S). PAdditiveMonoid a => Term s a -> Term s PNatural -> Term s a

-- | The notion of additive inverses, and the subtraction operation.
--   
--   <h1>Laws</h1>
--   
--   If you define <tt>pnegate</tt>, the following laws must hold:
--   
--   <ol>
--   <li><tt>(pnegate # x) #+ x</tt> <tt>=</tt> <tt>pzero</tt>
--   (<tt>pnegate</tt> is an additive inverse)</li>
--   <li><tt>pnegate #$ pnegate # x</tt> <tt>=</tt> <tt>x</tt>
--   (<tt>pnegate</tt> is self-inverting)</li>
--   </ol>
--   
--   If you define <tt>#-</tt>, the following law must hold:
--   
--   <ol>
--   <li><tt>x #- x</tt> <tt>=</tt> <tt>pzero</tt></li>
--   </ol>
--   
--   Additionally, the following 'consistency laws' must hold. Default
--   implementations of both <tt>pnegate</tt> and <tt>#-</tt> uphold these.
--   
--   <ol>
--   <li><tt>pnegate # x</tt> <tt>=</tt> <tt>pzero #- x</tt></li>
--   <li><tt>x #- y</tt> <tt>=</tt> <tt>x #+ (pnegate # y)</tt></li>
--   </ol>
--   
--   Lastly, if you define a custom <tt>pscaleInteger</tt>, the following
--   laws must hold:
--   
--   <ol>
--   <li><tt>pscaleInteger x pzero</tt> <tt>=</tt> <tt>pzero</tt></li>
--   <li><tt>pscaleInteger x (pnegate # y)</tt> <tt>=</tt> <tt>pnegate #
--   (pscaleInteger x y)</tt></li>
--   </ol>
--   
--   @since WIP
class PAdditiveMonoid a => PAdditiveGroup (a :: S -> Type)
pnegate :: forall (s :: S). PAdditiveGroup a => Term s (a :--> a)
(#-) :: forall (s :: S). PAdditiveGroup a => Term s a -> Term s a -> Term s a
pscaleInteger :: forall (s :: S). PAdditiveGroup a => Term s a -> Term s PInteger -> Term s a
infix 6 #-

-- | The multiplication operation.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>x #* (y #* z)</tt> <tt>=</tt> <tt>(x #* y) #* z</tt>
--   (associativity of <tt>#*</tt>)</li>
--   </ol>
--   
--   If you define a custom <tt>ppowPositive</tt>, ensure the following
--   also hold:
--   
--   <ol>
--   <li><tt>ppowPositive x pone</tt> <tt>=</tt> <tt>x</tt></li>
--   <li><tt>(ppowPositive x n) #* (ppowPositive x m)</tt> <tt>=</tt>
--   <tt>ppowPositive x (n #+ m)</tt></li>
--   <li><tt>ppowPositive (ppowPositive x n) m</tt> <tt>=</tt>
--   <tt>ppowPositive x (n #* m)</tt></li>
--   </ol>
--   
--   The default implementation ensures these laws are satisfied.
--   
--   <h1>Note</h1>
--   
--   Unlike <a>PAdditiveSemigroup</a>, the multiplication operation doesn't
--   need to be commutative. Currently, all Plutarch-provided instances
--   are, but this need not be true for other instances.
--   
--   @since WIP
class PMultiplicativeSemigroup (a :: S -> Type)
(#*) :: forall (s :: S). PMultiplicativeSemigroup a => Term s a -> Term s a -> Term s a
(#*) :: forall (s :: S). (PMultiplicativeSemigroup a, PMultiplicativeSemigroup (PInner a)) => Term s a -> Term s a -> Term s a
ppowPositive :: forall (s :: S). PMultiplicativeSemigroup a => Term s a -> Term s PPositive -> Term s a
infix 6 #*

-- | The notion of one (multiplicative identity), and exponentiation by -
--   naturals.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>pone #* x</tt> <tt>=</tt> <tt>x</tt> (<tt>pone</tt> is the
--   left identity of <tt>#*</tt>)</li>
--   <li><tt>x #* pone</tt> <tt>=</tt> <tt>x</tt> (<tt>pone</tt> is the
--   right identity of <tt>#*</tt>)</li>
--   <li><tt>ppowPositive pone p</tt> <tt>=</tt> <tt>pone</tt>
--   (<tt>pone</tt> does not scale up)</li>
--   </ol>
--   
--   If you define <a>ppowNatural</a>, ensure the following as well:
--   
--   <ol>
--   <li><tt>ppowNatural x (ppositiveToNatural # p)</tt> <tt>=</tt>
--   <tt>ppowPositive x p</tt></li>
--   <li><tt>ppowNatural x pzero</tt> <tt>=</tt> <tt>pone</tt></li>
--   </ol>
--   
--   @since WIP
class PMultiplicativeSemigroup a => PMultiplicativeMonoid (a :: S -> Type)
pone :: forall (s :: S). PMultiplicativeMonoid a => Term s a
ppowNatural :: forall (s :: S). PMultiplicativeMonoid a => Term s a -> Term s PNatural -> Term s a

-- | <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>pfromInteger 0</tt> <tt>=</tt> <tt>pzero</tt></li>
--   <li><tt>pfromInteger 1</tt> <tt>=</tt> <tt>pone</tt></li>
--   <li><tt>pfromInteger (x + y)</tt> <tt>=</tt> <tt>pfromInteger x #+
--   pfromInteger y</tt></li>
--   <li><tt>pfromInteger (x * y)</tt> <tt>=</tt> <tt>pfromInteger x #*
--   pfromInteger y</tt></li>
--   </ol>
--   
--   Additionally, the following 'interaction laws' must hold between the
--   instances of <a>PAdditiveGroup</a> and <a>PMultiplicativeMonoid</a>
--   for <tt>a</tt>:
--   
--   <ol>
--   <li><tt>x #* (y #+ z)</tt> <tt>=</tt> <tt>(x #* y) #+ (x #* z)</tt>
--   (<tt>#*</tt> left-distributes over <tt>#+</tt>)</li>
--   <li><tt>(y #+ z) #* x</tt> <tt>=</tt> <tt>(y #* x) #+ (z #* x)</tt>
--   (<tt>#*</tt> right-distributes over <tt>#+</tt>)</li>
--   </ol>
--   
--   @since WIP
class (PAdditiveGroup a, PMultiplicativeMonoid a) => PRing (a :: S -> Type)
pfromInteger :: forall (s :: S). PRing a => Integer -> Term s a
pfromInteger :: forall (s :: S). (PRing a, PRing (PInner a)) => Integer -> Term s a

-- | <h1>Laws</h1>
--   
--   <h1>Pedantry note</h1>
--   
--   Technically, the requirements here are too strong: we demand an
--   <i>ordered</i> ring, which integral domains don't necessarily have to
--   be. However, in our case, our hand is forced by expected semantics: in
--   abstract algebra, both the absolute value and the signum are real
--   numbers (which are always totally ordered) but in our case, both must
--   be elements of the integral domain itself. Thus, in order for the laws
--   to make any sense, we have to ensure a total order on the integral
--   domain. Since all of our integral domains are 'at least as big' as the
--   integers, this doesn't pose a huge problem.
--   
--   @since WIP
class (PRing a, POrd a) => PIntegralDomain (a :: S -> Type)
psignum :: forall (s :: S). PIntegralDomain a => Term s (a :--> a)
psignum :: forall (s :: S). PIntegralDomain a => Term s (a :--> a)
pabs :: forall (s :: S). PIntegralDomain a => Term s (a :--> a)
pabs :: forall (s :: S). PIntegralDomain a => Term s (a :--> a)

-- | @since WIP
positiveToInteger :: Positive -> Integer

-- | Converts negative <a>Integer</a>s into their absolute values, positive
--   <a>Integer</a>s into their <a>Positive</a> equivalents. Errors on 0.
--   
--   @since WIP
toPositiveAbs :: Integer -> Positive

-- | Partial version of <a>ppositive</a>. Errors if argument is not
--   positive.
--   
--   @since WIP
ptryPositive :: forall (s :: S). Term s (PInteger :--> PPositive)

-- | Build a <a>PPositive</a> from a <a>PInteger</a>. Yields
--   <a>PNothing</a> if argument is not positive.
ppositive :: Term s (PInteger :--> PMaybe PPositive)

-- | Partial version of <a>pnatural</a>. Errors if argument is negative.
--   
--   @since WIP
ptryNatural :: forall (s :: S). Term s (PInteger :--> PNatural)

-- | Build a <a>PNatural</a> from a <a>PInteger</a>. Yields <a>PNothing</a>
--   if given a negative value.
--   
--   @since WIP
pnatural :: forall (s :: S). Term s (PInteger :--> PMaybe PNatural)

-- | 'Relax' a <a>PPositive</a> to <a>PNatural</a>. This uses
--   <a>punsafeCoerce</a> underneath, but because any positive is also a
--   natural, is safe.
--   
--   @since WIP
ppositiveToNatural :: forall (s :: S). Term s (PPositive :--> PNatural)

-- | Specialized form of <tt>pmaybe</tt> for <a>PNatural</a>. Given a
--   default, and a way to turn a <a>PPositive</a> into an answer, produce
--   the default when given <a>pzero</a>, and apply the function otherwise.
--   
--   @since WIP
pnaturalToPositiveCPS :: forall (a :: S -> Type) (s :: S). Term s a -> (Term s PPositive -> Term s a) -> Term s PNatural -> Term s a

-- | A default implementation of exponentiation-by-squaring with a
--   strictly-positive exponent.
--   
--   <h1>Important note</h1>
--   
--   This implementation assumes that the operation argument is
--   associative.
--   
--   @since WIP
pbySquaringDefault :: forall (a :: S -> Type) (s :: S). (forall (s' :: S). Term s' a -> Term s' a -> Term s' a) -> Term s a -> Term s PPositive -> Term s a

-- | @since WIP
pdiv :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))

-- | @since WIP
pmod :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))

-- | @since WIP
pquot :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))

-- | @since WIP
prem :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Internal.Numeric.PPositive
instance Plutarch.Internal.Ord.POrd Plutarch.Internal.Numeric.PPositive
instance Plutarch.Internal.Eq.PEq Plutarch.Internal.Numeric.PPositive
instance Plutarch.Internal.IsData.PIsData Plutarch.Internal.Numeric.PPositive
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Internal.Numeric.PPositive s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Internal.Numeric.PPositive s)
instance Prettyprinter.Internal.Pretty Plutarch.Internal.Numeric.Positive
instance Test.QuickCheck.Arbitrary.CoArbitrary Plutarch.Internal.Numeric.Positive
instance Test.QuickCheck.Arbitrary.Arbitrary Plutarch.Internal.Numeric.Positive
instance GHC.Classes.Ord Plutarch.Internal.Numeric.Positive
instance GHC.Classes.Eq Plutarch.Internal.Numeric.Positive
instance GHC.Show.Show Plutarch.Internal.Numeric.Positive
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Internal.Numeric.PNatural
instance Plutarch.Internal.Ord.POrd Plutarch.Internal.Numeric.PNatural
instance Plutarch.Internal.Eq.PEq Plutarch.Internal.Numeric.PNatural
instance Plutarch.Internal.IsData.PIsData Plutarch.Internal.Numeric.PNatural
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Internal.Numeric.PNatural s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Internal.Numeric.PNatural s)
instance Plutarch.Internal.Lift.PLiftable Plutarch.Internal.Numeric.PPositive
instance Plutarch.Internal.Numeric.PIntegralDomain Plutarch.Builtin.Integer.PInteger
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). Plutarch.Internal.Numeric.PIntegralDomain a => GHC.Num.Num (Plutarch.Internal.Term.Term s a)
instance Plutarch.Internal.Numeric.PRing Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.Numeric.PMultiplicativeMonoid Plutarch.Internal.Numeric.PPositive
instance Plutarch.Internal.Numeric.PMultiplicativeMonoid Plutarch.Internal.Numeric.PNatural
instance Plutarch.Internal.Numeric.PMultiplicativeMonoid Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.Numeric.PAdditiveSemigroup Plutarch.Internal.Numeric.PPositive
instance Plutarch.Internal.Numeric.PAdditiveSemigroup Plutarch.Internal.Numeric.PNatural
instance Plutarch.Internal.Numeric.PAdditiveSemigroup Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.Numeric.PAdditiveMonoid Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.Numeric.PAdditiveMonoid Plutarch.Internal.Numeric.PNatural
instance Plutarch.Internal.Numeric.PAdditiveGroup Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.Numeric.PMultiplicativeSemigroup Plutarch.Internal.Numeric.PPositive
instance Plutarch.Internal.Numeric.PMultiplicativeSemigroup Plutarch.Internal.Numeric.PNatural
instance Plutarch.Internal.Numeric.PMultiplicativeSemigroup Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.Numeric.PMultiplicativeSemigroup Plutarch.Builtin.BLS.PBuiltinBLS12_381_MlResult
instance Plutarch.Internal.Numeric.PAdditiveGroup Plutarch.Builtin.BLS.PBuiltinBLS12_381_G1_Element
instance Plutarch.Internal.Numeric.PAdditiveGroup Plutarch.Builtin.BLS.PBuiltinBLS12_381_G2_Element
instance Plutarch.Internal.Numeric.PAdditiveMonoid Plutarch.Builtin.BLS.PBuiltinBLS12_381_G1_Element
instance Plutarch.Internal.Numeric.PAdditiveMonoid Plutarch.Builtin.BLS.PBuiltinBLS12_381_G2_Element
instance Plutarch.Internal.Numeric.PAdditiveSemigroup Plutarch.Builtin.BLS.PBuiltinBLS12_381_G1_Element
instance Plutarch.Internal.Numeric.PAdditiveSemigroup Plutarch.Builtin.BLS.PBuiltinBLS12_381_G2_Element
instance Plutarch.Internal.Lift.PLiftable Plutarch.Internal.Numeric.PNatural
instance Test.QuickCheck.Function.Function Plutarch.Internal.Numeric.Positive

module Plutarch.String

-- | Plutus <tt>BuiltinString</tt> values
data PString s

-- | Verify if the given argument is the ASCII encoding of a hex digit.
--   This includes specifically the following ASCII ranges (inclusively):
--   
--   <ul>
--   <li>48-54 (digits 0 through 9)</li>
--   <li>65-70 (upper-case A through upper-case F)</li>
--   <li>97-102 (lower-case a through lower-case f)</li>
--   </ul>
--   
--   @since WIP
pisHexDigit :: forall (s :: S). Term s (PInteger :--> PBool)

-- | Encode a <a>PString</a> using UTF-8.
pencodeUtf8 :: Term s (PString :--> PByteString)

-- | Decode a <a>PByteString</a> using UTF-8.
pdecodeUtf8 :: Term s (PByteString :--> PString)

module Plutarch.Internal.TryFrom

-- | <tt>PTryFrom a b</tt> represents a subtyping relationship between
--   <tt>a</tt> and <tt>b</tt>, and a way to go from <tt>a</tt> to
--   <tt>b</tt>. Laws: - <tt>(punsafeCoerce . fst) <a>$</a> tcont (ptryFrom
--   x)  pure x</tt>
class PSubtype a b => PTryFrom (a :: PType) (b :: PType)
type PTryFromExcess a b :: PType
ptryFrom' :: forall s r. PTryFrom a b => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r
ptryFrom :: forall b a s r. PTryFrom a b => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r
data PSubtypeRelation
PSubtypeRelation :: PSubtypeRelation
PNoSubtypeRelation :: PSubtypeRelation
type family PSubtype (a :: PType) (b :: PType) :: Constraint
type family PSubtype' (a :: PType) (b :: PType) :: PSubtypeRelation
pupcast :: forall a b s. PSubtype a b => Term s b -> Term s a
pupcastF :: forall a b (p :: PType -> PType) s. (PSubtype a b, PCovariant p) => Proxy p -> Term s (p b) -> Term s (p a)
pdowncastF :: forall a b (p :: PType -> PType) s. (PSubtype a b, PContravariant p) => Proxy p -> Term s (p a) -> Term s (p b)
instance forall k1 k2 (f :: k2 -> k1 -> GHC.Types.Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.Internal.TryFrom.Flip @{k2} @{k1} f a b)
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData Plutarch.Builtin.Integer.PInteger)
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData Plutarch.Builtin.ByteString.PByteString)
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData (Plutarch.Builtin.Data.PBuiltinList Plutarch.Builtin.Data.PData))
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData a), Plutarch.Internal.IsData.PIsData a) => Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData (Plutarch.Builtin.Data.PBuiltinList (Plutarch.Builtin.Data.PAsData a)))
instance forall (a :: Plutarch.Internal.Term.PType) (a' :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.PType) (b' :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData a, (a :: Plutarch.Internal.Term.PType) GHC.Types.~ (Plutarch.Builtin.Data.PAsData a' :: Plutarch.Internal.Term.PType), Plutarch.Internal.IsData.PIsData a', Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData b, (b :: Plutarch.Internal.Term.PType) GHC.Types.~ (Plutarch.Builtin.Data.PAsData b' :: Plutarch.Internal.Term.PType), Plutarch.Internal.IsData.PIsData b') => Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData (Plutarch.Builtin.Data.PBuiltinPair a b))
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData Plutarch.Internal.Numeric.PPositive)
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData Plutarch.Builtin.Bool.PBool)
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData Plutarch.Builtin.Data.PData)
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData Plutarch.Builtin.Data.PData
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Integer.PInteger Plutarch.Internal.Numeric.PPositive

module Plutarch.Internal.Show
class PShow t

-- | Return the string representation of a Plutarch value
--   
--   If the wrap argument is True, optionally wrap the output in `(..)` if
--   it represents multiple parameters.
pshow' :: PShow t => Bool -> Term s t -> Term s PString

-- | Return the string representation of a Plutarch value
--   
--   If the wrap argument is True, optionally wrap the output in `(..)` if
--   it represents multiple parameters.
pshow' :: (PShow t, PGeneric t, PlutusType t, All2 PShow (PCode t)) => Bool -> Term s t -> Term s PString

-- | Return the string representation of a Plutarch value
pshow :: PShow a => Term s a -> Term s PString

-- | Causes an error where the input is shown in the message. Works for all
--   types.
pshowAndErr :: Term s a -> Term s b
pshowList :: forall list a s. (PShow a, PIsListLike list a) => Term s (list a :--> PString)
instance Plutarch.Internal.Show.PShow Plutarch.Builtin.Unit.PUnit
instance Plutarch.Internal.Show.PShow Plutarch.Builtin.String.PString
instance Plutarch.Internal.Show.PShow Plutarch.Builtin.Bool.PBool
instance Plutarch.Internal.Show.PShow Plutarch.Builtin.Integer.PInteger
instance Plutarch.Internal.Show.PShow Plutarch.Builtin.ByteString.PByteString
instance Plutarch.Internal.Show.PShow Plutarch.Builtin.Data.PData
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.IsData.PIsData a, Plutarch.Internal.Show.PShow a) => Plutarch.Internal.Show.PShow (Plutarch.Builtin.Data.PAsData a)
instance forall (a :: Plutarch.Internal.Term.PType). (Plutarch.Internal.Show.PShow a, Universe.Core.Contains @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni (Plutarch.Internal.Lift.PlutusRepr a)) => Plutarch.Internal.Show.PShow (Plutarch.Builtin.Data.PBuiltinList a)
instance forall (a :: Plutarch.Internal.Term.PType) (b :: Plutarch.Internal.Term.PType). (Plutarch.Internal.Show.PShow a, Plutarch.Internal.Show.PShow b) => Plutarch.Internal.Show.PShow (Plutarch.Builtin.Data.PBuiltinPair a b)
instance Plutarch.Internal.Show.PShow Plutarch.Internal.Numeric.PPositive
instance forall (a :: Plutarch.Internal.Term.PType). Plutarch.Internal.Show.PShow a => Plutarch.Internal.Show.PShow (Plutarch.Maybe.PMaybe a)

module Plutarch.Trace

-- | Trace the given message at the info level before evaluating the given
--   argument.
ptraceInfo :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

-- | Like Haskell's <tt>traceShowId</tt> but for Plutarch, at the info
--   level.
ptraceInfoShowId :: forall (a :: S -> Type) (s :: S). PShow a => Term s a -> Term s a

-- | Trace the given message at the info level, then terminate with
--   <a>perror</a>.
ptraceInfoError :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a

-- | Trace the given message at the info level if the argument is true.
ptraceInfoIfTrue :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the info level if the argument is false.
ptraceInfoIfFalse :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the debug level before evaluating the given
--   argument.
ptraceDebug :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

-- | Like Haskell's <tt>traceShowId</tt> but for Plutarch, at the debug
--   level.
ptraceDebugShowId :: forall (a :: S -> Type) (s :: S). PShow a => Term s a -> Term s a

-- | Trace the given message at the debug level if the argument is true.
ptraceDebugIfTrue :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the debug level if the argument is false.
ptraceDebugIfFalse :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the debug level, then terminate with
--   <a>perror</a>.
ptraceDebugError :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a

-- | Backward compatibility synonym for <a>ptraceInfo</a>.

-- | <i>Deprecated: Use ptraceInfo</i>
ptrace :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

-- | Synonym for <a>ptraceInfoShowId</a>.

-- | <i>Deprecated: Use ptraceInfoShowId</i>
ptraceShowId :: forall (a :: S -> Type) (s :: S). PShow a => Term s a -> Term s a

-- | Synonym for <a>ptraceInfoError</a>.

-- | <i>Deprecated: Use ptraceInfoError</i>
ptraceError :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a

-- | Synonym for <a>ptraceInfoIfTrue</a>.

-- | <i>Deprecated: Use ptraceInfoIfTrue</i>
ptraceIfTrue :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Synonym for <a>ptraceInfoIfFalse</a>.

-- | <i>Deprecated: Use ptraceInfoIfFalse</i>
ptraceIfFalse :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

module Plutarch.Monadic

-- | Bind function used within do syntax.
--   
--   Enables elegant usage of <tt>pmatch</tt> and similar. <tt>P.do { y
--   &lt;- x ; z }</tt> is equivalent to <tt>x $ y -&gt; z</tt>.
--   
--   <pre>
--   import qualified Plutarch.Monadic as P
--   
--   f :: Term s (PTxInfo :--&gt; PBuiltinList (PAsData PTxInInfo))
--   f = plam $ x -&gt; P.do
--     PTxInfo txInfoFields &lt;- pmatch x
--     pfromData $ pdhead # txInfoFields
--   </pre>
(>>=) :: (x -> Term s a) -> x -> Term s a

-- | Forgetful bind function used within do syntax.
--   
--   Enables elegant usage of <tt>ptrace</tt> and similar. <tt>P.do { x ; y
--   }</tt> is equivalent to <tt>x y</tt>.
--   
--   <pre>
--   import qualified Plutarch.Monadic as P
--   
--   P.do
--     ptrace "yielding unit"
--     pconstant ()
--   </pre>
(>>) :: (x -> Term s a) -> x -> Term s a

-- | Implicitly invoked upon pattern match failure within do syntax.
--   
--   <pre>
--   import qualified Plutarch.Monadic as P
--   
--   P.do
--     -- calls <a>fail</a>, traces an error message, and invokes <tt>perror</tt>.
--     PTrue &lt;- pconstant False
--   </pre>
fail :: String -> Term s a

module Plutarch.Internal.Semigroup

-- | <h1>Laws</h1>
--   
--   The only mandatory law is that <a>#&lt;&gt;</a> must be associative:
--   
--   <tt>x #&lt;&gt; (y #&lt;&gt; z)</tt> <tt>=</tt> <tt>(x #&lt;&gt; y)
--   #&lt;&gt; z</tt>
--   
--   If you define <a>pstimes</a>, ensure the following also hold:
--   
--   <ol>
--   <li><tt>pstimes pone x</tt> <tt>=</tt> <tt>x</tt></li>
--   <li><tt>(pstimes p1 x) #&lt;&gt; (pstimes p2 x)</tt> <tt>=</tt>
--   <tt>pstimes (p1 #+ p2) x</tt></li>
--   <li><tt>pstimes p1 (pstimes p2 x)</tt> <tt>=</tt> <tt>pstimes (p1 #*
--   p2) x</tt></li>
--   </ol>
--   
--   The default implementation automatically ensures these laws hold.
--   
--   @since WIP
class PSemigroup (a :: S -> Type)
(#<>) :: forall (s :: S). PSemigroup a => Term s a -> Term s a -> Term s a
(#<>) :: forall (s :: S). (PSemigroup a, PSemigroup (PInner a)) => Term s a -> Term s a -> Term s a
pstimes :: forall (s :: S). PSemigroup a => Term s PPositive -> Term s a -> Term s a
infixr 6 #<>

-- | <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>pmempty #&lt;&gt; x</tt> <tt>=</tt> <tt>x #&lt;&gt;
--   pmempty</tt> <tt>=</tt> <tt>x</tt></li>
--   <li><tt>pstimes n pmempty</tt> <tt>=</tt> <tt>pmempty</tt></li>
--   </ol>
--   
--   If you define <a>pmtimes</a>, ensure the following as well:
--   
--   <ol>
--   <li><tt>pmtimes (ppositiveToNatural # p) x</tt> <tt>=</tt> <tt>pstimes
--   p x</tt></li>
--   <li><tt>pmtimes pzero x</tt> <tt>=</tt> <tt>pmempty</tt></li>
--   </ol>
--   
--   The default implementation of <a>pmtimes</a> ensures these laws hold.
--   
--   @since WIP
class PSemigroup a => PMonoid (a :: S -> Type)
pmempty :: forall (s :: S). PMonoid a => Term s a
pmempty :: forall (s :: S). (PMonoid a, PMonoid (PInner a)) => Term s a
pmtimes :: forall (s :: S). PMonoid a => Term s PNatural -> Term s a -> Term s a

-- | Wrapper for types which have logical AND semantics somehow.
--   
--   @since WIP
newtype PAnd (a :: S -> Type) (s :: S)
PAnd :: Term s a -> PAnd (a :: S -> Type) (s :: S)

-- | Wrapper for types which have logical OR semantics somehow.
--   
--   @since WIP
newtype POr (a :: S -> Type) (s :: S)
POr :: Term s a -> POr (a :: S -> Type) (s :: S)

-- | Wrapper for types which have logical XOR semantics somehow.
--   
--   @since WIP
newtype PXor (a :: S -> Type) (s :: S)
PXor :: Term s a -> PXor (a :: S -> Type) (s :: S)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Semigroup.PAnd a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Ord.POrd a => Plutarch.Internal.Ord.POrd (Plutarch.Internal.Semigroup.PAnd a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Eq.PEq a => Plutarch.Internal.Eq.PEq (Plutarch.Internal.Semigroup.PAnd a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Internal.Semigroup.PAnd a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Internal.Semigroup.PAnd a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Semigroup.POr a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Ord.POrd a => Plutarch.Internal.Ord.POrd (Plutarch.Internal.Semigroup.POr a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Eq.PEq a => Plutarch.Internal.Eq.PEq (Plutarch.Internal.Semigroup.POr a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Internal.Semigroup.POr a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Internal.Semigroup.POr a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Semigroup.PXor a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Ord.POrd a => Plutarch.Internal.Ord.POrd (Plutarch.Internal.Semigroup.PXor a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Eq.PEq a => Plutarch.Internal.Eq.PEq (Plutarch.Internal.Semigroup.PXor a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Internal.Semigroup.PXor a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Internal.Semigroup.PXor a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Lift.PLiftable a, Universe.Core.Includes @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni (Plutarch.Internal.Lift.PlutusRepr a)) => Plutarch.Internal.Lift.PLiftable (Plutarch.Internal.Semigroup.PAnd a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Lift.PLiftable a, Universe.Core.Includes @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni (Plutarch.Internal.Lift.PlutusRepr a)) => Plutarch.Internal.Lift.PLiftable (Plutarch.Internal.Semigroup.POr a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Lift.PLiftable a, Universe.Core.Includes @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni (Plutarch.Internal.Lift.PlutusRepr a)) => Plutarch.Internal.Lift.PLiftable (Plutarch.Internal.Semigroup.PXor a)
instance Plutarch.Internal.Semigroup.PSemigroup (Plutarch.Internal.Semigroup.PXor Plutarch.Builtin.Bool.PBool)
instance Plutarch.Internal.Semigroup.PMonoid (Plutarch.Internal.Semigroup.PXor Plutarch.Builtin.Bool.PBool)
instance Plutarch.Internal.Semigroup.PSemigroup (Plutarch.Internal.Semigroup.PXor Plutarch.Builtin.ByteString.PByteString)
instance Plutarch.Internal.Semigroup.PMonoid (Plutarch.Internal.Semigroup.PXor Plutarch.Builtin.ByteString.PByteString)
instance Plutarch.Internal.Semigroup.PSemigroup (Plutarch.Internal.Semigroup.POr Plutarch.Builtin.Bool.PBool)
instance Plutarch.Internal.Semigroup.PMonoid (Plutarch.Internal.Semigroup.POr Plutarch.Builtin.Bool.PBool)
instance Plutarch.Internal.Semigroup.PSemigroup (Plutarch.Internal.Semigroup.POr Plutarch.Builtin.ByteString.PByteString)
instance Plutarch.Internal.Semigroup.PMonoid (Plutarch.Internal.Semigroup.POr Plutarch.Builtin.ByteString.PByteString)
instance Plutarch.Internal.Semigroup.PSemigroup (Plutarch.Internal.Semigroup.PAnd Plutarch.Builtin.Bool.PBool)
instance Plutarch.Internal.Semigroup.PMonoid (Plutarch.Internal.Semigroup.PAnd Plutarch.Builtin.Bool.PBool)
instance Plutarch.Internal.Semigroup.PSemigroup (Plutarch.Internal.Semigroup.PAnd Plutarch.Builtin.ByteString.PByteString)
instance Plutarch.Internal.Semigroup.PMonoid (Plutarch.Internal.Semigroup.PAnd Plutarch.Builtin.ByteString.PByteString)
instance Plutarch.Internal.Semigroup.PMonoid Plutarch.Builtin.Unit.PUnit
instance Plutarch.Internal.Semigroup.PMonoid Plutarch.Builtin.String.PString
instance Plutarch.Internal.Semigroup.PMonoid Plutarch.Builtin.ByteString.PByteString
instance Plutarch.Internal.Semigroup.PMonoid Plutarch.Builtin.BLS.PBuiltinBLS12_381_G1_Element
instance Plutarch.Internal.Semigroup.PMonoid Plutarch.Builtin.BLS.PBuiltinBLS12_381_G2_Element
instance Plutarch.Internal.Semigroup.PSemigroup Plutarch.Builtin.Unit.PUnit
instance Plutarch.Internal.Semigroup.PSemigroup Plutarch.Builtin.String.PString
instance Plutarch.Internal.Semigroup.PSemigroup Plutarch.Builtin.ByteString.PByteString
instance Plutarch.Internal.Semigroup.PSemigroup Plutarch.Builtin.BLS.PBuiltinBLS12_381_G1_Element
instance Plutarch.Internal.Semigroup.PSemigroup Plutarch.Builtin.BLS.PBuiltinBLS12_381_G2_Element
instance Plutarch.Internal.Semigroup.PSemigroup Plutarch.Builtin.BLS.PBuiltinBLS12_381_MlResult

module Plutarch.Pair

-- | Plutus encoding of Pairs.
--   
--   Note: This is represented differently than <tt>BuiltinPair</tt>. It is
--   SoP encoded.
data PPair (a :: S -> Type) (b :: S -> Type) (s :: S)
PPair :: Term s a -> Term s b -> PPair (a :: S -> Type) (b :: S -> Type) (s :: S)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Show.PShow a, Plutarch.Internal.Show.PShow b) => Plutarch.Internal.Show.PShow (Plutarch.Pair.PPair a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Eq.PEq a, Plutarch.Internal.Eq.PEq b) => Plutarch.Internal.Eq.PEq (Plutarch.Pair.PPair a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Pair.PPair a b s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Pair.PPair a b s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Pair.PPair a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Semigroup.PSemigroup a, Plutarch.Internal.Semigroup.PSemigroup b) => Plutarch.Internal.Semigroup.PSemigroup (Plutarch.Pair.PPair a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Semigroup.PMonoid a, Plutarch.Internal.Semigroup.PMonoid b) => Plutarch.Internal.Semigroup.PMonoid (Plutarch.Pair.PPair a b)

module Plutarch.Rational

-- | A Scott-encoded rational number, with a guaranteed positive
--   denominator (and thus, a canonical form).
--   
--   <h1>Note</h1>
--   
--   This is not the Plutarch equivalent of a Plutus <tt>Rational</tt>; for
--   this, you want <tt>PRationalData</tt> from
--   <tt>plutarch-ledger-api</tt>. <a>PRational</a> is designed to optimize
--   for computation: if you want to do any serious work with rational
--   numbers that isn't just passing them around, you want to use (or
--   convert to) <a>PRational</a>.
data PRational s
PRational :: Term s PInteger -> Term s PPositive -> PRational s
preduce :: Term s (PRational :--> PRational)
pnumerator :: Term s (PRational :--> PInteger)
pdenominator :: Term s (PRational :--> PPositive)
pfromInteger :: Term s (PInteger :--> PRational)
pround :: Term s (PRational :--> PInteger)
ptruncate :: Term s (PRational :--> PInteger)
pproperFraction :: Term s (PRational :--> PPair PInteger PRational)
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Rational.PRational s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Rational.PRational s)
instance forall k1 k2 (f :: k2 -> k1 -> GHC.Types.Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.Rational.Flip @{k2} @{k1} f a b)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Rational.PRational
instance Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData Plutarch.Rational.PRational)
instance Plutarch.Internal.Lift.PLiftable Plutarch.Rational.PRational
instance Plutarch.Internal.Eq.PEq Plutarch.Rational.PRational
instance Plutarch.Internal.Ord.POrd Plutarch.Rational.PRational
instance Plutarch.Internal.Numeric.PAdditiveSemigroup Plutarch.Rational.PRational
instance Plutarch.Internal.Numeric.PAdditiveMonoid Plutarch.Rational.PRational
instance Plutarch.Internal.Numeric.PAdditiveGroup Plutarch.Rational.PRational
instance Plutarch.Internal.Numeric.PMultiplicativeSemigroup Plutarch.Rational.PRational
instance Plutarch.Internal.Numeric.PMultiplicativeMonoid Plutarch.Rational.PRational
instance Plutarch.Internal.Numeric.PRing Plutarch.Rational.PRational
instance Plutarch.Internal.Numeric.PIntegralDomain Plutarch.Rational.PRational
instance forall (s :: Plutarch.Internal.Term.S). GHC.Real.Fractional (Plutarch.Internal.Term.Term s Plutarch.Rational.PRational)
instance Plutarch.Internal.Show.PShow Plutarch.Rational.PRational


-- | Scott-encoded lists and ListLike typeclass
module Plutarch.List

-- | SOP-encoded list.
--   
--   @since WIP
data PList (a :: S -> Type) (s :: S)
PSCons :: Term s a -> Term s (PList a) -> PList (a :: S -> Type) (s :: S)
PSNil :: PList (a :: S -> Type) (s :: S)

-- | Extract head and tail of the list, throws error if list is empty.
ptryUncons :: PIsListLike list a => Term s (list a :--> PPair a (list a))

-- | Extract head and tail of the list, if list is not empty.
puncons :: PIsListLike list a => Term s (list a :--> PMaybe (PPair a (list a)))

-- | <i> O(min(n, m)) </i>. Zip two lists together, creating pairs of the
--   elements.
--   
--   If the lists are of differing lengths, cut to the shortest.
pzip :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list (PPair a b)) => Term s (list a :--> (list b :--> list (PPair a b)))

-- | <i> O(n) </i>. like haskell level <tt>find</tt> but on plutarch level
pfind :: PIsListLike l a => Term s ((a :--> PBool) :--> (l a :--> PMaybe a))

-- | <i> O(n) </i>. Reverse a list-like structure.
--   
--   @since WIP
preverse :: forall (l :: (S -> Type) -> S -> Type) (a :: S -> Type) (s :: S). PIsListLike l a => Term s (l a :--> l a)

-- | <i> O(n) </i>. Checks if a list-list structure is sorted.
--   
--   @since WIP
pcheckSorted :: forall (l :: (S -> Type) -> S -> Type) (a :: S -> Type) (s :: S). (PIsListLike l a, POrd a) => Term s (l a :--> PBool)

-- | <i> O(n) </i>. Check if element is in the list
pelem :: (PIsListLike list a, PEq a) => Term s (a :--> (list a :--> PBool))

-- | <i> O(n) </i>. Like Haskell level <a>(!!)</a> but on the plutarch
--   level
(#!!) :: PIsListLike l a => Term s (l a) -> Term s PInteger -> Term s a

-- | <i> O(n) </i>. Like Haskell level <a>(!!)</a> but on the Plutarch
--   level, not infix and with arguments reversed, errors if the specified
--   index is greater than or equal to the lists length
pelemAt :: PIsListLike l a => Term s (PInteger :--> (l a :--> a))

-- | <i> O(n) </i>. like <a>pelemAt</a> but doesn't fail on negative
--   indexes
pelemAt' :: PIsListLike l a => Term s (PInteger :--> (l a :--> a))

-- | <i> O(min(n, m)) </i>. Check if two lists are equal.
plistEquals :: (PIsListLike list a, PEq a) => Term s (list a :--> (list a :--> PBool))
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.List.PList a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.List.PList a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.List.PList a)
instance forall (a :: Plutarch.Internal.Term.PType). Plutarch.Internal.Show.PShow a => Plutarch.Internal.Show.PShow (Plutarch.List.PList a)
instance forall (a :: Plutarch.Internal.Term.PType). Plutarch.Internal.Eq.PEq a => Plutarch.Internal.Eq.PEq (Plutarch.List.PList a)
instance Plutarch.Internal.ListLike.PListLike Plutarch.List.PList

module Plutarch.Enum

-- | A notion of 'next' value. More formally, instances of this type class
--   are discrete linear orders with no maximal element.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><pre>x /= psuccessor x</pre></li>
--   <li><tt>y &lt; x</tt> <tt>=</tt> <tt>psuccessor y &lt;= x</tt></li>
--   <li><tt>x &lt; psuccessor y</tt> <tt>=</tt> <tt>x &lt;= y</tt></li>
--   </ol>
--   
--   If you define <a>psuccessorN</a>, you must also ensure the following
--   hold; the default implementation ensures this.
--   
--   <ol>
--   <li><tt>psuccessorN 1</tt> <tt>=</tt> <tt>psuccessor</tt></li>
--   <li><tt>psuccessorN n . psuccessorN m</tt> <tt>=</tt> <tt>psuccessorN
--   (n + m)</tt></li>
--   </ol>
--   
--   Law 1 ensures no value is its own successor. Laws 2 and 3 ensure that
--   there are no 'gaps': every value is 'reachable' from any lower value
--   by a finite number of applications of <tt>successor</tt>.
--   
--   @since WIP
class POrd a => PCountable (a :: S -> Type)

-- | @since WIP
psuccessor :: forall (s :: S). PCountable a => Term s (a :--> a)

-- | The default implementation of this function is inefficient: if at all
--   possible, give instances an optimized version that doesn't require
--   recursion.
--   
--   @since WIP
psuccessorN :: forall (s :: S). PCountable a => Term s (PPositive :--> (a :--> a))

-- | Similar to <a>PCountable</a>, but has the ability to get a 'previous'
--   value as well. More formally, instances of this type class are
--   discrete linear orders with no maximal or minimal element.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>ppredecessor . psuccessor</tt> <tt>=</tt> <tt>psuccessor .
--   ppredecessor</tt> <tt>=</tt> <tt>id</tt></li>
--   </ol>
--   
--   If you define <a>ppredecessorN</a>, you must also ensure the following
--   hold; the default implementation ensures this.
--   
--   <ol>
--   <li><tt>ppredecessorN 1</tt> <tt>=</tt> <tt>ppredecessor</tt></li>
--   <li><tt>ppredecessorN n . ppredecessorN m</tt> <tt>=</tt>
--   <tt>ppredecessorN (n + m)</tt></li>
--   </ol>
--   
--   From Law 1, we obtain the following theorem:
--   
--   <ul>
--   <li><pre>x /= predecessor x</pre></li>
--   </ul>
--   
--   @since WIP
class PCountable a => PEnumerable (a :: S -> Type)

-- | @since WIP
ppredecessor :: forall (s :: S). PEnumerable a => Term s (a :--> a)

-- | The default implementation of this function is inefficient: if at all
--   possible, give instances an optimized version that doesn't require
--   recursion.
--   
--   @since WIP
ppredecessorN :: forall (s :: S). PEnumerable a => Term s (PPositive :--> (a :--> a))
instance Plutarch.Enum.PEnumerable Plutarch.Builtin.Integer.PInteger
instance Plutarch.Enum.PCountable Plutarch.Builtin.Integer.PInteger
instance Plutarch.Enum.PCountable Plutarch.Internal.Numeric.PPositive

module Plutarch.BitString

-- | A wrapper around <a>PByteString</a> for CIP-122 and CIP-123 bitwise
--   operations.
--   
--   <h1>Note</h1>
--   
--   This type exists because <i>bit</i> and <i>byte</i> indexes work in
--   different directions. To avoid confusing behaviour, we require an
--   explicit wrapping of <a>PByteString</a>s to use bitwise functionality:
--   this way, it's clear where which scheme applies.
--   
--   @since WIP
newtype PBitString (s :: S)
PBitString :: Term s PByteString -> PBitString (s :: S)

-- | Bit access operation, as defined in <a>CIP-122</a>.
--   
--   @since WIP
preadBit :: forall (s :: S). Term s (PBitString :--> (PInteger :--> PBool))

-- | Given a list of positions, set the bits at those positions.
--   
--   This works similarly to the <tt>writeBits</tt> operation in
--   <a>CIP-122</a> with regard to the list of indexes. Effectively,
--   <tt>psetBits b ixes</tt> is equivalent to <tt>writeBits b . map (,
--   True) $ ixes</tt>. All caveats that this entails from the CIP-122
--   description apply.
--   
--   @since WIP
--   
--   Sets bits, as per <a>CIP-122</a>.
--   
--   @since WIP
pwriteBits :: forall (s :: S). Term s (PBitString :--> (PBuiltinList PInteger :--> (PBool :--> PBitString)))

-- | Performs a shift, as per <a>CIP-123</a>.
--   
--   @since WIP
pshift :: forall (s :: S). Term s (PBitString :--> (PInteger :--> PBitString))

-- | Performs a rotation, as per <a>CIP-123</a>.
--   
--   @since WIP
protate :: forall (s :: S). Term s (PBitString :--> (PInteger :--> PBitString))

-- | Counts the number of set bits, as per <a>CIP-123</a>.
--   
--   @since WIP
pcountSetBits :: forall (s :: S). Term s (PBitString :--> PInteger)

-- | As <tt>pfindFirstSetBit'</tt>, but produces <a>PNothing</a> if the
--   argument is empty, or contains no set bits.
--   
--   @since WIP
pfindFirstSetBit :: forall (s :: S). Term s (PBitString :--> PMaybe PInteger)

-- | Finds the index of the first set bit, as per <a>CIP-123</a>.
--   
--   <h1>Note</h1>
--   
--   This returns <tt>-1</tt> if the argument is either empty, or contains
--   no set bits.
--   
--   @since WIP
pfindFirstSetBit' :: forall (s :: S). Term s (PBitString :--> PInteger)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.BitString.PBitString
instance Plutarch.Internal.Semigroup.PMonoid Plutarch.BitString.PBitString
instance Plutarch.Internal.Semigroup.PSemigroup Plutarch.BitString.PBitString
instance Plutarch.Internal.Ord.POrd Plutarch.BitString.PBitString
instance Plutarch.Internal.Eq.PEq Plutarch.BitString.PBitString
instance forall (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.BitString.PBitString s)
instance forall (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.BitString.PBitString s)
instance Plutarch.Internal.Lift.PLiftable Plutarch.BitString.PBitString

module Plutarch.DataRepr.Internal.FromData

-- | removes the PAsData if the hole requires it but leaves it there if it
--   doesn't
--   
--   <pre>
--   &gt;&gt;&gt; :t pmaybeFromAsData (pdata 3 :: (Term s (PAsData PInteger))) :: (Term (s::S) PInteger)
--   pmaybeFromAsData (pdata 3 :: (Term s (PAsData PInteger))) :: (Term (s::S) PInteger)
--   :: forall (s :: S). Term s (PInteger @{S})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t pmaybeFromAsData (pdata 3 :: (Term s (PAsData PInteger))) :: (Term (s::S) (PAsData PInteger))
--   pmaybeFromAsData (pdata 3 :: (Term s (PAsData PInteger))) :: (Term (s::S) (PAsData PInteger))
--   :: forall (s :: S). Term s (PAsData (PInteger @{S}))
--   </pre>
class PFromDataable (a :: PType) (b :: PType) | b -> a, a -> b
pmaybeFromAsData :: PFromDataable a b => Term s (PAsData a) -> Term s b
instance forall (a :: Plutarch.Internal.Term.PType). Plutarch.DataRepr.Internal.FromData.PFromDataable a (Plutarch.Builtin.Data.PAsData a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.IsData.PIsData a, (b :: (Plutarch.Internal.Term.S -> GHC.Types.Type)) GHC.Types.~ (a :: (Plutarch.Internal.Term.S -> GHC.Types.Type))) => Plutarch.DataRepr.Internal.FromData.PFromDataable a b

module Plutarch.DataRepr.Internal.HList
data HRec as
[HNil] :: HRec '[]
[HCons] :: Labeled name a -> HRec as -> HRec ('(name, a) ': as)
newtype HRecGeneric as
HRecGeneric :: HRec as -> HRecGeneric as
newtype Labeled sym a
Labeled :: a -> Labeled sym a
[$sel:unLabeled:Labeled] :: Labeled sym a -> a

-- | Index a <a>HRec</a> with a field in a provided list of data fields.
--   Implicitly unwraps `PAsData a` to <tt>a</tt> when necessary.
--   
--   <pre>
--   &gt;&gt;&gt; xs = HRec @["x", "y", "z"] (HCons 1 (HCons 2 (HCons 3 HNil)))
--   
--   &gt;&gt;&gt; hrecField @"y" @["x", "y", "z"] xs
--   
--   &gt;&gt;&gt; 2
--   </pre>

-- | <i>Deprecated: please use getField from GHC.Records</i>
hrecField :: forall name c as a b s. (ElemOf name a as, Term s (PAsData b) ~ a, PFromDataable b c) => HRec as -> Term s c

-- | Index a HList with a field in a provided list of fields.
--   
--   <pre>
--   &gt;&gt;&gt; xs = HRec @["x", "y", "z"] (HCons 1 (HCons 2 (HCons 3 HNil)))
--   
--   &gt;&gt;&gt; hrecField @"y" @["x", "y", "z"] xs
--   
--   &gt;&gt;&gt; 2
--   </pre>
hrecField' :: forall name a as. ElemOf name a as => HRec as -> a

-- | Indexing type-level lists
type family IndexList (n :: Nat) (l :: [k]) :: k

-- | Indexing list of labeled pairs by label
type family IndexLabel name as

-- | Return the single item from a singleton list
type family SingleItem (as :: [k]) :: k

-- | Drop first n fields of a list
type family Drop (n :: Nat) (as :: [k]) :: [k]

-- | GADT proof-witness of HList membership, usable as an index
data Elem (a :: k) (as :: [k])
[Here] :: Elem a (a ': as)
[There] :: Elem a as -> Elem a (b ': as)

-- | Construct an <a>Elem</a> via Nat.
--   
--   This class could instead be a more direct version of
--   <tt>indexHList</tt>, but perhaps the <a>Elem</a> encoding will be
--   useful.
class IndexLabel name as ~ a => ElemOf name a as | as name -> a

-- | Construct the <a>Elem</a> corresponding to a Nat index.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; natElem @_ @0
--   Here
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; natElem @_ @3
--   There (There (There Here))
--   </pre>
elemOf :: ElemOf name a as => Elem '(name, a) as
instance forall (name :: GHC.Types.Symbol) a (as :: [(GHC.Types.Symbol, GHC.Types.Type)]). ((Plutarch.DataRepr.Internal.HList.Utils.IndexLabel name as :: GHC.Types.Type) GHC.Types.~ (a :: GHC.Types.Type), Plutarch.DataRepr.Internal.HList.ElemOf name a as) => GHC.Records.HasField @{GHC.Types.Symbol} name (Plutarch.DataRepr.Internal.HList.HRecGeneric as) a
instance forall (name :: GHC.Types.Symbol) a (as :: [(GHC.Types.Symbol, GHC.Types.Type)]). Plutarch.DataRepr.Internal.HList.ElemOf name a ((':) @(GHC.Types.Symbol, GHC.Types.Type) '(name, a) as)
instance forall (name :: GHC.Types.Symbol) (b :: (GHC.Types.Symbol, GHC.Types.Type)) (as :: [(GHC.Types.Symbol, GHC.Types.Type)]) a. ((Plutarch.DataRepr.Internal.HList.Utils.IndexLabel name ((':) @(GHC.Types.Symbol, GHC.Types.Type) b as) :: GHC.Types.Type) GHC.Types.~ (a :: GHC.Types.Type), Plutarch.DataRepr.Internal.HList.ElemOf name a as) => Plutarch.DataRepr.Internal.HList.ElemOf name a ((':) @(GHC.Types.Symbol, GHC.Types.Type) b as)
instance forall (name :: GHC.Types.Symbol) (c :: Plutarch.Internal.Term.PType) (as :: [(GHC.Types.Symbol, GHC.Types.Type)]) a (b :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). ((Plutarch.DataRepr.Internal.HList.Utils.IndexLabel name as :: GHC.Types.Type) GHC.Types.~ (a :: GHC.Types.Type), Plutarch.DataRepr.Internal.HList.ElemOf name a as, (Plutarch.Internal.Term.Term s (Plutarch.Builtin.Data.PAsData b) :: GHC.Types.Type) GHC.Types.~ (a :: GHC.Types.Type), Plutarch.DataRepr.Internal.FromData.PFromDataable b c) => GHC.Records.HasField @{GHC.Types.Symbol} name (Plutarch.DataRepr.Internal.HList.HRec as) (Plutarch.Internal.Term.Term s c)

module Plutarch.Either

-- | SOP-encoded <a>Either</a>.
--   
--   @since WIP
data PEither (a :: S -> Type) (b :: S -> Type) (s :: S)
PLeft :: Term s a -> PEither (a :: S -> Type) (b :: S -> Type) (s :: S)
PRight :: Term s b -> PEither (a :: S -> Type) (b :: S -> Type) (s :: S)

-- | <tt>Data</tt>-encoded <a>Either</a>.
--   
--   @since WIP
data PEitherData (a :: S -> Type) (b :: S -> Type) (s :: S)
PDLeft :: Term s (PAsData a) -> PEitherData (a :: S -> Type) (b :: S -> Type) (s :: S)
PDRight :: Term s (PAsData b) -> PEitherData (a :: S -> Type) (b :: S -> Type) (s :: S)

-- | @since WIP
pisLeft :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). Term s (PEither a b :--> PBool)

-- | @since WIP
pfromLeft :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). Term s (PEither a b :--> a)

-- | @since WIP
pfromRight :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). Term s (PEither a b :--> b)

-- | Make a <tt>Data</tt>-encoded <tt>Left</tt>.
--   
--   @since WIP
pdleft :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). PIsData a => Term s (a :--> PEitherData a b)

-- | Make a <tt>Data</tt>-encoded <tt>Right</tt>.
--   
--   @since WIP
pdright :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). PIsData b => Term s (b :--> PEitherData a b)

-- | Eliminator for <a>PEitherData</a>.
--   
--   @since WIP
peitherData :: forall (a :: S -> Type) (b :: S -> Type) (r :: S -> Type) (s :: S). (PIsData a, PIsData b) => Term s ((a :--> r) :--> ((b :--> r) :--> (PEitherData a b :--> r)))

-- | Verifies if a <a>PEitherData</a> is a <a>PDLeft</a>. Less code than
--   using <a>peitherData</a>, as it doesn't need to inspect the contents.
--   
--   @since WIP
pdisLeft :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). Term s (PEitherData a b :--> PBool)

-- | As <a>pdisLeft</a>, except verifies whether we have a <a>PDRight</a>.
--   
--   @since WIP
pdisRight :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). Term s (PEitherData a b :--> PBool)

-- | Return the value inside a <tt>PDEither</tt> if it's a <a>PDLeft</a>,
--   error otherwise.
--   
--   @since WIP
pdfromLeft :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). PIsData a => Term s (PEitherData a b :--> a)

-- | As <a>pdfromLeft</a>, but yields a value if given a <a>PDRight</a>
--   instead.
--   
--   @since WIP
pdfromRight :: forall (a :: S -> Type) (b :: S -> Type) (s :: S). PIsData b => Term s (PEitherData a b :--> b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Show.PShow a, Plutarch.Internal.Show.PShow b) => Plutarch.Internal.Show.PShow (Plutarch.Either.PEither a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Eq.PEq a, Plutarch.Internal.Eq.PEq b) => Plutarch.Internal.Eq.PEq (Plutarch.Either.PEither a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Either.PEither a b s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Either.PEither a b s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.IsData.PIsData a, Plutarch.Internal.IsData.PIsData b, Plutarch.Internal.Show.PShow a, Plutarch.Internal.Show.PShow b) => Plutarch.Internal.Show.PShow (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Eq.PEq (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Either.PEitherData a b s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Either.PEither a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). (PlutusTx.IsData.Class.ToData (Plutarch.Internal.Lift.AsHaskell a), PlutusTx.IsData.Class.FromData (Plutarch.Internal.Lift.AsHaskell a), PlutusTx.IsData.Class.ToData (Plutarch.Internal.Lift.AsHaskell b), PlutusTx.IsData.Class.FromData (Plutarch.Internal.Lift.AsHaskell b)) => Plutarch.Internal.Lift.PLiftable (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.Term.PType) (b :: Plutarch.Internal.Term.PType). (Plutarch.Internal.Ord.POrd a, Plutarch.Internal.Ord.POrd b, Plutarch.Internal.IsData.PIsData a, Plutarch.Internal.IsData.PIsData b) => Plutarch.Internal.Ord.POrd (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.IsData.PIsData (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.Term.PType) (b :: Plutarch.Internal.Term.PType). (Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData a, Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData b) => Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Either.PEitherData a b)
instance forall (a :: Plutarch.Internal.Term.PType) (b :: Plutarch.Internal.Term.PType). (Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData a, Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData b) => Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData (Plutarch.Either.PEitherData a b))
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (b :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Lift.PLiftable a, Plutarch.Internal.Lift.PLiftable b) => Plutarch.Internal.Lift.PLiftable (Plutarch.Either.PEither a b)

module Plutarch.DataRepr.Internal

-- | A sum of <a>PDataRecord</a>s. The underlying representation is the
--   <tt>Constr</tt> constructor, where the integer is the index of the
--   variant and the list is the record.
newtype PDataSum defs s
PDataSum :: NS (Compose (Term s) PDataRecord) defs -> PDataSum defs s

-- | If there is only a single variant, then we can safely extract it.
punDataSum :: Term s (PDataSum '[def] :--> PDataRecord def)

-- | Try getting the nth variant. Errs if it's another variant.
ptryIndexDataSum :: KnownNat n => Proxy n -> Term s (PDataSum (def ': defs) :--> PDataRecord (IndexList n (def ': defs)))

-- | Cons a field to a data record.
--   
--   You can specify the label to associate with the field using type
--   applications-
--   
--   <pre>
--   foo :: Term s (PDataRecord '[ "fooField" ':= PByteString ])
--   foo = pdcons @"fooField" # pdata (phexByteStr "ab") # pdnil
--   </pre>
pdcons :: forall label a l s. Term s (PAsData a :--> (PDataRecord l :--> PDataRecord ((label ':= a) ': l)))

-- | An empty <a>PDataRecord</a>.
pdnil :: Term s (PDataRecord '[])
data DataReprHandlers (out :: S -> Type) (defs :: [[PLabeledType]]) (s :: S)
[DRHNil] :: DataReprHandlers out '[] s
[DRHCons] :: (Term s (PDataRecord def) -> Term s out) -> DataReprHandlers out defs s -> DataReprHandlers out (def ': defs) s

-- | A "record" of `exists a. PAsData a`. The underlying representation is
--   `PBuiltinList PData`.
data PDataRecord (as :: [PLabeledType]) (s :: S)
[PDCons] :: forall name_x x xs s. PUnLabel name_x ~ x => Term s (PAsData x) -> Term s (PDataRecord xs) -> PDataRecord (name_x ': xs) s
[PDNil] :: PDataRecord '[] s
data PLabeledType
(:=) :: Symbol -> (S -> Type) -> PLabeledType
type family PLabelIndex (name :: Symbol) (as :: [PLabeledType]) :: Nat
type family PUnLabel (a :: PLabeledType) :: S -> Type
type family PLookupLabel name as

-- | Safely index a <a>PDataRecord</a>.
pindexDataRecord :: KnownNat n => Proxy n -> Term s (PDataRecord as) -> Term s (PAsData (PUnLabel (IndexList n as)))

-- | Safely drop the first n items of a <a>PDataRecord</a>.
pdropDataRecord :: KnownNat n => Proxy n -> Term s (PDataRecord xs) -> Term s (PDataRecord (Drop n xs))
newtype DualReprHandler s out def
DualRepr :: (Term s (PDataRecord def) -> Term s (PDataRecord def) -> Term s out) -> DualReprHandler s out def
data PlutusTypeData
instance forall (as :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.Internal.PlutusType.PlutusType (Plutarch.DataRepr.Internal.PDataRecordShowHelper as)
instance forall (as :: [Plutarch.DataRepr.Internal.PLabeledType]) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.DataRepr.Internal.PDataRecordShowHelper as s)
instance forall (as :: [(GHC.Types.Symbol, Plutarch.Internal.Term.S -> GHC.Types.Type)]) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.DataRepr.Internal.HRecP as s)
instance forall k1 k2 (f :: k2 -> k1 -> GHC.Types.Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.DataRepr.Internal.Flip @{k2} @{k1} f a b)
instance forall (b :: Plutarch.Internal.Subtype.PSubtypeRelation) (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.DataRepr.Internal.ExcessForField b a s)
instance forall k (a :: k -> GHC.Types.Type) (b :: k -> GHC.Types.Type) (s :: k). GHC.Generics.Generic (Plutarch.DataRepr.Internal.Helper @{k} a b s)
instance forall (n :: GHC.TypeNats.Nat) (x :: [Plutarch.DataRepr.Internal.PLabeledType]) (xs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). (Plutarch.Internal.TryFrom.PTryFrom (Plutarch.Builtin.Data.PBuiltinList Plutarch.Builtin.Data.PData) (Plutarch.DataRepr.Internal.PDataRecord x), Plutarch.DataRepr.Internal.SumValidation (n GHC.TypeNats.+ 1) xs, GHC.TypeNats.KnownNat n) => Plutarch.DataRepr.Internal.SumValidation n ((':) @[Plutarch.DataRepr.Internal.PLabeledType] x xs)
instance forall (n :: GHC.TypeNats.Nat). Plutarch.DataRepr.Internal.SumValidation n ('[] @[Plutarch.DataRepr.Internal.PLabeledType])
instance forall (ys :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Plutarch.DataRepr.Internal.SumValidation 0 ys => Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.DataRepr.Internal.PDataSum ys)
instance forall (as :: [Plutarch.DataRepr.Internal.PLabeledType]) (ase :: [(GHC.Types.Symbol, Plutarch.Internal.Term.S -> GHC.Types.Type)]). (Plutarch.Internal.TryFrom.PTryFrom (Plutarch.Builtin.Data.PBuiltinList Plutarch.Builtin.Data.PData) (Plutarch.DataRepr.Internal.PDataRecord as), (Plutarch.Internal.TryFrom.PTryFromExcess (Plutarch.Builtin.Data.PBuiltinList Plutarch.Builtin.Data.PData) (Plutarch.DataRepr.Internal.PDataRecord as) :: Plutarch.Internal.Term.PType) GHC.Types.~ (Plutarch.DataRepr.Internal.HRecP ase :: Plutarch.Internal.Term.PType)) => Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData (Plutarch.DataRepr.Internal.PDataRecord as))
instance forall (pty :: Plutarch.Internal.Term.PType) (as :: [Plutarch.DataRepr.Internal.PLabeledType]) (ase :: [(GHC.Types.Symbol, Plutarch.Internal.Term.S -> GHC.Types.Type)]) (name :: GHC.Types.Symbol). (Plutarch.DataRepr.Internal.Helper2 (Plutarch.Internal.Subtype.PSubtype' Plutarch.Builtin.Data.PData pty) pty, Plutarch.Internal.TryFrom.PTryFrom (Plutarch.Builtin.Data.PBuiltinList Plutarch.Builtin.Data.PData) (Plutarch.DataRepr.Internal.PDataRecord as), (Plutarch.Internal.TryFrom.PTryFromExcess (Plutarch.Builtin.Data.PBuiltinList Plutarch.Builtin.Data.PData) (Plutarch.DataRepr.Internal.PDataRecord as) :: Plutarch.Internal.Term.PType) GHC.Types.~ (Plutarch.DataRepr.Internal.HRecP ase :: Plutarch.Internal.Term.PType)) => Plutarch.Internal.TryFrom.PTryFrom (Plutarch.Builtin.Data.PBuiltinList Plutarch.Builtin.Data.PData) (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType (name 'Plutarch.DataRepr.Internal.:= pty) as))
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData a) => Plutarch.DataRepr.Internal.Helper2 'Plutarch.Internal.Subtype.PNoSubtypeRelation a
instance forall (a :: Plutarch.Internal.Term.PType). Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData a => Plutarch.DataRepr.Internal.Helper2 'Plutarch.Internal.Subtype.PSubtypeRelation a
instance Plutarch.Internal.TryFrom.PTryFrom (Plutarch.Builtin.Data.PBuiltinList Plutarch.Builtin.Data.PData) (Plutarch.DataRepr.Internal.PDataRecord ('[] @Plutarch.DataRepr.Internal.PLabeledType))
instance forall (a :: Plutarch.Internal.Term.PType). (Plutarch.DataRepr.Internal.IsPDataSum (Plutarch.Internal.Generic.PCode a), Data.SOP.Constraint.SListI @{[Plutarch.DataRepr.Internal.PLabeledType]} (Plutarch.DataRepr.Internal.IsPDataSumDefs (Plutarch.Internal.Generic.PCode a)), Plutarch.Internal.Generic.PGeneric a) => Plutarch.DataRepr.Internal.PlutusTypeDataConstraint a
instance Plutarch.Internal.PlutusType.PlutusTypeStrat Plutarch.DataRepr.Internal.PlutusTypeData
instance forall (defs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Data.SOP.Constraint.SListI @{[Plutarch.DataRepr.Internal.PLabeledType]} defs => Plutarch.Internal.PlutusType.PlutusType (Plutarch.DataRepr.Internal.PDataSum defs)
instance Plutarch.DataRepr.Internal.IsPDataSum ('[] @[Plutarch.Internal.Term.S -> GHC.Types.Type])
instance forall (xs :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]) (l :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.DataRepr.Internal.IsPDataSum xs => Plutarch.DataRepr.Internal.IsPDataSum ((':) @[Plutarch.Internal.Term.S -> GHC.Types.Type] ((':) @(Plutarch.Internal.Term.S -> GHC.Types.Type) (Plutarch.DataRepr.Internal.PDataRecord l) ('[] @(Plutarch.Internal.Term.S -> GHC.Types.Type))) xs)
instance forall (defs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). (Data.SOP.Constraint.All @[Plutarch.DataRepr.Internal.PLabeledType] (Data.SOP.Constraint.Top @{[Plutarch.DataRepr.Internal.PLabeledType]}) defs, Data.SOP.Constraint.All @[Plutarch.DataRepr.Internal.PLabeledType] (Data.SOP.Constraint.Compose @{Plutarch.Internal.Term.PType} @{[Plutarch.DataRepr.Internal.PLabeledType]} Plutarch.Internal.Show.PShow Plutarch.DataRepr.Internal.PDataRecord) defs) => Plutarch.Internal.Show.PShow (Plutarch.DataRepr.Internal.PDataSum defs)
instance forall (defs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Plutarch.Internal.IsData.PIsData (Plutarch.DataRepr.Internal.PDataSum defs)
instance forall (defs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Plutarch.Internal.Eq.PEq (Plutarch.DataRepr.Internal.PDataSum defs)
instance forall (defs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Data.SOP.Constraint.All @[Plutarch.DataRepr.Internal.PLabeledType] (Data.SOP.Constraint.Compose @{Plutarch.Internal.Term.PType} @{[Plutarch.DataRepr.Internal.PLabeledType]} Plutarch.Internal.Ord.POrd Plutarch.DataRepr.Internal.PDataRecord) defs => Plutarch.Internal.Ord.POrd (Plutarch.DataRepr.Internal.PDataSum defs)
instance forall (ys :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.DataRepr.Internal.PDataSum ys) => Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData (Plutarch.DataRepr.Internal.PDataSum ys))
instance forall (l :: [Plutarch.DataRepr.Internal.PLabeledType]). Data.SOP.Constraint.SListI @{Plutarch.DataRepr.Internal.PLabeledType} l => Plutarch.Internal.PlutusType.PlutusType (Plutarch.DataRepr.Internal.PDataRecord l)
instance forall (xs :: [Plutarch.DataRepr.Internal.PLabeledType]) (label :: GHC.Types.Symbol) (x :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Data.SOP.Constraint.All @Plutarch.DataRepr.Internal.PLabeledType (Data.SOP.Constraint.Top @{Plutarch.DataRepr.Internal.PLabeledType}) xs, GHC.TypeLits.KnownSymbol label, Plutarch.Internal.IsData.PIsData x, Plutarch.Internal.Show.PShow x, Plutarch.Internal.Show.PShow (Plutarch.DataRepr.Internal.PDataRecordShowHelper xs)) => Plutarch.Internal.Show.PShow (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType (label 'Plutarch.DataRepr.Internal.:= x) xs))
instance forall (as :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.DataRepr.Internal.PDataRecordShowHelper as)
instance Plutarch.Internal.Show.PShow (Plutarch.DataRepr.Internal.PDataRecordShowHelper ('[] @Plutarch.DataRepr.Internal.PLabeledType))
instance forall (xs :: [Plutarch.DataRepr.Internal.PLabeledType]) (label :: GHC.Types.Symbol) (x :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Data.SOP.Constraint.All @Plutarch.DataRepr.Internal.PLabeledType (Data.SOP.Constraint.Top @{Plutarch.DataRepr.Internal.PLabeledType}) xs, GHC.TypeLits.KnownSymbol label, Plutarch.Internal.IsData.PIsData x, Plutarch.Internal.Show.PShow x, Plutarch.Internal.Show.PShow (Plutarch.DataRepr.Internal.PDataRecordShowHelper xs)) => Plutarch.Internal.Show.PShow (Plutarch.DataRepr.Internal.PDataRecordShowHelper ((':) @Plutarch.DataRepr.Internal.PLabeledType (label 'Plutarch.DataRepr.Internal.:= x) xs))
instance forall (xs :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.Internal.Eq.PEq (Plutarch.DataRepr.Internal.PDataRecord xs)
instance Plutarch.Internal.Ord.POrd (Plutarch.DataRepr.Internal.PDataRecord ('[] @Plutarch.DataRepr.Internal.PLabeledType))
instance Plutarch.Internal.Show.PShow (Plutarch.DataRepr.Internal.PDataRecord ('[] @Plutarch.DataRepr.Internal.PLabeledType))
instance forall (x :: Plutarch.Internal.Term.PType) (label :: GHC.Types.Symbol). (Plutarch.Internal.Ord.POrd x, Plutarch.Internal.IsData.PIsData x) => Plutarch.Internal.Ord.POrd (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType (label 'Plutarch.DataRepr.Internal.:= x) ('[] @Plutarch.DataRepr.Internal.PLabeledType)))
instance forall (xs :: [Plutarch.DataRepr.Internal.PLabeledType]) (x :: Plutarch.Internal.Term.PType) (x' :: Plutarch.DataRepr.Internal.PLabeledType) (label :: GHC.Types.Symbol). (Data.SOP.Constraint.SListI @{Plutarch.DataRepr.Internal.PLabeledType} xs, Plutarch.Internal.Ord.POrd x, Plutarch.Internal.IsData.PIsData x, Plutarch.Internal.Ord.POrd (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType x' xs))) => Plutarch.Internal.Ord.POrd (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType (label 'Plutarch.DataRepr.Internal.:= x) ((':) @Plutarch.DataRepr.Internal.PLabeledType x' xs)))
instance forall (xs :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.Internal.IsData.PIsData (Plutarch.DataRepr.Internal.PDataRecord xs)

module Plutarch.DataRepr.Internal.Field

-- | Class allowing <tt>letFields</tt> to work for a PType, usually via
--   <tt>PIsDataRepr</tt>, but is derived for some other types for
--   convenience.
class PDataFields (a :: S -> Type) where {
    
    -- | Fields in HRec bound by <tt>letFields</tt>
    type PFields a :: [PLabeledType];
    type PFields a = Helper (PInner a);
}

-- | Convert a Term to a <tt>PDataList</tt>
ptoFields :: PDataFields a => Term s a -> Term s (PDataRecord (PFields a))

-- | Convert a Term to a <tt>PDataList</tt>
ptoFields :: (PDataFields a, PDataFields (PInner a), PFields (PInner a) ~ PFields a) => Term s a -> Term s (PDataRecord (PFields a))

-- | Bind a HRec of named fields containing all the specified fields.
pletFields :: forall fs a s b ps bs. (PDataFields a, ps ~ PFields a, bs ~ Bindings ps fs, BindFields ps bs) => Term s a -> (HRecOf a fs s -> Term s b) -> Term s b

-- | Get a single field from a Term.
--   
--   <ul>
--   <li>NB*: If you access more than one field from the same value you
--   should use <a>pletFields</a> instead, which will generate the bindings
--   more efficiently.</li>
--   </ul>
pfield :: forall name b p s a as n. (PDataFields p, as ~ PFields p, n ~ PLabelIndex name as, KnownNat n, a ~ PUnLabel (IndexList n as), PFromDataable a b) => Term s (p :--> b)
class BindFields (ps :: [PLabeledType]) (bs :: [ToBind])

-- | Bind all the fields in a <tt>PDataList</tt> term to a corresponding
--   HList of Terms.
--   
--   A continuation is returned to enable sharing of the generated
--   bound-variables.
bindFields :: BindFields ps bs => Proxy bs -> Term s (PDataRecord ps) -> TermCont s (HRec (BoundTerms ps bs s))

-- | Map <a>BindField</a> over <tt>[PLabeledType]</tt>, with <tt>Skips</tt>
--   removed at tail
type family Bindings (ps :: [PLabeledType]) (fs :: [Symbol]) :: [ToBind]

-- | Get the <a>Term</a> representations to be bound based on the result of
--   <a>Bindings</a>.
type family BoundTerms ps bs s

-- | Drop first n fields of a list
type family Drop (n :: Nat) (as :: [k]) :: [k]

-- | The <a>HRec</a> yielded by 'pletFields @fs t'.
type HRecOf t fs s = HRec (BoundTerms (PFields t) (Bindings (PFields t) fs) s)

-- | Constrain an <a>HRec</a> to contain the specified fields from the
--   given Plutarch type.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   import qualified GHC.Generics as GHC
--   import Generics.SOP
--   
--   import Plutarch.Prelude
--   import Plutarch.DataRepr
--   
--   newtype PFooType s = PFooType (Term s (PDataRecord '["frst" ':= PInteger, "scnd" ':= PBool, "thrd" ':= PString]))
--     deriving stock (GHC.Generic)
--     deriving anyclass (Generic)
--     deriving anyclass (PIsDataRepr)
--     deriving
--       (PlutusType, PIsData, PDataFields, PEq)
--       via PIsDataReprInstances PFooType
--   
--   foo :: PMemberFields PFooType '["scnd", "frst"] s as =&gt; HRec as -&gt; Term s PInteger
--   foo h = pif (getField <tt>"scnd" h) (getField </tt>"frst" h) 0
--   </pre>
type family PMemberFields t fs s as

-- | Single field version of <a>PMemberFields</a>.
type family PMemberField t name s as
data HRec as
[HNil] :: HRec '[]
[HCons] :: Labeled name a -> HRec as -> HRec ('(name, a) ': as)
newtype Labeled sym a
Labeled :: a -> Labeled sym a
[$sel:unLabeled:Labeled] :: Labeled sym a -> a

-- | Index a <a>HRec</a> with a field in a provided list of data fields.
--   Implicitly unwraps `PAsData a` to <tt>a</tt> when necessary.
--   
--   <pre>
--   &gt;&gt;&gt; xs = HRec @["x", "y", "z"] (HCons 1 (HCons 2 (HCons 3 HNil)))
--   
--   &gt;&gt;&gt; hrecField @"y" @["x", "y", "z"] xs
--   
--   &gt;&gt;&gt; 2
--   </pre>

-- | <i>Deprecated: please use getField from GHC.Records</i>
hrecField :: forall name c as a b s. (ElemOf name a as, Term s (PAsData b) ~ a, PFromDataable b c) => HRec as -> Term s c
instance forall (l :: GHC.Types.Symbol) (p :: Plutarch.Internal.Term.S -> GHC.Types.Type) (ps :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType (l 'Plutarch.DataRepr.Internal.:= p) ps) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Bind ('[] @Plutarch.DataRepr.Internal.Field.ToBind))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (l :: GHC.Types.Symbol) (p :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType (l 'Plutarch.DataRepr.Internal.:= p) ps) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Bind bs)
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ps) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs)
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ps)) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType) (p3 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ((':) @Plutarch.DataRepr.Internal.PLabeledType p3 ps))) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs)))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType) (p3 :: Plutarch.DataRepr.Internal.PLabeledType) (p4 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ((':) @Plutarch.DataRepr.Internal.PLabeledType p3 ((':) @Plutarch.DataRepr.Internal.PLabeledType p4 ps)))) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs))))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType) (p3 :: Plutarch.DataRepr.Internal.PLabeledType) (p4 :: Plutarch.DataRepr.Internal.PLabeledType) (p5 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ((':) @Plutarch.DataRepr.Internal.PLabeledType p3 ((':) @Plutarch.DataRepr.Internal.PLabeledType p4 ((':) @Plutarch.DataRepr.Internal.PLabeledType p5 ps))))) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs)))))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType) (p3 :: Plutarch.DataRepr.Internal.PLabeledType) (p4 :: Plutarch.DataRepr.Internal.PLabeledType) (p5 :: Plutarch.DataRepr.Internal.PLabeledType) (p6 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ((':) @Plutarch.DataRepr.Internal.PLabeledType p3 ((':) @Plutarch.DataRepr.Internal.PLabeledType p4 ((':) @Plutarch.DataRepr.Internal.PLabeledType p5 ((':) @Plutarch.DataRepr.Internal.PLabeledType p6 ps)))))) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs))))))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType) (p3 :: Plutarch.DataRepr.Internal.PLabeledType) (p4 :: Plutarch.DataRepr.Internal.PLabeledType) (p5 :: Plutarch.DataRepr.Internal.PLabeledType) (p6 :: Plutarch.DataRepr.Internal.PLabeledType) (p7 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ((':) @Plutarch.DataRepr.Internal.PLabeledType p3 ((':) @Plutarch.DataRepr.Internal.PLabeledType p4 ((':) @Plutarch.DataRepr.Internal.PLabeledType p5 ((':) @Plutarch.DataRepr.Internal.PLabeledType p6 ((':) @Plutarch.DataRepr.Internal.PLabeledType p7 ps))))))) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs)))))))
instance forall (as :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.DataRepr.Internal.PDataRecord as)
instance forall (as :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.DataRepr.Internal.PDataSum ((':) @[Plutarch.DataRepr.Internal.PLabeledType] as ('[] @[Plutarch.DataRepr.Internal.PLabeledType])))
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.IsData.PIsData a, Plutarch.DataRepr.Internal.Field.PDataFields a) => Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.Builtin.Data.PAsData a)

module Plutarch.DataRepr

-- | A sum of <a>PDataRecord</a>s. The underlying representation is the
--   <tt>Constr</tt> constructor, where the integer is the index of the
--   variant and the list is the record.
newtype PDataSum defs s
PDataSum :: NS (Compose (Term s) PDataRecord) defs -> PDataSum defs s

-- | If there is only a single variant, then we can safely extract it.
punDataSum :: Term s (PDataSum '[def] :--> PDataRecord def)

-- | Try getting the nth variant. Errs if it's another variant.
ptryIndexDataSum :: KnownNat n => Proxy n -> Term s (PDataSum (def ': defs) :--> PDataRecord (IndexList n (def ': defs)))
data DataReprHandlers (out :: S -> Type) (defs :: [[PLabeledType]]) (s :: S)
[DRHNil] :: DataReprHandlers out '[] s
[DRHCons] :: (Term s (PDataRecord def) -> Term s out) -> DataReprHandlers out defs s -> DataReprHandlers out (def ': defs) s

-- | A "record" of `exists a. PAsData a`. The underlying representation is
--   `PBuiltinList PData`.
data PDataRecord (as :: [PLabeledType]) (s :: S)
[PDCons] :: forall name_x x xs s. PUnLabel name_x ~ x => Term s (PAsData x) -> Term s (PDataRecord xs) -> PDataRecord (name_x ': xs) s
[PDNil] :: PDataRecord '[] s

-- | Cons a field to a data record.
--   
--   You can specify the label to associate with the field using type
--   applications-
--   
--   <pre>
--   foo :: Term s (PDataRecord '[ "fooField" ':= PByteString ])
--   foo = pdcons @"fooField" # pdata (phexByteStr "ab") # pdnil
--   </pre>
pdcons :: forall label a l s. Term s (PAsData a :--> (PDataRecord l :--> PDataRecord ((label ':= a) ': l)))

-- | An empty <a>PDataRecord</a>.
pdnil :: Term s (PDataRecord '[])
data PLabeledType
(:=) :: Symbol -> (S -> Type) -> PLabeledType

-- | Safely index a <a>PDataRecord</a>.
pindexDataRecord :: KnownNat n => Proxy n -> Term s (PDataRecord as) -> Term s (PAsData (PUnLabel (IndexList n as)))

-- | Safely drop the first n items of a <a>PDataRecord</a>.
pdropDataRecord :: KnownNat n => Proxy n -> Term s (PDataRecord xs) -> Term s (PDataRecord (Drop n xs))
data PlutusTypeData

-- | Class allowing <tt>letFields</tt> to work for a PType, usually via
--   <tt>PIsDataRepr</tt>, but is derived for some other types for
--   convenience.
class PDataFields (a :: S -> Type) where {
    
    -- | Fields in HRec bound by <tt>letFields</tt>
    type PFields a :: [PLabeledType];
    type PFields a = Helper (PInner a);
}

-- | Convert a Term to a <tt>PDataList</tt>
ptoFields :: PDataFields a => Term s a -> Term s (PDataRecord (PFields a))

-- | Convert a Term to a <tt>PDataList</tt>
ptoFields :: (PDataFields a, PDataFields (PInner a), PFields (PInner a) ~ PFields a) => Term s a -> Term s (PDataRecord (PFields a))

-- | Bind a HRec of named fields containing all the specified fields.
pletFields :: forall fs a s b ps bs. (PDataFields a, ps ~ PFields a, bs ~ Bindings ps fs, BindFields ps bs) => Term s a -> (HRecOf a fs s -> Term s b) -> Term s b

-- | Get a single field from a Term.
--   
--   <ul>
--   <li>NB*: If you access more than one field from the same value you
--   should use <a>pletFields</a> instead, which will generate the bindings
--   more efficiently.</li>
--   </ul>
pfield :: forall name b p s a as n. (PDataFields p, as ~ PFields p, n ~ PLabelIndex name as, KnownNat n, a ~ PUnLabel (IndexList n as), PFromDataable a b) => Term s (p :--> b)
data HRec as

-- | The <a>HRec</a> yielded by 'pletFields @fs t'.
type HRecOf t fs s = HRec (BoundTerms (PFields t) (Bindings (PFields t) fs) s)

-- | Constrain an <a>HRec</a> to contain the specified fields from the
--   given Plutarch type.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   import qualified GHC.Generics as GHC
--   import Generics.SOP
--   
--   import Plutarch.Prelude
--   import Plutarch.DataRepr
--   
--   newtype PFooType s = PFooType (Term s (PDataRecord '["frst" ':= PInteger, "scnd" ':= PBool, "thrd" ':= PString]))
--     deriving stock (GHC.Generic)
--     deriving anyclass (Generic)
--     deriving anyclass (PIsDataRepr)
--     deriving
--       (PlutusType, PIsData, PDataFields, PEq)
--       via PIsDataReprInstances PFooType
--   
--   foo :: PMemberFields PFooType '["scnd", "frst"] s as =&gt; HRec as -&gt; Term s PInteger
--   foo h = pif (getField <tt>"scnd" h) (getField </tt>"frst" h) 0
--   </pre>
type family PMemberFields t fs s as

-- | Single field version of <a>PMemberFields</a>.
type family PMemberField t name s as

module Plutarch.TermCont
hashOpenTerm :: Term s a -> TermCont s Dig
newtype TermCont :: forall (r :: PType). S -> Type -> Type
[TermCont] :: forall r s a. ((a -> Term s r) -> Term s r) -> TermCont @r s a
($sel:runTermCont:TermCont) :: TermCont @r s a -> (a -> Term s r) -> Term s r
unTermCont :: TermCont @a s (Term s a) -> Term s a
tcont :: ((a -> Term s r) -> Term s r) -> TermCont @r s a

-- | Given a term, and an integer tag, this function checks if the term
--   holds and <tt>PPlaceholder</tt> with the given integer tag.
pfindPlaceholder :: Integer -> Term s a -> TermCont s Bool

-- | Like <a>plet</a> but works in a <a>TermCont</a> monad
pletC :: Term s a -> TermCont s (Term s a)

-- | Like <a>pmatch</a> but works in a <a>TermCont</a> monad
pmatchC :: PlutusType a => Term s a -> TermCont s (a s)

-- | Like <a>pletFields</a> but works in a <a>TermCont</a> monad.
pletFieldsC :: forall fs a s b ps bs. (PDataFields a, ps ~ PFields a, bs ~ Bindings ps fs, BindFields ps bs) => Term s a -> TermCont @b s (HRec (BoundTerms ps bs s))

-- | Like <tt>ptrace</tt> but works in a <a>TermCont</a> monad.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   foo :: Term s PUnit
--   foo = unTermCont $ do
--     ptraceC "returning unit!"
--     pure $ pconstant ()
--   </pre>
ptraceC :: Term s PString -> TermCont s ()

-- | Trace a message and raise error if <tt>cond</tt> is false. Otherwise,
--   continue.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   onlyAllow42 :: Term s (PInteger :--&gt; PUnit)
--   onlyAllow42 = plam $ i -&gt; unTermCont $ do
--     pguardC "expected 42" $ i #== 42
--     pure $ pconstant ()
--   </pre>
pguardC :: Term s PString -> Term s PBool -> TermCont s ()

-- | Stop computation and return given term if <tt>cond</tt> is false.
--   Otherwise, continue.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   is42 :: Term s (PInteger :--&gt; PBool)
--   is42 = plam $ i -&gt; unTermCont $ do
--     pguardC' (pconstant False) $ i #== 42
--     pure $ pconstant True
--   </pre>
pguardC' :: Term s a -> Term s PBool -> TermCont @a s ()

-- | <a>TermCont</a> producing version of <a>ptryFrom</a>.
ptryFromC :: forall b r a s. PTryFrom a b => Term s a -> TermCont @r s (Term s b, Reduce (PTryFromExcess a b s))

-- | Escape with a particular value on expecting <a>PJust</a>. For use in
--   monadic context.
--   
--   @since WIP
pexpectJustC :: forall (a :: S -> Type) (r :: S -> Type) (s :: S). Term s r -> Term s (PMaybe a) -> TermCont @r s (Term s a)

module Plutarch.Repr.Tag

-- | @since WIP
newtype PTag (struct :: [S -> Type]) (s :: S)
PTag :: Term s PInteger -> PTag (struct :: [S -> Type]) (s :: S)

-- | @since WIP
[$sel:unPTag:PTag] :: PTag (struct :: [S -> Type]) (s :: S) -> Term s PInteger

-- | @since WIP
newtype DeriveAsTag (a :: S -> Type) s
DeriveAsTag :: a s -> DeriveAsTag (a :: S -> Type) s

-- | @since WIP
[$sel:unDeriveAsTag:DeriveAsTag] :: DeriveAsTag (a :: S -> Type) s -> a s

-- | @since WIP
newtype TagLiftHelper r struct
TagLiftHelper :: (Integer -> (SOP I struct -> r) -> r) -> TagLiftHelper r struct

-- | @since WIP
[$sel:unTagLiftHelper:TagLiftHelper] :: TagLiftHelper r struct -> Integer -> (SOP I struct -> r) -> r
instance forall (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Repr.Tag.PTag struct s)
instance forall (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Tag.PTag struct)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (struct :: [[GHC.Types.Type]]). (forall (s :: Plutarch.Internal.Term.S). Plutarch.Repr.Tag.TagTypeConstraints @{Plutarch.Internal.Term.S} s a struct) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Tag.DeriveAsTag a)
instance forall k (a :: k -> GHC.Types.Type) (s :: k) (struct :: [[GHC.Types.Type]]). (Generics.SOP.Universe.Generic (a s), Plutarch.Repr.Tag.TagTypePrettyError (Generics.SOP.Universe.Code (a s)), (Generics.SOP.Universe.Code (a s) :: [[GHC.Types.Type]]) GHC.Types.~ (struct :: [[GHC.Types.Type]]), Data.SOP.Constraint.All @[GHC.Types.Type] (Plutarch.Repr.Tag.IsEmpty @GHC.Types.Type) struct) => Plutarch.Repr.Tag.TagTypeConstraints @{k} s a struct
instance forall k1 k2 (x :: [k1]). ((x :: [k1]) GHC.Types.~ ('[] @k1 :: [k1])) => Plutarch.Repr.Tag.IsEmpty @k2 ('[] @k2)
instance forall (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]) (s :: Plutarch.Internal.Term.S). Generics.SOP.Universe.Generic (Plutarch.Repr.Tag.PTag struct s)

module Plutarch.Repr.Data
class (PInnerMostIsData' a (PInnerMost a), PInnerMost a ~ PData) => PInnerMostIsData a

-- | @since WIP
newtype PDataStruct (struct :: [[S -> Type]]) (s :: S)
PDataStruct :: PStruct struct s -> PDataStruct (struct :: [[S -> Type]]) (s :: S)
[$sel:unPDataStruct:PDataStruct] :: PDataStruct (struct :: [[S -> Type]]) (s :: S) -> PStruct struct s

-- | @since WIP
newtype PDataRec (struct :: [S -> Type]) (s :: S)
PDataRec :: PRec struct s -> PDataRec (struct :: [S -> Type]) (s :: S)
[$sel:unPDataRec:PDataRec] :: PDataRec (struct :: [S -> Type]) (s :: S) -> PRec struct s

-- | @since WIP
newtype DeriveAsDataRec (a :: S -> Type) s
DeriveAsDataRec :: a s -> DeriveAsDataRec (a :: S -> Type) s
[$sel:unDeriveAsDataRec:DeriveAsDataRec] :: DeriveAsDataRec (a :: S -> Type) s -> a s

-- | @since WIP
newtype DeriveAsDataStruct (a :: S -> Type) s
DeriveAsDataStruct :: a s -> DeriveAsDataStruct (a :: S -> Type) s
[$sel:unDeriveAsDataStruct:DeriveAsDataStruct] :: DeriveAsDataStruct (a :: S -> Type) s -> a s
type PInnerMost a = PInnerMost' (PInner a) a
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). (Generics.SOP.Universe.Generic (a (GHC.Types.Any @Plutarch.Internal.Term.S)), (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]) GHC.Types.~ (Plutarch.Repr.Internal.UnTermStruct (a (GHC.Types.Any @Plutarch.Internal.Term.S)) :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]), Data.SOP.Constraint.All2 @{Plutarch.Internal.Term.PType} Plutarch.Repr.Data.PInnerMostIsData struct, Data.SOP.Constraint.SListI2 @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct, forall (s :: Plutarch.Internal.Term.S). Plutarch.Repr.Internal.StructSameRepr @{[[Plutarch.Internal.Term.S -> GHC.Types.Type]]} s a struct) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Data.DeriveAsDataStruct a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (struct' :: [GHC.Types.Type]) (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]). (Generics.SOP.Universe.Generic (a (GHC.Types.Any @Plutarch.Internal.Term.S)), ((':) @[GHC.Types.Type] struct' ('[] @[GHC.Types.Type]) :: [[GHC.Types.Type]]) GHC.Types.~ (Generics.SOP.Universe.Code (a (GHC.Types.Any @Plutarch.Internal.Term.S)) :: [[GHC.Types.Type]]), (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]) GHC.Types.~ (Plutarch.Repr.Internal.UnTermRec struct' :: [Plutarch.Internal.Term.S -> GHC.Types.Type]), Data.SOP.Constraint.All @Plutarch.Internal.Term.PType Plutarch.Repr.Data.PInnerMostIsData struct, Data.SOP.Constraint.SListI @{Plutarch.Internal.Term.S -> GHC.Types.Type} struct, forall (s :: Plutarch.Internal.Term.S). Plutarch.Repr.Internal.StructSameRepr @{[[Plutarch.Internal.Term.S -> GHC.Types.Type]]} s a ((':) @[Plutarch.Internal.Term.S -> GHC.Types.Type] struct ('[] @[Plutarch.Internal.Term.S -> GHC.Types.Type])), Plutarch.Repr.Internal.RecTypePrettyError @{GHC.Types.Type} (Generics.SOP.Universe.Code (a (GHC.Types.Any @Plutarch.Internal.Term.S)))) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Data.DeriveAsDataRec a)
instance forall (struct :: [Plutarch.Internal.Term.PType]). (Data.SOP.Constraint.SListI @{Plutarch.Internal.Term.PType} struct, Data.SOP.Constraint.All @Plutarch.Internal.Term.PType Plutarch.Repr.Data.PInnerMostIsData struct) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Data.PDataRec struct)
instance forall (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]). Plutarch.Internal.Eq.PEq (Plutarch.Repr.Data.PDataRec struct)
instance forall (struct :: [Plutarch.Internal.Term.S -> GHC.Types.Type]). Plutarch.Internal.IsData.PIsData (Plutarch.Repr.Data.PDataRec struct)
instance forall (struct :: [[Plutarch.Internal.Term.PType]]). (Data.SOP.Constraint.SListI2 @{Plutarch.Internal.Term.PType} struct, Data.SOP.Constraint.All2 @{Plutarch.Internal.Term.PType} Plutarch.Repr.Data.PInnerMostIsData struct) => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Repr.Data.PDataStruct struct)
instance forall (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). Plutarch.Internal.Eq.PEq (Plutarch.Repr.Data.PDataStruct struct)
instance forall (struct :: [[Plutarch.Internal.Term.S -> GHC.Types.Type]]). Plutarch.Internal.IsData.PIsData (Plutarch.Repr.Data.PDataStruct struct)
instance forall (a :: Plutarch.Internal.Term.PType). (Plutarch.Repr.Data.PInnerMostIsData' @{Plutarch.Internal.Term.PType} a (Plutarch.Repr.Data.PInnerMost a), (Plutarch.Repr.Data.PInnerMost a :: (Plutarch.Internal.Term.S -> GHC.Types.Type)) GHC.Types.~ (Plutarch.Builtin.Data.PData :: (Plutarch.Internal.Term.S -> GHC.Types.Type))) => Plutarch.Repr.Data.PInnerMostIsData a

module Plutarch.Builtin.Crypto

-- | Hash a <a>PByteString</a> using SHA-256.
psha2_256 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using SHA3-256.
psha3_256 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using Blake2B-224.
pblake2b_224 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using Blake2B-256.
pblake2b_256 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using Keccak-256.
pkeccak_256 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using Ripemd_160.
pripemd_160 :: Term s (PByteString :--> PByteString)

-- | Verify the signature against the public key and message.

-- | <i>Deprecated: use one of the Ed25519, Schnorr- or ECDSA Secp256k1
--   signature verification functions</i>
pverifySignature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))

-- | Verify an ED25519 signature arguments are in this order: pubkey,
--   message, signature
pverifyEd25519Signature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))

-- | Verify an ECDSA SECP256k1 signature arguments are in this order:
--   pubkey, message, signature
pverifyEcdsaSecp256k1Signature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))

-- | Verify a Schnorr SECP256k1 signature arguments are in this order:
--   pubkey, message, signature
pverifySchnorrSecp256k1Signature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))

module Plutarch.Builtin

newtype PDataNewtype (a :: S -> Type) (s :: S)
PDataNewtype :: Term s (PAsData a) -> PDataNewtype (a :: S -> Type) (s :: S)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Builtin.PDataNewtype a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.PDataNewtype a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.IsData.PIsData (Plutarch.Builtin.PDataNewtype a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Eq.PEq (Plutarch.Builtin.PDataNewtype a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.IsData.PIsData a, Plutarch.Internal.Ord.POrd a) => Plutarch.Internal.Ord.POrd (Plutarch.Builtin.PDataNewtype a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.IsData.PIsData a, Plutarch.Internal.Show.PShow a) => Plutarch.Internal.Show.PShow (Plutarch.Builtin.PDataNewtype a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.IsData.PIsData a, Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData a)) => Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.PDataNewtype a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.TryFrom.PTryFrom Plutarch.Builtin.Data.PData (Plutarch.Builtin.Data.PAsData (Plutarch.Builtin.PDataNewtype a))

module Plutarch.Prelude

newtype PDataNewtype (a :: S -> Type) (s :: S)
PDataNewtype :: Term s (PAsData a) -> PDataNewtype (a :: S -> Type) (s :: S)

-- | Builtin Plutus boolean.
--   
--   @since WIP
data PBool (s :: S)
PTrue :: PBool (s :: S)
PFalse :: PBool (s :: S)

-- | As <a>pand</a>, but strict.
--   
--   @since WIP
pand' :: forall (s :: S). Term s (PBool :--> (PBool :--> PBool))

-- | Essentially multi-way <a>pif</a>. More precisely, given a list of
--   condition-action pairs, and an 'action of last resort', construct a
--   left-to-right 'chain' of <tt>pif</tt>s, using the conditions to
--   determine which action gets taken. The 'action of last resort'
--   finishes the 'chain'. For example:
--   
--   <pre>
--   pcond [(cond1, act1), (cond2, act2)] act3
--   </pre>
--   
--   does the same thing as
--   
--   <pre>
--   pif cond1 act1 (pif cond2 act2 act3)
--   </pre>
--   
--   @since WIP
pcond :: forall (a :: S -> Type) (s :: S). [(Term s PBool, Term s a)] -> Term s a -> Term s a

-- | Lazy if-then-else.
--   
--   @since WIP
pif :: forall (a :: S -> Type) (s :: S). Term s PBool -> Term s a -> Term s a -> Term s a

-- | Strict if-then-else. Emits slightly less code than the lazy version.
--   
--   @since WIP
pif' :: forall (a :: S -> Type) (s :: S). Term s (PBool :--> (a :--> (a :--> a)))

-- | Boolean negation.
--   
--   @since WIP
pnot :: forall (s :: S). Term s (PBool :--> PBool)

-- | As <a>por</a>, but strict.
--   
--   @since WIP
por' :: Term s (PBool :--> (PBool :--> PBool))

-- | Lazy AND for terms.
--   
--   @since WIP
(#&&) :: forall (s :: S). Term s PBool -> Term s PBool -> Term s PBool
infixr 3 #&&

-- | Lazy OR for terms.
--   
--   @since WIP
(#||) :: forall (s :: S). Term s PBool -> Term s PBool -> Term s PBool
infixr 2 #||

-- | A Plutarch-level representation of bytes.
--   
--   <h1>Note =</h1>
--   
--   This type is intentionally quite restrictive, as it's not really meant
--   to be computed with. Instead, it ensures certain operations' type
--   safety while also allowing more sensible signatures. If you want to do
--   anything with <a>PByte</a>s, we recommend converting them to
--   <a>PInteger</a>s first.
--   
--   @since WIP
data PByte (s :: S)

-- | Plutus <tt>BuiltinByteString</tt>
data PByteString s

-- | Type designating whether logical operations should use padding or
--   truncation semantics. See <a>CIP-122</a> for more details on this.
--   
--   @since WIP
data PLogicOpSemantics (s :: S)

-- | Perform the logical AND of two <a>PByteString</a>s, as per
--   <a>CIP-122</a>. The <a>PLogicOpSemantics</a> argument specifies what
--   should be done if the lengths of the two <a>PByteString</a> arguments
--   do not match.
--   
--   @since WIP
pandBS :: forall (s :: S). Term s (PLogicOpSemantics :--> (PByteString :--> (PByteString :--> PByteString)))

-- | Convert a <a>PByte</a> into its corresponding <a>PInteger</a>.
--   
--   @since WIP
pbyteToInteger :: Term s (PByte :--> PInteger)

-- | Perform the logical complement of a <a>PByteString</a>, as per
--   <a>CIP-122</a>.
--   
--   @since WIP
pcomplementBS :: forall (s :: S). Term s (PByteString :--> PByteString)

-- | Prepend a <a>PByte</a> to a 'PByteString.
--   
--   @since WIP
pconsBS :: Term s (PByte :--> (PByteString :--> PByteString))

-- | Interpret a hex string as a PByteString.
phexByteStr :: HasCallStack => String -> Term s PByteString

-- | Given a valid index into a <a>PByteString</a>, returns the
--   <a>PByte</a> at that index. Will crash if given an out-of-bounds
--   index.
--   
--   @since WIP
pindexBS :: Term s (PByteString :--> (PInteger :--> PByte))

-- | Try to convert a <a>PInteger</a> into its corresponding <a>PByte</a>.
--   This operation unchecked: use with care.
--   
--   @since WIP
pintegerToByte :: Term s (PInteger :--> PByte)

-- | Find the length of a <a>PByteString</a>.
plengthBS :: Term s (PByteString :--> PInteger)

-- | Perform the logical OR of two <a>PByteString</a>s, as per
--   <a>CIP-122</a>. The <a>PLogicOpSemantics</a> argument specifies what
--   should be done if the lengths of the two <a>PByteString</a> arguments
--   do not match.
--   
--   @since WIP
porBS :: forall (s :: S). Term s (PLogicOpSemantics :--> (PByteString :--> (PByteString :--> PByteString)))

-- | Indicates that padding semantics should be used.
--   
--   @since WIP
ppadding :: forall (s :: S). Term s PLogicOpSemantics

-- | Given a desired length and a <a>PByte</a>, construct a
--   <a>PByteString</a> of the specified length (0 if negative) consisting
--   entirely of that <a>PByte</a>.
--   
--   @since WIP
preplicateBS :: forall (s :: S). Term s (PInteger :--> (PByte :--> PByteString))

-- | Slice a <a>PByteString</a> with given start index and slice length.
--   
--   <pre>
--   &gt;&gt;&gt; (pslice # 2 # 3 phexByteStr "4102afde5b2a") #== phexByteStr "afde5b"
--   </pre>
psliceBS :: Term s (PInteger :--> (PInteger :--> (PByteString :--> PByteString)))

-- | Indicates that truncation semantics should be used.
--   
--   @since WIP
ptruncation :: forall (s :: S). Term s PLogicOpSemantics

-- | Perform the logical XOR of two <a>PByteString</a>s, as per
--   <a>CIP-122</a>. The <a>PLogicOpSemantics</a> argument specifies what
--   should be done if the lengths of the two <a>PByteString</a> arguments
--   do not match.
--   
--   @since WIP
pxorBS :: forall (s :: S). Term s (PLogicOpSemantics :--> (PByteString :--> (PByteString :--> PByteString)))

-- | Hash a <a>PByteString</a> using SHA-256.
psha2_256 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using SHA3-256.
psha3_256 :: Term s (PByteString :--> PByteString)

-- | Verify the signature against the public key and message.

-- | <i>Deprecated: use one of the Ed25519, Schnorr- or ECDSA Secp256k1
--   signature verification functions</i>
pverifySignature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))
newtype PAsData (a :: S -> Type) (s :: S)
PAsData :: Term s a -> PAsData (a :: S -> Type) (s :: S)

-- | Plutus <tt>BuiltinList</tt>
data PBuiltinList (a :: S -> Type) (s :: S)
PCons :: Term s a -> Term s (PBuiltinList a) -> PBuiltinList (a :: S -> Type) (s :: S)
PNil :: PBuiltinList (a :: S -> Type) (s :: S)
newtype PBuiltinPair (a :: S -> Type) (b :: S -> Type) (s :: S)
PBuiltinPair :: Term s (PBuiltinPair a b) -> PBuiltinPair (a :: S -> Type) (b :: S -> Type) (s :: S)
newtype PData (s :: S)
PData :: Term s PData -> PData (s :: S)
pasByteStr :: Term s (PData :--> PByteString)
pasConstr :: Term s (PData :--> PBuiltinPair PInteger (PBuiltinList PData))
pasInt :: Term s (PData :--> PInteger)
pasList :: Term s (PData :--> PBuiltinList PData)
pasMap :: Term s (PData :--> PBuiltinList (PBuiltinPair PData PData))
pchooseData :: Term s (PData :--> (a :--> (a :--> (a :--> (a :--> (a :--> a))))))
pchooseListBuiltin :: Term s (PBuiltinList a :--> (b :--> (b :--> b)))
pconsBuiltin :: Term s (a :--> (PBuiltinList a :--> PBuiltinList a))
pconstrBuiltin :: Term s (PInteger :--> (PBuiltinList PData :--> PAsData (PBuiltinPair PInteger (PBuiltinList PData))))
pfstBuiltin :: Term s (PBuiltinPair a b :--> a)
pheadBuiltin :: Term s (PBuiltinList a :--> a)
plistData :: Term s (PBuiltinList PData :--> PData)
pnullBuiltin :: Term s (PBuiltinList a :--> PBool)

-- | Construct a builtin pair of <a>PData</a> elements.
--   
--   Uses <a>PAsData</a> to preserve more information about the underlying
--   <a>PData</a>.
ppairDataBuiltin :: Term s (PAsData a :--> (PAsData b :--> PBuiltinPair (PAsData a) (PAsData b)))

-- | Serialise any builtin data to its cbor represented by a builtin
--   bytestring
pserialiseData :: Term s (PData :--> PByteString)
psndBuiltin :: Term s (PBuiltinPair a b :--> b)
ptailBuiltin :: Term s (PBuiltinList a :--> PBuiltinList a)

-- | A builtin Plutus integer.
--   
--   @since WIP
data PInteger s

-- | An Arbitrary Term with an unknown type
newtype POpaque s
POpaque :: Term s POpaque -> POpaque s

-- | Erase the type of a Term
popaque :: Term s a -> Term s POpaque

-- | Plutus <tt>BuiltinString</tt> values
data PString s

-- | Decode a <a>PByteString</a> using UTF-8.
pdecodeUtf8 :: Term s (PByteString :--> PString)

-- | Encode a <a>PString</a> using UTF-8.
pencodeUtf8 :: Term s (PString :--> PByteString)
data PUnit (s :: S)
PUnit :: PUnit (s :: S)

-- | Class allowing <tt>letFields</tt> to work for a PType, usually via
--   <tt>PIsDataRepr</tt>, but is derived for some other types for
--   convenience.
class PDataFields (a :: S -> Type)

-- | A "record" of `exists a. PAsData a`. The underlying representation is
--   `PBuiltinList PData`.
data PDataRecord (as :: [PLabeledType]) (s :: S)

-- | A sum of <a>PDataRecord</a>s. The underlying representation is the
--   <tt>Constr</tt> constructor, where the integer is the index of the
--   variant and the list is the record.
data PDataSum defs s
data PLabeledType
(:=) :: Symbol -> (S -> Type) -> PLabeledType
data PlutusTypeData

-- | Cons a field to a data record.
--   
--   You can specify the label to associate with the field using type
--   applications-
--   
--   <pre>
--   foo :: Term s (PDataRecord '[ "fooField" ':= PByteString ])
--   foo = pdcons @"fooField" # pdata (phexByteStr "ab") # pdnil
--   </pre>
pdcons :: forall label a l s. Term s (PAsData a :--> (PDataRecord l :--> PDataRecord ((label ':= a) ': l)))

-- | An empty <a>PDataRecord</a>.
pdnil :: Term s (PDataRecord '[])

-- | Get a single field from a Term.
--   
--   <ul>
--   <li>NB*: If you access more than one field from the same value you
--   should use <a>pletFields</a> instead, which will generate the bindings
--   more efficiently.</li>
--   </ul>
pfield :: forall name b p s a as n. (PDataFields p, as ~ PFields p, n ~ PLabelIndex name as, KnownNat n, a ~ PUnLabel (IndexList n as), PFromDataable a b) => Term s (p :--> b)

-- | Bind a HRec of named fields containing all the specified fields.
pletFields :: forall fs a s b ps bs. (PDataFields a, ps ~ PFields a, bs ~ Bindings ps fs, BindFields ps bs) => Term s a -> (HRecOf a fs s -> Term s b) -> Term s b

-- | SOP-encoded <a>Either</a>.
--   
--   @since WIP
data PEither (a :: S -> Type) (b :: S -> Type) (s :: S)
PLeft :: Term s a -> PEither (a :: S -> Type) (b :: S -> Type) (s :: S)
PRight :: Term s b -> PEither (a :: S -> Type) (b :: S -> Type) (s :: S)

-- | A notion of 'next' value. More formally, instances of this type class
--   are discrete linear orders with no maximal element.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><pre>x /= psuccessor x</pre></li>
--   <li><tt>y &lt; x</tt> <tt>=</tt> <tt>psuccessor y &lt;= x</tt></li>
--   <li><tt>x &lt; psuccessor y</tt> <tt>=</tt> <tt>x &lt;= y</tt></li>
--   </ol>
--   
--   If you define <a>psuccessorN</a>, you must also ensure the following
--   hold; the default implementation ensures this.
--   
--   <ol>
--   <li><tt>psuccessorN 1</tt> <tt>=</tt> <tt>psuccessor</tt></li>
--   <li><tt>psuccessorN n . psuccessorN m</tt> <tt>=</tt> <tt>psuccessorN
--   (n + m)</tt></li>
--   </ol>
--   
--   Law 1 ensures no value is its own successor. Laws 2 and 3 ensure that
--   there are no 'gaps': every value is 'reachable' from any lower value
--   by a finite number of applications of <tt>successor</tt>.
--   
--   @since WIP
class POrd a => PCountable (a :: S -> Type)

-- | @since WIP
psuccessor :: forall (s :: S). PCountable a => Term s (a :--> a)

-- | The default implementation of this function is inefficient: if at all
--   possible, give instances an optimized version that doesn't require
--   recursion.
--   
--   @since WIP
psuccessorN :: forall (s :: S). PCountable a => Term s (PPositive :--> (a :--> a))

-- | Similar to <a>PCountable</a>, but has the ability to get a 'previous'
--   value as well. More formally, instances of this type class are
--   discrete linear orders with no maximal or minimal element.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>ppredecessor . psuccessor</tt> <tt>=</tt> <tt>psuccessor .
--   ppredecessor</tt> <tt>=</tt> <tt>id</tt></li>
--   </ol>
--   
--   If you define <a>ppredecessorN</a>, you must also ensure the following
--   hold; the default implementation ensures this.
--   
--   <ol>
--   <li><tt>ppredecessorN 1</tt> <tt>=</tt> <tt>ppredecessor</tt></li>
--   <li><tt>ppredecessorN n . ppredecessorN m</tt> <tt>=</tt>
--   <tt>ppredecessorN (n + m)</tt></li>
--   </ol>
--   
--   From Law 1, we obtain the following theorem:
--   
--   <ul>
--   <li><pre>x /= predecessor x</pre></li>
--   </ul>
--   
--   @since WIP
class PCountable a => PEnumerable (a :: S -> Type)

-- | @since WIP
ppredecessor :: forall (s :: S). PEnumerable a => Term s (a :--> a)

-- | The default implementation of this function is inefficient: if at all
--   possible, give instances an optimized version that doesn't require
--   recursion.
--   
--   @since WIP
ppredecessorN :: forall (s :: S). PEnumerable a => Term s (PPositive :--> (a :--> a))
class PEq t
(#==) :: PEq t => Term s t -> Term s t -> Term s PBool
(#==) :: (PEq t, PGeneric t, PlutusType t, All2 PEq (PCode t)) => Term s t -> Term s t -> Term s PBool
infix 4 #==

-- | Total ordering relation.
--   
--   <h1>Laws</h1>
--   
--   <a>#&lt;=</a> must form a total order. More precisely:
--   
--   <ol>
--   <li><tt>x #&lt;= x</tt> <tt>=</tt> <tt>pcon PTrue</tt>
--   (reflexivity)</li>
--   <li><tt>(y #&lt; x) #|| (z #&lt; y) #|| (x #&lt;= z)</tt> <tt>=</tt>
--   <tt>pcon PTrue</tt> (transitivity)</li>
--   <li><tt>(x #&lt;= y) #|| (y #&lt;= x)</tt> <tt>=</tt> <tt>pcon
--   PTrue</tt> (totality)</li>
--   </ol>
--   
--   Furthermore, <a>#&lt;</a> must be an equivalent strict total order to
--   <a>#&lt;=</a>:
--   
--   <ol>
--   <li><tt>x #&lt; x</tt> <tt>=</tt> <tt>pcon PFalse</tt>
--   (irreflexivity)</li>
--   <li><tt>(y #&lt;= x) #|| (z #&lt;= y) #|| (x #&lt; z)</tt> <tt>=</tt>
--   <tt>pcon PTrue</tt> (transitivity)</li>
--   <li><tt>(x #&lt; y) #|| (y #&lt; x) #|| (x #== z)</tt> <tt>=</tt>
--   <tt>pcon PTrue</tt> (trichotomy)</li>
--   <li><tt>x #&lt;= y</tt> <tt>=</tt> <tt>(x #&lt; y) #|| (x #== y)</tt>
--   (strict equivalence)</li>
--   </ol>
--   
--   If you define <a>pmax</a> or <a>pmin</a>, ensure the following also
--   hold:
--   
--   <ol>
--   <li><tt>pmax # x # y</tt> <tt>=</tt> <tt>pmax # y # x</tt>
--   (commutativity, also for @pmin)</li>
--   <li><tt>pmax # x #$ pmax y z</tt> <tt>=</tt> <tt>pmax # (pmax # x # y)
--   # z</tt> (associativity, also for @pmin)</li>
--   <li><tt>pmax # x #$ pmin # y # z</tt> <tt>=</tt> <tt>pmin # (pmax # x
--   # y) # (pmax # x # z)</tt> (<a>pmax</a> distributes over <a>pmin</a>,
--   also equivalent for <a>pmin</a>)</li>
--   <li><tt>pmin x y</tt> <tt>=</tt> <tt>pif' (x #&lt;= y) x y</tt></li>
--   <li><tt>pmax x y</tt> <tt>=</tt> <tt>pif' (x #&lt;= y) y x</tt></li>
--   </ol>
--   
--   Laws 8-12 hold if you use the defaults provided by this type class.
--   
--   @since WIP
class PEq t => POrd t

-- | @since WIP
(#<=) :: POrd t => Term s t -> Term s t -> Term s PBool

-- | @since WIP
(#<=) :: (POrd t, POrd (PInner t)) => Term s t -> Term s t -> Term s PBool

-- | @since WIP
(#<) :: POrd t => Term s t -> Term s t -> Term s PBool

-- | @since WIP
(#<) :: (POrd t, POrd (PInner t)) => Term s t -> Term s t -> Term s PBool

-- | @since WIP
pmax :: forall (s :: S). POrd t => Term s t -> Term s t -> Term s t

-- | @since WIP
pmin :: forall (s :: S). POrd t => Term s t -> Term s t -> Term s t
infix 4 #<=
infix 4 #<

-- | @since WIP
(#>) :: forall (a :: S -> Type) (s :: S). POrd a => Term s a -> Term s a -> Term s PBool
infix 4 #>

-- | @since WIP
(#>=) :: forall (a :: S -> Type) (s :: S). POrd a => Term s a -> Term s a -> Term s PBool
infix 4 #>=

-- | Fixpoint recursion. Used to encode recursive functions.
--   
--   Example:
--   
--   <pre>
--   iterateN' ::
--    Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a) -&gt;
--    Term s PInteger -&gt;
--    Term s (a :--&gt; a) -&gt;
--    Term s a
--   iterateN' self n f x =
--     pif (n #== 0) x (self # n - 1 #$ f x)
--   
--   iterateN :: Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a)
--   iterateN = pfix #$ plam iterateN'
--   </pre>
--   
--   Further examples can be found in examples/Recursion.hs
pfix :: Term s (((a :--> b) :--> (a :--> b)) :--> (a :--> b))

-- | Laws: - If <tt>PSubtype PData a</tt>, then <tt>pdataImpl a</tt> must
--   be <a>pupcast</a>. - pdataImpl . pupcast . pfromDataImpl  id -
--   pfromDataImpl . punsafeDowncast . pdataImpl  id
class PIsData a
pfromDataImpl :: PIsData a => Term s (PAsData a) -> Term s a
pfromDataImpl :: (PIsData a, PIsData (PInner a)) => Term s (PAsData a) -> Term s a
pdataImpl :: PIsData a => Term s a -> Term s PData
pdataImpl :: (PIsData a, PIsData (PInner a)) => Term s a -> Term s PData
pdata :: PIsData a => Term s a -> Term s (PAsData a)
pforgetData :: forall s a. Term s (PAsData a) -> Term s PData
pfromData :: PIsData a => Term s (PAsData a) -> Term s a

-- | Indicates that the given Plutarch type has an equivalent in Haskell
--   (and Plutus by extension), and we have the ability to move between
--   them.
--   
--   <h1>Important note</h1>
--   
--   Calling methods of <a>PLiftable</a> directly should rarely, if ever,
--   be a thing you do, unless defining your own instances without
--   <tt>via</tt>-deriving helpers (below). Prefer using <a>pconstant</a>
--   and <a>plift</a>, as these handle some of the oddities required
--   without you having to think about them.
--   
--   You should rarely, if ever, need to define <a>PLiftable</a> instances
--   by hand. Whenever possible, prefer using
--   <a>DeriveBuiltinPLiftable</a>, <a>DeriveDataPLiftable</a>, and
--   <a>DeriveNewtypePLiftable</a> as they have fewer complexities and
--   caveats. See their documentation for when to use them.
--   
--   If you do want to define the methods yourself, there's a few key
--   factors to keep in mind:
--   
--   <ol>
--   <li>You still shouldn't write every method by hand, there are helpers
--   <tt>plutToReprUni</tt> and <tt>reprToPlutUni</tt> to cover common
--   cases.</li>
--   <li>If defining <a>plutToRepr</a> and <a>reprToPlut</a> for Scott
--   encoded types you need to set <tt><a>PlutusRepr</a> PMyType =
--   <a>PLiftedClosed</a> PMyType</tt></li>
--   <li>When choosing a type for <a>AsHaskell</a>, <i>any</i> value of
--   that type <i>must</i> be representable in Plutarch. If you have
--   internal invariants to maintain on the Haskell side, make sure you do
--   so with great care.</li>
--   </ol>
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt><a>reprToHask</a> <a>.</a> <a>haskToRepr</a></tt> <tt>=</tt>
--   <tt><a>Right</a></tt></li>
--   <li><tt><a>plutToRepr</a> <a>.</a> <a>reprToPlut</a></tt> <tt>=</tt>
--   <tt><a>Right</a></tt></li>
--   </ol>
--   
--   Any derivations via <a>DeriveBuiltinPLiftable</a>,
--   <a>DeriveDataPLiftable</a>, and <a>DeriveNewtypePLiftable</a>
--   automatically follow these laws.
--   
--   Together, these imply <tt>plift . pconstant = id</tt>.
--   
--   @since WIP
class PlutusType a => PLiftable (a :: S -> Type) where {
    type AsHaskell a :: Type;
    type PlutusRepr a :: Type;
}

-- | Transform <tt>a</tt>'s Haskell equivalent to its Plutus universe
--   representation.
haskToRepr :: PLiftable a => AsHaskell a -> PlutusRepr a

-- | Given <tt>a</tt>'s Plutus universe representation, turn it back into
--   its (true) Haskell equivalent if possible.
reprToHask :: PLiftable a => PlutusRepr a -> Either LiftError (AsHaskell a)

-- | Given <tt>a</tt>'s Plutus universe representation, lift it into
--   Plutarch.
reprToPlut :: forall (s :: S). PLiftable a => PlutusRepr a -> PLifted s a

-- | Given a closed Plutarch term, evaluate it back into its Plutus
--   universe representation, or fail.
plutToRepr :: PLiftable a => (forall (s :: S). PLifted s a) -> Either LiftError (PlutusRepr a)

-- | <tt>via</tt>-deriving helper, indicating that <tt>a</tt> has a
--   Haskell-level equivalent <tt>h</tt> by way of its <tt>Data</tt>
--   encoding, rather than by <tt>h</tt> being directly part of the Plutus
--   default universe.
--   
--   @since WIP
data DeriveDataPLiftable (a :: S -> Type) (h :: Type) (s :: S)

-- | <tt>via</tt>-deriving helper, indicating that <tt>wrapper</tt> has a
--   Haskell-level equivalent <tt>h</tt> by way <tt>PInner wrapper</tt>, up
--   to coercibility.
--   
--   @since WIP
data DeriveNewtypePLiftable (wrapper :: S -> Type) (h :: Type) (s :: S)

-- | Similar to <tt>Identity</tt>, but at the level of Plutarch. Only
--   needed when writing manual instances of <a>PLiftable</a>, or if you
--   want to use <a>reprToPlut</a> and <a>plutToRepr</a> directly.
--   
--   This is used for coercing Plutarch terms at Haskell level with `coerce
--   :: PLifted s a -&gt; PLifted s b` for <tt>via</tt>-deriving helpers.
--   
--   @since WIP
newtype PLifted (s :: S) (a :: S -> Type)
PLifted :: Term s POpaque -> PLifted (s :: S) (a :: S -> Type)

-- | Valid definition of <a>reprToPlut</a> if <tt>PlutusRepr a</tt> is in
--   the Plutus universe.
--   
--   @since WIP
reprToPlutUni :: forall (a :: S -> Type) (s :: S). (PLiftable a, DefaultUni `Includes` PlutusRepr a) => PlutusRepr a -> PLifted s a

-- | Valid definition of <a>plutToRepr</a> if <tt>PlutusRepr a</tt> is in
--   the Plutus universe.
--   
--   @since WIP
plutToReprUni :: forall (a :: S -> Type). (PLiftable a, DefaultUni `Includes` PlutusRepr a) => (forall (s :: S). PLifted s a) -> Either LiftError (PlutusRepr a)

-- | Given a Haskell-level representation of a Plutarch term, transform it
--   into its equivalent term.
--   
--   @since WIP
pconstant :: forall (a :: S -> Type) (s :: S). PLiftable a => AsHaskell a -> Term s a

-- | Given a closed Plutarch term, compile and evaluate it, then produce
--   the corresponding Haskell value. If compilation or evaluation fails
--   somehow, this will call <a>error</a>: if you need to 'trap' these
--   outcomes and handle them differently somehow, use <a>reprToPlut</a>
--   and <a>reprToHask</a> manually.
--   
--   @since WIP
plift :: forall (a :: S -> Type). PLiftable a => (forall (s :: S). Term s a) -> AsHaskell a
type PElemConstraint list (a :: S -> Type) :: Constraint

-- | 'PIsListLike list a' constraints <tt>list</tt> be a <a>PListLike</a>
--   with valid element type, <tt>a</tt>.
type PIsListLike list a = (PListLike list, PElemConstraint list a)

-- | Plutarch types that behave like lists.
class PListLike (list :: (S -> Type) -> S -> Type)

-- | SOP-encoded list.
--   
--   @since WIP
data PList (a :: S -> Type) (s :: S)
PSCons :: Term s a -> Term s (PList a) -> PList (a :: S -> Type) (s :: S)
PSNil :: PList (a :: S -> Type) (s :: S)

-- | <i> O(n) </i>. Check if element is in the list
pelem :: (PIsListLike list a, PEq a) => Term s (a :--> (list a :--> PBool))

-- | <i> O(n) </i>. Like Haskell level <a>(!!)</a> but on the Plutarch
--   level, not infix and with arguments reversed, errors if the specified
--   index is greater than or equal to the lists length
pelemAt :: PIsListLike l a => Term s (PInteger :--> (l a :--> a))

-- | <i> O(n) </i>. like haskell level <tt>find</tt> but on plutarch level
pfind :: PIsListLike l a => Term s ((a :--> PBool) :--> (l a :--> PMaybe a))

-- | <i> O(min(n, m)) </i>. Check if two lists are equal.
plistEquals :: (PIsListLike list a, PEq a) => Term s (list a :--> (list a :--> PBool))

-- | Extract head and tail of the list, if list is not empty.
puncons :: PIsListLike list a => Term s (list a :--> PMaybe (PPair a (list a)))

-- | <i> O(min(n, m)) </i>. Zip two lists together, creating pairs of the
--   elements.
--   
--   If the lists are of differing lengths, cut to the shortest.
pzip :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list (PPair a b)) => Term s (list a :--> (list b :--> list (PPair a b)))

-- | <i> O(n) </i>. Like Haskell level <a>(!!)</a> but on the plutarch
--   level
(#!!) :: PIsListLike l a => Term s (l a) -> Term s PInteger -> Term s a

-- | <i> O(n) </i>. Check that predicate holds for all elements in a list.
pall :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> PBool))

-- | <i> O(n) </i>. Check that predicate holds for any element in a list.
pany :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> PBool))

-- | <i> O(n) </i>. Concatenate two lists
--   
--   Example: &gt; pconcat # psingleton x # psingleton y == plistLiteral
--   [x, y]
--   
--   pconcat exhibits identities with empty lists such that &gt; forall x.
--   pconcat # pnil # x == x &gt; forall x. pconcat # x # pnil == x
pconcat :: PIsListLike list a => Term s (list a :--> (list a :--> list a))

-- | Cons an element onto an existing list.
pcons :: (PListLike list, PElemConstraint list a) => Term s (a :--> (list a :--> list a))

-- | Drop the first n fields of a List.
--   
--   The term will be statically generated as repeated applications of
--   <a>ptail</a>, which will be more efficient in many circumstances.
pdrop :: PIsListLike list a => Natural -> Term s (list a) -> Term s (list a)

-- | Canonical eliminator for list-likes.
pelimList :: (PListLike list, PElemConstraint list a) => (Term s a -> Term s (list a) -> Term s r) -> Term s r -> Term s (list a) -> Term s r

-- | <i> O(n) </i>. Filter elements from a list that don't match the
--   predicate.
pfilter :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> list a))

-- | <i> O(n) </i>. Fold on a list left-associatively.
pfoldl :: PIsListLike list a => Term s ((b :--> (a :--> b)) :--> (b :--> (list a :--> b)))

-- | <i> O(n) </i>. Fold on a list right-associatively.
pfoldr :: PIsListLike list a => Term s ((a :--> (b :--> b)) :--> (b :--> (list a :--> b)))

-- | <i> O(n) </i>. Fold on a list right-associatively, with opportunity
--   for short circuting.
--   
--   May short circuit when given reducer function is lazy in its second
--   argument.
pfoldrLazy :: PIsListLike list a => Term s ((a :--> (PDelayed b :--> b)) :--> (b :--> (list a :--> b)))

-- | Return the first element of a list. Partial, throws an error upon
--   encountering an empty list.
phead :: (PListLike list, PElemConstraint list a) => Term s (list a :--> a)

-- | <i> O(n) </i>. Count the number of elements in the list
plength :: PIsListLike list a => Term s (list a :--> PInteger)

-- | <i> O(n) </i>. Map a function over a list of elements
pmap :: (PListLike list, PElemConstraint list a, PElemConstraint list b) => Term s ((a :--> b) :--> (list a :--> list b))

-- | The empty list
pnil :: (PListLike list, PElemConstraint list a) => Term s (list a)

-- | <i> O(1) </i>. Check if a list is empty
pnull :: (PListLike list, PElemConstraint list a) => Term s (list a :--> PBool)

-- | Like <a>pelimList</a>, but with a fixpoint recursion hatch.
precList :: PIsListLike list a => (Term s (list a :--> r) -> Term s a -> Term s (list a) -> Term s r) -> (Term s (list a :--> r) -> Term s r) -> Term s (list a :--> r)

-- | <i> O(1) </i>. Create a singleton list from an element
psingleton :: PIsListLike list a => Term s (a :--> list a)

-- | Take the tail of a list, meaning drop its head. Partial, throws an
--   error upon encountering an empty list.
ptail :: (PListLike list, PElemConstraint list a) => Term s (list a :--> list a)

-- | Index a BuiltinList, throwing an error if the index is out of bounds.
ptryIndex :: PIsListLike list a => Natural -> Term s (list a) -> Term s a

-- | <i> O(min(n, m)) </i>. Zip two lists together with a passed function.
--   
--   If the lists are of differing lengths, cut to the shortest.
pzipWith :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list c) => Term s ((a :--> (b :--> c)) :--> (list a :--> (list b :--> list c)))

-- | Like <a>pzipWith</a> but with Haskell-level merge function.
pzipWith' :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list c) => (Term s a -> Term s b -> Term s c) -> Term s (list a :--> (list b :--> list c))
class (PInner a ~ DerivedPInner (DPTStrat a) a, PlutusTypeStrat (DPTStrat a), PlutusTypeStratConstraint (DPTStrat a) a, PlutusType a) => DerivePlutusType (a :: PType) where {
    type DPTStrat a :: Type;
    type DPTStrat a = TypeError ('Text "Please specify a strategy for deriving PlutusType for type "
                                 ':<>: 'ShowType a);
}

-- | <i>Deprecated: Use PlutusType</i>
type PCon = PlutusType

-- | <i>Deprecated: Use PlutusType</i>
type PMatch = PlutusType
class PlutusType (a :: PType) where {
    type PInner a :: PType;
    type PInner a = DerivedPInner (DPTStrat a) a;
    type PCovariant' a = All2 PCovariant'' (PCode a);
    type PContravariant' a = All2 PContravariant'' (PCode a);
    type PVariant' a = All2 PVariant'' (PCode a);
}

-- | Construct a Plutarch Term via a Haskell datatype
pcon :: PlutusType a => a s -> Term s a

-- | Pattern match over Plutarch Terms via a Haskell datatype
pmatch :: PlutusType a => Term s a -> (a s -> Term s b) -> Term s b
data PlutusTypeNewtype
data PlutusTypeScott

-- | @since WIP
newtype DeriveNewtypePlutusType (a :: S -> Type) s
DeriveNewtypePlutusType :: a s -> DeriveNewtypePlutusType (a :: S -> Type) s

-- | This is a cursed derivation strategy that will give you
--   <tt>PlutusType</tt> with no questions asked. This is occasionally
--   helpful for deriving <tt>PlutusType</tt> for another derivation
--   strategy wrapper whose target instance requires <tt>PlutusType</tt> as
--   superclass.
--   
--   See <tt>PLiftable</tt>
newtype DeriveFakePlutusType (a :: S -> Type) (s :: S)
DeriveFakePlutusType :: a s -> DeriveFakePlutusType (a :: S -> Type) (s :: S)

-- | @since WIP
data Positive

-- | @since WIP
data PPositive (s :: S)

-- | @since WIP
data PNatural (s :: S)

-- | The addition operation, and the notion of scaling by a positive.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>x #+ y</tt> <tt>=</tt> <tt>y #+ x</tt> (commutativity of
--   <tt>#+</tt>)</li>
--   <li><tt>x #+ (y #+ z)</tt> <tt>=</tt> <tt>(x #+ y) #+ z</tt>
--   (associativity of <tt>#+</tt>)</li>
--   </ol>
--   
--   If you define a custom <tt>pscalePositive</tt>, ensure the following
--   also hold:
--   
--   <ol>
--   <li><tt>pscalePositive x pone</tt> <tt>=</tt> <tt>x</tt></li>
--   <li><tt>(pscalePositive x n) #+ (pscalePositive x m)</tt> <tt>=</tt>
--   <tt>pscalePositive x (n #+ m)</tt></li>
--   <li><tt>pscalePositive (pscalePositive x n) m</tt> <tt>=</tt>
--   <tt>pscalePositive x (n #* m)</tt></li>
--   </ol>
--   
--   The default implementation ensures these laws are satisfied.
--   
--   @since WIP
class PAdditiveSemigroup (a :: S -> Type)
(#+) :: forall (s :: S). PAdditiveSemigroup a => Term s a -> Term s a -> Term s a
(#+) :: forall (s :: S). (PAdditiveSemigroup a, PAdditiveSemigroup (PInner a)) => Term s a -> Term s a -> Term s a

-- | This defaults to exponentiation-by-squaring, which in general is the
--   best we can do.
pscalePositive :: forall (s :: S). PAdditiveSemigroup a => Term s a -> Term s PPositive -> Term s a
infix 6 #+

-- | The notion of zero, as well as a way to scale by naturals.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>pzero #+ x</tt> <tt>=</tt> <tt>x</tt> (<tt>pzero</tt> is the
--   identity of <tt>#+</tt>)</li>
--   <li><tt>pscalePositive pzero n</tt> <tt>=</tt> <tt>pzero</tt>
--   (<tt>pzero</tt> does not scale up)</li>
--   </ol>
--   
--   If you define <a>pscaleNatural</a>, ensure the following as well:
--   
--   <ol>
--   <li><tt>pscaleNatural x (ppositiveToNatural # p)</tt> <tt>=</tt>
--   <tt>pscalePositive x p</tt></li>
--   <li><tt>pscaleNatural x pzero</tt> <tt>=</tt> <tt>pzero</tt></li>
--   </ol>
--   
--   The default implementation of <a>pscaleNatural</a> ensures these laws
--   hold.
--   
--   @since WIP
class PAdditiveSemigroup a => PAdditiveMonoid (a :: S -> Type)
pzero :: forall (s :: S). PAdditiveMonoid a => Term s a
pscaleNatural :: forall (s :: S). PAdditiveMonoid a => Term s a -> Term s PNatural -> Term s a

-- | The notion of additive inverses, and the subtraction operation.
--   
--   <h1>Laws</h1>
--   
--   If you define <tt>pnegate</tt>, the following laws must hold:
--   
--   <ol>
--   <li><tt>(pnegate # x) #+ x</tt> <tt>=</tt> <tt>pzero</tt>
--   (<tt>pnegate</tt> is an additive inverse)</li>
--   <li><tt>pnegate #$ pnegate # x</tt> <tt>=</tt> <tt>x</tt>
--   (<tt>pnegate</tt> is self-inverting)</li>
--   </ol>
--   
--   If you define <tt>#-</tt>, the following law must hold:
--   
--   <ol>
--   <li><tt>x #- x</tt> <tt>=</tt> <tt>pzero</tt></li>
--   </ol>
--   
--   Additionally, the following 'consistency laws' must hold. Default
--   implementations of both <tt>pnegate</tt> and <tt>#-</tt> uphold these.
--   
--   <ol>
--   <li><tt>pnegate # x</tt> <tt>=</tt> <tt>pzero #- x</tt></li>
--   <li><tt>x #- y</tt> <tt>=</tt> <tt>x #+ (pnegate # y)</tt></li>
--   </ol>
--   
--   Lastly, if you define a custom <tt>pscaleInteger</tt>, the following
--   laws must hold:
--   
--   <ol>
--   <li><tt>pscaleInteger x pzero</tt> <tt>=</tt> <tt>pzero</tt></li>
--   <li><tt>pscaleInteger x (pnegate # y)</tt> <tt>=</tt> <tt>pnegate #
--   (pscaleInteger x y)</tt></li>
--   </ol>
--   
--   @since WIP
class PAdditiveMonoid a => PAdditiveGroup (a :: S -> Type)
pnegate :: forall (s :: S). PAdditiveGroup a => Term s (a :--> a)
(#-) :: forall (s :: S). PAdditiveGroup a => Term s a -> Term s a -> Term s a
pscaleInteger :: forall (s :: S). PAdditiveGroup a => Term s a -> Term s PInteger -> Term s a
infix 6 #-

-- | The multiplication operation.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>x #* (y #* z)</tt> <tt>=</tt> <tt>(x #* y) #* z</tt>
--   (associativity of <tt>#*</tt>)</li>
--   </ol>
--   
--   If you define a custom <tt>ppowPositive</tt>, ensure the following
--   also hold:
--   
--   <ol>
--   <li><tt>ppowPositive x pone</tt> <tt>=</tt> <tt>x</tt></li>
--   <li><tt>(ppowPositive x n) #* (ppowPositive x m)</tt> <tt>=</tt>
--   <tt>ppowPositive x (n #+ m)</tt></li>
--   <li><tt>ppowPositive (ppowPositive x n) m</tt> <tt>=</tt>
--   <tt>ppowPositive x (n #* m)</tt></li>
--   </ol>
--   
--   The default implementation ensures these laws are satisfied.
--   
--   <h1>Note</h1>
--   
--   Unlike <a>PAdditiveSemigroup</a>, the multiplication operation doesn't
--   need to be commutative. Currently, all Plutarch-provided instances
--   are, but this need not be true for other instances.
--   
--   @since WIP
class PMultiplicativeSemigroup (a :: S -> Type)
(#*) :: forall (s :: S). PMultiplicativeSemigroup a => Term s a -> Term s a -> Term s a
(#*) :: forall (s :: S). (PMultiplicativeSemigroup a, PMultiplicativeSemigroup (PInner a)) => Term s a -> Term s a -> Term s a
ppowPositive :: forall (s :: S). PMultiplicativeSemigroup a => Term s a -> Term s PPositive -> Term s a
infix 6 #*

-- | The notion of one (multiplicative identity), and exponentiation by -
--   naturals.
--   
--   <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>pone #* x</tt> <tt>=</tt> <tt>x</tt> (<tt>pone</tt> is the
--   left identity of <tt>#*</tt>)</li>
--   <li><tt>x #* pone</tt> <tt>=</tt> <tt>x</tt> (<tt>pone</tt> is the
--   right identity of <tt>#*</tt>)</li>
--   <li><tt>ppowPositive pone p</tt> <tt>=</tt> <tt>pone</tt>
--   (<tt>pone</tt> does not scale up)</li>
--   </ol>
--   
--   If you define <a>ppowNatural</a>, ensure the following as well:
--   
--   <ol>
--   <li><tt>ppowNatural x (ppositiveToNatural # p)</tt> <tt>=</tt>
--   <tt>ppowPositive x p</tt></li>
--   <li><tt>ppowNatural x pzero</tt> <tt>=</tt> <tt>pone</tt></li>
--   </ol>
--   
--   @since WIP
class PMultiplicativeSemigroup a => PMultiplicativeMonoid (a :: S -> Type)
pone :: forall (s :: S). PMultiplicativeMonoid a => Term s a
ppowNatural :: forall (s :: S). PMultiplicativeMonoid a => Term s a -> Term s PNatural -> Term s a

-- | <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>pfromInteger 0</tt> <tt>=</tt> <tt>pzero</tt></li>
--   <li><tt>pfromInteger 1</tt> <tt>=</tt> <tt>pone</tt></li>
--   <li><tt>pfromInteger (x + y)</tt> <tt>=</tt> <tt>pfromInteger x #+
--   pfromInteger y</tt></li>
--   <li><tt>pfromInteger (x * y)</tt> <tt>=</tt> <tt>pfromInteger x #*
--   pfromInteger y</tt></li>
--   </ol>
--   
--   Additionally, the following 'interaction laws' must hold between the
--   instances of <a>PAdditiveGroup</a> and <a>PMultiplicativeMonoid</a>
--   for <tt>a</tt>:
--   
--   <ol>
--   <li><tt>x #* (y #+ z)</tt> <tt>=</tt> <tt>(x #* y) #+ (x #* z)</tt>
--   (<tt>#*</tt> left-distributes over <tt>#+</tt>)</li>
--   <li><tt>(y #+ z) #* x</tt> <tt>=</tt> <tt>(y #* x) #+ (z #* x)</tt>
--   (<tt>#*</tt> right-distributes over <tt>#+</tt>)</li>
--   </ol>
--   
--   @since WIP
class (PAdditiveGroup a, PMultiplicativeMonoid a) => PRing (a :: S -> Type)
pfromInteger :: forall (s :: S). PRing a => Integer -> Term s a
pfromInteger :: forall (s :: S). (PRing a, PRing (PInner a)) => Integer -> Term s a

-- | <h1>Laws</h1>
--   
--   <h1>Pedantry note</h1>
--   
--   Technically, the requirements here are too strong: we demand an
--   <i>ordered</i> ring, which integral domains don't necessarily have to
--   be. However, in our case, our hand is forced by expected semantics: in
--   abstract algebra, both the absolute value and the signum are real
--   numbers (which are always totally ordered) but in our case, both must
--   be elements of the integral domain itself. Thus, in order for the laws
--   to make any sense, we have to ensure a total order on the integral
--   domain. Since all of our integral domains are 'at least as big' as the
--   integers, this doesn't pose a huge problem.
--   
--   @since WIP
class (PRing a, POrd a) => PIntegralDomain (a :: S -> Type)
psignum :: forall (s :: S). PIntegralDomain a => Term s (a :--> a)
psignum :: forall (s :: S). PIntegralDomain a => Term s (a :--> a)
pabs :: forall (s :: S). PIntegralDomain a => Term s (a :--> a)
pabs :: forall (s :: S). PIntegralDomain a => Term s (a :--> a)

-- | @since WIP
pquot :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))

-- | @since WIP
prem :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))

-- | @since WIP
pdiv :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))

-- | @since WIP
pmod :: forall (s :: S). Term s (PInteger :--> (PInteger :--> PInteger))

-- | Build a <a>PPositive</a> from a <a>PInteger</a>. Yields
--   <a>PNothing</a> if argument is not positive.
ppositive :: Term s (PInteger :--> PMaybe PPositive)

-- | Partial version of <a>ppositive</a>. Errors if argument is not
--   positive.
--   
--   @since WIP
ptryPositive :: forall (s :: S). Term s (PInteger :--> PPositive)

-- | Build a <a>PNatural</a> from a <a>PInteger</a>. Yields <a>PNothing</a>
--   if given a negative value.
--   
--   @since WIP
pnatural :: forall (s :: S). Term s (PInteger :--> PMaybe PNatural)

-- | Partial version of <a>pnatural</a>. Errors if argument is negative.
--   
--   @since WIP
ptryNatural :: forall (s :: S). Term s (PInteger :--> PNatural)

-- | 'Relax' a <a>PPositive</a> to <a>PNatural</a>. This uses
--   <a>punsafeCoerce</a> underneath, but because any positive is also a
--   natural, is safe.
--   
--   @since WIP
ppositiveToNatural :: forall (s :: S). Term s (PPositive :--> PNatural)

-- | Safely coerce from a Term to it's <a>PInner</a> representation.
pto :: Term s a -> Term s (PInner a)
pinl :: Term s a -> (Term s a -> Term s b) -> Term s b
plam :: forall c. (PLamN a b s, HasCallStack) => (Term s c -> a) -> Term s (c :--> b)
newtype PForall (b :: a -> PType) s
PForall :: (forall (x :: a). Term s (b x)) -> PForall (b :: a -> PType) s
class PShow t

-- | Return the string representation of a Plutarch value
pshow :: PShow a => Term s a -> Term s PString
data Term (s :: S) (a :: PType)
data S

-- | <ul>
--   <li>Closed* terms with no free variables.</li>
--   </ul>
type ClosedTerm (a :: PType) = forall (s :: S). Term s a
data PDelayed (a :: PType) (s :: S)

-- | Lambda Application.
papp :: Term s (a :--> b) -> Term s a -> Term s b

-- | Plutus 'delay', used for laziness.
pdelay :: Term s a -> Term s (PDelayed a)

-- | Plutus 'force', used to force evaluation of <a>PDelayed</a> terms.
pforce :: Term s (PDelayed a) -> Term s a

-- | Plutus 'error'.
--   
--   When using this explicitly, it should be ensured that the containing
--   term is delayed, avoiding premature evaluation.
perror :: Term s a
phoistAcyclic :: HasCallStack => ClosedTerm a -> Term s a

-- | Let bindings.
--   
--   This is approximately a shorthand for a lambda and application:
--   
--   <tt>plet v f</tt> == <tt> papp (plam f) v</tt>
--   
--   But sufficiently small terms in WHNF may be inlined for efficiency.
plet :: Term s a -> (Term s a -> Term s b) -> Term s b
pthrow :: HasCallStack => Text -> Term s a

-- | High precedence infixl synonym of <a>papp</a>, to be used like
--   function juxtaposition. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x # y
--   f x y
--   </pre>
(#) :: Term s (a :--> b) -> Term s a -> Term s b
infixl 8 #

-- | Low precedence infixr synonym of <a>papp</a>, to be used like
--   <a>$</a>, in combination with <a>#</a>. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x #$ g # y # z
--   f x (g y z)
--   </pre>
(#$) :: Term s (a :--> b) -> Term s a -> Term s b
infixr 0 #$
data (:-->) (a :: PType) (b :: PType) (s :: S)
infixr 0 :-->
type family PSubtype (a :: PType) (b :: PType) :: Constraint

-- | <tt>PTryFrom a b</tt> represents a subtyping relationship between
--   <tt>a</tt> and <tt>b</tt>, and a way to go from <tt>a</tt> to
--   <tt>b</tt>. Laws: - <tt>(punsafeCoerce . fst) <a>$</a> tcont (ptryFrom
--   x)  pure x</tt>
class PSubtype a b => PTryFrom (a :: PType) (b :: PType) where {
    type PTryFromExcess a b :: PType;
    type PTryFromExcess a b = PTryFromExcess a (PInner b);
}
ptryFrom' :: forall s r. PTryFrom a b => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r
ptryFrom' :: forall s r. (PTryFrom a b, PTryFrom a (PInner b), PTryFromExcess a b ~ PTryFromExcess a (PInner b)) => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r
ptryFrom :: forall b a s r. PTryFrom a b => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r
pupcast :: forall a b s. PSubtype a b => Term s b -> Term s a

-- | @since WIP
data PMaybe (a :: S -> Type) (s :: S)
PJust :: Term s a -> PMaybe (a :: S -> Type) (s :: S)
PNothing :: PMaybe (a :: S -> Type) (s :: S)

-- | Plutus encoding of Pairs.
--   
--   Note: This is represented differently than <tt>BuiltinPair</tt>. It is
--   SoP encoded.
data PPair (a :: S -> Type) (b :: S -> Type) (s :: S)
PPair :: Term s a -> Term s b -> PPair (a :: S -> Type) (b :: S -> Type) (s :: S)

-- | A Scott-encoded rational number, with a guaranteed positive
--   denominator (and thus, a canonical form).
--   
--   <h1>Note</h1>
--   
--   This is not the Plutarch equivalent of a Plutus <tt>Rational</tt>; for
--   this, you want <tt>PRationalData</tt> from
--   <tt>plutarch-ledger-api</tt>. <a>PRational</a> is designed to optimize
--   for computation: if you want to do any serious work with rational
--   numbers that isn't just passing them around, you want to use (or
--   convert to) <a>PRational</a>.
data PRational s
PRational :: Term s PInteger -> Term s PPositive -> PRational s
pdenominator :: Term s (PRational :--> PPositive)
pnumerator :: Term s (PRational :--> PInteger)
pround :: Term s (PRational :--> PInteger)
newtype TermCont :: forall (r :: PType). S -> Type -> Type
[TermCont] :: forall r s a. ((a -> Term s r) -> Term s r) -> TermCont @r s a

-- | Trace a message and raise error if <tt>cond</tt> is false. Otherwise,
--   continue.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   onlyAllow42 :: Term s (PInteger :--&gt; PUnit)
--   onlyAllow42 = plam $ i -&gt; unTermCont $ do
--     pguardC "expected 42" $ i #== 42
--     pure $ pconstant ()
--   </pre>
pguardC :: Term s PString -> Term s PBool -> TermCont s ()

-- | Stop computation and return given term if <tt>cond</tt> is false.
--   Otherwise, continue.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   is42 :: Term s (PInteger :--&gt; PBool)
--   is42 = plam $ i -&gt; unTermCont $ do
--     pguardC' (pconstant False) $ i #== 42
--     pure $ pconstant True
--   </pre>
pguardC' :: Term s a -> Term s PBool -> TermCont @a s ()

-- | Like <a>plet</a> but works in a <a>TermCont</a> monad
pletC :: Term s a -> TermCont s (Term s a)

-- | Like <a>pletFields</a> but works in a <a>TermCont</a> monad.
pletFieldsC :: forall fs a s b ps bs. (PDataFields a, ps ~ PFields a, bs ~ Bindings ps fs, BindFields ps bs) => Term s a -> TermCont @b s (HRec (BoundTerms ps bs s))

-- | Like <a>pmatch</a> but works in a <a>TermCont</a> monad
pmatchC :: PlutusType a => Term s a -> TermCont s (a s)

-- | Like <tt>ptrace</tt> but works in a <a>TermCont</a> monad.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   foo :: Term s PUnit
--   foo = unTermCont $ do
--     ptraceC "returning unit!"
--     pure $ pconstant ()
--   </pre>
ptraceC :: Term s PString -> TermCont s ()

-- | <a>TermCont</a> producing version of <a>ptryFrom</a>.
ptryFromC :: forall b r a s. PTryFrom a b => Term s a -> TermCont @r s (Term s b, Reduce (PTryFromExcess a b s))
unTermCont :: TermCont @a s (Term s a) -> Term s a
tcont :: ((a -> Term s r) -> Term s r) -> TermCont @r s a

-- | Backward compatibility synonym for <a>ptraceInfo</a>.

-- | <i>Deprecated: Use ptraceInfo</i>
ptrace :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

-- | Trace the given message at the debug level before evaluating the given
--   argument.
ptraceDebug :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

-- | Trace the given message at the debug level, then terminate with
--   <a>perror</a>.
ptraceDebugError :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a

-- | Trace the given message at the debug level if the argument is false.
ptraceDebugIfFalse :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the debug level if the argument is true.
ptraceDebugIfTrue :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Like Haskell's <tt>traceShowId</tt> but for Plutarch, at the debug
--   level.
ptraceDebugShowId :: forall (a :: S -> Type) (s :: S). PShow a => Term s a -> Term s a

-- | Synonym for <a>ptraceInfoError</a>.

-- | <i>Deprecated: Use ptraceInfoError</i>
ptraceError :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a

-- | Synonym for <a>ptraceInfoIfFalse</a>.

-- | <i>Deprecated: Use ptraceInfoIfFalse</i>
ptraceIfFalse :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the info level before evaluating the given
--   argument.
ptraceInfo :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a -> Term s a

-- | Trace the given message at the info level, then terminate with
--   <a>perror</a>.
ptraceInfoError :: forall (a :: S -> Type) (s :: S). Term s PString -> Term s a

-- | Trace the given message at the info level if the argument is false.
ptraceInfoIfFalse :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message at the info level if the argument is true.
ptraceInfoIfTrue :: forall (s :: S). Term s PString -> Term s PBool -> Term s PBool

-- | Like Haskell's <tt>traceShowId</tt> but for Plutarch, at the info
--   level.
ptraceInfoShowId :: forall (a :: S -> Type) (s :: S). PShow a => Term s a -> Term s a

-- | Synonym for <a>ptraceInfoShowId</a>.

-- | <i>Deprecated: Use ptraceInfoShowId</i>
ptraceShowId :: forall (a :: S -> Type) (s :: S). PShow a => Term s a -> Term s a

-- | <h1>Laws</h1>
--   
--   The only mandatory law is that <a>#&lt;&gt;</a> must be associative:
--   
--   <tt>x #&lt;&gt; (y #&lt;&gt; z)</tt> <tt>=</tt> <tt>(x #&lt;&gt; y)
--   #&lt;&gt; z</tt>
--   
--   If you define <a>pstimes</a>, ensure the following also hold:
--   
--   <ol>
--   <li><tt>pstimes pone x</tt> <tt>=</tt> <tt>x</tt></li>
--   <li><tt>(pstimes p1 x) #&lt;&gt; (pstimes p2 x)</tt> <tt>=</tt>
--   <tt>pstimes (p1 #+ p2) x</tt></li>
--   <li><tt>pstimes p1 (pstimes p2 x)</tt> <tt>=</tt> <tt>pstimes (p1 #*
--   p2) x</tt></li>
--   </ol>
--   
--   The default implementation automatically ensures these laws hold.
--   
--   @since WIP
class PSemigroup (a :: S -> Type)
(#<>) :: forall (s :: S). PSemigroup a => Term s a -> Term s a -> Term s a
(#<>) :: forall (s :: S). (PSemigroup a, PSemigroup (PInner a)) => Term s a -> Term s a -> Term s a
pstimes :: forall (s :: S). PSemigroup a => Term s PPositive -> Term s a -> Term s a
infixr 6 #<>

-- | <h1>Laws</h1>
--   
--   <ol>
--   <li><tt>pmempty #&lt;&gt; x</tt> <tt>=</tt> <tt>x #&lt;&gt;
--   pmempty</tt> <tt>=</tt> <tt>x</tt></li>
--   <li><tt>pstimes n pmempty</tt> <tt>=</tt> <tt>pmempty</tt></li>
--   </ol>
--   
--   If you define <a>pmtimes</a>, ensure the following as well:
--   
--   <ol>
--   <li><tt>pmtimes (ppositiveToNatural # p) x</tt> <tt>=</tt> <tt>pstimes
--   p x</tt></li>
--   <li><tt>pmtimes pzero x</tt> <tt>=</tt> <tt>pmempty</tt></li>
--   </ol>
--   
--   The default implementation of <a>pmtimes</a> ensures these laws hold.
--   
--   @since WIP
class PSemigroup a => PMonoid (a :: S -> Type)
pmempty :: forall (s :: S). PMonoid a => Term s a
pmempty :: forall (s :: S). (PMonoid a, PMonoid (PInner a)) => Term s a
pmtimes :: forall (s :: S). PMonoid a => Term s PNatural -> Term s a -> Term s a

-- | Wrapper for types which have logical AND semantics somehow.
--   
--   @since WIP
newtype PAnd (a :: S -> Type) (s :: S)
PAnd :: Term s a -> PAnd (a :: S -> Type) (s :: S)

-- | Wrapper for types which have logical OR semantics somehow.
--   
--   @since WIP
newtype POr (a :: S -> Type) (s :: S)
POr :: Term s a -> POr (a :: S -> Type) (s :: S)

-- | Wrapper for types which have logical XOR semantics somehow.
--   
--   @since WIP
newtype PXor (a :: S -> Type) (s :: S)
PXor :: Term s a -> PXor (a :: S -> Type) (s :: S)

-- | This is simplified version of <tt>punrollBound'</tt> without doing
--   additional recursion on Haskell level value.
--   
--   @since WIP
punrollBound :: forall a b s. Integer -> Term s (a :--> b) -> (Term s (a :--> b) -> Term s (a :--> b)) -> Term s (a :--> b)

-- | The first argument specifies the unrolling depth. The second argument
--   defines the fallback behavior when the recursion depth exceeds the
--   provided unrolling depth.
--   
--   The fixed-point implementation provided requires a Haskell-level value
--   <tt>c</tt> and a Plutarch function of type `Term s (a :--&gt; b)`. The
--   functional for the recursion is passed as a Haskell function. The
--   inclusion of the additional, arbitrary Haskell value (typed
--   <tt>c</tt>) enables further optimization by allowing pre-computation
--   of constant values that depend only on the recursion depth.
--   
--   This function will be used in a very niche situations. Using
--   Haskell-level value for constant replacement is only practical on a
--   single branch recursion with constant value that needs to be added on
--   each step. <tt>plength</tt> is one of the niche use case.
--   
--   @since WIP
punrollBound' :: forall a b c s. Integer -> (c -> Term s (a :--> b)) -> ((c -> Term s (a :--> b)) -> c -> Term s (a :--> b)) -> c -> Term s (a :--> b)

-- | Unroll given amount of steps, and for rest, uses <a>pfix</a> to
--   support unbound recursion.
--   
--   @since WIP
punrollUnbound :: forall a b s. Integer -> (Term s (a :--> b) -> Term s (a :--> b)) -> Term s (a :--> b)

-- | Uses <a>pfix</a> to recurse unrolled function itself. Unlike
--   <tt>punrollUnbound</tt>, this function uses unrolled instructions
--   within <a>pfix</a> recursions.
--   
--   This should perform better than <tt>punrollUnbound</tt> when a
--   function requires a large recursion depth.
--   
--   @since WIP
punrollUnboundWhole :: forall a b s. Integer -> (Term s (a :--> b) -> Term s (a :--> b)) -> Term s (a :--> b)
