-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Interface to the Plutus ledger for the Cardano ledger.
--   
--   Interface to the Plutus scripting support for the Cardano ledger.
@package plutus-ledger-api
@version 1.36.0.0


-- | This module contains the code for handling the various kinds of
--   version that we care about:
--   
--   <ul>
--   <li>Protocol versions</li>
--   <li>Plutus ledger languages</li>
--   <li>Plutus Core language versions</li>
--   </ul>
module PlutusLedgerApi.Common.Versions

-- | This represents the major component of the Cardano protocol version.
--   The ledger can only supply the major component of the protocol
--   version, not the minor component, and Plutus should only need to care
--   about the major component anyway. This relies on careful understanding
--   between us and the ledger as to what this means.
newtype MajorProtocolVersion
MajorProtocolVersion :: Int -> MajorProtocolVersion
[getMajorProtocolVersion] :: MajorProtocolVersion -> Int

-- | Shelley era was introduced in protocol version 2.0
shelleyPV :: MajorProtocolVersion

-- | Allegra era was introduced in protocol version 3.0
allegraPV :: MajorProtocolVersion

-- | Mary era was introduced in protocol version 4.0
maryPV :: MajorProtocolVersion

-- | Alonzo era was introduced in protocol version 5.0
alonzoPV :: MajorProtocolVersion

-- | The Vasil HF introduced the Babbage era and Plutus V2
vasilPV :: MajorProtocolVersion

-- | Valentine was an intra-era HF where builtin functions
--   <tt>VerifyEcdsaSecp256k1Signature</tt> and
--   <tt>VerifySchnorrSecp256k1Signature</tt> were enabled.
valentinePV :: MajorProtocolVersion

-- | The Chang HF introduced the Conway era and Plutus V3
changPV :: MajorProtocolVersion

-- | The Chang+1 HF will be an intra-era HF where some new builtin
--   functions are introduced in Plutus V2 and V3.
changPlus1PV :: MajorProtocolVersion

-- | The set of protocol versions that are "known", i.e. that have been
--   released and have actual differences associated with them.
knownPVs :: Set MajorProtocolVersion

-- | This is a placeholder for when we don't yet know what protocol version
--   will be used for something. It's a very high protocol version that
--   should never appear in reality. New builtins should always be given
--   this protocol version until they've been finalised.
--   
--   We should not assign names to future protocol versions until it's
--   confirmed that they are correct, otherwise we could accidentally
--   associate something with the wrong protocol version.
futurePV :: MajorProtocolVersion

-- | The Plutus ledger language. These are entirely different script
--   languages from the ledger's perspective, which on our side are
--   interpreted in very similar ways.
--   
--   It is a simple enumerated datatype (there is no major and minor
--   components as in protocol version) and the <b>ordering of
--   constructors</b> is essential for deriving Enum,Ord,Bounded.
--   
--   IMPORTANT: this is different from the Plutus Core language version,
--   <a>Version</a>
data PlutusLedgerLanguage

-- | introduced in shelley era
PlutusV1 :: PlutusLedgerLanguage

-- | introduced in vasil era
PlutusV2 :: PlutusLedgerLanguage

-- | not yet enabled
PlutusV3 :: PlutusLedgerLanguage
data () => Version
Version :: Natural -> Natural -> Natural -> Version
[_versionMajor] :: Version -> Natural
[_versionMinor] :: Version -> Natural
[_versionPatch] :: Version -> Natural

-- | Query the protocol version that a specific Plutus ledger language was
--   first introduced in.
ledgerLanguageIntroducedIn :: PlutusLedgerLanguage -> MajorProtocolVersion

-- | Which Plutus language versions are available in the given
--   <a>MajorProtocolVersion</a>?
--   
--   See Note [New builtins/language versions and protocol versions]
ledgerLanguagesAvailableIn :: MajorProtocolVersion -> Set PlutusLedgerLanguage

-- | A map indicating which Plutus Core versions were introduced in which
--   <a>MajorProtocolVersion</a> and <a>PlutusLedgerLanguage</a>. Each
--   version should appear at most once.
--   
--   This <b>must</b> be updated when new versions are added. See Note [New
--   builtins/language versions and protocol versions]
plcVersionsIntroducedIn :: Map (PlutusLedgerLanguage, MajorProtocolVersion) (Set Version)

-- | Which Plutus Core language versions are available in the given
--   <a>PlutusLedgerLanguage</a> and <a>MajorProtocolVersion</a>?
--   
--   See Note [New builtins/language versions and protocol versions]
plcVersionsAvailableIn :: PlutusLedgerLanguage -> MajorProtocolVersion -> Set Version

-- | A map indicating which builtin functions were introduced in which
--   <a>MajorProtocolVersion</a>.
--   
--   This <b>must</b> be updated when new builtins are added. See Note [New
--   builtins/language versions and protocol versions]
builtinsIntroducedIn :: Map (PlutusLedgerLanguage, MajorProtocolVersion) (Set DefaultFun)

-- | Which builtin functions are available in the given given
--   <a>PlutusLedgerLanguage</a> and <a>MajorProtocolVersion</a>?
--   
--   See Note [New builtins/language versions and protocol versions]
builtinsAvailableIn :: PlutusLedgerLanguage -> MajorProtocolVersion -> Set DefaultFun
instance Codec.Serialise.Class.Serialise PlutusLedgerApi.Common.Versions.PlutusLedgerLanguage
instance NoThunks.Class.NoThunks PlutusLedgerApi.Common.Versions.PlutusLedgerLanguage
instance Control.DeepSeq.NFData PlutusLedgerApi.Common.Versions.PlutusLedgerLanguage
instance GHC.Enum.Bounded PlutusLedgerApi.Common.Versions.PlutusLedgerLanguage
instance GHC.Enum.Enum PlutusLedgerApi.Common.Versions.PlutusLedgerLanguage
instance GHC.Generics.Generic PlutusLedgerApi.Common.Versions.PlutusLedgerLanguage
instance GHC.Show.Show PlutusLedgerApi.Common.Versions.PlutusLedgerLanguage
instance GHC.Classes.Ord PlutusLedgerApi.Common.Versions.PlutusLedgerLanguage
instance GHC.Classes.Eq PlutusLedgerApi.Common.Versions.PlutusLedgerLanguage
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.Common.Versions.PlutusLedgerLanguage


-- | The types and functions that are common among all ledger Plutus
--   versions.
module PlutusLedgerApi.Common

-- | Scripts to the ledger are serialised bytestrings.
type SerialisedScript = ShortByteString

-- | A Plutus script ready to be evaluated on-chain, via
--   <tt>evaluateScriptRestricting</tt>.
data ScriptForEvaluation

-- | Get a <a>SerialisedScript</a> from a <a>ScriptForEvaluation</a>.
--   <i>O(1)</i>.
serialisedScript :: ScriptForEvaluation -> SerialisedScript

-- | Get a <a>ScriptNamedDeBruijn</a> from a <a>ScriptForEvaluation</a>.
--   <i>O(1)</i>.
deserialisedScript :: ScriptForEvaluation -> ScriptNamedDeBruijn

-- | Turns a program which was compiled using the 'PlutusTx' toolchain into
--   a binary format that is understood by the network and can be stored
--   on-chain.
serialiseCompiledCode :: forall a. CompiledCode a -> SerialisedScript

-- | Turns a program's AST (most likely manually constructed) into a binary
--   format that is understood by the network and can be stored on-chain.
serialiseUPLC :: Program DeBruijn DefaultUni DefaultFun () -> SerialisedScript

-- | The deserialization from a serialised script into a
--   <a>ScriptForEvaluation</a>, ready to be evaluated on-chain. Called
--   inside phase-1 validation (i.e., deserialisation error is a phase-1
--   error).
deserialiseScript :: forall m. MonadError ScriptDecodeError m => PlutusLedgerLanguage -> MajorProtocolVersion -> SerialisedScript -> m ScriptForEvaluation

-- | Deserialises a <a>SerialisedScript</a> back into an AST. Does *not* do
--   ledger-language-version-specific checks like for allowable builtins.
uncheckedDeserialiseUPLC :: SerialisedScript -> Program DeBruijn DefaultUni DefaultFun ()

-- | An error that occurred during script deserialization.
data ScriptDecodeError

-- | an error from the underlying CBOR/serialise library
CBORDeserialiseError :: !DeserialiseFailureInfo -> ScriptDecodeError

-- | Script was successfully parsed, but more (runaway) bytes encountered
--   after script's position
RemainderError :: !ByteString -> ScriptDecodeError

-- | the plutus version of the given script is not enabled yet
LedgerLanguageNotAvailableError :: !PlutusLedgerLanguage -> !MajorProtocolVersion -> !MajorProtocolVersion -> ScriptDecodeError

-- | the script's ledger language
[sdeAffectedLang] :: ScriptDecodeError -> !PlutusLedgerLanguage

-- | the major protocol version that will first introduce/enable the ledger
--   language
[sdeIntroPv] :: ScriptDecodeError -> !MajorProtocolVersion

-- | the current protocol version
[sdeThisPv] :: ScriptDecodeError -> !MajorProtocolVersion
PlutusCoreLanguageNotAvailableError :: !Version -> !PlutusLedgerLanguage -> !MajorProtocolVersion -> ScriptDecodeError

-- | the Plutus Core language of the script under execution.
[sdeAffectedVersion] :: ScriptDecodeError -> !Version

-- | the Plutus ledger language of the script under execution.
[sdeThisLang] :: ScriptDecodeError -> !PlutusLedgerLanguage

-- | the current protocol version
[sdeThisPv] :: ScriptDecodeError -> !MajorProtocolVersion

-- | A script with named de-bruijn indices.
newtype ScriptNamedDeBruijn
ScriptNamedDeBruijn :: Program NamedDeBruijn DefaultUni DefaultFun () -> ScriptNamedDeBruijn

-- | Evaluates a script, returning the minimum budget that the script would
--   need to evaluate successfully. This will take as long as the script
--   takes, if you need to limit the execution time of the script also, you
--   can use <a>evaluateScriptRestricting</a>, which also returns the used
--   budget.
--   
--   Note: Parameterized over the ledger-plutus-version since the builtins
--   allowed (during decoding) differs.
evaluateScriptCounting :: PlutusLedgerLanguage -> MajorProtocolVersion -> VerboseMode -> EvaluationContext -> ScriptForEvaluation -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | Evaluates a script, with a cost model and a budget that restricts how
--   many resources it can use according to the cost model. Also returns
--   the budget that was actually used.
--   
--   Can be used to calculate budgets for scripts, but even in this case
--   you must give a limit to guard against scripts that run for a long
--   time or loop.
--   
--   Note: Parameterized over the <tt>LedgerPlutusVersion</tt> since 1. The
--   builtins allowed (during decoding) differ, and 2. The Plutus language
--   versions allowed differ.
evaluateScriptRestricting :: PlutusLedgerLanguage -> MajorProtocolVersion -> VerboseMode -> EvaluationContext -> ExBudget -> ScriptForEvaluation -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | Evaluate a fully-applied term using the CEK machine. Useful for
--   mimicking the behaviour of the on-chain evaluator.
evaluateTerm :: ExBudgetMode cost DefaultUni DefaultFun -> MajorProtocolVersion -> VerboseMode -> EvaluationContext -> Term NamedDeBruijn DefaultUni DefaultFun () -> (Either (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun) (Term NamedDeBruijn DefaultUni DefaultFun ()), cost, [Text])

-- | A simple toggle indicating whether or not we should accumulate logs
--   during script execution.
data VerboseMode

-- | accumulate all traces
Verbose :: VerboseMode

-- | don't accumulate anything
Quiet :: VerboseMode

-- | The type of the executed script's accumulated log output: a list of
--   <a>Text</a>.
--   
--   It will be an empty list if the <a>VerboseMode</a> is set to
--   <a>Quiet</a>.
type LogOutput = [Text]

-- | Errors that can be thrown when evaluating a Plutus script.
data EvaluationError

-- | An error from the evaluator itself
CekError :: !CekEvaluationException NamedDeBruijn DefaultUni DefaultFun -> EvaluationError

-- | An error in the pre-evaluation step of converting from de-Bruijn
--   indices
DeBruijnError :: !FreeVariableError -> EvaluationError

-- | A deserialisation error TODO: make this error more informative when we
--   have more information about what went wrong
CodecError :: !ScriptDecodeError -> EvaluationError

-- | An error indicating that the cost model parameters didn't match what
--   we expected
CostModelParameterMismatch :: EvaluationError

-- | The script evaluated to a value that is not a valid return value.
InvalidReturnValue :: EvaluationError

-- | This represents the major component of the Cardano protocol version.
--   The ledger can only supply the major component of the protocol
--   version, not the minor component, and Plutus should only need to care
--   about the major component anyway. This relies on careful understanding
--   between us and the ledger as to what this means.
newtype MajorProtocolVersion
MajorProtocolVersion :: Int -> MajorProtocolVersion
[getMajorProtocolVersion] :: MajorProtocolVersion -> Int

-- | The Plutus ledger language. These are entirely different script
--   languages from the ledger's perspective, which on our side are
--   interpreted in very similar ways.
--   
--   It is a simple enumerated datatype (there is no major and minor
--   components as in protocol version) and the <b>ordering of
--   constructors</b> is essential for deriving Enum,Ord,Bounded.
--   
--   IMPORTANT: this is different from the Plutus Core language version,
--   <a>Version</a>
data PlutusLedgerLanguage

-- | introduced in shelley era
PlutusV1 :: PlutusLedgerLanguage

-- | introduced in vasil era
PlutusV2 :: PlutusLedgerLanguage

-- | not yet enabled
PlutusV3 :: PlutusLedgerLanguage
data () => Version
Version :: Natural -> Natural -> Natural -> Version
[_versionMajor] :: Version -> Natural
[_versionMinor] :: Version -> Natural
[_versionPatch] :: Version -> Natural

-- | A map indicating which builtin functions were introduced in which
--   <a>MajorProtocolVersion</a>.
--   
--   This <b>must</b> be updated when new builtins are added. See Note [New
--   builtins/language versions and protocol versions]
builtinsIntroducedIn :: Map (PlutusLedgerLanguage, MajorProtocolVersion) (Set DefaultFun)

-- | Which builtin functions are available in the given given
--   <a>PlutusLedgerLanguage</a> and <a>MajorProtocolVersion</a>?
--   
--   See Note [New builtins/language versions and protocol versions]
builtinsAvailableIn :: PlutusLedgerLanguage -> MajorProtocolVersion -> Set DefaultFun

-- | Query the protocol version that a specific Plutus ledger language was
--   first introduced in.
ledgerLanguageIntroducedIn :: PlutusLedgerLanguage -> MajorProtocolVersion

-- | Which Plutus language versions are available in the given
--   <a>MajorProtocolVersion</a>?
--   
--   See Note [New builtins/language versions and protocol versions]
ledgerLanguagesAvailableIn :: MajorProtocolVersion -> Set PlutusLedgerLanguage
data () => ExBudget
ExBudget :: ExCPU -> ExMemory -> ExBudget
[exBudgetCPU] :: ExBudget -> ExCPU
[exBudgetMemory] :: ExBudget -> ExMemory
newtype () => ExCPU
ExCPU :: CostingInteger -> ExCPU
newtype () => ExMemory
ExMemory :: CostingInteger -> ExMemory
data () => SatInt
fromSatInt :: Num a => SatInt -> a
type CostModelParams = Map Text Int64

-- | Untags the plutus version from the typed cost model parameters and
--   returns their raw textual form (internally used by
--   CostModelInterface).
toCostModelParams :: IsParamName p => [(p, Int64)] -> CostModelParams
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()

-- | A parameter name for different plutus versions.
--   
--   Each Plutus version should expose such an enumeration as an ADT and
--   create an instance of <tt>ParamName</tt> out of it.
--   
--   A valid parameter name has to be enumeration, bounded, ordered, and
--   prettyprintable to a "lower-Kebab" string.
class (Enum a, Bounded a) => IsParamName a

-- | Produce the raw textual form for a given typed-by-plutus-version cost
--   model parameter Any implementation *must be* an injective function.
--   The <a>GIsParamName</a> generic implementation guarantees injectivity.
showParamName :: IsParamName a => a -> Text

-- | default implementation that inverts the showParamName operation (not
--   very efficient)
readParamName :: IsParamName a => Text -> Maybe a

-- | A Generic wrapper for use with deriving via
data GenericParamName a
data () => CostModelApplyError
CMUnknownParamError :: !Text -> CostModelApplyError
CMInternalReadError :: CostModelApplyError
CMInternalWriteError :: !String -> CostModelApplyError
data () => CostModelApplyWarn
CMTooManyParamsWarn :: !Int -> !Int -> CostModelApplyWarn
[cmExpected] :: CostModelApplyWarn -> !Int
[cmActual] :: CostModelApplyWarn -> !Int
CMTooFewParamsWarn :: !Int -> !Int -> CostModelApplyWarn
[cmExpected] :: CostModelApplyWarn -> !Int
[cmActual] :: CostModelApplyWarn -> !Int

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than being recomputed on every
--   evaluation.
--   
--   Different protocol versions may require different bundles of machine
--   parameters, which allows us for example to tweak the shape of the
--   costing function of a builtin, so that the builtin costs less.
--   Currently this means that we have to create multiple
--   <a>DefaultMachineParameters</a> per language version, which we put
--   into a cache (represented by an association list) in order to avoid
--   costly recomputation of machine parameters.
--   
--   In order to get the appropriate <a>DefaultMachineParameters</a> at
--   validation time we look it up in the cache using a semantics variant
--   as a key. We compute the semantics variant from the protocol version
--   using the stored function. Note that the semantics variant depends on
--   the language version too, but the latter is known statically (because
--   each language version has its own evaluation context), hence there's
--   no reason to require it to be provided at runtime.
--   
--   To say it differently, there's a matrix of semantics variants indexed
--   by (LL, PV) pairs and we cache its particular row corresponding to the
--   statically given LL in an <a>EvaluationContext</a>.
--   
--   The reason why we associate a <a>DefaultMachineParameters</a> with a
--   semantics variant rather than a protocol version are
--   
--   <ol>
--   <li>generally there are far more protocol versions than semantics
--   variants supported by a specific language version, so we save on
--   pointless duplication of bundles of machine parameters</li>
--   <li>builtins don't know anything about protocol versions, only
--   semantics variants. It is therefore more semantically precise to
--   associate bundles of machine parameters with semantics variants than
--   with protocol versions</li>
--   </ol>
data EvaluationContext
EvaluationContext :: PlutusLedgerLanguage -> (MajorProtocolVersion -> BuiltinSemanticsVariant DefaultFun) -> [(BuiltinSemanticsVariant DefaultFun, DefaultMachineParameters)] -> EvaluationContext

-- | Specifies what language versions the <a>EvaluationContext</a> is for.
[_evalCtxLedgerLang] :: EvaluationContext -> PlutusLedgerLanguage

-- | Specifies how to get a semantics variant for this ledger language
--   given a <a>MajorProtocolVersion</a>.
[_evalCtxToSemVar] :: EvaluationContext -> MajorProtocolVersion -> BuiltinSemanticsVariant DefaultFun

-- | The cache of <a>DefaultMachineParameters</a> for each semantics
--   variant supported by the current language version.
[_evalCtxMachParsCache] :: EvaluationContext -> [(BuiltinSemanticsVariant DefaultFun, DefaultMachineParameters)]

-- | Create an <a>EvaluationContext</a> given all builtin semantics
--   variants supported by the provided language version.
--   
--   The input is a <a>Map</a> of <a>Text</a>s to cost integer values (aka
--   <a>CostModelParams</a>, <a>CostModel</a>) See Note [Inlining meanings
--   of builtins].
--   
--   IMPORTANT: the <tt>toSemVar</tt> argument computes the semantics
--   variant for each <a>MajorProtocolVersion</a> and it must only return
--   semantics variants from the <tt>semVars</tt> list, as well as cover
--   ANY <a>MajorProtocolVersion</a>, including those that do not exist yet
--   (i.e. <tt>toSemVar</tt> must never fail).
--   
--   IMPORTANT: The evaluation context of every Plutus version must be
--   recreated upon a protocol update with the updated cost model
--   parameters.
mkDynEvaluationContext :: MonadError CostModelApplyError m => PlutusLedgerLanguage -> [BuiltinSemanticsVariant DefaultFun] -> (MajorProtocolVersion -> BuiltinSemanticsVariant DefaultFun) -> CostModelParams -> m EvaluationContext
toMachineParameters :: MajorProtocolVersion -> EvaluationContext -> DefaultMachineParameters

-- | Shared helper for the evaluation functions:
--   <a>evaluateScriptCounting</a> and <a>evaluateScriptRestricting</a>,
--   
--   Given a <a>ScriptForEvaluation</a>:
--   
--   1) applies the term to a list of <a>Data</a> arguments (e.g. Datum,
--   Redeemer, <tt>ScriptContext</tt>) 2) checks that the applied-term is
--   well-scoped 3) returns the applied-term
mkTermToEvaluate :: MonadError EvaluationError m => PlutusLedgerLanguage -> MajorProtocolVersion -> ScriptForEvaluation -> [Data] -> m (Term NamedDeBruijn DefaultUni DefaultFun ())
data () => BuiltinByteString
toBuiltin :: HasToBuiltin a => a -> ToBuiltin a
fromBuiltin :: HasFromBuiltin arep => arep -> FromBuiltin arep
toOpaque :: HasToOpaque a arep => a -> arep
fromOpaque :: HasFromOpaque arep a => arep -> a
data () => Data
Constr :: Integer -> [Data] -> Data
Map :: [(Data, Data)] -> Data
List :: [Data] -> Data
I :: Integer -> Data
B :: ByteString -> Data
data () => BuiltinData
BuiltinData :: ~Data -> BuiltinData
class () => ToData a
toBuiltinData :: ToData a => a -> BuiltinData
class () => FromData a
fromBuiltinData :: FromData a => BuiltinData -> Maybe a
class () => UnsafeFromData a
unsafeFromBuiltinData :: UnsafeFromData a => BuiltinData -> a
toData :: ToData a => a -> Data
fromData :: FromData a => Data -> Maybe a
unsafeFromData :: UnsafeFromData a => Data -> a
dataToBuiltinData :: Data -> BuiltinData
builtinDataToData :: BuiltinData -> Data

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>MonadError</a> class. (If you are using the deprecated
--   <a>Control.Monad.Error</a> or <a>Control.Monad.Trans.Error</a>, you
--   may also have to define an <tt>Error</tt> instance.)
class Monad m => MonadError e (m :: Type -> Type) | m -> e


-- | A type for intervals and associated functions.
module PlutusLedgerApi.V1.Interval

-- | An interval of <tt>a</tt>s.
--   
--   The interval may be either closed or open at either end, meaning that
--   the endpoints may or may not be included in the interval.
--   
--   The interval can also be unbounded on either side.
--   
--   The <a>Eq</a> instance gives equality of the intervals, not structural
--   equality. There is no <a>Ord</a> instance, but <a>contains</a> gives a
--   partial order.
--   
--   Note that some of the functions on <a>Interval</a> rely on <a>Enum</a>
--   in order to handle non-inclusive endpoints. For this reason, it may
--   not be safe to use <a>Interval</a>s with non-inclusive endpoints on
--   types whose <a>Enum</a> instances have partial methods.
data Interval a
Interval :: LowerBound a -> UpperBound a -> Interval a
[ivFrom] :: Interval a -> LowerBound a
[ivTo] :: Interval a -> UpperBound a

-- | The upper bound of an interval.
data UpperBound a
UpperBound :: Extended a -> Closure -> UpperBound a

-- | The lower bound of an interval.
data LowerBound a
LowerBound :: Extended a -> Closure -> LowerBound a

-- | A set extended with a positive and negative infinity.
data Extended a
NegInf :: Extended a
Finite :: a -> Extended a
PosInf :: Extended a

-- | Whether a bound is inclusive or not.
type Closure = Bool

-- | Check whether a value is in an interval.
member :: (Enum a, Ord a) => a -> Interval a -> Bool

-- | <tt>interval a b</tt> includes all values that are greater than or
--   equal to <tt>a</tt> and smaller than or equal to <tt>b</tt>. Therefore
--   it includes <tt>a</tt> and <tt>b</tt>. In math. notation: [a,b]
interval :: a -> a -> Interval a

-- | <tt>from a</tt> is an <a>Interval</a> that includes all values that
--   are greater than or equal to <tt>a</tt>. In math. notation: [a,+∞]
from :: a -> Interval a

-- | <tt>to a</tt> is an <a>Interval</a> that includes all values that are
--   smaller than or equal to <tt>a</tt>. In math. notation: [-∞,a]
to :: a -> Interval a

-- | An <a>Interval</a> that covers every slot. In math. notation [-∞,+∞]
always :: Interval a

-- | An <a>Interval</a> that is empty.
--   
--   There can be many empty intervals, see <a>isEmpty</a>. The empty
--   interval <a>never</a> is arbitrarily set to [+∞,-∞].
never :: Interval a

-- | Create an interval that includes just a single concrete point
--   <tt>a</tt>, i.e. having the same non-strict lower and upper bounds. In
--   math.notation: [a,a]
singleton :: a -> Interval a

-- | 'hull a b' is the smallest interval containing <tt>a</tt> and
--   <tt>b</tt>.
hull :: (Enum a, Ord a) => Interval a -> Interval a -> Interval a

-- | 'intersection a b' is the largest interval that is contained in
--   <tt>a</tt> and in <tt>b</tt>, if it exists.
intersection :: (Enum a, Ord a) => Interval a -> Interval a -> Interval a

-- | Check whether two intervals overlap, that is, whether there is a value
--   that is a member of both intervals.
overlaps :: (Enum a, Ord a) => Interval a -> Interval a -> Bool

-- | <tt>a <a>contains</a> b</tt> is true if the <a>Interval</a> <tt>b</tt>
--   is entirely contained in <tt>a</tt>. That is, <tt>a <a>contains</a>
--   b</tt> if for every entry <tt>s</tt>, if <tt>member s b</tt> then
--   <tt>member s a</tt>.
contains :: (Enum a, Ord a) => Interval a -> Interval a -> Bool

-- | Check if an <a>Interval</a> is empty.
isEmpty :: (Enum a, Ord a) => Interval a -> Bool

-- | Check if a value is earlier than the beginning of an <a>Interval</a>.
before :: (Enum a, Ord a) => a -> Interval a -> Bool

-- | Check if a value is later than the end of an <a>Interval</a>.
after :: (Enum a, Ord a) => a -> Interval a -> Bool

-- | Construct a lower bound from a value.
--   
--   The resulting bound includes all values that are equal or greater than
--   the input value.
lowerBound :: a -> LowerBound a

-- | Construct an upper bound from a value.
--   
--   The resulting bound includes all values that are equal or smaller than
--   the input value.
upperBound :: a -> UpperBound a

-- | Construct a strict lower bound from a value.
--   
--   The resulting bound includes all values that are (strictly) greater
--   than the input value.
strictLowerBound :: a -> LowerBound a

-- | Construct a strict upper bound from a value.
--   
--   The resulting bound includes all values that are (strictly) smaller
--   than the input value.
strictUpperBound :: a -> UpperBound a
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Interval.Interval
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni a, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (PlutusLedgerApi.V1.Interval.LowerBound a), PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (PlutusLedgerApi.V1.Interval.UpperBound a)) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (PlutusLedgerApi.V1.Interval.Interval a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Interval.UpperBound
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni a, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (PlutusLedgerApi.V1.Interval.Extended a)) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (PlutusLedgerApi.V1.Interval.UpperBound a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Interval.LowerBound
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni a, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (PlutusLedgerApi.V1.Interval.Extended a)) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (PlutusLedgerApi.V1.Interval.LowerBound a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Interval.Extended
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni a, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni a) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (PlutusLedgerApi.V1.Interval.Extended a)
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (PlutusLedgerApi.V1.Interval.Interval a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (PlutusLedgerApi.V1.Interval.Interval a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (PlutusLedgerApi.V1.Interval.Interval a)
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (PlutusLedgerApi.V1.Interval.LowerBound a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (PlutusLedgerApi.V1.Interval.LowerBound a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (PlutusLedgerApi.V1.Interval.LowerBound a)
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (PlutusLedgerApi.V1.Interval.UpperBound a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (PlutusLedgerApi.V1.Interval.UpperBound a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (PlutusLedgerApi.V1.Interval.UpperBound a)
instance (PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition a, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition a referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema (PlutusLedgerApi.V1.Interval.Extended a) referencedTypes
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (PlutusLedgerApi.V1.Interval.Extended a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (PlutusLedgerApi.V1.Interval.Extended a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (PlutusLedgerApi.V1.Interval.Extended a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (PlutusLedgerApi.V1.Interval.Extended a)
instance GHC.Generics.Generic (PlutusLedgerApi.V1.Interval.Extended a)
instance GHC.Show.Show a => GHC.Show.Show (PlutusLedgerApi.V1.Interval.Extended a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (PlutusLedgerApi.V1.Interval.UpperBound a)
instance GHC.Generics.Generic (PlutusLedgerApi.V1.Interval.UpperBound a)
instance GHC.Show.Show a => GHC.Show.Show (PlutusLedgerApi.V1.Interval.UpperBound a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (PlutusLedgerApi.V1.Interval.LowerBound a)
instance GHC.Generics.Generic (PlutusLedgerApi.V1.Interval.LowerBound a)
instance GHC.Show.Show a => GHC.Show.Show (PlutusLedgerApi.V1.Interval.LowerBound a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (PlutusLedgerApi.V1.Interval.Interval a)
instance GHC.Generics.Generic (PlutusLedgerApi.V1.Interval.Interval a)
instance GHC.Show.Show a => GHC.Show.Show (PlutusLedgerApi.V1.Interval.Interval a)
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition a => PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition (PlutusLedgerApi.V1.Interval.Interval a)
instance (PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition a, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (PlutusLedgerApi.V1.Interval.LowerBound a) referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (PlutusLedgerApi.V1.Interval.UpperBound a) referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema (PlutusLedgerApi.V1.Interval.Interval a) referencedTypes
instance PlutusTx.Functor.Functor PlutusLedgerApi.V1.Interval.Interval
instance Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (PlutusLedgerApi.V1.Interval.Interval a)
instance (PlutusTx.Enum.Enum a, PlutusTx.Ord.Ord a) => PlutusTx.Lattice.JoinSemiLattice (PlutusLedgerApi.V1.Interval.Interval a)
instance (PlutusTx.Enum.Enum a, PlutusTx.Ord.Ord a) => PlutusTx.Lattice.BoundedJoinSemiLattice (PlutusLedgerApi.V1.Interval.Interval a)
instance (PlutusTx.Enum.Enum a, PlutusTx.Ord.Ord a) => PlutusTx.Lattice.MeetSemiLattice (PlutusLedgerApi.V1.Interval.Interval a)
instance (PlutusTx.Enum.Enum a, PlutusTx.Ord.Ord a) => PlutusTx.Lattice.BoundedMeetSemiLattice (PlutusLedgerApi.V1.Interval.Interval a)
instance (PlutusTx.Enum.Enum a, PlutusTx.Ord.Ord a) => PlutusTx.Eq.Eq (PlutusLedgerApi.V1.Interval.Interval a)
instance (PlutusTx.Enum.Enum a, PlutusTx.Ord.Ord a) => GHC.Classes.Eq (PlutusLedgerApi.V1.Interval.Interval a)
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition (PlutusLedgerApi.V1.Interval.Extended a) => PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition (PlutusLedgerApi.V1.Interval.LowerBound a)
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition a referencedTypes, PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition a, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (PlutusLedgerApi.V1.Interval.Extended a) referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Interval.Closure referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema (PlutusLedgerApi.V1.Interval.LowerBound a) referencedTypes
instance PlutusTx.Functor.Functor PlutusLedgerApi.V1.Interval.LowerBound
instance Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (PlutusLedgerApi.V1.Interval.LowerBound a)
instance (PlutusTx.Enum.Enum a, PlutusTx.Eq.Eq a) => PlutusTx.Eq.Eq (PlutusLedgerApi.V1.Interval.LowerBound a)
instance (PlutusTx.Enum.Enum a, PlutusTx.Eq.Eq a) => GHC.Classes.Eq (PlutusLedgerApi.V1.Interval.LowerBound a)
instance (PlutusTx.Enum.Enum a, PlutusTx.Ord.Ord a) => PlutusTx.Ord.Ord (PlutusLedgerApi.V1.Interval.LowerBound a)
instance (PlutusTx.Enum.Enum a, PlutusTx.Ord.Ord a) => GHC.Classes.Ord (PlutusLedgerApi.V1.Interval.LowerBound a)
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition (PlutusLedgerApi.V1.Interval.Extended a) => PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition (PlutusLedgerApi.V1.Interval.UpperBound a)
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition a referencedTypes, PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition a, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (PlutusLedgerApi.V1.Interval.Extended a) referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Interval.Closure referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema (PlutusLedgerApi.V1.Interval.UpperBound a) referencedTypes
instance PlutusTx.Functor.Functor PlutusLedgerApi.V1.Interval.UpperBound
instance Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (PlutusLedgerApi.V1.Interval.UpperBound a)
instance (PlutusTx.Enum.Enum a, PlutusTx.Eq.Eq a) => PlutusTx.Eq.Eq (PlutusLedgerApi.V1.Interval.UpperBound a)
instance (PlutusTx.Enum.Enum a, PlutusTx.Eq.Eq a) => GHC.Classes.Eq (PlutusLedgerApi.V1.Interval.UpperBound a)
instance (PlutusTx.Enum.Enum a, PlutusTx.Ord.Ord a) => PlutusTx.Ord.Ord (PlutusLedgerApi.V1.Interval.UpperBound a)
instance (PlutusTx.Enum.Enum a, PlutusTx.Ord.Ord a) => GHC.Classes.Ord (PlutusLedgerApi.V1.Interval.UpperBound a)
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition a => PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition (PlutusLedgerApi.V1.Interval.Extended a)
instance PlutusTx.Functor.Functor PlutusLedgerApi.V1.Interval.Extended
instance Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (PlutusLedgerApi.V1.Interval.Extended a)
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (PlutusLedgerApi.V1.Interval.Extended a)
instance PlutusTx.Eq.Eq a => GHC.Classes.Eq (PlutusLedgerApi.V1.Interval.Extended a)
instance PlutusTx.Ord.Ord a => PlutusTx.Ord.Ord (PlutusLedgerApi.V1.Interval.Extended a)
instance PlutusTx.Ord.Ord a => GHC.Classes.Ord (PlutusLedgerApi.V1.Interval.Extended a)

module PlutusLedgerApi.V1.ParamName

-- | The enumeration of all possible cost model parameter names for this
--   language version.
--   
--   IMPORTANT: The order of appearance of the data constructors here
--   matters. DO NOT REORDER. See Note [Quotation marks in cost model
--   parameter constructors] See Note [Cost model parameters from the
--   ledger's point of view]
data ParamName
AddInteger'cpu'arguments'intercept :: ParamName
AddInteger'cpu'arguments'slope :: ParamName
AddInteger'memory'arguments'intercept :: ParamName
AddInteger'memory'arguments'slope :: ParamName
AppendByteString'cpu'arguments'intercept :: ParamName
AppendByteString'cpu'arguments'slope :: ParamName
AppendByteString'memory'arguments'intercept :: ParamName
AppendByteString'memory'arguments'slope :: ParamName
AppendString'cpu'arguments'intercept :: ParamName
AppendString'cpu'arguments'slope :: ParamName
AppendString'memory'arguments'intercept :: ParamName
AppendString'memory'arguments'slope :: ParamName
BData'cpu'arguments :: ParamName
BData'memory'arguments :: ParamName
Blake2b_256'cpu'arguments'intercept :: ParamName
Blake2b_256'cpu'arguments'slope :: ParamName
Blake2b_256'memory'arguments :: ParamName
CekApplyCost'exBudgetCPU :: ParamName
CekApplyCost'exBudgetMemory :: ParamName
CekBuiltinCost'exBudgetCPU :: ParamName
CekBuiltinCost'exBudgetMemory :: ParamName
CekConstCost'exBudgetCPU :: ParamName
CekConstCost'exBudgetMemory :: ParamName
CekDelayCost'exBudgetCPU :: ParamName
CekDelayCost'exBudgetMemory :: ParamName
CekForceCost'exBudgetCPU :: ParamName
CekForceCost'exBudgetMemory :: ParamName
CekLamCost'exBudgetCPU :: ParamName
CekLamCost'exBudgetMemory :: ParamName
CekStartupCost'exBudgetCPU :: ParamName
CekStartupCost'exBudgetMemory :: ParamName
CekVarCost'exBudgetCPU :: ParamName
CekVarCost'exBudgetMemory :: ParamName
ChooseData'cpu'arguments :: ParamName
ChooseData'memory'arguments :: ParamName
ChooseList'cpu'arguments :: ParamName
ChooseList'memory'arguments :: ParamName
ChooseUnit'cpu'arguments :: ParamName
ChooseUnit'memory'arguments :: ParamName
ConsByteString'cpu'arguments'intercept :: ParamName
ConsByteString'cpu'arguments'slope :: ParamName
ConsByteString'memory'arguments'intercept :: ParamName
ConsByteString'memory'arguments'slope :: ParamName
ConstrData'cpu'arguments :: ParamName
ConstrData'memory'arguments :: ParamName
DecodeUtf8'cpu'arguments'intercept :: ParamName
DecodeUtf8'cpu'arguments'slope :: ParamName
DecodeUtf8'memory'arguments'intercept :: ParamName
DecodeUtf8'memory'arguments'slope :: ParamName
DivideInteger'cpu'arguments'constant :: ParamName
DivideInteger'cpu'arguments'model'arguments'intercept :: ParamName
DivideInteger'cpu'arguments'model'arguments'slope :: ParamName
DivideInteger'memory'arguments'intercept :: ParamName
DivideInteger'memory'arguments'minimum :: ParamName
DivideInteger'memory'arguments'slope :: ParamName
EncodeUtf8'cpu'arguments'intercept :: ParamName
EncodeUtf8'cpu'arguments'slope :: ParamName
EncodeUtf8'memory'arguments'intercept :: ParamName
EncodeUtf8'memory'arguments'slope :: ParamName
EqualsByteString'cpu'arguments'constant :: ParamName
EqualsByteString'cpu'arguments'intercept :: ParamName
EqualsByteString'cpu'arguments'slope :: ParamName
EqualsByteString'memory'arguments :: ParamName
EqualsData'cpu'arguments'intercept :: ParamName
EqualsData'cpu'arguments'slope :: ParamName
EqualsData'memory'arguments :: ParamName
EqualsInteger'cpu'arguments'intercept :: ParamName
EqualsInteger'cpu'arguments'slope :: ParamName
EqualsInteger'memory'arguments :: ParamName
EqualsString'cpu'arguments'constant :: ParamName
EqualsString'cpu'arguments'intercept :: ParamName
EqualsString'cpu'arguments'slope :: ParamName
EqualsString'memory'arguments :: ParamName
FstPair'cpu'arguments :: ParamName
FstPair'memory'arguments :: ParamName
HeadList'cpu'arguments :: ParamName
HeadList'memory'arguments :: ParamName
IData'cpu'arguments :: ParamName
IData'memory'arguments :: ParamName
IfThenElse'cpu'arguments :: ParamName
IfThenElse'memory'arguments :: ParamName
IndexByteString'cpu'arguments :: ParamName
IndexByteString'memory'arguments :: ParamName
LengthOfByteString'cpu'arguments :: ParamName
LengthOfByteString'memory'arguments :: ParamName
LessThanByteString'cpu'arguments'intercept :: ParamName
LessThanByteString'cpu'arguments'slope :: ParamName
LessThanByteString'memory'arguments :: ParamName
LessThanEqualsByteString'cpu'arguments'intercept :: ParamName
LessThanEqualsByteString'cpu'arguments'slope :: ParamName
LessThanEqualsByteString'memory'arguments :: ParamName
LessThanEqualsInteger'cpu'arguments'intercept :: ParamName
LessThanEqualsInteger'cpu'arguments'slope :: ParamName
LessThanEqualsInteger'memory'arguments :: ParamName
LessThanInteger'cpu'arguments'intercept :: ParamName
LessThanInteger'cpu'arguments'slope :: ParamName
LessThanInteger'memory'arguments :: ParamName
ListData'cpu'arguments :: ParamName
ListData'memory'arguments :: ParamName
MapData'cpu'arguments :: ParamName
MapData'memory'arguments :: ParamName
MkCons'cpu'arguments :: ParamName
MkCons'memory'arguments :: ParamName
MkNilData'cpu'arguments :: ParamName
MkNilData'memory'arguments :: ParamName
MkNilPairData'cpu'arguments :: ParamName
MkNilPairData'memory'arguments :: ParamName
MkPairData'cpu'arguments :: ParamName
MkPairData'memory'arguments :: ParamName
ModInteger'cpu'arguments'constant :: ParamName
ModInteger'cpu'arguments'model'arguments'intercept :: ParamName
ModInteger'cpu'arguments'model'arguments'slope :: ParamName
ModInteger'memory'arguments'intercept :: ParamName
ModInteger'memory'arguments'minimum :: ParamName
ModInteger'memory'arguments'slope :: ParamName
MultiplyInteger'cpu'arguments'intercept :: ParamName
MultiplyInteger'cpu'arguments'slope :: ParamName
MultiplyInteger'memory'arguments'intercept :: ParamName
MultiplyInteger'memory'arguments'slope :: ParamName
NullList'cpu'arguments :: ParamName
NullList'memory'arguments :: ParamName
QuotientInteger'cpu'arguments'constant :: ParamName
QuotientInteger'cpu'arguments'model'arguments'intercept :: ParamName
QuotientInteger'cpu'arguments'model'arguments'slope :: ParamName
QuotientInteger'memory'arguments'intercept :: ParamName
QuotientInteger'memory'arguments'minimum :: ParamName
QuotientInteger'memory'arguments'slope :: ParamName
RemainderInteger'cpu'arguments'constant :: ParamName
RemainderInteger'cpu'arguments'model'arguments'intercept :: ParamName
RemainderInteger'cpu'arguments'model'arguments'slope :: ParamName
RemainderInteger'memory'arguments'intercept :: ParamName
RemainderInteger'memory'arguments'minimum :: ParamName
RemainderInteger'memory'arguments'slope :: ParamName
Sha2_256'cpu'arguments'intercept :: ParamName
Sha2_256'cpu'arguments'slope :: ParamName
Sha2_256'memory'arguments :: ParamName
Sha3_256'cpu'arguments'intercept :: ParamName
Sha3_256'cpu'arguments'slope :: ParamName
Sha3_256'memory'arguments :: ParamName
SliceByteString'cpu'arguments'intercept :: ParamName
SliceByteString'cpu'arguments'slope :: ParamName
SliceByteString'memory'arguments'intercept :: ParamName
SliceByteString'memory'arguments'slope :: ParamName
SndPair'cpu'arguments :: ParamName
SndPair'memory'arguments :: ParamName
SubtractInteger'cpu'arguments'intercept :: ParamName
SubtractInteger'cpu'arguments'slope :: ParamName
SubtractInteger'memory'arguments'intercept :: ParamName
SubtractInteger'memory'arguments'slope :: ParamName
TailList'cpu'arguments :: ParamName
TailList'memory'arguments :: ParamName
Trace'cpu'arguments :: ParamName
Trace'memory'arguments :: ParamName
UnBData'cpu'arguments :: ParamName
UnBData'memory'arguments :: ParamName
UnConstrData'cpu'arguments :: ParamName
UnConstrData'memory'arguments :: ParamName
UnIData'cpu'arguments :: ParamName
UnIData'memory'arguments :: ParamName
UnListData'cpu'arguments :: ParamName
UnListData'memory'arguments :: ParamName
UnMapData'cpu'arguments :: ParamName
UnMapData'memory'arguments :: ParamName
VerifyEd25519Signature'cpu'arguments'intercept :: ParamName
VerifyEd25519Signature'cpu'arguments'slope :: ParamName
VerifyEd25519Signature'memory'arguments :: ParamName

-- | Given an ordered list of parameter values, tag them with their
--   parameter names. If the passed parameter values are more than
--   expected: the function will ignore the extraneous values at the tail
--   of the list, if the passed values are less than expected: the function
--   will throw an error; for more information, see Note [Cost model
--   parameters from the ledger's point of view]
tagWithParamNames :: forall k m. (Enum k, Bounded k, MonadError CostModelApplyError m, MonadWriter [CostModelApplyWarn] m) => [Int64] -> m [(k, Int64)]
instance PlutusLedgerApi.Common.ParamName.IsParamName PlutusLedgerApi.V1.ParamName.ParamName
instance GHC.Generics.Generic PlutusLedgerApi.V1.ParamName.ParamName
instance GHC.Enum.Bounded PlutusLedgerApi.V1.ParamName.ParamName
instance GHC.Ix.Ix PlutusLedgerApi.V1.ParamName.ParamName
instance GHC.Enum.Enum PlutusLedgerApi.V1.ParamName.ParamName
instance GHC.Classes.Ord PlutusLedgerApi.V1.ParamName.ParamName
instance GHC.Classes.Eq PlutusLedgerApi.V1.ParamName.ParamName

module PlutusLedgerApi.V1.EvaluationContext

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than being recomputed on every
--   evaluation.
--   
--   Different protocol versions may require different bundles of machine
--   parameters, which allows us for example to tweak the shape of the
--   costing function of a builtin, so that the builtin costs less.
--   Currently this means that we have to create multiple
--   <a>DefaultMachineParameters</a> per language version, which we put
--   into a cache (represented by an association list) in order to avoid
--   costly recomputation of machine parameters.
--   
--   In order to get the appropriate <a>DefaultMachineParameters</a> at
--   validation time we look it up in the cache using a semantics variant
--   as a key. We compute the semantics variant from the protocol version
--   using the stored function. Note that the semantics variant depends on
--   the language version too, but the latter is known statically (because
--   each language version has its own evaluation context), hence there's
--   no reason to require it to be provided at runtime.
--   
--   To say it differently, there's a matrix of semantics variants indexed
--   by (LL, PV) pairs and we cache its particular row corresponding to the
--   statically given LL in an <a>EvaluationContext</a>.
--   
--   The reason why we associate a <a>DefaultMachineParameters</a> with a
--   semantics variant rather than a protocol version are
--   
--   <ol>
--   <li>generally there are far more protocol versions than semantics
--   variants supported by a specific language version, so we save on
--   pointless duplication of bundles of machine parameters</li>
--   <li>builtins don't know anything about protocol versions, only
--   semantics variants. It is therefore more semantically precise to
--   associate bundles of machine parameters with semantics variants than
--   with protocol versions</li>
--   </ol>
data EvaluationContext

-- | Build the <a>EvaluationContext</a>.
--   
--   The input is a list of cost model parameters (which are integer
--   values) passed from the ledger.
--   
--   IMPORTANT: the cost model parameters <b>MUST</b> appear in the correct
--   order, matching the names in <a>ParamName</a>. If the parameters are
--   supplied in the wrong order then script cost calculations will be
--   incorrect.
--   
--   IMPORTANT: The evaluation context of every Plutus version must be
--   recreated upon a protocol update with the updated cost model
--   parameters.
mkEvaluationContext :: (MonadError CostModelApplyError m, MonadWriter [CostModelApplyWarn] m) => [Int64] -> m EvaluationContext
type CostModelParams = Map Text Int64
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()
toMachineParameters :: MajorProtocolVersion -> EvaluationContext -> DefaultMachineParameters
data () => CostModelApplyError
CMUnknownParamError :: !Text -> CostModelApplyError
CMInternalReadError :: CostModelApplyError
CMInternalWriteError :: !String -> CostModelApplyError


-- | UTCTime and UTCTime ranges.
module PlutusLedgerApi.V1.Time

-- | POSIX time is measured as the number of <i>milliseconds</i> since
--   1970-01-01T00:00:00Z. This is not the same as Haskell's
--   <a>POSIXTime</a>
newtype POSIXTime
POSIXTime :: Integer -> POSIXTime
[getPOSIXTime] :: POSIXTime -> Integer

-- | An <a>Interval</a> of <a>POSIXTime</a>s.
type POSIXTimeRange = Interval POSIXTime

-- | This is a length of time, as measured by a number of milliseconds.
newtype DiffMilliSeconds
DiffMilliSeconds :: Integer -> DiffMilliSeconds

-- | Simple conversion from <a>DiffMilliSeconds</a> to <a>POSIXTime</a>.
fromMilliSeconds :: DiffMilliSeconds -> POSIXTime
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance GHC.Real.Integral PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance GHC.Real.Real PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance GHC.Enum.Enum PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance PlutusTx.Numeric.AdditiveGroup PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance PlutusTx.Numeric.AdditiveMonoid PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance PlutusTx.Numeric.AdditiveSemigroup PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance GHC.Num.Num PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance GHC.Generics.Generic PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance GHC.Show.Show PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance GHC.Classes.Ord PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance GHC.Classes.Eq PlutusLedgerApi.V1.Time.DiffMilliSeconds
instance GHC.Real.Integral PlutusLedgerApi.V1.Time.POSIXTime
instance GHC.Real.Real PlutusLedgerApi.V1.Time.POSIXTime
instance GHC.Enum.Enum PlutusLedgerApi.V1.Time.POSIXTime
instance GHC.Num.Num PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.Enum.Enum PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.Numeric.AdditiveGroup PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.Numeric.AdditiveMonoid PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.Numeric.AdditiveSemigroup PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Time.POSIXTime
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Time.POSIXTime
instance GHC.Generics.Generic PlutusLedgerApi.V1.Time.POSIXTime
instance GHC.Show.Show PlutusLedgerApi.V1.Time.POSIXTime
instance GHC.Classes.Ord PlutusLedgerApi.V1.Time.POSIXTime
instance GHC.Classes.Eq PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Time.POSIXTime referencedTypes
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Time.POSIXTime
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Time.DiffMilliSeconds referencedTypes

module PlutusLedgerApi.V2.ParamName

-- | The enumeration of all possible cost model parameter names for this
--   language version.
--   
--   IMPORTANT: The order of appearance of the data constructors here
--   matters. DO NOT REORDER. See Note [Quotation marks in cost model
--   parameter constructors] See Note [Cost model parameters from the
--   ledger's point of view]
data ParamName
AddInteger'cpu'arguments'intercept :: ParamName
AddInteger'cpu'arguments'slope :: ParamName
AddInteger'memory'arguments'intercept :: ParamName
AddInteger'memory'arguments'slope :: ParamName
AppendByteString'cpu'arguments'intercept :: ParamName
AppendByteString'cpu'arguments'slope :: ParamName
AppendByteString'memory'arguments'intercept :: ParamName
AppendByteString'memory'arguments'slope :: ParamName
AppendString'cpu'arguments'intercept :: ParamName
AppendString'cpu'arguments'slope :: ParamName
AppendString'memory'arguments'intercept :: ParamName
AppendString'memory'arguments'slope :: ParamName
BData'cpu'arguments :: ParamName
BData'memory'arguments :: ParamName
Blake2b_256'cpu'arguments'intercept :: ParamName
Blake2b_256'cpu'arguments'slope :: ParamName
Blake2b_256'memory'arguments :: ParamName
CekApplyCost'exBudgetCPU :: ParamName
CekApplyCost'exBudgetMemory :: ParamName
CekBuiltinCost'exBudgetCPU :: ParamName
CekBuiltinCost'exBudgetMemory :: ParamName
CekConstCost'exBudgetCPU :: ParamName
CekConstCost'exBudgetMemory :: ParamName
CekDelayCost'exBudgetCPU :: ParamName
CekDelayCost'exBudgetMemory :: ParamName
CekForceCost'exBudgetCPU :: ParamName
CekForceCost'exBudgetMemory :: ParamName
CekLamCost'exBudgetCPU :: ParamName
CekLamCost'exBudgetMemory :: ParamName
CekStartupCost'exBudgetCPU :: ParamName
CekStartupCost'exBudgetMemory :: ParamName
CekVarCost'exBudgetCPU :: ParamName
CekVarCost'exBudgetMemory :: ParamName
ChooseData'cpu'arguments :: ParamName
ChooseData'memory'arguments :: ParamName
ChooseList'cpu'arguments :: ParamName
ChooseList'memory'arguments :: ParamName
ChooseUnit'cpu'arguments :: ParamName
ChooseUnit'memory'arguments :: ParamName
ConsByteString'cpu'arguments'intercept :: ParamName
ConsByteString'cpu'arguments'slope :: ParamName
ConsByteString'memory'arguments'intercept :: ParamName
ConsByteString'memory'arguments'slope :: ParamName
ConstrData'cpu'arguments :: ParamName
ConstrData'memory'arguments :: ParamName
DecodeUtf8'cpu'arguments'intercept :: ParamName
DecodeUtf8'cpu'arguments'slope :: ParamName
DecodeUtf8'memory'arguments'intercept :: ParamName
DecodeUtf8'memory'arguments'slope :: ParamName
DivideInteger'cpu'arguments'constant :: ParamName
DivideInteger'cpu'arguments'model'arguments'intercept :: ParamName
DivideInteger'cpu'arguments'model'arguments'slope :: ParamName
DivideInteger'memory'arguments'intercept :: ParamName
DivideInteger'memory'arguments'minimum :: ParamName
DivideInteger'memory'arguments'slope :: ParamName
EncodeUtf8'cpu'arguments'intercept :: ParamName
EncodeUtf8'cpu'arguments'slope :: ParamName
EncodeUtf8'memory'arguments'intercept :: ParamName
EncodeUtf8'memory'arguments'slope :: ParamName
EqualsByteString'cpu'arguments'constant :: ParamName
EqualsByteString'cpu'arguments'intercept :: ParamName
EqualsByteString'cpu'arguments'slope :: ParamName
EqualsByteString'memory'arguments :: ParamName
EqualsData'cpu'arguments'intercept :: ParamName
EqualsData'cpu'arguments'slope :: ParamName
EqualsData'memory'arguments :: ParamName
EqualsInteger'cpu'arguments'intercept :: ParamName
EqualsInteger'cpu'arguments'slope :: ParamName
EqualsInteger'memory'arguments :: ParamName
EqualsString'cpu'arguments'constant :: ParamName
EqualsString'cpu'arguments'intercept :: ParamName
EqualsString'cpu'arguments'slope :: ParamName
EqualsString'memory'arguments :: ParamName
FstPair'cpu'arguments :: ParamName
FstPair'memory'arguments :: ParamName
HeadList'cpu'arguments :: ParamName
HeadList'memory'arguments :: ParamName
IData'cpu'arguments :: ParamName
IData'memory'arguments :: ParamName
IfThenElse'cpu'arguments :: ParamName
IfThenElse'memory'arguments :: ParamName
IndexByteString'cpu'arguments :: ParamName
IndexByteString'memory'arguments :: ParamName
LengthOfByteString'cpu'arguments :: ParamName
LengthOfByteString'memory'arguments :: ParamName
LessThanByteString'cpu'arguments'intercept :: ParamName
LessThanByteString'cpu'arguments'slope :: ParamName
LessThanByteString'memory'arguments :: ParamName
LessThanEqualsByteString'cpu'arguments'intercept :: ParamName
LessThanEqualsByteString'cpu'arguments'slope :: ParamName
LessThanEqualsByteString'memory'arguments :: ParamName
LessThanEqualsInteger'cpu'arguments'intercept :: ParamName
LessThanEqualsInteger'cpu'arguments'slope :: ParamName
LessThanEqualsInteger'memory'arguments :: ParamName
LessThanInteger'cpu'arguments'intercept :: ParamName
LessThanInteger'cpu'arguments'slope :: ParamName
LessThanInteger'memory'arguments :: ParamName
ListData'cpu'arguments :: ParamName
ListData'memory'arguments :: ParamName
MapData'cpu'arguments :: ParamName
MapData'memory'arguments :: ParamName
MkCons'cpu'arguments :: ParamName
MkCons'memory'arguments :: ParamName
MkNilData'cpu'arguments :: ParamName
MkNilData'memory'arguments :: ParamName
MkNilPairData'cpu'arguments :: ParamName
MkNilPairData'memory'arguments :: ParamName
MkPairData'cpu'arguments :: ParamName
MkPairData'memory'arguments :: ParamName
ModInteger'cpu'arguments'constant :: ParamName
ModInteger'cpu'arguments'model'arguments'intercept :: ParamName
ModInteger'cpu'arguments'model'arguments'slope :: ParamName
ModInteger'memory'arguments'intercept :: ParamName
ModInteger'memory'arguments'minimum :: ParamName
ModInteger'memory'arguments'slope :: ParamName
MultiplyInteger'cpu'arguments'intercept :: ParamName
MultiplyInteger'cpu'arguments'slope :: ParamName
MultiplyInteger'memory'arguments'intercept :: ParamName
MultiplyInteger'memory'arguments'slope :: ParamName
NullList'cpu'arguments :: ParamName
NullList'memory'arguments :: ParamName
QuotientInteger'cpu'arguments'constant :: ParamName
QuotientInteger'cpu'arguments'model'arguments'intercept :: ParamName
QuotientInteger'cpu'arguments'model'arguments'slope :: ParamName
QuotientInteger'memory'arguments'intercept :: ParamName
QuotientInteger'memory'arguments'minimum :: ParamName
QuotientInteger'memory'arguments'slope :: ParamName
RemainderInteger'cpu'arguments'constant :: ParamName
RemainderInteger'cpu'arguments'model'arguments'intercept :: ParamName
RemainderInteger'cpu'arguments'model'arguments'slope :: ParamName
RemainderInteger'memory'arguments'intercept :: ParamName
RemainderInteger'memory'arguments'minimum :: ParamName
RemainderInteger'memory'arguments'slope :: ParamName
SerialiseData'cpu'arguments'intercept :: ParamName
SerialiseData'cpu'arguments'slope :: ParamName
SerialiseData'memory'arguments'intercept :: ParamName
SerialiseData'memory'arguments'slope :: ParamName
Sha2_256'cpu'arguments'intercept :: ParamName
Sha2_256'cpu'arguments'slope :: ParamName
Sha2_256'memory'arguments :: ParamName
Sha3_256'cpu'arguments'intercept :: ParamName
Sha3_256'cpu'arguments'slope :: ParamName
Sha3_256'memory'arguments :: ParamName
SliceByteString'cpu'arguments'intercept :: ParamName
SliceByteString'cpu'arguments'slope :: ParamName
SliceByteString'memory'arguments'intercept :: ParamName
SliceByteString'memory'arguments'slope :: ParamName
SndPair'cpu'arguments :: ParamName
SndPair'memory'arguments :: ParamName
SubtractInteger'cpu'arguments'intercept :: ParamName
SubtractInteger'cpu'arguments'slope :: ParamName
SubtractInteger'memory'arguments'intercept :: ParamName
SubtractInteger'memory'arguments'slope :: ParamName
TailList'cpu'arguments :: ParamName
TailList'memory'arguments :: ParamName
Trace'cpu'arguments :: ParamName
Trace'memory'arguments :: ParamName
UnBData'cpu'arguments :: ParamName
UnBData'memory'arguments :: ParamName
UnConstrData'cpu'arguments :: ParamName
UnConstrData'memory'arguments :: ParamName
UnIData'cpu'arguments :: ParamName
UnIData'memory'arguments :: ParamName
UnListData'cpu'arguments :: ParamName
UnListData'memory'arguments :: ParamName
UnMapData'cpu'arguments :: ParamName
UnMapData'memory'arguments :: ParamName
VerifyEcdsaSecp256k1Signature'cpu'arguments :: ParamName
VerifyEcdsaSecp256k1Signature'memory'arguments :: ParamName
VerifyEd25519Signature'cpu'arguments'intercept :: ParamName
VerifyEd25519Signature'cpu'arguments'slope :: ParamName
VerifyEd25519Signature'memory'arguments :: ParamName
VerifySchnorrSecp256k1Signature'cpu'arguments'intercept :: ParamName
VerifySchnorrSecp256k1Signature'cpu'arguments'slope :: ParamName
VerifySchnorrSecp256k1Signature'memory'arguments :: ParamName
IntegerToByteString'cpu'arguments'c0 :: ParamName
IntegerToByteString'cpu'arguments'c1 :: ParamName
IntegerToByteString'cpu'arguments'c2 :: ParamName
IntegerToByteString'memory'arguments'intercept :: ParamName
IntegerToByteString'memory'arguments'slope :: ParamName
ByteStringToInteger'cpu'arguments'c0 :: ParamName
ByteStringToInteger'cpu'arguments'c1 :: ParamName
ByteStringToInteger'cpu'arguments'c2 :: ParamName
ByteStringToInteger'memory'arguments'intercept :: ParamName
ByteStringToInteger'memory'arguments'slope :: ParamName

-- | Given an ordered list of parameter values, tag them with their
--   parameter names. If the passed parameter values are more than
--   expected: the function will ignore the extraneous values at the tail
--   of the list, if the passed values are less than expected: the function
--   will throw an error; for more information, see Note [Cost model
--   parameters from the ledger's point of view]
tagWithParamNames :: forall k m. (Enum k, Bounded k, MonadError CostModelApplyError m, MonadWriter [CostModelApplyWarn] m) => [Int64] -> m [(k, Int64)]
instance PlutusLedgerApi.Common.ParamName.IsParamName PlutusLedgerApi.V2.ParamName.ParamName
instance GHC.Generics.Generic PlutusLedgerApi.V2.ParamName.ParamName
instance GHC.Enum.Bounded PlutusLedgerApi.V2.ParamName.ParamName
instance GHC.Ix.Ix PlutusLedgerApi.V2.ParamName.ParamName
instance GHC.Enum.Enum PlutusLedgerApi.V2.ParamName.ParamName
instance GHC.Classes.Ord PlutusLedgerApi.V2.ParamName.ParamName
instance GHC.Classes.Eq PlutusLedgerApi.V2.ParamName.ParamName

module PlutusLedgerApi.V2.EvaluationContext

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than being recomputed on every
--   evaluation.
--   
--   Different protocol versions may require different bundles of machine
--   parameters, which allows us for example to tweak the shape of the
--   costing function of a builtin, so that the builtin costs less.
--   Currently this means that we have to create multiple
--   <a>DefaultMachineParameters</a> per language version, which we put
--   into a cache (represented by an association list) in order to avoid
--   costly recomputation of machine parameters.
--   
--   In order to get the appropriate <a>DefaultMachineParameters</a> at
--   validation time we look it up in the cache using a semantics variant
--   as a key. We compute the semantics variant from the protocol version
--   using the stored function. Note that the semantics variant depends on
--   the language version too, but the latter is known statically (because
--   each language version has its own evaluation context), hence there's
--   no reason to require it to be provided at runtime.
--   
--   To say it differently, there's a matrix of semantics variants indexed
--   by (LL, PV) pairs and we cache its particular row corresponding to the
--   statically given LL in an <a>EvaluationContext</a>.
--   
--   The reason why we associate a <a>DefaultMachineParameters</a> with a
--   semantics variant rather than a protocol version are
--   
--   <ol>
--   <li>generally there are far more protocol versions than semantics
--   variants supported by a specific language version, so we save on
--   pointless duplication of bundles of machine parameters</li>
--   <li>builtins don't know anything about protocol versions, only
--   semantics variants. It is therefore more semantically precise to
--   associate bundles of machine parameters with semantics variants than
--   with protocol versions</li>
--   </ol>
data EvaluationContext

-- | Build the <a>EvaluationContext</a>.
--   
--   The input is a list of cost model parameters (which are integer
--   values) passed from the ledger.
--   
--   IMPORTANT: the cost model parameters <b>MUST</b> appear in the correct
--   order, matching the names in <a>ParamName</a>. If the parameters are
--   supplied in the wrong order then script cost calculations will be
--   incorrect.
--   
--   IMPORTANT: The evaluation context of every Plutus version must be
--   recreated upon a protocol update with the updated cost model
--   parameters.
mkEvaluationContext :: (MonadError CostModelApplyError m, MonadWriter [CostModelApplyWarn] m) => [Int64] -> m EvaluationContext
type CostModelParams = Map Text Int64
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()
toMachineParameters :: MajorProtocolVersion -> EvaluationContext -> DefaultMachineParameters
data () => CostModelApplyError
CMUnknownParamError :: !Text -> CostModelApplyError
CMInternalReadError :: CostModelApplyError
CMInternalWriteError :: !String -> CostModelApplyError

module PlutusLedgerApi.V3.ParamName

-- | The enumeration of all possible cost model parameter names for this
--   language version.
--   
--   IMPORTANT: The order of appearance of the data constructors here
--   matters. DO NOT REORDER. See Note [Quotation marks in cost model
--   parameter constructors] See Note [Cost model parameters from the
--   ledger's point of view]
data ParamName
AddInteger'cpu'arguments'intercept :: ParamName
AddInteger'cpu'arguments'slope :: ParamName
AddInteger'memory'arguments'intercept :: ParamName
AddInteger'memory'arguments'slope :: ParamName
AppendByteString'cpu'arguments'intercept :: ParamName
AppendByteString'cpu'arguments'slope :: ParamName
AppendByteString'memory'arguments'intercept :: ParamName
AppendByteString'memory'arguments'slope :: ParamName
AppendString'cpu'arguments'intercept :: ParamName
AppendString'cpu'arguments'slope :: ParamName
AppendString'memory'arguments'intercept :: ParamName
AppendString'memory'arguments'slope :: ParamName
BData'cpu'arguments :: ParamName
BData'memory'arguments :: ParamName
Blake2b_256'cpu'arguments'intercept :: ParamName
Blake2b_256'cpu'arguments'slope :: ParamName
Blake2b_256'memory'arguments :: ParamName
CekApplyCost'exBudgetCPU :: ParamName
CekApplyCost'exBudgetMemory :: ParamName
CekBuiltinCost'exBudgetCPU :: ParamName
CekBuiltinCost'exBudgetMemory :: ParamName
CekConstCost'exBudgetCPU :: ParamName
CekConstCost'exBudgetMemory :: ParamName
CekDelayCost'exBudgetCPU :: ParamName
CekDelayCost'exBudgetMemory :: ParamName
CekForceCost'exBudgetCPU :: ParamName
CekForceCost'exBudgetMemory :: ParamName
CekLamCost'exBudgetCPU :: ParamName
CekLamCost'exBudgetMemory :: ParamName
CekStartupCost'exBudgetCPU :: ParamName
CekStartupCost'exBudgetMemory :: ParamName
CekVarCost'exBudgetCPU :: ParamName
CekVarCost'exBudgetMemory :: ParamName
ChooseData'cpu'arguments :: ParamName
ChooseData'memory'arguments :: ParamName
ChooseList'cpu'arguments :: ParamName
ChooseList'memory'arguments :: ParamName
ChooseUnit'cpu'arguments :: ParamName
ChooseUnit'memory'arguments :: ParamName
ConsByteString'cpu'arguments'intercept :: ParamName
ConsByteString'cpu'arguments'slope :: ParamName
ConsByteString'memory'arguments'intercept :: ParamName
ConsByteString'memory'arguments'slope :: ParamName
ConstrData'cpu'arguments :: ParamName
ConstrData'memory'arguments :: ParamName
DecodeUtf8'cpu'arguments'intercept :: ParamName
DecodeUtf8'cpu'arguments'slope :: ParamName
DecodeUtf8'memory'arguments'intercept :: ParamName
DecodeUtf8'memory'arguments'slope :: ParamName
DivideInteger'cpu'arguments'constant :: ParamName
DivideInteger'cpu'arguments'model'arguments'c00 :: ParamName
DivideInteger'cpu'arguments'model'arguments'c01 :: ParamName
DivideInteger'cpu'arguments'model'arguments'c02 :: ParamName
DivideInteger'cpu'arguments'model'arguments'c10 :: ParamName
DivideInteger'cpu'arguments'model'arguments'c11 :: ParamName
DivideInteger'cpu'arguments'model'arguments'c20 :: ParamName
DivideInteger'cpu'arguments'model'arguments'minimum :: ParamName
DivideInteger'memory'arguments'intercept :: ParamName
DivideInteger'memory'arguments'minimum :: ParamName
DivideInteger'memory'arguments'slope :: ParamName
EncodeUtf8'cpu'arguments'intercept :: ParamName
EncodeUtf8'cpu'arguments'slope :: ParamName
EncodeUtf8'memory'arguments'intercept :: ParamName
EncodeUtf8'memory'arguments'slope :: ParamName
EqualsByteString'cpu'arguments'constant :: ParamName
EqualsByteString'cpu'arguments'intercept :: ParamName
EqualsByteString'cpu'arguments'slope :: ParamName
EqualsByteString'memory'arguments :: ParamName
EqualsData'cpu'arguments'intercept :: ParamName
EqualsData'cpu'arguments'slope :: ParamName
EqualsData'memory'arguments :: ParamName
EqualsInteger'cpu'arguments'intercept :: ParamName
EqualsInteger'cpu'arguments'slope :: ParamName
EqualsInteger'memory'arguments :: ParamName
EqualsString'cpu'arguments'constant :: ParamName
EqualsString'cpu'arguments'intercept :: ParamName
EqualsString'cpu'arguments'slope :: ParamName
EqualsString'memory'arguments :: ParamName
FstPair'cpu'arguments :: ParamName
FstPair'memory'arguments :: ParamName
HeadList'cpu'arguments :: ParamName
HeadList'memory'arguments :: ParamName
IData'cpu'arguments :: ParamName
IData'memory'arguments :: ParamName
IfThenElse'cpu'arguments :: ParamName
IfThenElse'memory'arguments :: ParamName
IndexByteString'cpu'arguments :: ParamName
IndexByteString'memory'arguments :: ParamName
LengthOfByteString'cpu'arguments :: ParamName
LengthOfByteString'memory'arguments :: ParamName
LessThanByteString'cpu'arguments'intercept :: ParamName
LessThanByteString'cpu'arguments'slope :: ParamName
LessThanByteString'memory'arguments :: ParamName
LessThanEqualsByteString'cpu'arguments'intercept :: ParamName
LessThanEqualsByteString'cpu'arguments'slope :: ParamName
LessThanEqualsByteString'memory'arguments :: ParamName
LessThanEqualsInteger'cpu'arguments'intercept :: ParamName
LessThanEqualsInteger'cpu'arguments'slope :: ParamName
LessThanEqualsInteger'memory'arguments :: ParamName
LessThanInteger'cpu'arguments'intercept :: ParamName
LessThanInteger'cpu'arguments'slope :: ParamName
LessThanInteger'memory'arguments :: ParamName
ListData'cpu'arguments :: ParamName
ListData'memory'arguments :: ParamName
MapData'cpu'arguments :: ParamName
MapData'memory'arguments :: ParamName
MkCons'cpu'arguments :: ParamName
MkCons'memory'arguments :: ParamName
MkNilData'cpu'arguments :: ParamName
MkNilData'memory'arguments :: ParamName
MkNilPairData'cpu'arguments :: ParamName
MkNilPairData'memory'arguments :: ParamName
MkPairData'cpu'arguments :: ParamName
MkPairData'memory'arguments :: ParamName
ModInteger'cpu'arguments'constant :: ParamName
ModInteger'cpu'arguments'model'arguments'c00 :: ParamName
ModInteger'cpu'arguments'model'arguments'c01 :: ParamName
ModInteger'cpu'arguments'model'arguments'c02 :: ParamName
ModInteger'cpu'arguments'model'arguments'c10 :: ParamName
ModInteger'cpu'arguments'model'arguments'c11 :: ParamName
ModInteger'cpu'arguments'model'arguments'c20 :: ParamName
ModInteger'cpu'arguments'model'arguments'minimum :: ParamName
ModInteger'memory'arguments'intercept :: ParamName
ModInteger'memory'arguments'slope :: ParamName
MultiplyInteger'cpu'arguments'intercept :: ParamName
MultiplyInteger'cpu'arguments'slope :: ParamName
MultiplyInteger'memory'arguments'intercept :: ParamName
MultiplyInteger'memory'arguments'slope :: ParamName
NullList'cpu'arguments :: ParamName
NullList'memory'arguments :: ParamName
QuotientInteger'cpu'arguments'constant :: ParamName
QuotientInteger'cpu'arguments'model'arguments'c00 :: ParamName
QuotientInteger'cpu'arguments'model'arguments'c01 :: ParamName
QuotientInteger'cpu'arguments'model'arguments'c02 :: ParamName
QuotientInteger'cpu'arguments'model'arguments'c10 :: ParamName
QuotientInteger'cpu'arguments'model'arguments'c11 :: ParamName
QuotientInteger'cpu'arguments'model'arguments'c20 :: ParamName
QuotientInteger'cpu'arguments'model'arguments'minimum :: ParamName
QuotientInteger'memory'arguments'intercept :: ParamName
QuotientInteger'memory'arguments'minimum :: ParamName
QuotientInteger'memory'arguments'slope :: ParamName
RemainderInteger'cpu'arguments'constant :: ParamName
RemainderInteger'cpu'arguments'model'arguments'c00 :: ParamName
RemainderInteger'cpu'arguments'model'arguments'c01 :: ParamName
RemainderInteger'cpu'arguments'model'arguments'c02 :: ParamName
RemainderInteger'cpu'arguments'model'arguments'c10 :: ParamName
RemainderInteger'cpu'arguments'model'arguments'c11 :: ParamName
RemainderInteger'cpu'arguments'model'arguments'c20 :: ParamName
RemainderInteger'cpu'arguments'model'arguments'minimum :: ParamName
RemainderInteger'memory'arguments'intercept :: ParamName
RemainderInteger'memory'arguments'slope :: ParamName
SerialiseData'cpu'arguments'intercept :: ParamName
SerialiseData'cpu'arguments'slope :: ParamName
SerialiseData'memory'arguments'intercept :: ParamName
SerialiseData'memory'arguments'slope :: ParamName
Sha2_256'cpu'arguments'intercept :: ParamName
Sha2_256'cpu'arguments'slope :: ParamName
Sha2_256'memory'arguments :: ParamName
Sha3_256'cpu'arguments'intercept :: ParamName
Sha3_256'cpu'arguments'slope :: ParamName
Sha3_256'memory'arguments :: ParamName
SliceByteString'cpu'arguments'intercept :: ParamName
SliceByteString'cpu'arguments'slope :: ParamName
SliceByteString'memory'arguments'intercept :: ParamName
SliceByteString'memory'arguments'slope :: ParamName
SndPair'cpu'arguments :: ParamName
SndPair'memory'arguments :: ParamName
SubtractInteger'cpu'arguments'intercept :: ParamName
SubtractInteger'cpu'arguments'slope :: ParamName
SubtractInteger'memory'arguments'intercept :: ParamName
SubtractInteger'memory'arguments'slope :: ParamName
TailList'cpu'arguments :: ParamName
TailList'memory'arguments :: ParamName
Trace'cpu'arguments :: ParamName
Trace'memory'arguments :: ParamName
UnBData'cpu'arguments :: ParamName
UnBData'memory'arguments :: ParamName
UnConstrData'cpu'arguments :: ParamName
UnConstrData'memory'arguments :: ParamName
UnIData'cpu'arguments :: ParamName
UnIData'memory'arguments :: ParamName
UnListData'cpu'arguments :: ParamName
UnListData'memory'arguments :: ParamName
UnMapData'cpu'arguments :: ParamName
UnMapData'memory'arguments :: ParamName
VerifyEcdsaSecp256k1Signature'cpu'arguments :: ParamName
VerifyEcdsaSecp256k1Signature'memory'arguments :: ParamName
VerifyEd25519Signature'cpu'arguments'intercept :: ParamName
VerifyEd25519Signature'cpu'arguments'slope :: ParamName
VerifyEd25519Signature'memory'arguments :: ParamName
VerifySchnorrSecp256k1Signature'cpu'arguments'intercept :: ParamName
VerifySchnorrSecp256k1Signature'cpu'arguments'slope :: ParamName
VerifySchnorrSecp256k1Signature'memory'arguments :: ParamName
CekConstrCost'exBudgetCPU :: ParamName
CekConstrCost'exBudgetMemory :: ParamName
CekCaseCost'exBudgetCPU :: ParamName
CekCaseCost'exBudgetMemory :: ParamName
Bls12_381_G1_add'cpu'arguments :: ParamName
Bls12_381_G1_add'memory'arguments :: ParamName
Bls12_381_G1_compress'cpu'arguments :: ParamName
Bls12_381_G1_compress'memory'arguments :: ParamName
Bls12_381_G1_equal'cpu'arguments :: ParamName
Bls12_381_G1_equal'memory'arguments :: ParamName
Bls12_381_G1_hashToGroup'cpu'arguments'intercept :: ParamName
Bls12_381_G1_hashToGroup'cpu'arguments'slope :: ParamName
Bls12_381_G1_hashToGroup'memory'arguments :: ParamName
Bls12_381_G1_neg'cpu'arguments :: ParamName
Bls12_381_G1_neg'memory'arguments :: ParamName
Bls12_381_G1_scalarMul'cpu'arguments'intercept :: ParamName
Bls12_381_G1_scalarMul'cpu'arguments'slope :: ParamName
Bls12_381_G1_scalarMul'memory'arguments :: ParamName
Bls12_381_G1_uncompress'cpu'arguments :: ParamName
Bls12_381_G1_uncompress'memory'arguments :: ParamName
Bls12_381_G2_add'cpu'arguments :: ParamName
Bls12_381_G2_add'memory'arguments :: ParamName
Bls12_381_G2_compress'cpu'arguments :: ParamName
Bls12_381_G2_compress'memory'arguments :: ParamName
Bls12_381_G2_equal'cpu'arguments :: ParamName
Bls12_381_G2_equal'memory'arguments :: ParamName
Bls12_381_G2_hashToGroup'cpu'arguments'intercept :: ParamName
Bls12_381_G2_hashToGroup'cpu'arguments'slope :: ParamName
Bls12_381_G2_hashToGroup'memory'arguments :: ParamName
Bls12_381_G2_neg'cpu'arguments :: ParamName
Bls12_381_G2_neg'memory'arguments :: ParamName
Bls12_381_G2_scalarMul'cpu'arguments'intercept :: ParamName
Bls12_381_G2_scalarMul'cpu'arguments'slope :: ParamName
Bls12_381_G2_scalarMul'memory'arguments :: ParamName
Bls12_381_G2_uncompress'cpu'arguments :: ParamName
Bls12_381_G2_uncompress'memory'arguments :: ParamName
Bls12_381_finalVerify'cpu'arguments :: ParamName
Bls12_381_finalVerify'memory'arguments :: ParamName
Bls12_381_millerLoop'cpu'arguments :: ParamName
Bls12_381_millerLoop'memory'arguments :: ParamName
Bls12_381_mulMlResult'cpu'arguments :: ParamName
Bls12_381_mulMlResult'memory'arguments :: ParamName
Keccak_256'cpu'arguments'intercept :: ParamName
Keccak_256'cpu'arguments'slope :: ParamName
Keccak_256'memory'arguments :: ParamName
Blake2b_224'cpu'arguments'intercept :: ParamName
Blake2b_224'cpu'arguments'slope :: ParamName
Blake2b_224'memory'arguments :: ParamName
IntegerToByteString'cpu'arguments'c0 :: ParamName
IntegerToByteString'cpu'arguments'c1 :: ParamName
IntegerToByteString'cpu'arguments'c2 :: ParamName
IntegerToByteString'memory'arguments'intercept :: ParamName
IntegerToByteString'memory'arguments'slope :: ParamName
ByteStringToInteger'cpu'arguments'c0 :: ParamName
ByteStringToInteger'cpu'arguments'c1 :: ParamName
ByteStringToInteger'cpu'arguments'c2 :: ParamName
ByteStringToInteger'memory'arguments'intercept :: ParamName
ByteStringToInteger'memory'arguments'slope :: ParamName
AndByteString'cpu'arguments'intercept :: ParamName
AndByteString'cpu'arguments'slope1 :: ParamName
AndByteString'cpu'arguments'slope2 :: ParamName
AndByteString'memory'arguments'intercept :: ParamName
AndByteString'memory'arguments'slope :: ParamName
OrByteString'cpu'arguments'intercept :: ParamName
OrByteString'cpu'arguments'slope1 :: ParamName
OrByteString'cpu'arguments'slope2 :: ParamName
OrByteString'memory'arguments'intercept :: ParamName
OrByteString'memory'arguments'slope :: ParamName
XorByteString'cpu'arguments'intercept :: ParamName
XorByteString'cpu'arguments'slope1 :: ParamName
XorByteString'cpu'arguments'slope2 :: ParamName
XorByteString'memory'arguments'intercept :: ParamName
XorByteString'memory'arguments'slope :: ParamName
ComplementByteString'cpu'arguments'intercept :: ParamName
ComplementByteString'cpu'arguments'slope :: ParamName
ComplementByteString'memory'arguments'intercept :: ParamName
ComplementByteString'memory'arguments'slope :: ParamName
ReadBit'cpu'arguments :: ParamName
ReadBit'memory'arguments :: ParamName
WriteBits'cpu'arguments'intercept :: ParamName
WriteBits'cpu'arguments'slope :: ParamName
WriteBits'memory'arguments'intercept :: ParamName
WriteBits'memory'arguments'slope :: ParamName
ReplicateByte'cpu'arguments'intercept :: ParamName
ReplicateByte'cpu'arguments'slope :: ParamName
ReplicateByte'memory'arguments'intercept :: ParamName
ReplicateByte'memory'arguments'slope :: ParamName
ShiftByteString'cpu'arguments'intercept :: ParamName
ShiftByteString'cpu'arguments'slope :: ParamName
ShiftByteString'memory'arguments'intercept :: ParamName
ShiftByteString'memory'arguments'slope :: ParamName
RotateByteString'cpu'arguments'intercept :: ParamName
RotateByteString'cpu'arguments'slope :: ParamName
RotateByteString'memory'arguments'intercept :: ParamName
RotateByteString'memory'arguments'slope :: ParamName
CountSetBits'cpu'arguments'intercept :: ParamName
CountSetBits'cpu'arguments'slope :: ParamName
CountSetBits'memory'arguments :: ParamName
FindFirstSetBit'cpu'arguments'intercept :: ParamName
FindFirstSetBit'cpu'arguments'slope :: ParamName
FindFirstSetBit'memory'arguments :: ParamName
Ripemd_160'cpu'arguments'intercept :: ParamName
Ripemd_160'cpu'arguments'slope :: ParamName
Ripemd_160'memory'arguments :: ParamName

-- | Given an ordered list of parameter values, tag them with their
--   parameter names. If the passed parameter values are more than
--   expected: the function will ignore the extraneous values at the tail
--   of the list, if the passed values are less than expected: the function
--   will throw an error; for more information, see Note [Cost model
--   parameters from the ledger's point of view]
tagWithParamNames :: forall k m. (Enum k, Bounded k, MonadError CostModelApplyError m, MonadWriter [CostModelApplyWarn] m) => [Int64] -> m [(k, Int64)]
instance PlutusLedgerApi.Common.ParamName.IsParamName PlutusLedgerApi.V3.ParamName.ParamName
instance GHC.Generics.Generic PlutusLedgerApi.V3.ParamName.ParamName
instance GHC.Enum.Bounded PlutusLedgerApi.V3.ParamName.ParamName
instance GHC.Ix.Ix PlutusLedgerApi.V3.ParamName.ParamName
instance GHC.Enum.Enum PlutusLedgerApi.V3.ParamName.ParamName
instance GHC.Classes.Ord PlutusLedgerApi.V3.ParamName.ParamName
instance GHC.Classes.Eq PlutusLedgerApi.V3.ParamName.ParamName

module PlutusLedgerApi.V3.EvaluationContext

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than being recomputed on every
--   evaluation.
--   
--   Different protocol versions may require different bundles of machine
--   parameters, which allows us for example to tweak the shape of the
--   costing function of a builtin, so that the builtin costs less.
--   Currently this means that we have to create multiple
--   <a>DefaultMachineParameters</a> per language version, which we put
--   into a cache (represented by an association list) in order to avoid
--   costly recomputation of machine parameters.
--   
--   In order to get the appropriate <a>DefaultMachineParameters</a> at
--   validation time we look it up in the cache using a semantics variant
--   as a key. We compute the semantics variant from the protocol version
--   using the stored function. Note that the semantics variant depends on
--   the language version too, but the latter is known statically (because
--   each language version has its own evaluation context), hence there's
--   no reason to require it to be provided at runtime.
--   
--   To say it differently, there's a matrix of semantics variants indexed
--   by (LL, PV) pairs and we cache its particular row corresponding to the
--   statically given LL in an <a>EvaluationContext</a>.
--   
--   The reason why we associate a <a>DefaultMachineParameters</a> with a
--   semantics variant rather than a protocol version are
--   
--   <ol>
--   <li>generally there are far more protocol versions than semantics
--   variants supported by a specific language version, so we save on
--   pointless duplication of bundles of machine parameters</li>
--   <li>builtins don't know anything about protocol versions, only
--   semantics variants. It is therefore more semantically precise to
--   associate bundles of machine parameters with semantics variants than
--   with protocol versions</li>
--   </ol>
data EvaluationContext

-- | Build the <a>EvaluationContext</a>.
--   
--   The input is a list of cost model parameters (which are integer
--   values) passed from the ledger.
--   
--   IMPORTANT: the cost model parameters <b>MUST</b> appear in the correct
--   order, matching the names in <a>ParamName</a>. If the parameters are
--   supplied in the wrong order then script cost calculations will be
--   incorrect.
--   
--   IMPORTANT: The evaluation context of every Plutus version must be
--   recreated upon a protocol update with the updated cost model
--   parameters.
mkEvaluationContext :: (MonadError CostModelApplyError m, MonadWriter [CostModelApplyWarn] m) => [Int64] -> m EvaluationContext
type CostModelParams = Map Text Int64
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()
toMachineParameters :: MajorProtocolVersion -> EvaluationContext -> DefaultMachineParameters
data () => CostModelApplyError
CMUnknownParamError :: !Text -> CostModelApplyError
CMInternalReadError :: CostModelApplyError
CMInternalWriteError :: !String -> CostModelApplyError

module PlutusLedgerApi.V1.Bytes
newtype LedgerBytes
LedgerBytes :: BuiltinByteString -> LedgerBytes
[getLedgerBytes] :: LedgerBytes -> BuiltinByteString

-- | An error that is encountered when converting a <tt>ByteString</tt> to
--   a <a>LedgerBytes</a>.
data LedgerBytesError

-- | Odd number of bytes in the original bytestring.
UnpairedDigit :: LedgerBytesError

-- | A non-hex digit character ([^A-Fa-f0-9]) encountered during decoding.
NotHexit :: !Char -> LedgerBytesError

-- | Convert a hex-encoded (Base16) <tt>ByteString</tt> to a
--   <a>LedgerBytes</a>. May return an error (<a>LedgerBytesError</a>).
fromHex :: ByteString -> Either LedgerBytesError LedgerBytes

-- | Extract the Haskell bytestring from inside the Plutus opaque
--   <a>LedgerBytes</a>.
bytes :: LedgerBytes -> ByteString

-- | Lift a Haskell bytestring to the Plutus abstraction <a>LedgerBytes</a>
fromBytes :: ByteString -> LedgerBytes

-- | Encode a ByteString value to Base16 (i.e. hexadecimal), then decode
--   with UTF-8 to a <tt>Text</tt>.
encodeByteString :: ByteString -> Text
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Bytes.LedgerBytes
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Bytes.LedgerBytes
instance GHC.Exception.Type.Exception PlutusLedgerApi.V1.Bytes.LedgerBytesError
instance GHC.Show.Show PlutusLedgerApi.V1.Bytes.LedgerBytesError
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Bytes.LedgerBytes
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Bytes.LedgerBytes
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Bytes.LedgerBytes
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Bytes.LedgerBytes
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Bytes.LedgerBytes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Bytes.LedgerBytes
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Bytes.LedgerBytes
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Bytes.LedgerBytes
instance GHC.Generics.Generic PlutusLedgerApi.V1.Bytes.LedgerBytes
instance GHC.Classes.Ord PlutusLedgerApi.V1.Bytes.LedgerBytes
instance GHC.Classes.Eq PlutusLedgerApi.V1.Bytes.LedgerBytes
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Bytes.LedgerBytes referencedTypes
instance Data.String.IsString PlutusLedgerApi.V1.Bytes.LedgerBytes
instance GHC.Show.Show PlutusLedgerApi.V1.Bytes.LedgerBytes

module PlutusLedgerApi.V3.Tx

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the Shelley ledger
--   specification.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Tx.TxOutRef
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Tx.TxOutRef
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Tx.TxId referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition GHC.Num.Integer.Integer referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Tx.TxOutRef referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Tx.TxOutRef
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Tx.TxOutRef
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Tx.TxOutRef
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Tx.TxId
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Tx.TxId
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Tx.TxId
instance GHC.Show.Show PlutusLedgerApi.V3.Tx.TxId
instance Data.String.IsString PlutusLedgerApi.V3.Tx.TxId
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Tx.TxId
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Tx.TxId
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Tx.TxId
instance PlutusTx.Ord.Ord PlutusLedgerApi.V3.Tx.TxId
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Tx.TxId
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Tx.TxId
instance Control.DeepSeq.NFData PlutusLedgerApi.V3.Tx.TxId
instance GHC.Generics.Generic PlutusLedgerApi.V3.Tx.TxId
instance GHC.Classes.Ord PlutusLedgerApi.V3.Tx.TxId
instance GHC.Classes.Eq PlutusLedgerApi.V3.Tx.TxId
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Tx.TxOutRef
instance Control.DeepSeq.NFData PlutusLedgerApi.V3.Tx.TxOutRef
instance GHC.Generics.Generic PlutusLedgerApi.V3.Tx.TxOutRef
instance GHC.Classes.Ord PlutusLedgerApi.V3.Tx.TxOutRef
instance GHC.Classes.Eq PlutusLedgerApi.V3.Tx.TxOutRef
instance GHC.Show.Show PlutusLedgerApi.V3.Tx.TxOutRef
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Tx.TxOutRef
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Tx.TxOutRef
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Tx.TxId referencedTypes


-- | Functions for working with <a>Value</a>.
module PlutusLedgerApi.V1.Value

-- | ByteString representing the currency, hashed with <i>BLAKE2b-224</i>.
--   It is empty for <tt>Ada</tt>, 28 bytes for <tt>MintingPolicyHash</tt>.
--   Forms an <a>AssetClass</a> along with <a>TokenName</a>. A <a>Value</a>
--   is a map from <a>CurrencySymbol</a>'s to a map from <a>TokenName</a>
--   to an <a>Integer</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype CurrencySymbol
CurrencySymbol :: BuiltinByteString -> CurrencySymbol
[unCurrencySymbol] :: CurrencySymbol -> BuiltinByteString

-- | Creates <a>CurrencySymbol</a> from raw <tt>ByteString</tt>.
currencySymbol :: ByteString -> CurrencySymbol

-- | The <a>CurrencySymbol</a> of the <tt>Ada</tt> currency.
adaSymbol :: CurrencySymbol

-- | ByteString of a name of a token. Shown as UTF-8 string when possible.
--   Should be no longer than 32 bytes, empty for Ada. Forms an
--   <a>AssetClass</a> along with a <a>CurrencySymbol</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TokenName
TokenName :: BuiltinByteString -> TokenName
[unTokenName] :: TokenName -> BuiltinByteString

-- | Creates <a>TokenName</a> from raw <a>ByteString</a>.
tokenName :: ByteString -> TokenName

-- | Turn a TokenName to a hex-encoded <tt>String</tt>
--   
--   Compared to <tt>show</tt> , it will not surround the string with
--   double-quotes.
toString :: TokenName -> String

-- | The <a>TokenName</a> of the <tt>Ada</tt> currency.
adaToken :: TokenName

-- | An asset class, identified by a <a>CurrencySymbol</a> and a
--   <a>TokenName</a>.
newtype AssetClass
AssetClass :: (CurrencySymbol, TokenName) -> AssetClass
[unAssetClass] :: AssetClass -> (CurrencySymbol, TokenName)

-- | The curried version of <a>AssetClass</a> constructor
assetClass :: CurrencySymbol -> TokenName -> AssetClass

-- | A <a>Value</a> containing the given amount of the asset class.
assetClassValue :: AssetClass -> Integer -> Value

-- | Get the quantity of the given <a>AssetClass</a> class in the
--   <a>Value</a>.
assetClassValueOf :: Value -> AssetClass -> Integer

-- | The <a>Value</a> type represents a collection of amounts of different
--   currencies. We can think of <a>Value</a> as a vector space whose
--   dimensions are currencies.
--   
--   Operations on currencies are usually implemented <i>pointwise</i>.
--   That is, we apply the operation to the quantities for each currency in
--   turn. So when we add two <a>Value</a>s the resulting <a>Value</a> has,
--   for each currency, the sum of the quantities of <i>that particular</i>
--   currency in the argument <a>Value</a>. The effect of this is that the
--   currencies in the <a>Value</a> are "independent", and are operated on
--   separately.
--   
--   Whenever we need to get the quantity of a currency in a <a>Value</a>
--   where there is no explicit quantity of that currency in the
--   <a>Value</a>, then the quantity is taken to be zero.
--   
--   There is no 'Ord Value' instance since <a>Value</a> is only a partial
--   order, so <a>compare</a> can't do the right thing in some cases.
newtype Value
Value :: Map CurrencySymbol (Map TokenName Integer) -> Value
[getValue] :: Value -> Map CurrencySymbol (Map TokenName Integer)

-- | Make a <a>Value</a> containing only the given quantity of the given
--   currency.
singleton :: CurrencySymbol -> TokenName -> Integer -> Value

-- | Get the quantity of the given currency in the <a>Value</a>. Assumes
--   that the underlying map doesn't contain duplicate keys.
valueOf :: Value -> CurrencySymbol -> TokenName -> Integer

-- | Get the total value of the currency symbol in the <a>Value</a> map.
--   Assumes that the underlying map doesn't contain duplicate keys.
--   
--   Note that each token of the currency symbol may have a value that is
--   positive, zero or negative.
currencySymbolValueOf :: Value -> CurrencySymbol -> Integer

-- | A <a>Value</a> containing the given quantity of Lovelace.
lovelaceValue :: Lovelace -> Value

-- | Get the quantity of Lovelace in the <a>Value</a>.
lovelaceValueOf :: Value -> Lovelace
scale :: Module s v => s -> v -> v

-- | The list of <a>CurrencySymbol</a>s of a <a>Value</a>.
symbols :: Value -> [CurrencySymbol]

-- | Check whether one <a>Value</a> is greater than or equal to another.
--   See <a>Value</a> for an explanation of how operations on <a>Value</a>s
--   work.
geq :: Value -> Value -> Bool

-- | Check whether one <a>Value</a> is strictly greater than another. This
--   is *not* a pointwise operation. <tt>gt l r</tt> means <tt>geq l r
--   &amp;&amp; not (eq l r)</tt>.
gt :: Value -> Value -> Bool

-- | Check whether one <a>Value</a> is less than or equal to another. See
--   <a>Value</a> for an explanation of how operations on <a>Value</a>s
--   work.
leq :: Value -> Value -> Bool

-- | Check whether one <a>Value</a> is strictly less than another. This is
--   *not* a pointwise operation. <tt>lt l r</tt> means <tt>leq l r
--   &amp;&amp; not (eq l r)</tt>.
lt :: Value -> Value -> Bool

-- | Check whether a <a>Value</a> is zero.
isZero :: Value -> Bool

-- | Split a <a>Value</a> into its positive and negative parts. The first
--   element of the tuple contains the negative parts of the <a>Value</a>,
--   the second element contains the positive parts.
--   
--   <pre>
--   negate (fst (split a)) <tt>plus</tt> (snd (split a)) == a
--   </pre>
split :: Value -> (Value, Value)

-- | Combine two <a>Value</a> maps with the argument function. Assumes the
--   well-definedness of the two maps.
unionWith :: (Integer -> Integer -> Integer) -> Value -> Value -> Value

-- | Convert a <a>Value</a> to a simple list, keeping only the non-zero
--   amounts. Note that the result isn't sorted, meaning <tt>v1 == v2</tt>
--   doesn't generally imply <tt>flattenValue v1 == flattenValue v2</tt>.
--   Also assumes that there are no duplicate keys in the <a>Value</a>
--   <tt>Map</tt>.
flattenValue :: Value -> [(CurrencySymbol, TokenName, Integer)]
newtype Lovelace
Lovelace :: Integer -> Lovelace
[getLovelace] :: Lovelace -> Integer
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Value.Lovelace
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Value.Lovelace
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Value.AssetClass
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Value.AssetClass
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Value.TokenName
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Value.TokenName
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Value.CurrencySymbol
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Value.CurrencySymbol
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Value.CurrencySymbol
instance GHC.Show.Show PlutusLedgerApi.V1.Value.CurrencySymbol
instance Data.String.IsString PlutusLedgerApi.V1.Value.CurrencySymbol
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Value.CurrencySymbol
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Value.CurrencySymbol
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Value.CurrencySymbol
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Value.CurrencySymbol
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Value.CurrencySymbol
instance GHC.Classes.Ord PlutusLedgerApi.V1.Value.CurrencySymbol
instance GHC.Classes.Eq PlutusLedgerApi.V1.Value.CurrencySymbol
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Value.CurrencySymbol
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Value.CurrencySymbol
instance Data.Data.Data PlutusLedgerApi.V1.Value.CurrencySymbol
instance GHC.Generics.Generic PlutusLedgerApi.V1.Value.CurrencySymbol
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Value.TokenName
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Value.TokenName
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Value.TokenName
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Value.TokenName
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Value.TokenName
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Value.TokenName
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Value.TokenName
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Value.TokenName
instance GHC.Classes.Ord PlutusLedgerApi.V1.Value.TokenName
instance GHC.Classes.Eq PlutusLedgerApi.V1.Value.TokenName
instance Data.Data.Data PlutusLedgerApi.V1.Value.TokenName
instance GHC.Generics.Generic PlutusLedgerApi.V1.Value.TokenName
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Value.AssetClass
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Value.AssetClass
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Value.AssetClass
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Value.AssetClass
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Value.AssetClass
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Value.AssetClass
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Value.AssetClass
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Value.AssetClass
instance GHC.Show.Show PlutusLedgerApi.V1.Value.AssetClass
instance GHC.Classes.Ord PlutusLedgerApi.V1.Value.AssetClass
instance GHC.Classes.Eq PlutusLedgerApi.V1.Value.AssetClass
instance Data.Data.Data PlutusLedgerApi.V1.Value.AssetClass
instance GHC.Generics.Generic PlutusLedgerApi.V1.Value.AssetClass
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Value.Value
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Value.Value
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Value.Value
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Value.Value
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Value.Value
instance GHC.Show.Show PlutusLedgerApi.V1.Value.Value
instance Data.Data.Data PlutusLedgerApi.V1.Value.Value
instance GHC.Generics.Generic PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Show.TH.Show PlutusLedgerApi.V1.Value.Lovelace
instance PlutusTx.Numeric.AdditiveGroup PlutusLedgerApi.V1.Value.Lovelace
instance PlutusTx.Numeric.AdditiveMonoid PlutusLedgerApi.V1.Value.Lovelace
instance PlutusTx.Numeric.AdditiveSemigroup PlutusLedgerApi.V1.Value.Lovelace
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Value.Lovelace
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Value.Lovelace
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Value.Lovelace
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Value.Lovelace
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Value.Lovelace
instance GHC.Enum.Enum PlutusLedgerApi.V1.Value.Lovelace
instance GHC.Real.Real PlutusLedgerApi.V1.Value.Lovelace
instance GHC.Num.Num PlutusLedgerApi.V1.Value.Lovelace
instance GHC.Show.Show PlutusLedgerApi.V1.Value.Lovelace
instance GHC.Classes.Ord PlutusLedgerApi.V1.Value.Lovelace
instance GHC.Classes.Eq PlutusLedgerApi.V1.Value.Lovelace
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Value.Lovelace
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Value.Lovelace
instance GHC.Generics.Generic PlutusLedgerApi.V1.Value.Lovelace
instance PlutusTx.Numeric.AdditiveSemigroup PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Numeric.AdditiveMonoid PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Numeric.AdditiveGroup PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Value.Lovelace referencedTypes
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Value.Value referencedTypes
instance GHC.Classes.Eq PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Value.Value
instance GHC.Base.Semigroup PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Semigroup.Semigroup PlutusLedgerApi.V1.Value.Value
instance GHC.Base.Monoid PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Monoid.Monoid PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Monoid.Group PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Numeric.Module GHC.Num.Integer.Integer PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Lattice.JoinSemiLattice PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Lattice.MeetSemiLattice PlutusLedgerApi.V1.Value.Value
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Value.AssetClass referencedTypes
instance Data.String.IsString PlutusLedgerApi.V1.Value.TokenName
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Value.TokenName referencedTypes
instance GHC.Show.Show PlutusLedgerApi.V1.Value.TokenName
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Value.CurrencySymbol referencedTypes


-- | Functions for working with scripts on the ledger.
module PlutusLedgerApi.V1.Scripts

-- | A higher-level evaluation error.
data ScriptError

-- | Expected behavior of the engine (e.g. user-provided error)
EvaluationError :: ![Text] -> !String -> ScriptError

-- | Unexpected behavior of the engine (a bug)
EvaluationException :: !String -> !String -> ScriptError

-- | <a>Redeemer</a> is a wrapper around <tt>Data</tt> values that are used
--   as redeemers in transaction inputs.
newtype Redeemer
Redeemer :: BuiltinData -> Redeemer
[getRedeemer] :: Redeemer -> BuiltinData

-- | <a>Datum</a> is a wrapper around <tt>Data</tt> values which are used
--   as data in transaction outputs.
newtype Datum
Datum :: BuiltinData -> Datum
[getDatum] :: Datum -> BuiltinData

-- | Information about the state of the blockchain and about the
--   transaction that is currently being validated, represented as a value
--   in <tt>Data</tt>.
newtype Context
Context :: BuiltinData -> Context

-- | Type representing the <i>BLAKE2b-256</i> hash of a datum. 32 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype DatumHash
DatumHash :: BuiltinByteString -> DatumHash

-- | Type representing the <i>BLAKE2b-256</i> hash of a redeemer. 32 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype RedeemerHash
RedeemerHash :: BuiltinByteString -> RedeemerHash

-- | Type representing the <i>BLAKE2b-224</i> hash of a script. 28 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype ScriptHash
ScriptHash :: BuiltinByteString -> ScriptHash
[getScriptHash] :: ScriptHash -> BuiltinByteString
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Scripts.Redeemer
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Scripts.Redeemer
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Scripts.Datum
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Scripts.Datum
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Scripts.RedeemerHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Scripts.RedeemerHash
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Scripts.DatumHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Scripts.DatumHash
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Scripts.ScriptHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Scripts.ScriptHash
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Scripts.ScriptError
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Scripts.ScriptError
instance GHC.Generics.Generic PlutusLedgerApi.V1.Scripts.ScriptError
instance GHC.Classes.Eq PlutusLedgerApi.V1.Scripts.ScriptError
instance GHC.Show.Show PlutusLedgerApi.V1.Scripts.ScriptError
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Scripts.Datum
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Scripts.Datum
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Scripts.Datum
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Scripts.Datum
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Scripts.Datum
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Scripts.Datum
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Scripts.Datum
instance GHC.Classes.Ord PlutusLedgerApi.V1.Scripts.Datum
instance GHC.Classes.Eq PlutusLedgerApi.V1.Scripts.Datum
instance GHC.Show.Show PlutusLedgerApi.V1.Scripts.Datum
instance GHC.Generics.Generic PlutusLedgerApi.V1.Scripts.Datum
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Scripts.Redeemer
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Scripts.Redeemer
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Scripts.Redeemer
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Scripts.Redeemer
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Scripts.Redeemer
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Scripts.Redeemer
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Scripts.Redeemer
instance GHC.Classes.Ord PlutusLedgerApi.V1.Scripts.Redeemer
instance GHC.Classes.Eq PlutusLedgerApi.V1.Scripts.Redeemer
instance GHC.Show.Show PlutusLedgerApi.V1.Scripts.Redeemer
instance GHC.Generics.Generic PlutusLedgerApi.V1.Scripts.Redeemer
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Scripts.ScriptHash
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Scripts.ScriptHash
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Scripts.ScriptHash
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Scripts.ScriptHash
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Scripts.ScriptHash
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Scripts.ScriptHash
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Scripts.ScriptHash
instance GHC.Classes.Ord PlutusLedgerApi.V1.Scripts.ScriptHash
instance GHC.Classes.Eq PlutusLedgerApi.V1.Scripts.ScriptHash
instance GHC.Generics.Generic PlutusLedgerApi.V1.Scripts.ScriptHash
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Scripts.ScriptHash
instance GHC.Show.Show PlutusLedgerApi.V1.Scripts.ScriptHash
instance Data.String.IsString PlutusLedgerApi.V1.Scripts.ScriptHash
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Scripts.DatumHash
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Scripts.DatumHash
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Scripts.DatumHash
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Scripts.DatumHash
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Scripts.DatumHash
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Scripts.DatumHash
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Scripts.DatumHash
instance GHC.Classes.Ord PlutusLedgerApi.V1.Scripts.DatumHash
instance GHC.Classes.Eq PlutusLedgerApi.V1.Scripts.DatumHash
instance GHC.Generics.Generic PlutusLedgerApi.V1.Scripts.DatumHash
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Scripts.DatumHash
instance GHC.Show.Show PlutusLedgerApi.V1.Scripts.DatumHash
instance Data.String.IsString PlutusLedgerApi.V1.Scripts.DatumHash
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Scripts.RedeemerHash
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Scripts.RedeemerHash
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Scripts.RedeemerHash
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Scripts.RedeemerHash
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Scripts.RedeemerHash
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Scripts.RedeemerHash
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Scripts.RedeemerHash
instance GHC.Classes.Ord PlutusLedgerApi.V1.Scripts.RedeemerHash
instance GHC.Classes.Eq PlutusLedgerApi.V1.Scripts.RedeemerHash
instance GHC.Generics.Generic PlutusLedgerApi.V1.Scripts.RedeemerHash
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Scripts.RedeemerHash
instance GHC.Show.Show PlutusLedgerApi.V1.Scripts.RedeemerHash
instance Data.String.IsString PlutusLedgerApi.V1.Scripts.RedeemerHash
instance GHC.Show.Show PlutusLedgerApi.V1.Scripts.Context
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Scripts.Context
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Scripts.RedeemerHash referencedTypes
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Scripts.DatumHash referencedTypes
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Scripts.ScriptHash referencedTypes
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Scripts.Redeemer referencedTypes
instance Codec.Serialise.Class.Serialise PlutusLedgerApi.V1.Scripts.Redeemer
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Scripts.Datum referencedTypes
instance Codec.Serialise.Class.Serialise PlutusLedgerApi.V1.Scripts.Datum

module PlutusLedgerApi.V1.Crypto

-- | The hash of a public key. This is frequently used to identify the
--   public key, rather than the key itself. Hashed with
--   <i>BLAKE2b-224</i>. 28 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype PubKeyHash
PubKeyHash :: BuiltinByteString -> PubKeyHash
[getPubKeyHash] :: PubKeyHash -> BuiltinByteString
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Crypto.PubKeyHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Crypto.PubKeyHash
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Crypto.PubKeyHash
instance GHC.Show.Show PlutusLedgerApi.V1.Crypto.PubKeyHash
instance Data.String.IsString PlutusLedgerApi.V1.Crypto.PubKeyHash
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Crypto.PubKeyHash
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Crypto.PubKeyHash
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Crypto.PubKeyHash
instance PlutusTx.Show.TH.Show PlutusLedgerApi.V1.Crypto.PubKeyHash
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Crypto.PubKeyHash
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Crypto.PubKeyHash
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Crypto.PubKeyHash
instance GHC.Generics.Generic PlutusLedgerApi.V1.Crypto.PubKeyHash
instance GHC.Classes.Ord PlutusLedgerApi.V1.Crypto.PubKeyHash
instance GHC.Classes.Eq PlutusLedgerApi.V1.Crypto.PubKeyHash
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Crypto.PubKeyHash referenedTypes
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Crypto.PubKeyHash


-- | Address and staking address credentials for outputs.
module PlutusLedgerApi.V1.Credential

-- | Staking credential used to assign rewards.
data StakingCredential

-- | The staking hash is the <a>Credential</a> required to unlock a
--   transaction output. Either a public key credential (<a>PubKeyHash</a>)
--   or a script credential (<a>ScriptHash</a>). Both are hashed with
--   <i>BLAKE2b-244</i>. 28 byte.
StakingHash :: Credential -> StakingCredential

-- | The certificate pointer, constructed by the given slot number,
--   transaction and certificate indices. NB: The fields should really be
--   all <tt>Word64</tt>, as they are implemented in <tt>Word64</tt>, but
--   <a>Integer</a> is our only integral type so we need to use it instead.
StakingPtr :: Integer -> Integer -> Integer -> StakingCredential

-- | Credentials required to unlock a transaction output.
data Credential

-- | The transaction that spends this output must be signed by the private
--   key. See <a>PubKeyHash</a>.
PubKeyCredential :: PubKeyHash -> Credential

-- | The transaction that spends this output must include the validator
--   script and be accepted by the validator. See <a>ScriptHash</a>.
ScriptCredential :: ScriptHash -> Credential
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Credential.StakingCredential
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Credential.StakingCredential
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Credential.Credential
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Credential.Credential
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Credential.Credential referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition GHC.Num.Integer.Integer referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Credential.StakingCredential referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Credential.StakingCredential
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Credential.StakingCredential
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Credential.StakingCredential
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Crypto.PubKeyHash referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Scripts.ScriptHash referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Credential.Credential referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Credential.Credential
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Credential.Credential
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Credential.Credential
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Credential.Credential
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Credential.Credential
instance GHC.Generics.Generic PlutusLedgerApi.V1.Credential.Credential
instance GHC.Show.Show PlutusLedgerApi.V1.Credential.Credential
instance GHC.Classes.Ord PlutusLedgerApi.V1.Credential.Credential
instance GHC.Classes.Eq PlutusLedgerApi.V1.Credential.Credential
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Credential.StakingCredential
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Credential.StakingCredential
instance GHC.Generics.Generic PlutusLedgerApi.V1.Credential.StakingCredential
instance GHC.Show.Show PlutusLedgerApi.V1.Credential.StakingCredential
instance GHC.Classes.Ord PlutusLedgerApi.V1.Credential.StakingCredential
instance GHC.Classes.Eq PlutusLedgerApi.V1.Credential.StakingCredential
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Credential.StakingCredential
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Credential.StakingCredential
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Credential.Credential
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Credential.Credential


-- | Digests of certificates that are included in transactions.
module PlutusLedgerApi.V1.DCert

-- | A representation of the ledger DCert. Some information is digested,
--   and not included
data DCert
DCertDelegRegKey :: StakingCredential -> DCert
DCertDelegDeRegKey :: StakingCredential -> DCert
DCertDelegDelegate :: StakingCredential -> PubKeyHash -> DCert

-- | A digest of the PoolParams
DCertPoolRegister :: PubKeyHash -> PubKeyHash -> DCert

-- | The retirement certificate and the Epoch in which the retirement will
--   take place
DCertPoolRetire :: PubKeyHash -> Integer -> DCert

-- | A really terse Digest
DCertGenesis :: DCert

-- | Another really terse Digest
DCertMir :: DCert
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Credential.StakingCredential referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Crypto.PubKeyHash referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition GHC.Num.Integer.Integer referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.DCert.DCert referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.DCert.DCert
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.DCert.DCert
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.DCert.DCert
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.DCert.DCert
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.DCert.DCert
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.DCert.DCert
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.DCert.DCert
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.DCert.DCert
instance GHC.Generics.Generic PlutusLedgerApi.V1.DCert.DCert
instance GHC.Show.Show PlutusLedgerApi.V1.DCert.DCert
instance GHC.Classes.Ord PlutusLedgerApi.V1.DCert.DCert
instance GHC.Classes.Eq PlutusLedgerApi.V1.DCert.DCert
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.DCert.DCert

module PlutusLedgerApi.V1.Address

-- | An address may contain two credentials, the payment credential and
--   optionally a <a>StakingCredential</a>.
data Address
Address :: Credential -> Maybe StakingCredential -> Address

-- | the payment credential
[addressCredential] :: Address -> Credential

-- | the staking credential
[addressStakingCredential] :: Address -> Maybe StakingCredential

-- | The address that should be targeted by a transaction output locked by
--   the public key with the given hash.
pubKeyHashAddress :: PubKeyHash -> Address

-- | The PubKeyHash of the address, if any
toPubKeyHash :: Address -> Maybe PubKeyHash

-- | The validator hash of the address, if any
toScriptHash :: Address -> Maybe ScriptHash

-- | The address that should be used by a transaction output locked by the
--   given validator script hash.
scriptHashAddress :: ScriptHash -> Address

-- | The staking credential of an address (if any)
stakingCredential :: Address -> Maybe StakingCredential
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Address.Address
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Address.Address
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Credential.Credential referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (GHC.Maybe.Maybe PlutusLedgerApi.V1.Credential.StakingCredential) referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Address.Address referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Address.Address
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Address.Address
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Address.Address
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Address.Address
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Address.Address
instance GHC.Generics.Generic PlutusLedgerApi.V1.Address.Address
instance GHC.Show.Show PlutusLedgerApi.V1.Address.Address
instance GHC.Classes.Ord PlutusLedgerApi.V1.Address.Address
instance GHC.Classes.Eq PlutusLedgerApi.V1.Address.Address
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Address.Address
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Address.Address

module PlutusLedgerApi.V1.Tx

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A tag indicating the type of script that we are pointing to.
--   
--   See also <a>ScriptPurpose</a>
data ScriptTag
Spend :: ScriptTag
Mint :: ScriptTag
Cert :: ScriptTag
Reward :: ScriptTag

-- | A redeemer pointer is a pair of a script type tag (<a>ScriptTag</a>)
--   <tt>t</tt> and an index <tt>i</tt>, picking out the i-th script of
--   type <tt>t</tt> in the transaction.
data RedeemerPtr
RedeemerPtr :: ScriptTag -> Integer -> RedeemerPtr

-- | Redeemers is a <a>Map</a> of redeemer pointer (<a>RedeemerPtr</a>) and
--   its <a>Redeemer</a>.
type Redeemers = Map RedeemerPtr Redeemer

-- | A transaction output, consisting of a target address (<a>Address</a>),
--   a value (<a>Value</a>), and optionally a datum hash
--   (<a>DatumHash</a>).
data TxOut
TxOut :: Address -> Value -> Maybe DatumHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatumHash] :: TxOut -> Maybe DatumHash

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | Whether the output is a pay-to-pubkey output.
isPubKeyOut :: TxOut -> Bool

-- | Whether the output is a pay-to-script output.
isPayToScriptOut :: TxOut -> Bool

-- | The address of a transaction output.
outAddress :: Lens' TxOut Address

-- | The value of a transaction output. | TODO: Compute address again
outValue :: Lens' TxOut Value

-- | The public key attached to a <a>TxOut</a>, if there is one.
txOutPubKey :: TxOut -> Maybe PubKeyHash

-- | The datum attached to a <a>TxOut</a>, if there is one.
txOutDatum :: TxOut -> Maybe DatumHash

-- | Create a transaction output locked by a public key.
pubKeyHashTxOut :: Value -> PubKeyHash -> TxOut
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Tx.ScriptTag referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition GHC.Num.Integer.Integer referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Tx.RedeemerPtr referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Tx.RedeemerPtr
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Tx.RedeemerPtr
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Tx.RedeemerPtr
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Tx.ScriptTag referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Tx.ScriptTag
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Tx.ScriptTag
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Tx.ScriptTag
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Tx.TxId referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition GHC.Num.Integer.Integer referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Tx.TxOutRef referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Tx.TxOutRef
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Tx.TxOutRef
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Tx.TxOutRef
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Address.Address referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Value.Value referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (GHC.Maybe.Maybe PlutusLedgerApi.V1.Scripts.DatumHash) referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Tx.TxOut referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Tx.TxOut
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Tx.TxOut
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Tx.TxOut
instance PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusTx.Builtins.Internal.BuiltinByteString referencedTypes => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Tx.TxId referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Tx.TxId
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Tx.TxId
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Tx.TxId
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Tx.TxOutRef
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Tx.TxOutRef
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Tx.TxOut
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Tx.TxOut
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Tx.TxId
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Tx.TxId
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Tx.TxId
instance GHC.Show.Show PlutusLedgerApi.V1.Tx.TxId
instance Data.String.IsString PlutusLedgerApi.V1.Tx.TxId
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Tx.TxId
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Tx.TxId
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Tx.TxId
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Tx.TxId
instance GHC.Generics.Generic PlutusLedgerApi.V1.Tx.TxId
instance GHC.Classes.Ord PlutusLedgerApi.V1.Tx.TxId
instance GHC.Classes.Eq PlutusLedgerApi.V1.Tx.TxId
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Tx.ScriptTag
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Tx.ScriptTag
instance GHC.Generics.Generic PlutusLedgerApi.V1.Tx.ScriptTag
instance GHC.Classes.Ord PlutusLedgerApi.V1.Tx.ScriptTag
instance GHC.Classes.Eq PlutusLedgerApi.V1.Tx.ScriptTag
instance GHC.Show.Show PlutusLedgerApi.V1.Tx.ScriptTag
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Tx.RedeemerPtr
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Tx.RedeemerPtr
instance GHC.Generics.Generic PlutusLedgerApi.V1.Tx.RedeemerPtr
instance GHC.Classes.Ord PlutusLedgerApi.V1.Tx.RedeemerPtr
instance GHC.Classes.Eq PlutusLedgerApi.V1.Tx.RedeemerPtr
instance GHC.Show.Show PlutusLedgerApi.V1.Tx.RedeemerPtr
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Tx.TxOutRef
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Tx.TxOutRef
instance GHC.Generics.Generic PlutusLedgerApi.V1.Tx.TxOutRef
instance GHC.Classes.Ord PlutusLedgerApi.V1.Tx.TxOutRef
instance GHC.Classes.Eq PlutusLedgerApi.V1.Tx.TxOutRef
instance GHC.Show.Show PlutusLedgerApi.V1.Tx.TxOutRef
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Tx.TxOut
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Tx.TxOut
instance GHC.Generics.Generic PlutusLedgerApi.V1.Tx.TxOut
instance GHC.Classes.Eq PlutusLedgerApi.V1.Tx.TxOut
instance GHC.Show.Show PlutusLedgerApi.V1.Tx.TxOut
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Tx.TxOut
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Tx.TxOut
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Tx.TxOutRef
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Tx.TxOutRef

module PlutusLedgerApi.V2.Tx

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A tag indicating the type of script that we are pointing to.
--   
--   See also <a>ScriptPurpose</a>
data ScriptTag
Spend :: ScriptTag
Mint :: ScriptTag
Cert :: ScriptTag
Reward :: ScriptTag

-- | A redeemer pointer is a pair of a script type tag (<a>ScriptTag</a>)
--   <tt>t</tt> and an index <tt>i</tt>, picking out the i-th script of
--   type <tt>t</tt> in the transaction.
data RedeemerPtr
RedeemerPtr :: ScriptTag -> Integer -> RedeemerPtr

-- | Redeemers is a <a>Map</a> of redeemer pointer (<a>RedeemerPtr</a>) and
--   its <a>Redeemer</a>.
type Redeemers = Map RedeemerPtr Redeemer

-- | A transaction output, consisting of a target address, a value,
--   optionally a datum/datum hash, and optionally a reference script.
data TxOut
TxOut :: Address -> Value -> OutputDatum -> Maybe ScriptHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatum] :: TxOut -> OutputDatum
[txOutReferenceScript] :: TxOut -> Maybe ScriptHash

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | The datum attached to an output: either nothing; a datum hash; or the
--   datum itself (an "inline datum").
data OutputDatum
NoOutputDatum :: OutputDatum
OutputDatumHash :: DatumHash -> OutputDatum
OutputDatum :: Datum -> OutputDatum

-- | Whether the output is a pay-to-pubkey output.
isPubKeyOut :: TxOut -> Bool

-- | Whether the output is a pay-to-script output.
isPayToScriptOut :: TxOut -> Bool

-- | The address of a transaction output.
outAddress :: Lens' TxOut Address

-- | The value of a transaction output. | TODO: Compute address again
outValue :: Lens' TxOut Value

-- | The public key attached to a <a>TxOut</a>, if there is one.
txOutPubKey :: TxOut -> Maybe PubKeyHash

-- | The datum attached to a <a>TxOut</a>.
outDatum :: Lens' TxOut OutputDatum

-- | The reference script attached to a <a>TxOut</a>.
outReferenceScript :: Lens' TxOut (Maybe ScriptHash)

-- | Create a transaction output locked by a public key.
pubKeyHashTxOut :: Value -> PubKeyHash -> TxOut
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Address.Address referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Value.Value referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V2.Tx.OutputDatum referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (GHC.Maybe.Maybe PlutusLedgerApi.V1.Scripts.ScriptHash) referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V2.Tx.TxOut referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V2.Tx.TxOut
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V2.Tx.TxOut
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V2.Tx.TxOut
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Scripts.DatumHash referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Scripts.Datum referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V2.Tx.OutputDatum referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V2.Tx.OutputDatum
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V2.Tx.OutputDatum
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V2.Tx.OutputDatum
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Tx.TxOut
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Tx.TxOut
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Tx.OutputDatum
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Tx.OutputDatum
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V2.Tx.OutputDatum
instance Control.DeepSeq.NFData PlutusLedgerApi.V2.Tx.OutputDatum
instance GHC.Generics.Generic PlutusLedgerApi.V2.Tx.OutputDatum
instance GHC.Classes.Eq PlutusLedgerApi.V2.Tx.OutputDatum
instance GHC.Show.Show PlutusLedgerApi.V2.Tx.OutputDatum
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V2.Tx.TxOut
instance Control.DeepSeq.NFData PlutusLedgerApi.V2.Tx.TxOut
instance GHC.Generics.Generic PlutusLedgerApi.V2.Tx.TxOut
instance GHC.Classes.Eq PlutusLedgerApi.V2.Tx.TxOut
instance GHC.Show.Show PlutusLedgerApi.V2.Tx.TxOut
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V2.Tx.TxOut
instance PlutusTx.Eq.Eq PlutusLedgerApi.V2.Tx.TxOut
instance PlutusTx.Eq.Eq PlutusLedgerApi.V2.Tx.OutputDatum
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V2.Tx.OutputDatum

module PlutusLedgerApi.V1.Contexts

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> [(StakingCredential, Integer)] -> POSIXTimeRange -> [PubKeyHash] -> [(DatumHash, Datum)] -> TxId -> TxInfo

-- | Transaction inputs; cannot be an empty list
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals
[txInfoWdrl] :: TxInfo -> [(StakingCredential, Integer)]

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]

-- | The lookup table of datums attached to the transaction
[txInfoData] :: TxInfo -> [(DatumHash, Datum)]

-- | Hash of the pending transaction body (i.e. transaction excluding
--   witnesses)
[txInfoId] :: TxInfo -> TxId

-- | The context that the currently-executing script can access.
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext

-- | information about the transaction the currently-executing script is
--   included in
[scriptContextTxInfo] :: ScriptContext -> TxInfo

-- | the purpose of the currently-executing script
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A transaction output, consisting of a target address (<a>Address</a>),
--   a value (<a>Value</a>), and optionally a datum hash
--   (<a>DatumHash</a>).
data TxOut
TxOut :: Address -> Value -> Maybe DatumHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatumHash] :: TxOut -> Maybe DatumHash

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | Find the input currently being validated.
findOwnInput :: ScriptContext -> Maybe TxInInfo

-- | Find the data corresponding to a data hash, if there is one
findDatum :: DatumHash -> TxInfo -> Maybe Datum

-- | Find the hash of a datum, if it is part of the pending transaction's
--   hashes
findDatumHash :: Datum -> TxInfo -> Maybe DatumHash

-- | Given a UTXO reference and a transaction (<a>TxInfo</a>), resolve it
--   to one of the transaction's inputs (<a>TxInInfo</a>).
findTxInByTxOutRef :: TxOutRef -> TxInfo -> Maybe TxInInfo

-- | Finds all the outputs that pay to the same script address that we are
--   currently spending from, if any.
findContinuingOutputs :: ScriptContext -> [Integer]

-- | Get all the outputs that pay to the same script address we are
--   currently spending from, if any.
getContinuingOutputs :: ScriptContext -> [TxOut]

-- | Get the values paid to a public key address by a pending transaction.
pubKeyOutputsAt :: PubKeyHash -> TxInfo -> [Value]

-- | Get the total value paid to a public key address by a pending
--   transaction.
valuePaidTo :: TxInfo -> PubKeyHash -> Value

-- | Check if the pending transaction spends a specific transaction output
--   (identified by the hash of a transaction and an index into that
--   transactions' outputs)
spendsOutput :: TxInfo -> TxId -> Integer -> Bool

-- | Check if a transaction was signed by the given public key.
txSignedBy :: TxInfo -> PubKeyHash -> Bool

-- | Get the total value of inputs spent by this transaction.
valueSpent :: TxInfo -> Value

-- | Get the total value of outputs produced by this transaction.
valueProduced :: TxInfo -> Value

-- | The <a>CurrencySymbol</a> of the current validator script.
ownCurrencySymbol :: ScriptContext -> CurrencySymbol
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Contexts.TxInfo referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Contexts.ScriptPurpose referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Contexts.ScriptContext referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Contexts.ScriptContext
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Contexts.ScriptContext
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Contexts.ScriptContext
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Value.CurrencySymbol referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Tx.TxOutRef referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Credential.StakingCredential referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.DCert.DCert referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Contexts.ScriptPurpose referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition [PlutusLedgerApi.V1.Contexts.TxInInfo] referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition [PlutusLedgerApi.V1.Tx.TxOut] referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Value.Value referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition [PlutusLedgerApi.V1.DCert.DCert] referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition [(PlutusLedgerApi.V1.Credential.StakingCredential, GHC.Num.Integer.Integer)] referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Time.POSIXTimeRange referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition [PlutusLedgerApi.V1.Crypto.PubKeyHash] referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition [(PlutusLedgerApi.V1.Scripts.DatumHash, PlutusLedgerApi.V1.Scripts.Datum)] referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Tx.TxId referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Contexts.TxInfo referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Contexts.TxInfo
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Contexts.TxInfo
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Contexts.TxInfo
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Tx.TxOutRef referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Tx.TxOut referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Contexts.TxInInfo referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Contexts.TxInInfo
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Contexts.TxInInfo
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Contexts.TxInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Contexts.TxInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Contexts.TxInInfo
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Contexts.TxInInfo
instance GHC.Classes.Eq PlutusLedgerApi.V1.Contexts.TxInInfo
instance GHC.Show.Show PlutusLedgerApi.V1.Contexts.TxInInfo
instance GHC.Generics.Generic PlutusLedgerApi.V1.Contexts.TxInInfo
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance GHC.Classes.Ord PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance GHC.Classes.Eq PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance GHC.Show.Show PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance GHC.Generics.Generic PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Contexts.TxInfo
instance GHC.Classes.Eq PlutusLedgerApi.V1.Contexts.TxInfo
instance GHC.Show.Show PlutusLedgerApi.V1.Contexts.TxInfo
instance GHC.Generics.Generic PlutusLedgerApi.V1.Contexts.TxInfo
instance GHC.Show.Show PlutusLedgerApi.V1.Contexts.ScriptContext
instance GHC.Classes.Eq PlutusLedgerApi.V1.Contexts.ScriptContext
instance GHC.Generics.Generic PlutusLedgerApi.V1.Contexts.ScriptContext
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Contexts.ScriptContext
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Contexts.ScriptContext
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Contexts.TxInfo
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Contexts.TxInfo
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Contexts.TxInInfo
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Contexts.TxInInfo

module PlutusLedgerApi.V2.Contexts

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> Map StakingCredential Integer -> POSIXTimeRange -> [PubKeyHash] -> Map ScriptPurpose Redeemer -> Map DatumHash Datum -> TxId -> TxInfo

-- | Transaction inputs; cannot be an empty list
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | <i>Added in V2:</i> Transaction reference inputs
[txInfoReferenceInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals <i>V1-&gt;V2</i>: changed from assoc list to a
--   <a>AssocMap</a>
[txInfoWdrl] :: TxInfo -> Map StakingCredential Integer

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]

-- | <i>Added in V2:</i> a table of redeemers attached to the transaction
[txInfoRedeemers] :: TxInfo -> Map ScriptPurpose Redeemer

-- | The lookup table of datums attached to the transaction
--   <i>V1-&gt;V2</i>: changed from assoc list to a <a>AssocMap</a>
[txInfoData] :: TxInfo -> Map DatumHash Datum

-- | Hash of the pending transaction body (i.e. transaction excluding
--   witnesses)
[txInfoId] :: TxInfo -> TxId

-- | The context that the currently-executing script can access.
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext

-- | information about the transaction the currently-executing script is
--   included in
[scriptContextTxInfo] :: ScriptContext -> TxInfo

-- | the purpose of the currently-executing script
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A transaction output, consisting of a target address, a value,
--   optionally a datum/datum hash, and optionally a reference script.
data TxOut
TxOut :: Address -> Value -> OutputDatum -> Maybe ScriptHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatum] :: TxOut -> OutputDatum
[txOutReferenceScript] :: TxOut -> Maybe ScriptHash

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | Find the input currently being validated.
findOwnInput :: ScriptContext -> Maybe TxInInfo

-- | Find the data corresponding to a data hash, if there is one
findDatum :: DatumHash -> TxInfo -> Maybe Datum

-- | Find the hash of a datum, if it is part of the pending transaction's
--   hashes
findDatumHash :: Datum -> TxInfo -> Maybe DatumHash

-- | Given a UTXO reference and a transaction (<a>TxInfo</a>), resolve it
--   to one of the transaction's inputs (<a>TxInInfo</a>).
--   
--   Note: this only searches the true transaction inputs and not the
--   referenced transaction inputs.
findTxInByTxOutRef :: TxOutRef -> TxInfo -> Maybe TxInInfo

-- | Find the indices of all the outputs that pay to the same script
--   address we are currently spending from, if any.
findContinuingOutputs :: ScriptContext -> [Integer]

-- | Get all the outputs that pay to the same script address we are
--   currently spending from, if any.
getContinuingOutputs :: ScriptContext -> [TxOut]

-- | Get the values paid to a public key address by a pending transaction.
pubKeyOutputsAt :: PubKeyHash -> TxInfo -> [Value]

-- | Get the total value paid to a public key address by a pending
--   transaction.
valuePaidTo :: TxInfo -> PubKeyHash -> Value

-- | Check if the pending transaction spends a specific transaction output
--   (identified by the hash of a transaction and an index into that
--   transactions' outputs)
spendsOutput :: TxInfo -> TxId -> Integer -> Bool

-- | Check if a transaction was signed by the given public key.
txSignedBy :: TxInfo -> PubKeyHash -> Bool

-- | Get the total value of inputs spent by this transaction.
valueSpent :: TxInfo -> Value

-- | Get the total value of outputs produced by this transaction.
valueProduced :: TxInfo -> Value

-- | The <a>CurrencySymbol</a> of the current validator script.
ownCurrencySymbol :: ScriptContext -> CurrencySymbol
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V2.Contexts.TxInfo referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Contexts.ScriptPurpose referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V2.Contexts.ScriptContext referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V2.Contexts.ScriptContext
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V2.Contexts.ScriptContext
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V2.Contexts.ScriptContext
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition [PlutusLedgerApi.V2.Contexts.TxInInfo] referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition [PlutusLedgerApi.V2.Tx.TxOut] referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Value.Value referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition [PlutusLedgerApi.V1.DCert.DCert] referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (PlutusTx.AssocMap.Map PlutusLedgerApi.V1.Credential.StakingCredential GHC.Num.Integer.Integer) referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Time.POSIXTimeRange referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition [PlutusLedgerApi.V1.Crypto.PubKeyHash] referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (PlutusTx.AssocMap.Map PlutusLedgerApi.V1.Contexts.ScriptPurpose PlutusLedgerApi.V1.Scripts.Redeemer) referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (PlutusTx.AssocMap.Map PlutusLedgerApi.V1.Scripts.DatumHash PlutusLedgerApi.V1.Scripts.Datum) referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Tx.TxId referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V2.Contexts.TxInfo referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V2.Contexts.TxInfo
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V2.Contexts.TxInfo
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V2.Contexts.TxInfo
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Tx.TxOutRef referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V2.Tx.TxOut referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V2.Contexts.TxInInfo referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V2.Contexts.TxInInfo
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V2.Contexts.TxInInfo
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V2.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Contexts.TxInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Contexts.TxInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Contexts.TxInInfo
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V2.Contexts.TxInInfo
instance GHC.Classes.Eq PlutusLedgerApi.V2.Contexts.TxInInfo
instance GHC.Show.Show PlutusLedgerApi.V2.Contexts.TxInInfo
instance GHC.Generics.Generic PlutusLedgerApi.V2.Contexts.TxInInfo
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V2.Contexts.TxInfo
instance GHC.Classes.Eq PlutusLedgerApi.V2.Contexts.TxInfo
instance GHC.Show.Show PlutusLedgerApi.V2.Contexts.TxInfo
instance GHC.Generics.Generic PlutusLedgerApi.V2.Contexts.TxInfo
instance GHC.Show.Show PlutusLedgerApi.V2.Contexts.ScriptContext
instance GHC.Classes.Eq PlutusLedgerApi.V2.Contexts.ScriptContext
instance GHC.Generics.Generic PlutusLedgerApi.V2.Contexts.ScriptContext
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V2.Contexts.ScriptContext
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V2.Contexts.TxInfo
instance PlutusTx.Eq.Eq PlutusLedgerApi.V2.Contexts.TxInInfo
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V2.Contexts.TxInInfo


-- | The interface to Plutus V1 for the ledger.
module PlutusLedgerApi.V1

-- | Scripts to the ledger are serialised bytestrings.
type SerialisedScript = ShortByteString

-- | A Plutus script ready to be evaluated on-chain, via
--   <tt>evaluateScriptRestricting</tt>.
data ScriptForEvaluation

-- | Get a <a>SerialisedScript</a> from a <a>ScriptForEvaluation</a>.
--   <i>O(1)</i>.
serialisedScript :: ScriptForEvaluation -> SerialisedScript

-- | Get a <a>ScriptNamedDeBruijn</a> from a <a>ScriptForEvaluation</a>.
--   <i>O(1)</i>.
deserialisedScript :: ScriptForEvaluation -> ScriptNamedDeBruijn

-- | Turns a program which was compiled using the 'PlutusTx' toolchain into
--   a binary format that is understood by the network and can be stored
--   on-chain.
serialiseCompiledCode :: forall a. CompiledCode a -> SerialisedScript

-- | Turns a program's AST (most likely manually constructed) into a binary
--   format that is understood by the network and can be stored on-chain.
serialiseUPLC :: Program DeBruijn DefaultUni DefaultFun () -> SerialisedScript

-- | The deserialization from a serialised script into a
--   <tt>ScriptForEvaluation</tt>, ready to be evaluated on-chain. Called
--   inside phase-1 validation (i.e., deserialisation error is a phase-1
--   error).
deserialiseScript :: forall m. MonadError ScriptDecodeError m => MajorProtocolVersion -> SerialisedScript -> m ScriptForEvaluation

-- | Deserialises a <a>SerialisedScript</a> back into an AST. Does *not* do
--   ledger-language-version-specific checks like for allowable builtins.
uncheckedDeserialiseUPLC :: SerialisedScript -> Program DeBruijn DefaultUni DefaultFun ()

-- | Evaluates a script, with a cost model and a budget that restricts how
--   many resources it can use according to the cost model. Also returns
--   the budget that was actually used.
--   
--   Can be used to calculate budgets for scripts, but even in this case
--   you must give a limit to guard against scripts that run for a long
--   time or loop.
evaluateScriptRestricting :: MajorProtocolVersion -> VerboseMode -> EvaluationContext -> ExBudget -> ScriptForEvaluation -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | Evaluates a script, returning the minimum budget that the script would
--   need to evaluate successfully. This will take as long as the script
--   takes, if you need to limit the execution time of the script also, you
--   can use <a>evaluateScriptRestricting</a>, which also returns the used
--   budget.
evaluateScriptCounting :: MajorProtocolVersion -> VerboseMode -> EvaluationContext -> ScriptForEvaluation -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | This represents the major component of the Cardano protocol version.
--   The ledger can only supply the major component of the protocol
--   version, not the minor component, and Plutus should only need to care
--   about the major component anyway. This relies on careful understanding
--   between us and the ledger as to what this means.
newtype MajorProtocolVersion
MajorProtocolVersion :: Int -> MajorProtocolVersion
[getMajorProtocolVersion] :: MajorProtocolVersion -> Int

-- | A simple toggle indicating whether or not we should accumulate logs
--   during script execution.
data VerboseMode

-- | accumulate all traces
Verbose :: VerboseMode

-- | don't accumulate anything
Quiet :: VerboseMode

-- | The type of the executed script's accumulated log output: a list of
--   <a>Text</a>.
--   
--   It will be an empty list if the <a>VerboseMode</a> is set to
--   <a>Quiet</a>.
type LogOutput = [Text]
data () => ExBudget
ExBudget :: ExCPU -> ExMemory -> ExBudget
[exBudgetCPU] :: ExBudget -> ExCPU
[exBudgetMemory] :: ExBudget -> ExMemory
newtype () => ExCPU
ExCPU :: CostingInteger -> ExCPU
newtype () => ExMemory
ExMemory :: CostingInteger -> ExMemory
data () => SatInt
fromSatInt :: Num a => SatInt -> a

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than being recomputed on every
--   evaluation.
--   
--   Different protocol versions may require different bundles of machine
--   parameters, which allows us for example to tweak the shape of the
--   costing function of a builtin, so that the builtin costs less.
--   Currently this means that we have to create multiple
--   <a>DefaultMachineParameters</a> per language version, which we put
--   into a cache (represented by an association list) in order to avoid
--   costly recomputation of machine parameters.
--   
--   In order to get the appropriate <a>DefaultMachineParameters</a> at
--   validation time we look it up in the cache using a semantics variant
--   as a key. We compute the semantics variant from the protocol version
--   using the stored function. Note that the semantics variant depends on
--   the language version too, but the latter is known statically (because
--   each language version has its own evaluation context), hence there's
--   no reason to require it to be provided at runtime.
--   
--   To say it differently, there's a matrix of semantics variants indexed
--   by (LL, PV) pairs and we cache its particular row corresponding to the
--   statically given LL in an <a>EvaluationContext</a>.
--   
--   The reason why we associate a <a>DefaultMachineParameters</a> with a
--   semantics variant rather than a protocol version are
--   
--   <ol>
--   <li>generally there are far more protocol versions than semantics
--   variants supported by a specific language version, so we save on
--   pointless duplication of bundles of machine parameters</li>
--   <li>builtins don't know anything about protocol versions, only
--   semantics variants. It is therefore more semantically precise to
--   associate bundles of machine parameters with semantics variants than
--   with protocol versions</li>
--   </ol>
data EvaluationContext

-- | Build the <a>EvaluationContext</a>.
--   
--   The input is a list of cost model parameters (which are integer
--   values) passed from the ledger.
--   
--   IMPORTANT: the cost model parameters <b>MUST</b> appear in the correct
--   order, matching the names in <a>ParamName</a>. If the parameters are
--   supplied in the wrong order then script cost calculations will be
--   incorrect.
--   
--   IMPORTANT: The evaluation context of every Plutus version must be
--   recreated upon a protocol update with the updated cost model
--   parameters.
mkEvaluationContext :: (MonadError CostModelApplyError m, MonadWriter [CostModelApplyWarn] m) => [Int64] -> m EvaluationContext

-- | The enumeration of all possible cost model parameter names for this
--   language version.
--   
--   IMPORTANT: The order of appearance of the data constructors here
--   matters. DO NOT REORDER. See Note [Quotation marks in cost model
--   parameter constructors] See Note [Cost model parameters from the
--   ledger's point of view]
data ParamName
AddInteger'cpu'arguments'intercept :: ParamName
AddInteger'cpu'arguments'slope :: ParamName
AddInteger'memory'arguments'intercept :: ParamName
AddInteger'memory'arguments'slope :: ParamName
AppendByteString'cpu'arguments'intercept :: ParamName
AppendByteString'cpu'arguments'slope :: ParamName
AppendByteString'memory'arguments'intercept :: ParamName
AppendByteString'memory'arguments'slope :: ParamName
AppendString'cpu'arguments'intercept :: ParamName
AppendString'cpu'arguments'slope :: ParamName
AppendString'memory'arguments'intercept :: ParamName
AppendString'memory'arguments'slope :: ParamName
BData'cpu'arguments :: ParamName
BData'memory'arguments :: ParamName
Blake2b_256'cpu'arguments'intercept :: ParamName
Blake2b_256'cpu'arguments'slope :: ParamName
Blake2b_256'memory'arguments :: ParamName
CekApplyCost'exBudgetCPU :: ParamName
CekApplyCost'exBudgetMemory :: ParamName
CekBuiltinCost'exBudgetCPU :: ParamName
CekBuiltinCost'exBudgetMemory :: ParamName
CekConstCost'exBudgetCPU :: ParamName
CekConstCost'exBudgetMemory :: ParamName
CekDelayCost'exBudgetCPU :: ParamName
CekDelayCost'exBudgetMemory :: ParamName
CekForceCost'exBudgetCPU :: ParamName
CekForceCost'exBudgetMemory :: ParamName
CekLamCost'exBudgetCPU :: ParamName
CekLamCost'exBudgetMemory :: ParamName
CekStartupCost'exBudgetCPU :: ParamName
CekStartupCost'exBudgetMemory :: ParamName
CekVarCost'exBudgetCPU :: ParamName
CekVarCost'exBudgetMemory :: ParamName
ChooseData'cpu'arguments :: ParamName
ChooseData'memory'arguments :: ParamName
ChooseList'cpu'arguments :: ParamName
ChooseList'memory'arguments :: ParamName
ChooseUnit'cpu'arguments :: ParamName
ChooseUnit'memory'arguments :: ParamName
ConsByteString'cpu'arguments'intercept :: ParamName
ConsByteString'cpu'arguments'slope :: ParamName
ConsByteString'memory'arguments'intercept :: ParamName
ConsByteString'memory'arguments'slope :: ParamName
ConstrData'cpu'arguments :: ParamName
ConstrData'memory'arguments :: ParamName
DecodeUtf8'cpu'arguments'intercept :: ParamName
DecodeUtf8'cpu'arguments'slope :: ParamName
DecodeUtf8'memory'arguments'intercept :: ParamName
DecodeUtf8'memory'arguments'slope :: ParamName
DivideInteger'cpu'arguments'constant :: ParamName
DivideInteger'cpu'arguments'model'arguments'intercept :: ParamName
DivideInteger'cpu'arguments'model'arguments'slope :: ParamName
DivideInteger'memory'arguments'intercept :: ParamName
DivideInteger'memory'arguments'minimum :: ParamName
DivideInteger'memory'arguments'slope :: ParamName
EncodeUtf8'cpu'arguments'intercept :: ParamName
EncodeUtf8'cpu'arguments'slope :: ParamName
EncodeUtf8'memory'arguments'intercept :: ParamName
EncodeUtf8'memory'arguments'slope :: ParamName
EqualsByteString'cpu'arguments'constant :: ParamName
EqualsByteString'cpu'arguments'intercept :: ParamName
EqualsByteString'cpu'arguments'slope :: ParamName
EqualsByteString'memory'arguments :: ParamName
EqualsData'cpu'arguments'intercept :: ParamName
EqualsData'cpu'arguments'slope :: ParamName
EqualsData'memory'arguments :: ParamName
EqualsInteger'cpu'arguments'intercept :: ParamName
EqualsInteger'cpu'arguments'slope :: ParamName
EqualsInteger'memory'arguments :: ParamName
EqualsString'cpu'arguments'constant :: ParamName
EqualsString'cpu'arguments'intercept :: ParamName
EqualsString'cpu'arguments'slope :: ParamName
EqualsString'memory'arguments :: ParamName
FstPair'cpu'arguments :: ParamName
FstPair'memory'arguments :: ParamName
HeadList'cpu'arguments :: ParamName
HeadList'memory'arguments :: ParamName
IData'cpu'arguments :: ParamName
IData'memory'arguments :: ParamName
IfThenElse'cpu'arguments :: ParamName
IfThenElse'memory'arguments :: ParamName
IndexByteString'cpu'arguments :: ParamName
IndexByteString'memory'arguments :: ParamName
LengthOfByteString'cpu'arguments :: ParamName
LengthOfByteString'memory'arguments :: ParamName
LessThanByteString'cpu'arguments'intercept :: ParamName
LessThanByteString'cpu'arguments'slope :: ParamName
LessThanByteString'memory'arguments :: ParamName
LessThanEqualsByteString'cpu'arguments'intercept :: ParamName
LessThanEqualsByteString'cpu'arguments'slope :: ParamName
LessThanEqualsByteString'memory'arguments :: ParamName
LessThanEqualsInteger'cpu'arguments'intercept :: ParamName
LessThanEqualsInteger'cpu'arguments'slope :: ParamName
LessThanEqualsInteger'memory'arguments :: ParamName
LessThanInteger'cpu'arguments'intercept :: ParamName
LessThanInteger'cpu'arguments'slope :: ParamName
LessThanInteger'memory'arguments :: ParamName
ListData'cpu'arguments :: ParamName
ListData'memory'arguments :: ParamName
MapData'cpu'arguments :: ParamName
MapData'memory'arguments :: ParamName
MkCons'cpu'arguments :: ParamName
MkCons'memory'arguments :: ParamName
MkNilData'cpu'arguments :: ParamName
MkNilData'memory'arguments :: ParamName
MkNilPairData'cpu'arguments :: ParamName
MkNilPairData'memory'arguments :: ParamName
MkPairData'cpu'arguments :: ParamName
MkPairData'memory'arguments :: ParamName
ModInteger'cpu'arguments'constant :: ParamName
ModInteger'cpu'arguments'model'arguments'intercept :: ParamName
ModInteger'cpu'arguments'model'arguments'slope :: ParamName
ModInteger'memory'arguments'intercept :: ParamName
ModInteger'memory'arguments'minimum :: ParamName
ModInteger'memory'arguments'slope :: ParamName
MultiplyInteger'cpu'arguments'intercept :: ParamName
MultiplyInteger'cpu'arguments'slope :: ParamName
MultiplyInteger'memory'arguments'intercept :: ParamName
MultiplyInteger'memory'arguments'slope :: ParamName
NullList'cpu'arguments :: ParamName
NullList'memory'arguments :: ParamName
QuotientInteger'cpu'arguments'constant :: ParamName
QuotientInteger'cpu'arguments'model'arguments'intercept :: ParamName
QuotientInteger'cpu'arguments'model'arguments'slope :: ParamName
QuotientInteger'memory'arguments'intercept :: ParamName
QuotientInteger'memory'arguments'minimum :: ParamName
QuotientInteger'memory'arguments'slope :: ParamName
RemainderInteger'cpu'arguments'constant :: ParamName
RemainderInteger'cpu'arguments'model'arguments'intercept :: ParamName
RemainderInteger'cpu'arguments'model'arguments'slope :: ParamName
RemainderInteger'memory'arguments'intercept :: ParamName
RemainderInteger'memory'arguments'minimum :: ParamName
RemainderInteger'memory'arguments'slope :: ParamName
Sha2_256'cpu'arguments'intercept :: ParamName
Sha2_256'cpu'arguments'slope :: ParamName
Sha2_256'memory'arguments :: ParamName
Sha3_256'cpu'arguments'intercept :: ParamName
Sha3_256'cpu'arguments'slope :: ParamName
Sha3_256'memory'arguments :: ParamName
SliceByteString'cpu'arguments'intercept :: ParamName
SliceByteString'cpu'arguments'slope :: ParamName
SliceByteString'memory'arguments'intercept :: ParamName
SliceByteString'memory'arguments'slope :: ParamName
SndPair'cpu'arguments :: ParamName
SndPair'memory'arguments :: ParamName
SubtractInteger'cpu'arguments'intercept :: ParamName
SubtractInteger'cpu'arguments'slope :: ParamName
SubtractInteger'memory'arguments'intercept :: ParamName
SubtractInteger'memory'arguments'slope :: ParamName
TailList'cpu'arguments :: ParamName
TailList'memory'arguments :: ParamName
Trace'cpu'arguments :: ParamName
Trace'memory'arguments :: ParamName
UnBData'cpu'arguments :: ParamName
UnBData'memory'arguments :: ParamName
UnConstrData'cpu'arguments :: ParamName
UnConstrData'memory'arguments :: ParamName
UnIData'cpu'arguments :: ParamName
UnIData'memory'arguments :: ParamName
UnListData'cpu'arguments :: ParamName
UnListData'memory'arguments :: ParamName
UnMapData'cpu'arguments :: ParamName
UnMapData'memory'arguments :: ParamName
VerifyEd25519Signature'cpu'arguments'intercept :: ParamName
VerifyEd25519Signature'cpu'arguments'slope :: ParamName
VerifyEd25519Signature'memory'arguments :: ParamName
data () => CostModelApplyError
CMUnknownParamError :: !Text -> CostModelApplyError
CMInternalReadError :: CostModelApplyError
CMInternalWriteError :: !String -> CostModelApplyError
type CostModelParams = Map Text Int64
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()

-- | The context that the currently-executing script can access.
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext

-- | information about the transaction the currently-executing script is
--   included in
[scriptContextTxInfo] :: ScriptContext -> TxInfo

-- | the purpose of the currently-executing script
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose
data () => BuiltinByteString
toBuiltin :: HasToBuiltin a => a -> ToBuiltin a
fromBuiltin :: HasFromBuiltin arep => arep -> FromBuiltin arep
toOpaque :: HasToOpaque a arep => a -> arep
fromOpaque :: HasFromOpaque arep a => arep -> a
newtype LedgerBytes
LedgerBytes :: BuiltinByteString -> LedgerBytes
[getLedgerBytes] :: LedgerBytes -> BuiltinByteString

-- | Lift a Haskell bytestring to the Plutus abstraction <a>LedgerBytes</a>
fromBytes :: ByteString -> LedgerBytes

-- | A representation of the ledger DCert. Some information is digested,
--   and not included
data DCert
DCertDelegRegKey :: StakingCredential -> DCert
DCertDelegDeRegKey :: StakingCredential -> DCert
DCertDelegDelegate :: StakingCredential -> PubKeyHash -> DCert

-- | A digest of the PoolParams
DCertPoolRegister :: PubKeyHash -> PubKeyHash -> DCert

-- | The retirement certificate and the Epoch in which the retirement will
--   take place
DCertPoolRetire :: PubKeyHash -> Integer -> DCert

-- | A really terse Digest
DCertGenesis :: DCert

-- | Another really terse Digest
DCertMir :: DCert

-- | Staking credential used to assign rewards.
data StakingCredential

-- | The staking hash is the <a>Credential</a> required to unlock a
--   transaction output. Either a public key credential (<a>PubKeyHash</a>)
--   or a script credential (<a>ScriptHash</a>). Both are hashed with
--   <i>BLAKE2b-244</i>. 28 byte.
StakingHash :: Credential -> StakingCredential

-- | The certificate pointer, constructed by the given slot number,
--   transaction and certificate indices. NB: The fields should really be
--   all <tt>Word64</tt>, as they are implemented in <tt>Word64</tt>, but
--   <a>Integer</a> is our only integral type so we need to use it instead.
StakingPtr :: Integer -> Integer -> Integer -> StakingCredential

-- | Credentials required to unlock a transaction output.
data Credential

-- | The transaction that spends this output must be signed by the private
--   key. See <a>PubKeyHash</a>.
PubKeyCredential :: PubKeyHash -> Credential

-- | The transaction that spends this output must include the validator
--   script and be accepted by the validator. See <a>ScriptHash</a>.
ScriptCredential :: ScriptHash -> Credential

-- | The <a>Value</a> type represents a collection of amounts of different
--   currencies. We can think of <a>Value</a> as a vector space whose
--   dimensions are currencies.
--   
--   Operations on currencies are usually implemented <i>pointwise</i>.
--   That is, we apply the operation to the quantities for each currency in
--   turn. So when we add two <a>Value</a>s the resulting <a>Value</a> has,
--   for each currency, the sum of the quantities of <i>that particular</i>
--   currency in the argument <a>Value</a>. The effect of this is that the
--   currencies in the <a>Value</a> are "independent", and are operated on
--   separately.
--   
--   Whenever we need to get the quantity of a currency in a <a>Value</a>
--   where there is no explicit quantity of that currency in the
--   <a>Value</a>, then the quantity is taken to be zero.
--   
--   There is no 'Ord Value' instance since <a>Value</a> is only a partial
--   order, so <a>compare</a> can't do the right thing in some cases.
newtype Value
Value :: Map CurrencySymbol (Map TokenName Integer) -> Value
[getValue] :: Value -> Map CurrencySymbol (Map TokenName Integer)

-- | ByteString representing the currency, hashed with <i>BLAKE2b-224</i>.
--   It is empty for <tt>Ada</tt>, 28 bytes for <tt>MintingPolicyHash</tt>.
--   Forms an <a>AssetClass</a> along with <a>TokenName</a>. A <a>Value</a>
--   is a map from <a>CurrencySymbol</a>'s to a map from <a>TokenName</a>
--   to an <a>Integer</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype CurrencySymbol
CurrencySymbol :: BuiltinByteString -> CurrencySymbol
[unCurrencySymbol] :: CurrencySymbol -> BuiltinByteString

-- | ByteString of a name of a token. Shown as UTF-8 string when possible.
--   Should be no longer than 32 bytes, empty for Ada. Forms an
--   <a>AssetClass</a> along with a <a>CurrencySymbol</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TokenName
TokenName :: BuiltinByteString -> TokenName
[unTokenName] :: TokenName -> BuiltinByteString

-- | Make a <a>Value</a> containing only the given quantity of the given
--   currency.
singleton :: CurrencySymbol -> TokenName -> Integer -> Value

-- | Combine two <a>Value</a> maps with the argument function. Assumes the
--   well-definedness of the two maps.
unionWith :: (Integer -> Integer -> Integer) -> Value -> Value -> Value

-- | The <a>CurrencySymbol</a> of the <tt>Ada</tt> currency.
adaSymbol :: CurrencySymbol

-- | The <a>TokenName</a> of the <tt>Ada</tt> currency.
adaToken :: TokenName
newtype Lovelace
Lovelace :: Integer -> Lovelace
[getLovelace] :: Lovelace -> Integer

-- | POSIX time is measured as the number of <i>milliseconds</i> since
--   1970-01-01T00:00:00Z. This is not the same as Haskell's
--   <a>POSIXTime</a>
newtype POSIXTime
POSIXTime :: Integer -> POSIXTime
[getPOSIXTime] :: POSIXTime -> Integer

-- | An <a>Interval</a> of <a>POSIXTime</a>s.
type POSIXTimeRange = Interval POSIXTime

-- | An address may contain two credentials, the payment credential and
--   optionally a <a>StakingCredential</a>.
data Address
Address :: Credential -> Maybe StakingCredential -> Address

-- | the payment credential
[addressCredential] :: Address -> Credential

-- | the staking credential
[addressStakingCredential] :: Address -> Maybe StakingCredential

-- | The hash of a public key. This is frequently used to identify the
--   public key, rather than the key itself. Hashed with
--   <i>BLAKE2b-224</i>. 28 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype PubKeyHash
PubKeyHash :: BuiltinByteString -> PubKeyHash
[getPubKeyHash] :: PubKeyHash -> BuiltinByteString

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> [(StakingCredential, Integer)] -> POSIXTimeRange -> [PubKeyHash] -> [(DatumHash, Datum)] -> TxId -> TxInfo

-- | Transaction inputs; cannot be an empty list
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals
[txInfoWdrl] :: TxInfo -> [(StakingCredential, Integer)]

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]

-- | The lookup table of datums attached to the transaction
[txInfoData] :: TxInfo -> [(DatumHash, Datum)]

-- | Hash of the pending transaction body (i.e. transaction excluding
--   witnesses)
[txInfoId] :: TxInfo -> TxId

-- | A transaction output, consisting of a target address (<a>Address</a>),
--   a value (<a>Value</a>), and optionally a datum hash
--   (<a>DatumHash</a>).
data TxOut
TxOut :: Address -> Value -> Maybe DatumHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatumHash] :: TxOut -> Maybe DatumHash

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | An interval of <tt>a</tt>s.
--   
--   The interval may be either closed or open at either end, meaning that
--   the endpoints may or may not be included in the interval.
--   
--   The interval can also be unbounded on either side.
--   
--   The <a>Eq</a> instance gives equality of the intervals, not structural
--   equality. There is no <a>Ord</a> instance, but <a>contains</a> gives a
--   partial order.
--   
--   Note that some of the functions on <a>Interval</a> rely on <a>Enum</a>
--   in order to handle non-inclusive endpoints. For this reason, it may
--   not be safe to use <a>Interval</a>s with non-inclusive endpoints on
--   types whose <a>Enum</a> instances have partial methods.
data Interval a
Interval :: LowerBound a -> UpperBound a -> Interval a
[ivFrom] :: Interval a -> LowerBound a
[ivTo] :: Interval a -> UpperBound a

-- | A set extended with a positive and negative infinity.
data Extended a
NegInf :: Extended a
Finite :: a -> Extended a
PosInf :: Extended a

-- | Whether a bound is inclusive or not.
type Closure = Bool

-- | The upper bound of an interval.
data UpperBound a
UpperBound :: Extended a -> Closure -> UpperBound a

-- | The lower bound of an interval.
data LowerBound a
LowerBound :: Extended a -> Closure -> LowerBound a

-- | An <a>Interval</a> that covers every slot. In math. notation [-∞,+∞]
always :: Interval a

-- | <tt>from a</tt> is an <a>Interval</a> that includes all values that
--   are greater than or equal to <tt>a</tt>. In math. notation: [a,+∞]
from :: a -> Interval a

-- | <tt>to a</tt> is an <a>Interval</a> that includes all values that are
--   smaller than or equal to <tt>a</tt>. In math. notation: [-∞,a]
to :: a -> Interval a

-- | Construct a lower bound from a value.
--   
--   The resulting bound includes all values that are equal or greater than
--   the input value.
lowerBound :: a -> LowerBound a

-- | Construct an upper bound from a value.
--   
--   The resulting bound includes all values that are equal or smaller than
--   the input value.
upperBound :: a -> UpperBound a

-- | Construct a strict lower bound from a value.
--   
--   The resulting bound includes all values that are (strictly) greater
--   than the input value.
strictLowerBound :: a -> LowerBound a

-- | Construct a strict upper bound from a value.
--   
--   The resulting bound includes all values that are (strictly) smaller
--   than the input value.
strictUpperBound :: a -> UpperBound a

-- | Type representing the <i>BLAKE2b-224</i> hash of a script. 28 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype ScriptHash
ScriptHash :: BuiltinByteString -> ScriptHash
[getScriptHash] :: ScriptHash -> BuiltinByteString

-- | <a>Redeemer</a> is a wrapper around <tt>Data</tt> values that are used
--   as redeemers in transaction inputs.
newtype Redeemer
Redeemer :: BuiltinData -> Redeemer
[getRedeemer] :: Redeemer -> BuiltinData

-- | Type representing the <i>BLAKE2b-256</i> hash of a redeemer. 32 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype RedeemerHash
RedeemerHash :: BuiltinByteString -> RedeemerHash

-- | <a>Datum</a> is a wrapper around <tt>Data</tt> values which are used
--   as data in transaction outputs.
newtype Datum
Datum :: BuiltinData -> Datum
[getDatum] :: Datum -> BuiltinData

-- | Type representing the <i>BLAKE2b-256</i> hash of a datum. 32 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype DatumHash
DatumHash :: BuiltinByteString -> DatumHash
data () => Data
Constr :: Integer -> [Data] -> Data
Map :: [(Data, Data)] -> Data
List :: [Data] -> Data
I :: Integer -> Data
B :: ByteString -> Data
data () => BuiltinData
BuiltinData :: ~Data -> BuiltinData
class () => ToData a
toBuiltinData :: ToData a => a -> BuiltinData
class () => FromData a
fromBuiltinData :: FromData a => BuiltinData -> Maybe a
class () => UnsafeFromData a
unsafeFromBuiltinData :: UnsafeFromData a => BuiltinData -> a
toData :: ToData a => a -> Data
fromData :: FromData a => Data -> Maybe a
unsafeFromData :: UnsafeFromData a => Data -> a
dataToBuiltinData :: Data -> BuiltinData
builtinDataToData :: BuiltinData -> Data

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>MonadError</a> class. (If you are using the deprecated
--   <a>Control.Monad.Error</a> or <a>Control.Monad.Trans.Error</a>, you
--   may also have to define an <tt>Error</tt> instance.)
class Monad m => MonadError e (m :: Type -> Type) | m -> e

-- | Errors that can be thrown when evaluating a Plutus script.
data EvaluationError

-- | An error from the evaluator itself
CekError :: !CekEvaluationException NamedDeBruijn DefaultUni DefaultFun -> EvaluationError

-- | An error in the pre-evaluation step of converting from de-Bruijn
--   indices
DeBruijnError :: !FreeVariableError -> EvaluationError

-- | A deserialisation error TODO: make this error more informative when we
--   have more information about what went wrong
CodecError :: !ScriptDecodeError -> EvaluationError

-- | An error indicating that the cost model parameters didn't match what
--   we expected
CostModelParameterMismatch :: EvaluationError

-- | The script evaluated to a value that is not a valid return value.
InvalidReturnValue :: EvaluationError

-- | An error that occurred during script deserialization.
data ScriptDecodeError

-- | an error from the underlying CBOR/serialise library
CBORDeserialiseError :: !DeserialiseFailureInfo -> ScriptDecodeError

-- | Script was successfully parsed, but more (runaway) bytes encountered
--   after script's position
RemainderError :: !ByteString -> ScriptDecodeError

-- | the plutus version of the given script is not enabled yet
LedgerLanguageNotAvailableError :: !PlutusLedgerLanguage -> !MajorProtocolVersion -> !MajorProtocolVersion -> ScriptDecodeError

-- | the script's ledger language
[sdeAffectedLang] :: ScriptDecodeError -> !PlutusLedgerLanguage

-- | the major protocol version that will first introduce/enable the ledger
--   language
[sdeIntroPv] :: ScriptDecodeError -> !MajorProtocolVersion

-- | the current protocol version
[sdeThisPv] :: ScriptDecodeError -> !MajorProtocolVersion
PlutusCoreLanguageNotAvailableError :: !Version -> !PlutusLedgerLanguage -> !MajorProtocolVersion -> ScriptDecodeError

-- | the Plutus Core language of the script under execution.
[sdeAffectedVersion] :: ScriptDecodeError -> !Version

-- | the Plutus ledger language of the script under execution.
[sdeThisLang] :: ScriptDecodeError -> !PlutusLedgerLanguage

-- | the current protocol version
[sdeThisPv] :: ScriptDecodeError -> !MajorProtocolVersion


-- | The interface to Plutus V2 for the ledger.
module PlutusLedgerApi.V2

-- | Scripts to the ledger are serialised bytestrings.
type SerialisedScript = ShortByteString

-- | A Plutus script ready to be evaluated on-chain, via
--   <tt>evaluateScriptRestricting</tt>.
data ScriptForEvaluation

-- | Get a <a>SerialisedScript</a> from a <a>ScriptForEvaluation</a>.
--   <i>O(1)</i>.
serialisedScript :: ScriptForEvaluation -> SerialisedScript

-- | Get a <a>ScriptNamedDeBruijn</a> from a <a>ScriptForEvaluation</a>.
--   <i>O(1)</i>.
deserialisedScript :: ScriptForEvaluation -> ScriptNamedDeBruijn

-- | Turns a program which was compiled using the 'PlutusTx' toolchain into
--   a binary format that is understood by the network and can be stored
--   on-chain.
serialiseCompiledCode :: forall a. CompiledCode a -> SerialisedScript

-- | Turns a program's AST (most likely manually constructed) into a binary
--   format that is understood by the network and can be stored on-chain.
serialiseUPLC :: Program DeBruijn DefaultUni DefaultFun () -> SerialisedScript

-- | The deserialization from a serialised script into a
--   <tt>ScriptForEvaluation</tt>, ready to be evaluated on-chain. Called
--   inside phase-1 validation (i.e., deserialisation error is a phase-1
--   error).
deserialiseScript :: forall m. MonadError ScriptDecodeError m => MajorProtocolVersion -> SerialisedScript -> m ScriptForEvaluation

-- | Deserialises a <a>SerialisedScript</a> back into an AST. Does *not* do
--   ledger-language-version-specific checks like for allowable builtins.
uncheckedDeserialiseUPLC :: SerialisedScript -> Program DeBruijn DefaultUni DefaultFun ()

-- | Evaluates a script, with a cost model and a budget that restricts how
--   many resources it can use according to the cost model. Also returns
--   the budget that was actually used.
--   
--   Can be used to calculate budgets for scripts, but even in this case
--   you must give a limit to guard against scripts that run for a long
--   time or loop.
evaluateScriptRestricting :: MajorProtocolVersion -> VerboseMode -> EvaluationContext -> ExBudget -> ScriptForEvaluation -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | Evaluates a script, returning the minimum budget that the script would
--   need to evaluate successfully. This will take as long as the script
--   takes, if you need to limit the execution time of the script also, you
--   can use <a>evaluateScriptRestricting</a>, which also returns the used
--   budget.
evaluateScriptCounting :: MajorProtocolVersion -> VerboseMode -> EvaluationContext -> ScriptForEvaluation -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | This represents the major component of the Cardano protocol version.
--   The ledger can only supply the major component of the protocol
--   version, not the minor component, and Plutus should only need to care
--   about the major component anyway. This relies on careful understanding
--   between us and the ledger as to what this means.
newtype MajorProtocolVersion
MajorProtocolVersion :: Int -> MajorProtocolVersion
[getMajorProtocolVersion] :: MajorProtocolVersion -> Int

-- | A simple toggle indicating whether or not we should accumulate logs
--   during script execution.
data VerboseMode

-- | accumulate all traces
Verbose :: VerboseMode

-- | don't accumulate anything
Quiet :: VerboseMode

-- | The type of the executed script's accumulated log output: a list of
--   <a>Text</a>.
--   
--   It will be an empty list if the <a>VerboseMode</a> is set to
--   <a>Quiet</a>.
type LogOutput = [Text]
data () => ExBudget
ExBudget :: ExCPU -> ExMemory -> ExBudget
[exBudgetCPU] :: ExBudget -> ExCPU
[exBudgetMemory] :: ExBudget -> ExMemory
newtype () => ExCPU
ExCPU :: CostingInteger -> ExCPU
newtype () => ExMemory
ExMemory :: CostingInteger -> ExMemory
data () => SatInt
fromSatInt :: Num a => SatInt -> a

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than being recomputed on every
--   evaluation.
--   
--   Different protocol versions may require different bundles of machine
--   parameters, which allows us for example to tweak the shape of the
--   costing function of a builtin, so that the builtin costs less.
--   Currently this means that we have to create multiple
--   <a>DefaultMachineParameters</a> per language version, which we put
--   into a cache (represented by an association list) in order to avoid
--   costly recomputation of machine parameters.
--   
--   In order to get the appropriate <a>DefaultMachineParameters</a> at
--   validation time we look it up in the cache using a semantics variant
--   as a key. We compute the semantics variant from the protocol version
--   using the stored function. Note that the semantics variant depends on
--   the language version too, but the latter is known statically (because
--   each language version has its own evaluation context), hence there's
--   no reason to require it to be provided at runtime.
--   
--   To say it differently, there's a matrix of semantics variants indexed
--   by (LL, PV) pairs and we cache its particular row corresponding to the
--   statically given LL in an <a>EvaluationContext</a>.
--   
--   The reason why we associate a <a>DefaultMachineParameters</a> with a
--   semantics variant rather than a protocol version are
--   
--   <ol>
--   <li>generally there are far more protocol versions than semantics
--   variants supported by a specific language version, so we save on
--   pointless duplication of bundles of machine parameters</li>
--   <li>builtins don't know anything about protocol versions, only
--   semantics variants. It is therefore more semantically precise to
--   associate bundles of machine parameters with semantics variants than
--   with protocol versions</li>
--   </ol>
data EvaluationContext

-- | Build the <a>EvaluationContext</a>.
--   
--   The input is a list of cost model parameters (which are integer
--   values) passed from the ledger.
--   
--   IMPORTANT: the cost model parameters <b>MUST</b> appear in the correct
--   order, matching the names in <a>ParamName</a>. If the parameters are
--   supplied in the wrong order then script cost calculations will be
--   incorrect.
--   
--   IMPORTANT: The evaluation context of every Plutus version must be
--   recreated upon a protocol update with the updated cost model
--   parameters.
mkEvaluationContext :: (MonadError CostModelApplyError m, MonadWriter [CostModelApplyWarn] m) => [Int64] -> m EvaluationContext

-- | The enumeration of all possible cost model parameter names for this
--   language version.
--   
--   IMPORTANT: The order of appearance of the data constructors here
--   matters. DO NOT REORDER. See Note [Quotation marks in cost model
--   parameter constructors] See Note [Cost model parameters from the
--   ledger's point of view]
data ParamName
AddInteger'cpu'arguments'intercept :: ParamName
AddInteger'cpu'arguments'slope :: ParamName
AddInteger'memory'arguments'intercept :: ParamName
AddInteger'memory'arguments'slope :: ParamName
AppendByteString'cpu'arguments'intercept :: ParamName
AppendByteString'cpu'arguments'slope :: ParamName
AppendByteString'memory'arguments'intercept :: ParamName
AppendByteString'memory'arguments'slope :: ParamName
AppendString'cpu'arguments'intercept :: ParamName
AppendString'cpu'arguments'slope :: ParamName
AppendString'memory'arguments'intercept :: ParamName
AppendString'memory'arguments'slope :: ParamName
BData'cpu'arguments :: ParamName
BData'memory'arguments :: ParamName
Blake2b_256'cpu'arguments'intercept :: ParamName
Blake2b_256'cpu'arguments'slope :: ParamName
Blake2b_256'memory'arguments :: ParamName
CekApplyCost'exBudgetCPU :: ParamName
CekApplyCost'exBudgetMemory :: ParamName
CekBuiltinCost'exBudgetCPU :: ParamName
CekBuiltinCost'exBudgetMemory :: ParamName
CekConstCost'exBudgetCPU :: ParamName
CekConstCost'exBudgetMemory :: ParamName
CekDelayCost'exBudgetCPU :: ParamName
CekDelayCost'exBudgetMemory :: ParamName
CekForceCost'exBudgetCPU :: ParamName
CekForceCost'exBudgetMemory :: ParamName
CekLamCost'exBudgetCPU :: ParamName
CekLamCost'exBudgetMemory :: ParamName
CekStartupCost'exBudgetCPU :: ParamName
CekStartupCost'exBudgetMemory :: ParamName
CekVarCost'exBudgetCPU :: ParamName
CekVarCost'exBudgetMemory :: ParamName
ChooseData'cpu'arguments :: ParamName
ChooseData'memory'arguments :: ParamName
ChooseList'cpu'arguments :: ParamName
ChooseList'memory'arguments :: ParamName
ChooseUnit'cpu'arguments :: ParamName
ChooseUnit'memory'arguments :: ParamName
ConsByteString'cpu'arguments'intercept :: ParamName
ConsByteString'cpu'arguments'slope :: ParamName
ConsByteString'memory'arguments'intercept :: ParamName
ConsByteString'memory'arguments'slope :: ParamName
ConstrData'cpu'arguments :: ParamName
ConstrData'memory'arguments :: ParamName
DecodeUtf8'cpu'arguments'intercept :: ParamName
DecodeUtf8'cpu'arguments'slope :: ParamName
DecodeUtf8'memory'arguments'intercept :: ParamName
DecodeUtf8'memory'arguments'slope :: ParamName
DivideInteger'cpu'arguments'constant :: ParamName
DivideInteger'cpu'arguments'model'arguments'intercept :: ParamName
DivideInteger'cpu'arguments'model'arguments'slope :: ParamName
DivideInteger'memory'arguments'intercept :: ParamName
DivideInteger'memory'arguments'minimum :: ParamName
DivideInteger'memory'arguments'slope :: ParamName
EncodeUtf8'cpu'arguments'intercept :: ParamName
EncodeUtf8'cpu'arguments'slope :: ParamName
EncodeUtf8'memory'arguments'intercept :: ParamName
EncodeUtf8'memory'arguments'slope :: ParamName
EqualsByteString'cpu'arguments'constant :: ParamName
EqualsByteString'cpu'arguments'intercept :: ParamName
EqualsByteString'cpu'arguments'slope :: ParamName
EqualsByteString'memory'arguments :: ParamName
EqualsData'cpu'arguments'intercept :: ParamName
EqualsData'cpu'arguments'slope :: ParamName
EqualsData'memory'arguments :: ParamName
EqualsInteger'cpu'arguments'intercept :: ParamName
EqualsInteger'cpu'arguments'slope :: ParamName
EqualsInteger'memory'arguments :: ParamName
EqualsString'cpu'arguments'constant :: ParamName
EqualsString'cpu'arguments'intercept :: ParamName
EqualsString'cpu'arguments'slope :: ParamName
EqualsString'memory'arguments :: ParamName
FstPair'cpu'arguments :: ParamName
FstPair'memory'arguments :: ParamName
HeadList'cpu'arguments :: ParamName
HeadList'memory'arguments :: ParamName
IData'cpu'arguments :: ParamName
IData'memory'arguments :: ParamName
IfThenElse'cpu'arguments :: ParamName
IfThenElse'memory'arguments :: ParamName
IndexByteString'cpu'arguments :: ParamName
IndexByteString'memory'arguments :: ParamName
LengthOfByteString'cpu'arguments :: ParamName
LengthOfByteString'memory'arguments :: ParamName
LessThanByteString'cpu'arguments'intercept :: ParamName
LessThanByteString'cpu'arguments'slope :: ParamName
LessThanByteString'memory'arguments :: ParamName
LessThanEqualsByteString'cpu'arguments'intercept :: ParamName
LessThanEqualsByteString'cpu'arguments'slope :: ParamName
LessThanEqualsByteString'memory'arguments :: ParamName
LessThanEqualsInteger'cpu'arguments'intercept :: ParamName
LessThanEqualsInteger'cpu'arguments'slope :: ParamName
LessThanEqualsInteger'memory'arguments :: ParamName
LessThanInteger'cpu'arguments'intercept :: ParamName
LessThanInteger'cpu'arguments'slope :: ParamName
LessThanInteger'memory'arguments :: ParamName
ListData'cpu'arguments :: ParamName
ListData'memory'arguments :: ParamName
MapData'cpu'arguments :: ParamName
MapData'memory'arguments :: ParamName
MkCons'cpu'arguments :: ParamName
MkCons'memory'arguments :: ParamName
MkNilData'cpu'arguments :: ParamName
MkNilData'memory'arguments :: ParamName
MkNilPairData'cpu'arguments :: ParamName
MkNilPairData'memory'arguments :: ParamName
MkPairData'cpu'arguments :: ParamName
MkPairData'memory'arguments :: ParamName
ModInteger'cpu'arguments'constant :: ParamName
ModInteger'cpu'arguments'model'arguments'intercept :: ParamName
ModInteger'cpu'arguments'model'arguments'slope :: ParamName
ModInteger'memory'arguments'intercept :: ParamName
ModInteger'memory'arguments'minimum :: ParamName
ModInteger'memory'arguments'slope :: ParamName
MultiplyInteger'cpu'arguments'intercept :: ParamName
MultiplyInteger'cpu'arguments'slope :: ParamName
MultiplyInteger'memory'arguments'intercept :: ParamName
MultiplyInteger'memory'arguments'slope :: ParamName
NullList'cpu'arguments :: ParamName
NullList'memory'arguments :: ParamName
QuotientInteger'cpu'arguments'constant :: ParamName
QuotientInteger'cpu'arguments'model'arguments'intercept :: ParamName
QuotientInteger'cpu'arguments'model'arguments'slope :: ParamName
QuotientInteger'memory'arguments'intercept :: ParamName
QuotientInteger'memory'arguments'minimum :: ParamName
QuotientInteger'memory'arguments'slope :: ParamName
RemainderInteger'cpu'arguments'constant :: ParamName
RemainderInteger'cpu'arguments'model'arguments'intercept :: ParamName
RemainderInteger'cpu'arguments'model'arguments'slope :: ParamName
RemainderInteger'memory'arguments'intercept :: ParamName
RemainderInteger'memory'arguments'minimum :: ParamName
RemainderInteger'memory'arguments'slope :: ParamName
SerialiseData'cpu'arguments'intercept :: ParamName
SerialiseData'cpu'arguments'slope :: ParamName
SerialiseData'memory'arguments'intercept :: ParamName
SerialiseData'memory'arguments'slope :: ParamName
Sha2_256'cpu'arguments'intercept :: ParamName
Sha2_256'cpu'arguments'slope :: ParamName
Sha2_256'memory'arguments :: ParamName
Sha3_256'cpu'arguments'intercept :: ParamName
Sha3_256'cpu'arguments'slope :: ParamName
Sha3_256'memory'arguments :: ParamName
SliceByteString'cpu'arguments'intercept :: ParamName
SliceByteString'cpu'arguments'slope :: ParamName
SliceByteString'memory'arguments'intercept :: ParamName
SliceByteString'memory'arguments'slope :: ParamName
SndPair'cpu'arguments :: ParamName
SndPair'memory'arguments :: ParamName
SubtractInteger'cpu'arguments'intercept :: ParamName
SubtractInteger'cpu'arguments'slope :: ParamName
SubtractInteger'memory'arguments'intercept :: ParamName
SubtractInteger'memory'arguments'slope :: ParamName
TailList'cpu'arguments :: ParamName
TailList'memory'arguments :: ParamName
Trace'cpu'arguments :: ParamName
Trace'memory'arguments :: ParamName
UnBData'cpu'arguments :: ParamName
UnBData'memory'arguments :: ParamName
UnConstrData'cpu'arguments :: ParamName
UnConstrData'memory'arguments :: ParamName
UnIData'cpu'arguments :: ParamName
UnIData'memory'arguments :: ParamName
UnListData'cpu'arguments :: ParamName
UnListData'memory'arguments :: ParamName
UnMapData'cpu'arguments :: ParamName
UnMapData'memory'arguments :: ParamName
VerifyEcdsaSecp256k1Signature'cpu'arguments :: ParamName
VerifyEcdsaSecp256k1Signature'memory'arguments :: ParamName
VerifyEd25519Signature'cpu'arguments'intercept :: ParamName
VerifyEd25519Signature'cpu'arguments'slope :: ParamName
VerifyEd25519Signature'memory'arguments :: ParamName
VerifySchnorrSecp256k1Signature'cpu'arguments'intercept :: ParamName
VerifySchnorrSecp256k1Signature'cpu'arguments'slope :: ParamName
VerifySchnorrSecp256k1Signature'memory'arguments :: ParamName
IntegerToByteString'cpu'arguments'c0 :: ParamName
IntegerToByteString'cpu'arguments'c1 :: ParamName
IntegerToByteString'cpu'arguments'c2 :: ParamName
IntegerToByteString'memory'arguments'intercept :: ParamName
IntegerToByteString'memory'arguments'slope :: ParamName
ByteStringToInteger'cpu'arguments'c0 :: ParamName
ByteStringToInteger'cpu'arguments'c1 :: ParamName
ByteStringToInteger'cpu'arguments'c2 :: ParamName
ByteStringToInteger'memory'arguments'intercept :: ParamName
ByteStringToInteger'memory'arguments'slope :: ParamName
data () => CostModelApplyError
CMUnknownParamError :: !Text -> CostModelApplyError
CMInternalReadError :: CostModelApplyError
CMInternalWriteError :: !String -> CostModelApplyError
type CostModelParams = Map Text Int64
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()

-- | The context that the currently-executing script can access.
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext

-- | information about the transaction the currently-executing script is
--   included in
[scriptContextTxInfo] :: ScriptContext -> TxInfo

-- | the purpose of the currently-executing script
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose
data () => BuiltinByteString
toBuiltin :: HasToBuiltin a => a -> ToBuiltin a
fromBuiltin :: HasFromBuiltin arep => arep -> FromBuiltin arep
toOpaque :: HasToOpaque a arep => a -> arep
fromOpaque :: HasFromOpaque arep a => arep -> a
newtype LedgerBytes
LedgerBytes :: BuiltinByteString -> LedgerBytes
[getLedgerBytes] :: LedgerBytes -> BuiltinByteString

-- | Lift a Haskell bytestring to the Plutus abstraction <a>LedgerBytes</a>
fromBytes :: ByteString -> LedgerBytes

-- | A representation of the ledger DCert. Some information is digested,
--   and not included
data DCert
DCertDelegRegKey :: StakingCredential -> DCert
DCertDelegDeRegKey :: StakingCredential -> DCert
DCertDelegDelegate :: StakingCredential -> PubKeyHash -> DCert

-- | A digest of the PoolParams
DCertPoolRegister :: PubKeyHash -> PubKeyHash -> DCert

-- | The retirement certificate and the Epoch in which the retirement will
--   take place
DCertPoolRetire :: PubKeyHash -> Integer -> DCert

-- | A really terse Digest
DCertGenesis :: DCert

-- | Another really terse Digest
DCertMir :: DCert

-- | Staking credential used to assign rewards.
data StakingCredential

-- | The staking hash is the <a>Credential</a> required to unlock a
--   transaction output. Either a public key credential (<a>PubKeyHash</a>)
--   or a script credential (<a>ScriptHash</a>). Both are hashed with
--   <i>BLAKE2b-244</i>. 28 byte.
StakingHash :: Credential -> StakingCredential

-- | The certificate pointer, constructed by the given slot number,
--   transaction and certificate indices. NB: The fields should really be
--   all <tt>Word64</tt>, as they are implemented in <tt>Word64</tt>, but
--   <a>Integer</a> is our only integral type so we need to use it instead.
StakingPtr :: Integer -> Integer -> Integer -> StakingCredential

-- | Credentials required to unlock a transaction output.
data Credential

-- | The transaction that spends this output must be signed by the private
--   key. See <a>PubKeyHash</a>.
PubKeyCredential :: PubKeyHash -> Credential

-- | The transaction that spends this output must include the validator
--   script and be accepted by the validator. See <a>ScriptHash</a>.
ScriptCredential :: ScriptHash -> Credential

-- | The <a>Value</a> type represents a collection of amounts of different
--   currencies. We can think of <a>Value</a> as a vector space whose
--   dimensions are currencies.
--   
--   Operations on currencies are usually implemented <i>pointwise</i>.
--   That is, we apply the operation to the quantities for each currency in
--   turn. So when we add two <a>Value</a>s the resulting <a>Value</a> has,
--   for each currency, the sum of the quantities of <i>that particular</i>
--   currency in the argument <a>Value</a>. The effect of this is that the
--   currencies in the <a>Value</a> are "independent", and are operated on
--   separately.
--   
--   Whenever we need to get the quantity of a currency in a <a>Value</a>
--   where there is no explicit quantity of that currency in the
--   <a>Value</a>, then the quantity is taken to be zero.
--   
--   There is no 'Ord Value' instance since <a>Value</a> is only a partial
--   order, so <a>compare</a> can't do the right thing in some cases.
newtype Value
Value :: Map CurrencySymbol (Map TokenName Integer) -> Value
[getValue] :: Value -> Map CurrencySymbol (Map TokenName Integer)

-- | ByteString representing the currency, hashed with <i>BLAKE2b-224</i>.
--   It is empty for <tt>Ada</tt>, 28 bytes for <tt>MintingPolicyHash</tt>.
--   Forms an <a>AssetClass</a> along with <a>TokenName</a>. A <a>Value</a>
--   is a map from <a>CurrencySymbol</a>'s to a map from <a>TokenName</a>
--   to an <a>Integer</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype CurrencySymbol
CurrencySymbol :: BuiltinByteString -> CurrencySymbol
[unCurrencySymbol] :: CurrencySymbol -> BuiltinByteString

-- | ByteString of a name of a token. Shown as UTF-8 string when possible.
--   Should be no longer than 32 bytes, empty for Ada. Forms an
--   <a>AssetClass</a> along with a <a>CurrencySymbol</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TokenName
TokenName :: BuiltinByteString -> TokenName
[unTokenName] :: TokenName -> BuiltinByteString

-- | Make a <a>Value</a> containing only the given quantity of the given
--   currency.
singleton :: CurrencySymbol -> TokenName -> Integer -> Value

-- | Combine two <a>Value</a> maps with the argument function. Assumes the
--   well-definedness of the two maps.
unionWith :: (Integer -> Integer -> Integer) -> Value -> Value -> Value

-- | The <a>CurrencySymbol</a> of the <tt>Ada</tt> currency.
adaSymbol :: CurrencySymbol

-- | The <a>TokenName</a> of the <tt>Ada</tt> currency.
adaToken :: TokenName
newtype Lovelace
Lovelace :: Integer -> Lovelace
[getLovelace] :: Lovelace -> Integer

-- | POSIX time is measured as the number of <i>milliseconds</i> since
--   1970-01-01T00:00:00Z. This is not the same as Haskell's
--   <a>POSIXTime</a>
newtype POSIXTime
POSIXTime :: Integer -> POSIXTime
[getPOSIXTime] :: POSIXTime -> Integer

-- | An <a>Interval</a> of <a>POSIXTime</a>s.
type POSIXTimeRange = Interval POSIXTime

-- | An address may contain two credentials, the payment credential and
--   optionally a <a>StakingCredential</a>.
data Address
Address :: Credential -> Maybe StakingCredential -> Address

-- | the payment credential
[addressCredential] :: Address -> Credential

-- | the staking credential
[addressStakingCredential] :: Address -> Maybe StakingCredential

-- | The hash of a public key. This is frequently used to identify the
--   public key, rather than the key itself. Hashed with
--   <i>BLAKE2b-224</i>. 28 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype PubKeyHash
PubKeyHash :: BuiltinByteString -> PubKeyHash
[getPubKeyHash] :: PubKeyHash -> BuiltinByteString

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> Map StakingCredential Integer -> POSIXTimeRange -> [PubKeyHash] -> Map ScriptPurpose Redeemer -> Map DatumHash Datum -> TxId -> TxInfo

-- | Transaction inputs; cannot be an empty list
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | <i>Added in V2:</i> Transaction reference inputs
[txInfoReferenceInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals <i>V1-&gt;V2</i>: changed from assoc list to a
--   <a>AssocMap</a>
[txInfoWdrl] :: TxInfo -> Map StakingCredential Integer

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]

-- | <i>Added in V2:</i> a table of redeemers attached to the transaction
[txInfoRedeemers] :: TxInfo -> Map ScriptPurpose Redeemer

-- | The lookup table of datums attached to the transaction
--   <i>V1-&gt;V2</i>: changed from assoc list to a <a>AssocMap</a>
[txInfoData] :: TxInfo -> Map DatumHash Datum

-- | Hash of the pending transaction body (i.e. transaction excluding
--   witnesses)
[txInfoId] :: TxInfo -> TxId

-- | A transaction output, consisting of a target address, a value,
--   optionally a datum/datum hash, and optionally a reference script.
data TxOut
TxOut :: Address -> Value -> OutputDatum -> Maybe ScriptHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatum] :: TxOut -> OutputDatum
[txOutReferenceScript] :: TxOut -> Maybe ScriptHash

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | The datum attached to an output: either nothing; a datum hash; or the
--   datum itself (an "inline datum").
data OutputDatum
NoOutputDatum :: OutputDatum
OutputDatumHash :: DatumHash -> OutputDatum
OutputDatum :: Datum -> OutputDatum

-- | An interval of <tt>a</tt>s.
--   
--   The interval may be either closed or open at either end, meaning that
--   the endpoints may or may not be included in the interval.
--   
--   The interval can also be unbounded on either side.
--   
--   The <a>Eq</a> instance gives equality of the intervals, not structural
--   equality. There is no <a>Ord</a> instance, but <a>contains</a> gives a
--   partial order.
--   
--   Note that some of the functions on <a>Interval</a> rely on <a>Enum</a>
--   in order to handle non-inclusive endpoints. For this reason, it may
--   not be safe to use <a>Interval</a>s with non-inclusive endpoints on
--   types whose <a>Enum</a> instances have partial methods.
data Interval a
Interval :: LowerBound a -> UpperBound a -> Interval a
[ivFrom] :: Interval a -> LowerBound a
[ivTo] :: Interval a -> UpperBound a

-- | A set extended with a positive and negative infinity.
data Extended a
NegInf :: Extended a
Finite :: a -> Extended a
PosInf :: Extended a

-- | Whether a bound is inclusive or not.
type Closure = Bool

-- | The upper bound of an interval.
data UpperBound a
UpperBound :: Extended a -> Closure -> UpperBound a

-- | The lower bound of an interval.
data LowerBound a
LowerBound :: Extended a -> Closure -> LowerBound a

-- | An <a>Interval</a> that covers every slot. In math. notation [-∞,+∞]
always :: Interval a

-- | <tt>from a</tt> is an <a>Interval</a> that includes all values that
--   are greater than or equal to <tt>a</tt>. In math. notation: [a,+∞]
from :: a -> Interval a

-- | <tt>to a</tt> is an <a>Interval</a> that includes all values that are
--   smaller than or equal to <tt>a</tt>. In math. notation: [-∞,a]
to :: a -> Interval a

-- | Construct a lower bound from a value.
--   
--   The resulting bound includes all values that are equal or greater than
--   the input value.
lowerBound :: a -> LowerBound a

-- | Construct an upper bound from a value.
--   
--   The resulting bound includes all values that are equal or smaller than
--   the input value.
upperBound :: a -> UpperBound a

-- | Construct a strict lower bound from a value.
--   
--   The resulting bound includes all values that are (strictly) greater
--   than the input value.
strictLowerBound :: a -> LowerBound a

-- | Construct a strict upper bound from a value.
--   
--   The resulting bound includes all values that are (strictly) smaller
--   than the input value.
strictUpperBound :: a -> UpperBound a
data () => Map k v
unsafeFromList :: [(k, v)] -> Map k v

-- | Type representing the <i>BLAKE2b-224</i> hash of a script. 28 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype ScriptHash
ScriptHash :: BuiltinByteString -> ScriptHash
[getScriptHash] :: ScriptHash -> BuiltinByteString

-- | <a>Redeemer</a> is a wrapper around <tt>Data</tt> values that are used
--   as redeemers in transaction inputs.
newtype Redeemer
Redeemer :: BuiltinData -> Redeemer
[getRedeemer] :: Redeemer -> BuiltinData

-- | Type representing the <i>BLAKE2b-256</i> hash of a redeemer. 32 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype RedeemerHash
RedeemerHash :: BuiltinByteString -> RedeemerHash

-- | <a>Datum</a> is a wrapper around <tt>Data</tt> values which are used
--   as data in transaction outputs.
newtype Datum
Datum :: BuiltinData -> Datum
[getDatum] :: Datum -> BuiltinData

-- | Type representing the <i>BLAKE2b-256</i> hash of a datum. 32 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype DatumHash
DatumHash :: BuiltinByteString -> DatumHash
data () => Data
Constr :: Integer -> [Data] -> Data
Map :: [(Data, Data)] -> Data
List :: [Data] -> Data
I :: Integer -> Data
B :: ByteString -> Data
data () => BuiltinData
BuiltinData :: ~Data -> BuiltinData
class () => ToData a
toBuiltinData :: ToData a => a -> BuiltinData
class () => FromData a
fromBuiltinData :: FromData a => BuiltinData -> Maybe a
class () => UnsafeFromData a
unsafeFromBuiltinData :: UnsafeFromData a => BuiltinData -> a
toData :: ToData a => a -> Data
fromData :: FromData a => Data -> Maybe a
unsafeFromData :: UnsafeFromData a => Data -> a
dataToBuiltinData :: Data -> BuiltinData
builtinDataToData :: BuiltinData -> Data

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>MonadError</a> class. (If you are using the deprecated
--   <a>Control.Monad.Error</a> or <a>Control.Monad.Trans.Error</a>, you
--   may also have to define an <tt>Error</tt> instance.)
class Monad m => MonadError e (m :: Type -> Type) | m -> e

-- | Errors that can be thrown when evaluating a Plutus script.
data EvaluationError

-- | An error from the evaluator itself
CekError :: !CekEvaluationException NamedDeBruijn DefaultUni DefaultFun -> EvaluationError

-- | An error in the pre-evaluation step of converting from de-Bruijn
--   indices
DeBruijnError :: !FreeVariableError -> EvaluationError

-- | A deserialisation error TODO: make this error more informative when we
--   have more information about what went wrong
CodecError :: !ScriptDecodeError -> EvaluationError

-- | An error indicating that the cost model parameters didn't match what
--   we expected
CostModelParameterMismatch :: EvaluationError

-- | The script evaluated to a value that is not a valid return value.
InvalidReturnValue :: EvaluationError

-- | An error that occurred during script deserialization.
data ScriptDecodeError

-- | an error from the underlying CBOR/serialise library
CBORDeserialiseError :: !DeserialiseFailureInfo -> ScriptDecodeError

-- | Script was successfully parsed, but more (runaway) bytes encountered
--   after script's position
RemainderError :: !ByteString -> ScriptDecodeError

-- | the plutus version of the given script is not enabled yet
LedgerLanguageNotAvailableError :: !PlutusLedgerLanguage -> !MajorProtocolVersion -> !MajorProtocolVersion -> ScriptDecodeError

-- | the script's ledger language
[sdeAffectedLang] :: ScriptDecodeError -> !PlutusLedgerLanguage

-- | the major protocol version that will first introduce/enable the ledger
--   language
[sdeIntroPv] :: ScriptDecodeError -> !MajorProtocolVersion

-- | the current protocol version
[sdeThisPv] :: ScriptDecodeError -> !MajorProtocolVersion
PlutusCoreLanguageNotAvailableError :: !Version -> !PlutusLedgerLanguage -> !MajorProtocolVersion -> ScriptDecodeError

-- | the Plutus Core language of the script under execution.
[sdeAffectedVersion] :: ScriptDecodeError -> !Version

-- | the Plutus ledger language of the script under execution.
[sdeThisLang] :: ScriptDecodeError -> !PlutusLedgerLanguage

-- | the current protocol version
[sdeThisPv] :: ScriptDecodeError -> !MajorProtocolVersion

module PlutusLedgerApi.V3.Contexts
newtype ColdCommitteeCredential
ColdCommitteeCredential :: Credential -> ColdCommitteeCredential
newtype HotCommitteeCredential
HotCommitteeCredential :: Credential -> HotCommitteeCredential
newtype DRepCredential
DRepCredential :: Credential -> DRepCredential
data DRep
DRep :: DRepCredential -> DRep
DRepAlwaysAbstain :: DRep
DRepAlwaysNoConfidence :: DRep
data Delegatee
DelegStake :: PubKeyHash -> Delegatee
DelegVote :: DRep -> Delegatee
DelegStakeVote :: PubKeyHash -> DRep -> Delegatee
data TxCert

-- | Register staking credential with an optional deposit amount
TxCertRegStaking :: Credential -> Maybe Lovelace -> TxCert

-- | Un-Register staking credential with an optional refund amount
TxCertUnRegStaking :: Credential -> Maybe Lovelace -> TxCert

-- | Delegate staking credential to a Delegatee
TxCertDelegStaking :: Credential -> Delegatee -> TxCert

-- | Register and delegate staking credential to a Delegatee in one
--   certificate. Note that deposit is mandatory.
TxCertRegDeleg :: Credential -> Delegatee -> Lovelace -> TxCert

-- | Register a DRep with a deposit value. The optional anchor is omitted.
TxCertRegDRep :: DRepCredential -> Lovelace -> TxCert

-- | Update a DRep. The optional anchor is omitted.
TxCertUpdateDRep :: DRepCredential -> TxCert

-- | UnRegister a DRep with mandatory refund value
TxCertUnRegDRep :: DRepCredential -> Lovelace -> TxCert

-- | A digest of the PoolParams
TxCertPoolRegister :: PubKeyHash -> PubKeyHash -> TxCert

-- | The retirement certificate and the Epoch in which the retirement will
--   take place
TxCertPoolRetire :: PubKeyHash -> Integer -> TxCert

-- | Authorize a Hot credential for a specific Committee member's cold
--   credential
TxCertAuthHotCommittee :: ColdCommitteeCredential -> HotCommitteeCredential -> TxCert
TxCertResignColdCommittee :: ColdCommitteeCredential -> TxCert
data Voter
CommitteeVoter :: HotCommitteeCredential -> Voter
DRepVoter :: DRepCredential -> Voter
StakePoolVoter :: PubKeyHash -> Voter

-- | A vote. The optional anchor is omitted.
data Vote
VoteNo :: Vote
VoteYes :: Vote
Abstain :: Vote

-- | Similar to TxOutRef, but for GovActions
data GovernanceActionId
GovernanceActionId :: TxId -> Integer -> GovernanceActionId
[gaidTxId] :: GovernanceActionId -> TxId
[gaidGovActionIx] :: GovernanceActionId -> Integer
data Committee
Committee :: Map ColdCommitteeCredential Integer -> Rational -> Committee

-- | Committee members with epoch number when each of them expires
[committeeMembers] :: Committee -> Map ColdCommitteeCredential Integer

-- | Quorum of the committee that is necessary for a successful vote
[committeeQuorum] :: Committee -> Rational

-- | A constitution. The optional anchor is omitted.
newtype Constitution
Constitution :: Maybe ScriptHash -> Constitution
[constitutionScript] :: Constitution -> Maybe ScriptHash
data ProtocolVersion
ProtocolVersion :: Integer -> Integer -> ProtocolVersion
[pvMajor] :: ProtocolVersion -> Integer
[pvMinor] :: ProtocolVersion -> Integer

-- | A Plutus Data object containing proposed parameter changes. The Data
--   object contains a <tt>Map</tt> with one entry per changed parameter,
--   from the parameter ID to the new value. Unchanged parameters are not
--   included.
--   
--   The mapping from parameter IDs to parameters can be found in
--   <a>conway.cddl</a>.
--   
--   <i>Invariant:</i> This map is non-empty, and the keys are stored in
--   ascending order.
--   
--   This <tt>Data</tt> object has the following format (in pseudocode):
--   
--   ChangedParametersData = Map ChangedIdData ChangedManyValueData
--   ChangedIdData = I Integer ChangedManyValueData =
--   ChangedSingleValueData | List[ChangedSingleValueData...] -- ^ an
--   arbitrary-length, heterogeneous (integer or ratio) list of values (to
--   support sub-parameters)
--   
--   ChangedSingleValueData = I Integer -- a proposed integer value |
--   List[I Integer, I Integer] -- a proposed numerator,denominator (ratio
--   value) -- ^ a 2-exact element list; *BE CAREFUL* because this can be
--   alternatively (ambiguously) interpreted -- as a many-value data
--   (sub-parameter) of two integer single-value data.
--   
--   , where Map,I,List are the constructors of <a>Data</a> and Integer is
--   the usual arbitrary-precision PlutusTx/Haskell Integer.
newtype ChangedParameters
ChangedParameters :: BuiltinData -> ChangedParameters
[getChangedParameters] :: ChangedParameters -> BuiltinData
data GovernanceAction

-- | Hash of the constitution script
ParameterChange :: Maybe GovernanceActionId -> ChangedParameters -> Maybe ScriptHash -> GovernanceAction

-- | proposal to update protocol version
HardForkInitiation :: Maybe GovernanceActionId -> ProtocolVersion -> GovernanceAction

-- | Hash of the constitution script
TreasuryWithdrawals :: Map Credential Lovelace -> Maybe ScriptHash -> GovernanceAction
NoConfidence :: Maybe GovernanceActionId -> GovernanceAction
UpdateCommittee :: Maybe GovernanceActionId -> [ColdCommitteeCredential] -> Map ColdCommitteeCredential Integer -> Rational -> GovernanceAction
NewConstitution :: Maybe GovernanceActionId -> Constitution -> GovernanceAction
InfoAction :: GovernanceAction

-- | A proposal procedure. The optional anchor is omitted.
data ProposalProcedure
ProposalProcedure :: Lovelace -> Credential -> GovernanceAction -> ProposalProcedure
[ppDeposit] :: ProposalProcedure -> Lovelace
[ppReturnAddr] :: ProposalProcedure -> Credential
[ppGovernanceAction] :: ProposalProcedure -> GovernanceAction

-- | A <a>ScriptPurpose</a> uniquely identifies a Plutus script within a
--   transaction.
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: Credential -> ScriptPurpose
Certifying :: Integer -> TxCert -> ScriptPurpose
Voting :: Voter -> ScriptPurpose
Proposing :: Integer -> ProposalProcedure -> ScriptPurpose

-- | Like <a>ScriptPurpose</a> but with an optional datum for spending
--   scripts.
data ScriptInfo
MintingScript :: CurrencySymbol -> ScriptInfo
SpendingScript :: TxOutRef -> Maybe Datum -> ScriptInfo
RewardingScript :: Credential -> ScriptInfo
CertifyingScript :: Integer -> TxCert -> ScriptInfo
VotingScript :: Voter -> ScriptInfo
ProposingScript :: Integer -> ProposalProcedure -> ScriptInfo

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | TxInfo for PlutusV3
data TxInfo
TxInfo :: [TxInInfo] -> [TxInInfo] -> [TxOut] -> Lovelace -> Value -> [TxCert] -> Map Credential Lovelace -> POSIXTimeRange -> [PubKeyHash] -> Map ScriptPurpose Redeemer -> Map DatumHash Datum -> TxId -> Map Voter (Map GovernanceActionId Vote) -> [ProposalProcedure] -> Maybe Lovelace -> Maybe Lovelace -> TxInfo
[txInfoInputs] :: TxInfo -> [TxInInfo]
[txInfoReferenceInputs] :: TxInfo -> [TxInInfo]
[txInfoOutputs] :: TxInfo -> [TxOut]
[txInfoFee] :: TxInfo -> Lovelace

-- | The <tt>Value</tt> minted by this transaction.
--   
--   <i>Invariant:</i> This field does not contain Ada with zero quantity,
--   unlike their namesakes in Plutus V1 and V2's ScriptContexts.
[txInfoMint] :: TxInfo -> Value
[txInfoTxCerts] :: TxInfo -> [TxCert]
[txInfoWdrl] :: TxInfo -> Map Credential Lovelace
[txInfoValidRange] :: TxInfo -> POSIXTimeRange
[txInfoSignatories] :: TxInfo -> [PubKeyHash]
[txInfoRedeemers] :: TxInfo -> Map ScriptPurpose Redeemer
[txInfoData] :: TxInfo -> Map DatumHash Datum
[txInfoId] :: TxInfo -> TxId
[txInfoVotes] :: TxInfo -> Map Voter (Map GovernanceActionId Vote)
[txInfoProposalProcedures] :: TxInfo -> [ProposalProcedure]
[txInfoCurrentTreasuryAmount] :: TxInfo -> Maybe Lovelace
[txInfoTreasuryDonation] :: TxInfo -> Maybe Lovelace

-- | The context that the currently-executing script can access.
data ScriptContext
ScriptContext :: TxInfo -> Redeemer -> ScriptInfo -> ScriptContext

-- | information about the transaction the currently-executing script is
--   included in
[scriptContextTxInfo] :: ScriptContext -> TxInfo

-- | Redeemer for the currently-executing script
[scriptContextRedeemer] :: ScriptContext -> Redeemer

-- | the purpose of the currently-executing script, along with information
--   associated with the purpose
[scriptContextScriptInfo] :: ScriptContext -> ScriptInfo

-- | Find the input currently being validated.
findOwnInput :: ScriptContext -> Maybe TxInInfo

-- | Find the data corresponding to a data hash, if there is one
findDatum :: DatumHash -> TxInfo -> Maybe Datum

-- | Find the hash of a datum, if it is part of the pending transaction's
--   hashes
findDatumHash :: Datum -> TxInfo -> Maybe DatumHash

-- | Given a UTXO reference and a transaction (<a>TxInfo</a>), resolve it
--   to one of the transaction's inputs (<a>TxInInfo</a>).
--   
--   Note: this only searches the true transaction inputs and not the
--   referenced transaction inputs.
findTxInByTxOutRef :: TxOutRef -> TxInfo -> Maybe TxInInfo

-- | Find the indices of all the outputs that pay to the same script
--   address we are currently spending from, if any.
findContinuingOutputs :: ScriptContext -> [Integer]

-- | Get all the outputs that pay to the same script address we are
--   currently spending from, if any.
getContinuingOutputs :: ScriptContext -> [TxOut]

-- | Check if a transaction was signed by the given public key.
txSignedBy :: TxInfo -> PubKeyHash -> Bool

-- | Get the values paid to a public key address by a pending transaction.
pubKeyOutputsAt :: PubKeyHash -> TxInfo -> [Value]

-- | Get the total value paid to a public key address by a pending
--   transaction.
valuePaidTo :: TxInfo -> PubKeyHash -> Value

-- | Get the total value of inputs spent by this transaction.
valueSpent :: TxInfo -> Value

-- | Get the total value of outputs produced by this transaction.
valueProduced :: TxInfo -> Value

-- | The <tt>CurrencySymbol</tt> of the current validator script.
ownCurrencySymbol :: ScriptContext -> CurrencySymbol

-- | Check if the pending transaction spends a specific transaction output
--   (identified by the hash of a transaction and an index into that
--   transactions' outputs)
spendsOutput :: TxInfo -> TxId -> Integer -> Bool
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Contexts.TxInfo referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Scripts.Redeemer referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Contexts.ScriptInfo referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Contexts.ScriptContext referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Contexts.ScriptContext
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Contexts.ScriptContext
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.ScriptContext
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition [PlutusLedgerApi.V3.Contexts.TxInInfo] referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition [PlutusLedgerApi.V2.Tx.TxOut] referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Value.Lovelace referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Value.Value referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition [PlutusLedgerApi.V3.Contexts.TxCert] referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (PlutusTx.AssocMap.Map PlutusLedgerApi.V1.Credential.Credential PlutusLedgerApi.V1.Value.Lovelace) referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Time.POSIXTimeRange referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition [PlutusLedgerApi.V1.Crypto.PubKeyHash] referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (PlutusTx.AssocMap.Map PlutusLedgerApi.V3.Contexts.ScriptPurpose PlutusLedgerApi.V1.Scripts.Redeemer) referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (PlutusTx.AssocMap.Map PlutusLedgerApi.V1.Scripts.DatumHash PlutusLedgerApi.V1.Scripts.Datum) referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Tx.TxId referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (PlutusTx.AssocMap.Map PlutusLedgerApi.V3.Contexts.Voter (PlutusTx.AssocMap.Map PlutusLedgerApi.V3.Contexts.GovernanceActionId PlutusLedgerApi.V3.Contexts.Vote)) referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition [PlutusLedgerApi.V3.Contexts.ProposalProcedure] referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (GHC.Maybe.Maybe PlutusLedgerApi.V1.Value.Lovelace) referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Contexts.TxInfo referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Contexts.TxInfo
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Contexts.TxInfo
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Contexts.TxInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.TxInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.TxInfo
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Tx.TxOutRef referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V2.Tx.TxOut referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Contexts.TxInInfo referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Contexts.TxInInfo
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Contexts.TxInInfo
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.TxInInfo
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Value.CurrencySymbol referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Tx.TxOutRef referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (GHC.Maybe.Maybe PlutusLedgerApi.V1.Scripts.Datum) referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Credential.Credential referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition GHC.Num.Integer.Integer referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Contexts.TxCert referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Contexts.Voter referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Contexts.ProposalProcedure referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Contexts.ScriptInfo referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Contexts.ScriptInfo
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Contexts.ScriptInfo
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Contexts.ScriptInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.ScriptInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.ScriptInfo
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Value.CurrencySymbol referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Tx.TxOutRef referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Credential.Credential referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition GHC.Num.Integer.Integer referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Contexts.TxCert referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Contexts.Voter referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Contexts.ProposalProcedure referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Contexts.ScriptPurpose referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Contexts.ScriptPurpose
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Contexts.ScriptPurpose
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Contexts.ScriptPurpose
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.ScriptPurpose
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.ScriptPurpose
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Value.Lovelace referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Credential.Credential referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Contexts.GovernanceAction referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Contexts.ProposalProcedure referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Contexts.ProposalProcedure
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Contexts.ProposalProcedure
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Contexts.ProposalProcedure
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.ProposalProcedure
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.ProposalProcedure
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (GHC.Maybe.Maybe PlutusLedgerApi.V3.Contexts.GovernanceActionId) referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Contexts.ChangedParameters referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (GHC.Maybe.Maybe PlutusLedgerApi.V1.Scripts.ScriptHash) referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Contexts.ProtocolVersion referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (PlutusTx.AssocMap.Map PlutusLedgerApi.V1.Credential.Credential PlutusLedgerApi.V1.Value.Lovelace) referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition [PlutusLedgerApi.V3.Contexts.ColdCommitteeCredential] referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (PlutusTx.AssocMap.Map PlutusLedgerApi.V3.Contexts.ColdCommitteeCredential GHC.Num.Integer.Integer) referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusTx.Ratio.Rational referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Contexts.Constitution referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Contexts.GovernanceAction referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Contexts.GovernanceAction
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Contexts.GovernanceAction
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Contexts.GovernanceAction
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.GovernanceAction
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.GovernanceAction
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.ChangedParameters
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.ChangedParameters
instance PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition GHC.Num.Integer.Integer referencedTypes => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Contexts.ProtocolVersion referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Contexts.ProtocolVersion
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Contexts.ProtocolVersion
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Contexts.ProtocolVersion
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.ProtocolVersion
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.ProtocolVersion
instance PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (GHC.Maybe.Maybe PlutusLedgerApi.V1.Scripts.ScriptHash) referencedTypes => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Contexts.Constitution referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Contexts.Constitution
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Contexts.Constitution
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Contexts.Constitution
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.Constitution
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.Constitution
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (PlutusTx.AssocMap.Map PlutusLedgerApi.V3.Contexts.ColdCommitteeCredential GHC.Num.Integer.Integer) referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusTx.Ratio.Rational referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Contexts.Committee referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Contexts.Committee
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Contexts.Committee
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Contexts.Committee
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.Committee
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.Committee
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Tx.TxId referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition GHC.Num.Integer.Integer referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Contexts.GovernanceActionId referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Contexts.GovernanceActionId
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Contexts.GovernanceActionId
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Contexts.GovernanceActionId
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.GovernanceActionId
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.GovernanceActionId
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Contexts.Vote referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Contexts.Vote
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Contexts.Vote
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Contexts.Vote
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.Vote
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.Vote
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Contexts.HotCommitteeCredential referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Contexts.DRepCredential referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Crypto.PubKeyHash referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Contexts.Voter referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Contexts.Voter
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Contexts.Voter
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Contexts.Voter
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.Voter
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.Voter
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Credential.Credential referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition (GHC.Maybe.Maybe PlutusLedgerApi.V1.Value.Lovelace) referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Contexts.Delegatee referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Value.Lovelace referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Contexts.DRepCredential referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Crypto.PubKeyHash referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition GHC.Num.Integer.Integer referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Contexts.ColdCommitteeCredential referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Contexts.HotCommitteeCredential referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Contexts.TxCert referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Contexts.TxCert
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Contexts.TxCert
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Contexts.TxCert
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.TxCert
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.TxCert
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Crypto.PubKeyHash referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Contexts.DRep referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Contexts.Delegatee referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Contexts.Delegatee
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Contexts.Delegatee
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Contexts.Delegatee
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.Delegatee
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.Delegatee
instance PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V3.Contexts.DRepCredential referencedTypes => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Contexts.DRep referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Contexts.DRep
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Contexts.DRep
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Contexts.DRep
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.DRep
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.DRep
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.DRepCredential
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.DRepCredential
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.HotCommitteeCredential
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.HotCommitteeCredential
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.ColdCommitteeCredential
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Contexts.ColdCommitteeCredential
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Contexts.ColdCommitteeCredential
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Contexts.ColdCommitteeCredential
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Contexts.ColdCommitteeCredential
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Contexts.ColdCommitteeCredential
instance GHC.Show.Show PlutusLedgerApi.V3.Contexts.ColdCommitteeCredential
instance GHC.Classes.Ord PlutusLedgerApi.V3.Contexts.ColdCommitteeCredential
instance GHC.Classes.Eq PlutusLedgerApi.V3.Contexts.ColdCommitteeCredential
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Contexts.ColdCommitteeCredential
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Contexts.ColdCommitteeCredential
instance GHC.Generics.Generic PlutusLedgerApi.V3.Contexts.ColdCommitteeCredential
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Contexts.HotCommitteeCredential
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Contexts.HotCommitteeCredential
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Contexts.HotCommitteeCredential
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Contexts.HotCommitteeCredential
instance GHC.Show.Show PlutusLedgerApi.V3.Contexts.HotCommitteeCredential
instance GHC.Classes.Ord PlutusLedgerApi.V3.Contexts.HotCommitteeCredential
instance GHC.Classes.Eq PlutusLedgerApi.V3.Contexts.HotCommitteeCredential
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Contexts.HotCommitteeCredential
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Contexts.HotCommitteeCredential
instance GHC.Generics.Generic PlutusLedgerApi.V3.Contexts.HotCommitteeCredential
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Contexts.DRepCredential
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Contexts.DRepCredential
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Contexts.DRepCredential
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Contexts.DRepCredential
instance GHC.Show.Show PlutusLedgerApi.V3.Contexts.DRepCredential
instance GHC.Classes.Ord PlutusLedgerApi.V3.Contexts.DRepCredential
instance GHC.Classes.Eq PlutusLedgerApi.V3.Contexts.DRepCredential
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Contexts.DRepCredential
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Contexts.DRepCredential
instance GHC.Generics.Generic PlutusLedgerApi.V3.Contexts.DRepCredential
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Contexts.DRep
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Contexts.DRep
instance GHC.Classes.Ord PlutusLedgerApi.V3.Contexts.DRep
instance GHC.Classes.Eq PlutusLedgerApi.V3.Contexts.DRep
instance GHC.Show.Show PlutusLedgerApi.V3.Contexts.DRep
instance GHC.Generics.Generic PlutusLedgerApi.V3.Contexts.DRep
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Contexts.Delegatee
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Contexts.Delegatee
instance GHC.Classes.Ord PlutusLedgerApi.V3.Contexts.Delegatee
instance GHC.Classes.Eq PlutusLedgerApi.V3.Contexts.Delegatee
instance GHC.Show.Show PlutusLedgerApi.V3.Contexts.Delegatee
instance GHC.Generics.Generic PlutusLedgerApi.V3.Contexts.Delegatee
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Contexts.TxCert
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Contexts.TxCert
instance GHC.Classes.Ord PlutusLedgerApi.V3.Contexts.TxCert
instance GHC.Classes.Eq PlutusLedgerApi.V3.Contexts.TxCert
instance GHC.Show.Show PlutusLedgerApi.V3.Contexts.TxCert
instance GHC.Generics.Generic PlutusLedgerApi.V3.Contexts.TxCert
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Contexts.Voter
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Contexts.Voter
instance GHC.Classes.Ord PlutusLedgerApi.V3.Contexts.Voter
instance GHC.Classes.Eq PlutusLedgerApi.V3.Contexts.Voter
instance GHC.Show.Show PlutusLedgerApi.V3.Contexts.Voter
instance GHC.Generics.Generic PlutusLedgerApi.V3.Contexts.Voter
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Contexts.Vote
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Contexts.Vote
instance GHC.Classes.Eq PlutusLedgerApi.V3.Contexts.Vote
instance GHC.Show.Show PlutusLedgerApi.V3.Contexts.Vote
instance GHC.Generics.Generic PlutusLedgerApi.V3.Contexts.Vote
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Contexts.GovernanceActionId
instance GHC.Classes.Ord PlutusLedgerApi.V3.Contexts.GovernanceActionId
instance GHC.Classes.Eq PlutusLedgerApi.V3.Contexts.GovernanceActionId
instance GHC.Show.Show PlutusLedgerApi.V3.Contexts.GovernanceActionId
instance GHC.Generics.Generic PlutusLedgerApi.V3.Contexts.GovernanceActionId
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Contexts.Committee
instance GHC.Classes.Ord PlutusLedgerApi.V3.Contexts.Committee
instance GHC.Classes.Eq PlutusLedgerApi.V3.Contexts.Committee
instance GHC.Show.Show PlutusLedgerApi.V3.Contexts.Committee
instance GHC.Generics.Generic PlutusLedgerApi.V3.Contexts.Committee
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Contexts.Constitution
instance GHC.Classes.Ord PlutusLedgerApi.V3.Contexts.Constitution
instance GHC.Classes.Eq PlutusLedgerApi.V3.Contexts.Constitution
instance GHC.Show.Show PlutusLedgerApi.V3.Contexts.Constitution
instance GHC.Generics.Generic PlutusLedgerApi.V3.Contexts.Constitution
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Contexts.ProtocolVersion
instance GHC.Classes.Ord PlutusLedgerApi.V3.Contexts.ProtocolVersion
instance GHC.Classes.Eq PlutusLedgerApi.V3.Contexts.ProtocolVersion
instance GHC.Show.Show PlutusLedgerApi.V3.Contexts.ProtocolVersion
instance GHC.Generics.Generic PlutusLedgerApi.V3.Contexts.ProtocolVersion
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Contexts.ChangedParameters
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Contexts.ChangedParameters
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Contexts.ChangedParameters
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Contexts.ChangedParameters
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Contexts.ChangedParameters
instance GHC.Classes.Ord PlutusLedgerApi.V3.Contexts.ChangedParameters
instance GHC.Classes.Eq PlutusLedgerApi.V3.Contexts.ChangedParameters
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Contexts.ChangedParameters
instance GHC.Show.Show PlutusLedgerApi.V3.Contexts.ChangedParameters
instance GHC.Generics.Generic PlutusLedgerApi.V3.Contexts.ChangedParameters
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Contexts.GovernanceAction
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Contexts.GovernanceAction
instance GHC.Classes.Ord PlutusLedgerApi.V3.Contexts.GovernanceAction
instance GHC.Classes.Eq PlutusLedgerApi.V3.Contexts.GovernanceAction
instance GHC.Show.Show PlutusLedgerApi.V3.Contexts.GovernanceAction
instance GHC.Generics.Generic PlutusLedgerApi.V3.Contexts.GovernanceAction
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Contexts.ProposalProcedure
instance GHC.Classes.Ord PlutusLedgerApi.V3.Contexts.ProposalProcedure
instance GHC.Classes.Eq PlutusLedgerApi.V3.Contexts.ProposalProcedure
instance GHC.Show.Show PlutusLedgerApi.V3.Contexts.ProposalProcedure
instance GHC.Generics.Generic PlutusLedgerApi.V3.Contexts.ProposalProcedure
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Contexts.ScriptPurpose
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Contexts.ScriptPurpose
instance GHC.Classes.Ord PlutusLedgerApi.V3.Contexts.ScriptPurpose
instance GHC.Classes.Eq PlutusLedgerApi.V3.Contexts.ScriptPurpose
instance GHC.Show.Show PlutusLedgerApi.V3.Contexts.ScriptPurpose
instance GHC.Generics.Generic PlutusLedgerApi.V3.Contexts.ScriptPurpose
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Contexts.ScriptInfo
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Contexts.ScriptInfo
instance GHC.Classes.Eq PlutusLedgerApi.V3.Contexts.ScriptInfo
instance GHC.Show.Show PlutusLedgerApi.V3.Contexts.ScriptInfo
instance GHC.Generics.Generic PlutusLedgerApi.V3.Contexts.ScriptInfo
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Contexts.TxInInfo
instance GHC.Classes.Eq PlutusLedgerApi.V3.Contexts.TxInInfo
instance GHC.Show.Show PlutusLedgerApi.V3.Contexts.TxInInfo
instance GHC.Generics.Generic PlutusLedgerApi.V3.Contexts.TxInInfo
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Contexts.TxInfo
instance GHC.Classes.Eq PlutusLedgerApi.V3.Contexts.TxInfo
instance GHC.Show.Show PlutusLedgerApi.V3.Contexts.TxInfo
instance GHC.Generics.Generic PlutusLedgerApi.V3.Contexts.TxInfo
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V3.Contexts.ScriptContext
instance GHC.Show.Show PlutusLedgerApi.V3.Contexts.ScriptContext
instance GHC.Classes.Eq PlutusLedgerApi.V3.Contexts.ScriptContext
instance GHC.Generics.Generic PlutusLedgerApi.V3.Contexts.ScriptContext
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Contexts.ScriptContext
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Contexts.TxInfo
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Contexts.TxInInfo
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Contexts.TxInInfo
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Contexts.ProposalProcedure
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Contexts.ChangedParameters referencedTypes
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Contexts.ProtocolVersion
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Contexts.ProtocolVersion
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Contexts.Constitution
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Contexts.Constitution
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Contexts.Committee
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Contexts.GovernanceActionId
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Contexts.GovernanceActionId
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Contexts.Vote
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Contexts.Voter
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Contexts.TxCert
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Contexts.Delegatee
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Contexts.DRep
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Crypto.PubKeyHash referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Scripts.ScriptHash referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Contexts.DRepCredential referencedTypes
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Crypto.PubKeyHash referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Scripts.ScriptHash referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Contexts.HotCommitteeCredential referencedTypes
instance (PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Crypto.PubKeyHash referencedTypes, PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition PlutusLedgerApi.V1.Scripts.ScriptHash referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V3.Contexts.ColdCommitteeCredential referencedTypes


-- | The interface to Plutus V3 for the ledger.
module PlutusLedgerApi.V3

-- | Scripts to the ledger are serialised bytestrings.
type SerialisedScript = ShortByteString

-- | A Plutus script ready to be evaluated on-chain, via
--   <tt>evaluateScriptRestricting</tt>.
data ScriptForEvaluation

-- | Get a <a>SerialisedScript</a> from a <a>ScriptForEvaluation</a>.
--   <i>O(1)</i>.
serialisedScript :: ScriptForEvaluation -> SerialisedScript

-- | Get a <a>ScriptNamedDeBruijn</a> from a <a>ScriptForEvaluation</a>.
--   <i>O(1)</i>.
deserialisedScript :: ScriptForEvaluation -> ScriptNamedDeBruijn

-- | Turns a program which was compiled using the 'PlutusTx' toolchain into
--   a binary format that is understood by the network and can be stored
--   on-chain.
serialiseCompiledCode :: forall a. CompiledCode a -> SerialisedScript

-- | Turns a program's AST (most likely manually constructed) into a binary
--   format that is understood by the network and can be stored on-chain.
serialiseUPLC :: Program DeBruijn DefaultUni DefaultFun () -> SerialisedScript

-- | The deserialization from a serialised script into a
--   <tt>ScriptForEvaluation</tt>, ready to be evaluated on-chain. Called
--   inside phase-1 validation (i.e., deserialisation error is a phase-1
--   error).
deserialiseScript :: forall m. MonadError ScriptDecodeError m => MajorProtocolVersion -> SerialisedScript -> m ScriptForEvaluation

-- | Deserialises a <a>SerialisedScript</a> back into an AST. Does *not* do
--   ledger-language-version-specific checks like for allowable builtins.
uncheckedDeserialiseUPLC :: SerialisedScript -> Program DeBruijn DefaultUni DefaultFun ()

-- | Evaluates a script, with a cost model and a budget that restricts how
--   many resources it can use according to the cost model. Also returns
--   the budget that was actually used.
--   
--   Can be used to calculate budgets for scripts, but even in this case
--   you must give a limit to guard against scripts that run for a long
--   time or loop.
evaluateScriptRestricting :: MajorProtocolVersion -> VerboseMode -> EvaluationContext -> ExBudget -> ScriptForEvaluation -> Data -> (LogOutput, Either EvaluationError ExBudget)

-- | Evaluates a script, returning the minimum budget that the script would
--   need to evaluate successfully. This will take as long as the script
--   takes, if you need to limit the execution time of the script also, you
--   can use <a>evaluateScriptRestricting</a>, which also returns the used
--   budget.
evaluateScriptCounting :: MajorProtocolVersion -> VerboseMode -> EvaluationContext -> ScriptForEvaluation -> Data -> (LogOutput, Either EvaluationError ExBudget)
newtype ColdCommitteeCredential
ColdCommitteeCredential :: Credential -> ColdCommitteeCredential
newtype HotCommitteeCredential
HotCommitteeCredential :: Credential -> HotCommitteeCredential
newtype DRepCredential
DRepCredential :: Credential -> DRepCredential
data DRep
DRep :: DRepCredential -> DRep
DRepAlwaysAbstain :: DRep
DRepAlwaysNoConfidence :: DRep
data Delegatee
DelegStake :: PubKeyHash -> Delegatee
DelegVote :: DRep -> Delegatee
DelegStakeVote :: PubKeyHash -> DRep -> Delegatee
data TxCert

-- | Register staking credential with an optional deposit amount
TxCertRegStaking :: Credential -> Maybe Lovelace -> TxCert

-- | Un-Register staking credential with an optional refund amount
TxCertUnRegStaking :: Credential -> Maybe Lovelace -> TxCert

-- | Delegate staking credential to a Delegatee
TxCertDelegStaking :: Credential -> Delegatee -> TxCert

-- | Register and delegate staking credential to a Delegatee in one
--   certificate. Note that deposit is mandatory.
TxCertRegDeleg :: Credential -> Delegatee -> Lovelace -> TxCert

-- | Register a DRep with a deposit value. The optional anchor is omitted.
TxCertRegDRep :: DRepCredential -> Lovelace -> TxCert

-- | Update a DRep. The optional anchor is omitted.
TxCertUpdateDRep :: DRepCredential -> TxCert

-- | UnRegister a DRep with mandatory refund value
TxCertUnRegDRep :: DRepCredential -> Lovelace -> TxCert

-- | A digest of the PoolParams
TxCertPoolRegister :: PubKeyHash -> PubKeyHash -> TxCert

-- | The retirement certificate and the Epoch in which the retirement will
--   take place
TxCertPoolRetire :: PubKeyHash -> Integer -> TxCert

-- | Authorize a Hot credential for a specific Committee member's cold
--   credential
TxCertAuthHotCommittee :: ColdCommitteeCredential -> HotCommitteeCredential -> TxCert
TxCertResignColdCommittee :: ColdCommitteeCredential -> TxCert
data Voter
CommitteeVoter :: HotCommitteeCredential -> Voter
DRepVoter :: DRepCredential -> Voter
StakePoolVoter :: PubKeyHash -> Voter

-- | A vote. The optional anchor is omitted.
data Vote
VoteNo :: Vote
VoteYes :: Vote
Abstain :: Vote

-- | Similar to TxOutRef, but for GovActions
data GovernanceActionId
GovernanceActionId :: TxId -> Integer -> GovernanceActionId
[gaidTxId] :: GovernanceActionId -> TxId
[gaidGovActionIx] :: GovernanceActionId -> Integer
data Committee
Committee :: Map ColdCommitteeCredential Integer -> Rational -> Committee

-- | Committee members with epoch number when each of them expires
[committeeMembers] :: Committee -> Map ColdCommitteeCredential Integer

-- | Quorum of the committee that is necessary for a successful vote
[committeeQuorum] :: Committee -> Rational

-- | A constitution. The optional anchor is omitted.
newtype Constitution
Constitution :: Maybe ScriptHash -> Constitution
[constitutionScript] :: Constitution -> Maybe ScriptHash
data ProtocolVersion
ProtocolVersion :: Integer -> Integer -> ProtocolVersion
[pvMajor] :: ProtocolVersion -> Integer
[pvMinor] :: ProtocolVersion -> Integer
data GovernanceAction

-- | Hash of the constitution script
ParameterChange :: Maybe GovernanceActionId -> ChangedParameters -> Maybe ScriptHash -> GovernanceAction

-- | proposal to update protocol version
HardForkInitiation :: Maybe GovernanceActionId -> ProtocolVersion -> GovernanceAction

-- | Hash of the constitution script
TreasuryWithdrawals :: Map Credential Lovelace -> Maybe ScriptHash -> GovernanceAction
NoConfidence :: Maybe GovernanceActionId -> GovernanceAction
UpdateCommittee :: Maybe GovernanceActionId -> [ColdCommitteeCredential] -> Map ColdCommitteeCredential Integer -> Rational -> GovernanceAction
NewConstitution :: Maybe GovernanceActionId -> Constitution -> GovernanceAction
InfoAction :: GovernanceAction

-- | A Plutus Data object containing proposed parameter changes. The Data
--   object contains a <tt>Map</tt> with one entry per changed parameter,
--   from the parameter ID to the new value. Unchanged parameters are not
--   included.
--   
--   The mapping from parameter IDs to parameters can be found in
--   <a>conway.cddl</a>.
--   
--   <i>Invariant:</i> This map is non-empty, and the keys are stored in
--   ascending order.
--   
--   This <tt>Data</tt> object has the following format (in pseudocode):
--   
--   ChangedParametersData = Map ChangedIdData ChangedManyValueData
--   ChangedIdData = I Integer ChangedManyValueData =
--   ChangedSingleValueData | List[ChangedSingleValueData...] -- ^ an
--   arbitrary-length, heterogeneous (integer or ratio) list of values (to
--   support sub-parameters)
--   
--   ChangedSingleValueData = I Integer -- a proposed integer value |
--   List[I Integer, I Integer] -- a proposed numerator,denominator (ratio
--   value) -- ^ a 2-exact element list; *BE CAREFUL* because this can be
--   alternatively (ambiguously) interpreted -- as a many-value data
--   (sub-parameter) of two integer single-value data.
--   
--   , where Map,I,List are the constructors of <a>Data</a> and Integer is
--   the usual arbitrary-precision PlutusTx/Haskell Integer.
newtype ChangedParameters
ChangedParameters :: BuiltinData -> ChangedParameters
[getChangedParameters] :: ChangedParameters -> BuiltinData

-- | A proposal procedure. The optional anchor is omitted.
data ProposalProcedure
ProposalProcedure :: Lovelace -> Credential -> GovernanceAction -> ProposalProcedure
[ppDeposit] :: ProposalProcedure -> Lovelace
[ppReturnAddr] :: ProposalProcedure -> Credential
[ppGovernanceAction] :: ProposalProcedure -> GovernanceAction

-- | This represents the major component of the Cardano protocol version.
--   The ledger can only supply the major component of the protocol
--   version, not the minor component, and Plutus should only need to care
--   about the major component anyway. This relies on careful understanding
--   between us and the ledger as to what this means.
newtype MajorProtocolVersion
MajorProtocolVersion :: Int -> MajorProtocolVersion
[getMajorProtocolVersion] :: MajorProtocolVersion -> Int

-- | A simple toggle indicating whether or not we should accumulate logs
--   during script execution.
data VerboseMode

-- | accumulate all traces
Verbose :: VerboseMode

-- | don't accumulate anything
Quiet :: VerboseMode

-- | The type of the executed script's accumulated log output: a list of
--   <a>Text</a>.
--   
--   It will be an empty list if the <a>VerboseMode</a> is set to
--   <a>Quiet</a>.
type LogOutput = [Text]
data () => ExBudget
ExBudget :: ExCPU -> ExMemory -> ExBudget
[exBudgetCPU] :: ExBudget -> ExCPU
[exBudgetMemory] :: ExBudget -> ExMemory
newtype () => ExCPU
ExCPU :: CostingInteger -> ExCPU
newtype () => ExMemory
ExMemory :: CostingInteger -> ExMemory
data () => SatInt
fromSatInt :: Num a => SatInt -> a

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than being recomputed on every
--   evaluation.
--   
--   Different protocol versions may require different bundles of machine
--   parameters, which allows us for example to tweak the shape of the
--   costing function of a builtin, so that the builtin costs less.
--   Currently this means that we have to create multiple
--   <a>DefaultMachineParameters</a> per language version, which we put
--   into a cache (represented by an association list) in order to avoid
--   costly recomputation of machine parameters.
--   
--   In order to get the appropriate <a>DefaultMachineParameters</a> at
--   validation time we look it up in the cache using a semantics variant
--   as a key. We compute the semantics variant from the protocol version
--   using the stored function. Note that the semantics variant depends on
--   the language version too, but the latter is known statically (because
--   each language version has its own evaluation context), hence there's
--   no reason to require it to be provided at runtime.
--   
--   To say it differently, there's a matrix of semantics variants indexed
--   by (LL, PV) pairs and we cache its particular row corresponding to the
--   statically given LL in an <a>EvaluationContext</a>.
--   
--   The reason why we associate a <a>DefaultMachineParameters</a> with a
--   semantics variant rather than a protocol version are
--   
--   <ol>
--   <li>generally there are far more protocol versions than semantics
--   variants supported by a specific language version, so we save on
--   pointless duplication of bundles of machine parameters</li>
--   <li>builtins don't know anything about protocol versions, only
--   semantics variants. It is therefore more semantically precise to
--   associate bundles of machine parameters with semantics variants than
--   with protocol versions</li>
--   </ol>
data EvaluationContext

-- | Build the <a>EvaluationContext</a>.
--   
--   The input is a list of cost model parameters (which are integer
--   values) passed from the ledger.
--   
--   IMPORTANT: the cost model parameters <b>MUST</b> appear in the correct
--   order, matching the names in <a>ParamName</a>. If the parameters are
--   supplied in the wrong order then script cost calculations will be
--   incorrect.
--   
--   IMPORTANT: The evaluation context of every Plutus version must be
--   recreated upon a protocol update with the updated cost model
--   parameters.
mkEvaluationContext :: (MonadError CostModelApplyError m, MonadWriter [CostModelApplyWarn] m) => [Int64] -> m EvaluationContext

-- | The enumeration of all possible cost model parameter names for this
--   language version.
--   
--   IMPORTANT: The order of appearance of the data constructors here
--   matters. DO NOT REORDER. See Note [Quotation marks in cost model
--   parameter constructors] See Note [Cost model parameters from the
--   ledger's point of view]
data ParamName
AddInteger'cpu'arguments'intercept :: ParamName
AddInteger'cpu'arguments'slope :: ParamName
AddInteger'memory'arguments'intercept :: ParamName
AddInteger'memory'arguments'slope :: ParamName
AppendByteString'cpu'arguments'intercept :: ParamName
AppendByteString'cpu'arguments'slope :: ParamName
AppendByteString'memory'arguments'intercept :: ParamName
AppendByteString'memory'arguments'slope :: ParamName
AppendString'cpu'arguments'intercept :: ParamName
AppendString'cpu'arguments'slope :: ParamName
AppendString'memory'arguments'intercept :: ParamName
AppendString'memory'arguments'slope :: ParamName
BData'cpu'arguments :: ParamName
BData'memory'arguments :: ParamName
Blake2b_256'cpu'arguments'intercept :: ParamName
Blake2b_256'cpu'arguments'slope :: ParamName
Blake2b_256'memory'arguments :: ParamName
CekApplyCost'exBudgetCPU :: ParamName
CekApplyCost'exBudgetMemory :: ParamName
CekBuiltinCost'exBudgetCPU :: ParamName
CekBuiltinCost'exBudgetMemory :: ParamName
CekConstCost'exBudgetCPU :: ParamName
CekConstCost'exBudgetMemory :: ParamName
CekDelayCost'exBudgetCPU :: ParamName
CekDelayCost'exBudgetMemory :: ParamName
CekForceCost'exBudgetCPU :: ParamName
CekForceCost'exBudgetMemory :: ParamName
CekLamCost'exBudgetCPU :: ParamName
CekLamCost'exBudgetMemory :: ParamName
CekStartupCost'exBudgetCPU :: ParamName
CekStartupCost'exBudgetMemory :: ParamName
CekVarCost'exBudgetCPU :: ParamName
CekVarCost'exBudgetMemory :: ParamName
ChooseData'cpu'arguments :: ParamName
ChooseData'memory'arguments :: ParamName
ChooseList'cpu'arguments :: ParamName
ChooseList'memory'arguments :: ParamName
ChooseUnit'cpu'arguments :: ParamName
ChooseUnit'memory'arguments :: ParamName
ConsByteString'cpu'arguments'intercept :: ParamName
ConsByteString'cpu'arguments'slope :: ParamName
ConsByteString'memory'arguments'intercept :: ParamName
ConsByteString'memory'arguments'slope :: ParamName
ConstrData'cpu'arguments :: ParamName
ConstrData'memory'arguments :: ParamName
DecodeUtf8'cpu'arguments'intercept :: ParamName
DecodeUtf8'cpu'arguments'slope :: ParamName
DecodeUtf8'memory'arguments'intercept :: ParamName
DecodeUtf8'memory'arguments'slope :: ParamName
DivideInteger'cpu'arguments'constant :: ParamName
DivideInteger'cpu'arguments'model'arguments'c00 :: ParamName
DivideInteger'cpu'arguments'model'arguments'c01 :: ParamName
DivideInteger'cpu'arguments'model'arguments'c02 :: ParamName
DivideInteger'cpu'arguments'model'arguments'c10 :: ParamName
DivideInteger'cpu'arguments'model'arguments'c11 :: ParamName
DivideInteger'cpu'arguments'model'arguments'c20 :: ParamName
DivideInteger'cpu'arguments'model'arguments'minimum :: ParamName
DivideInteger'memory'arguments'intercept :: ParamName
DivideInteger'memory'arguments'minimum :: ParamName
DivideInteger'memory'arguments'slope :: ParamName
EncodeUtf8'cpu'arguments'intercept :: ParamName
EncodeUtf8'cpu'arguments'slope :: ParamName
EncodeUtf8'memory'arguments'intercept :: ParamName
EncodeUtf8'memory'arguments'slope :: ParamName
EqualsByteString'cpu'arguments'constant :: ParamName
EqualsByteString'cpu'arguments'intercept :: ParamName
EqualsByteString'cpu'arguments'slope :: ParamName
EqualsByteString'memory'arguments :: ParamName
EqualsData'cpu'arguments'intercept :: ParamName
EqualsData'cpu'arguments'slope :: ParamName
EqualsData'memory'arguments :: ParamName
EqualsInteger'cpu'arguments'intercept :: ParamName
EqualsInteger'cpu'arguments'slope :: ParamName
EqualsInteger'memory'arguments :: ParamName
EqualsString'cpu'arguments'constant :: ParamName
EqualsString'cpu'arguments'intercept :: ParamName
EqualsString'cpu'arguments'slope :: ParamName
EqualsString'memory'arguments :: ParamName
FstPair'cpu'arguments :: ParamName
FstPair'memory'arguments :: ParamName
HeadList'cpu'arguments :: ParamName
HeadList'memory'arguments :: ParamName
IData'cpu'arguments :: ParamName
IData'memory'arguments :: ParamName
IfThenElse'cpu'arguments :: ParamName
IfThenElse'memory'arguments :: ParamName
IndexByteString'cpu'arguments :: ParamName
IndexByteString'memory'arguments :: ParamName
LengthOfByteString'cpu'arguments :: ParamName
LengthOfByteString'memory'arguments :: ParamName
LessThanByteString'cpu'arguments'intercept :: ParamName
LessThanByteString'cpu'arguments'slope :: ParamName
LessThanByteString'memory'arguments :: ParamName
LessThanEqualsByteString'cpu'arguments'intercept :: ParamName
LessThanEqualsByteString'cpu'arguments'slope :: ParamName
LessThanEqualsByteString'memory'arguments :: ParamName
LessThanEqualsInteger'cpu'arguments'intercept :: ParamName
LessThanEqualsInteger'cpu'arguments'slope :: ParamName
LessThanEqualsInteger'memory'arguments :: ParamName
LessThanInteger'cpu'arguments'intercept :: ParamName
LessThanInteger'cpu'arguments'slope :: ParamName
LessThanInteger'memory'arguments :: ParamName
ListData'cpu'arguments :: ParamName
ListData'memory'arguments :: ParamName
MapData'cpu'arguments :: ParamName
MapData'memory'arguments :: ParamName
MkCons'cpu'arguments :: ParamName
MkCons'memory'arguments :: ParamName
MkNilData'cpu'arguments :: ParamName
MkNilData'memory'arguments :: ParamName
MkNilPairData'cpu'arguments :: ParamName
MkNilPairData'memory'arguments :: ParamName
MkPairData'cpu'arguments :: ParamName
MkPairData'memory'arguments :: ParamName
ModInteger'cpu'arguments'constant :: ParamName
ModInteger'cpu'arguments'model'arguments'c00 :: ParamName
ModInteger'cpu'arguments'model'arguments'c01 :: ParamName
ModInteger'cpu'arguments'model'arguments'c02 :: ParamName
ModInteger'cpu'arguments'model'arguments'c10 :: ParamName
ModInteger'cpu'arguments'model'arguments'c11 :: ParamName
ModInteger'cpu'arguments'model'arguments'c20 :: ParamName
ModInteger'cpu'arguments'model'arguments'minimum :: ParamName
ModInteger'memory'arguments'intercept :: ParamName
ModInteger'memory'arguments'slope :: ParamName
MultiplyInteger'cpu'arguments'intercept :: ParamName
MultiplyInteger'cpu'arguments'slope :: ParamName
MultiplyInteger'memory'arguments'intercept :: ParamName
MultiplyInteger'memory'arguments'slope :: ParamName
NullList'cpu'arguments :: ParamName
NullList'memory'arguments :: ParamName
QuotientInteger'cpu'arguments'constant :: ParamName
QuotientInteger'cpu'arguments'model'arguments'c00 :: ParamName
QuotientInteger'cpu'arguments'model'arguments'c01 :: ParamName
QuotientInteger'cpu'arguments'model'arguments'c02 :: ParamName
QuotientInteger'cpu'arguments'model'arguments'c10 :: ParamName
QuotientInteger'cpu'arguments'model'arguments'c11 :: ParamName
QuotientInteger'cpu'arguments'model'arguments'c20 :: ParamName
QuotientInteger'cpu'arguments'model'arguments'minimum :: ParamName
QuotientInteger'memory'arguments'intercept :: ParamName
QuotientInteger'memory'arguments'minimum :: ParamName
QuotientInteger'memory'arguments'slope :: ParamName
RemainderInteger'cpu'arguments'constant :: ParamName
RemainderInteger'cpu'arguments'model'arguments'c00 :: ParamName
RemainderInteger'cpu'arguments'model'arguments'c01 :: ParamName
RemainderInteger'cpu'arguments'model'arguments'c02 :: ParamName
RemainderInteger'cpu'arguments'model'arguments'c10 :: ParamName
RemainderInteger'cpu'arguments'model'arguments'c11 :: ParamName
RemainderInteger'cpu'arguments'model'arguments'c20 :: ParamName
RemainderInteger'cpu'arguments'model'arguments'minimum :: ParamName
RemainderInteger'memory'arguments'intercept :: ParamName
RemainderInteger'memory'arguments'slope :: ParamName
SerialiseData'cpu'arguments'intercept :: ParamName
SerialiseData'cpu'arguments'slope :: ParamName
SerialiseData'memory'arguments'intercept :: ParamName
SerialiseData'memory'arguments'slope :: ParamName
Sha2_256'cpu'arguments'intercept :: ParamName
Sha2_256'cpu'arguments'slope :: ParamName
Sha2_256'memory'arguments :: ParamName
Sha3_256'cpu'arguments'intercept :: ParamName
Sha3_256'cpu'arguments'slope :: ParamName
Sha3_256'memory'arguments :: ParamName
SliceByteString'cpu'arguments'intercept :: ParamName
SliceByteString'cpu'arguments'slope :: ParamName
SliceByteString'memory'arguments'intercept :: ParamName
SliceByteString'memory'arguments'slope :: ParamName
SndPair'cpu'arguments :: ParamName
SndPair'memory'arguments :: ParamName
SubtractInteger'cpu'arguments'intercept :: ParamName
SubtractInteger'cpu'arguments'slope :: ParamName
SubtractInteger'memory'arguments'intercept :: ParamName
SubtractInteger'memory'arguments'slope :: ParamName
TailList'cpu'arguments :: ParamName
TailList'memory'arguments :: ParamName
Trace'cpu'arguments :: ParamName
Trace'memory'arguments :: ParamName
UnBData'cpu'arguments :: ParamName
UnBData'memory'arguments :: ParamName
UnConstrData'cpu'arguments :: ParamName
UnConstrData'memory'arguments :: ParamName
UnIData'cpu'arguments :: ParamName
UnIData'memory'arguments :: ParamName
UnListData'cpu'arguments :: ParamName
UnListData'memory'arguments :: ParamName
UnMapData'cpu'arguments :: ParamName
UnMapData'memory'arguments :: ParamName
VerifyEcdsaSecp256k1Signature'cpu'arguments :: ParamName
VerifyEcdsaSecp256k1Signature'memory'arguments :: ParamName
VerifyEd25519Signature'cpu'arguments'intercept :: ParamName
VerifyEd25519Signature'cpu'arguments'slope :: ParamName
VerifyEd25519Signature'memory'arguments :: ParamName
VerifySchnorrSecp256k1Signature'cpu'arguments'intercept :: ParamName
VerifySchnorrSecp256k1Signature'cpu'arguments'slope :: ParamName
VerifySchnorrSecp256k1Signature'memory'arguments :: ParamName
CekConstrCost'exBudgetCPU :: ParamName
CekConstrCost'exBudgetMemory :: ParamName
CekCaseCost'exBudgetCPU :: ParamName
CekCaseCost'exBudgetMemory :: ParamName
Bls12_381_G1_add'cpu'arguments :: ParamName
Bls12_381_G1_add'memory'arguments :: ParamName
Bls12_381_G1_compress'cpu'arguments :: ParamName
Bls12_381_G1_compress'memory'arguments :: ParamName
Bls12_381_G1_equal'cpu'arguments :: ParamName
Bls12_381_G1_equal'memory'arguments :: ParamName
Bls12_381_G1_hashToGroup'cpu'arguments'intercept :: ParamName
Bls12_381_G1_hashToGroup'cpu'arguments'slope :: ParamName
Bls12_381_G1_hashToGroup'memory'arguments :: ParamName
Bls12_381_G1_neg'cpu'arguments :: ParamName
Bls12_381_G1_neg'memory'arguments :: ParamName
Bls12_381_G1_scalarMul'cpu'arguments'intercept :: ParamName
Bls12_381_G1_scalarMul'cpu'arguments'slope :: ParamName
Bls12_381_G1_scalarMul'memory'arguments :: ParamName
Bls12_381_G1_uncompress'cpu'arguments :: ParamName
Bls12_381_G1_uncompress'memory'arguments :: ParamName
Bls12_381_G2_add'cpu'arguments :: ParamName
Bls12_381_G2_add'memory'arguments :: ParamName
Bls12_381_G2_compress'cpu'arguments :: ParamName
Bls12_381_G2_compress'memory'arguments :: ParamName
Bls12_381_G2_equal'cpu'arguments :: ParamName
Bls12_381_G2_equal'memory'arguments :: ParamName
Bls12_381_G2_hashToGroup'cpu'arguments'intercept :: ParamName
Bls12_381_G2_hashToGroup'cpu'arguments'slope :: ParamName
Bls12_381_G2_hashToGroup'memory'arguments :: ParamName
Bls12_381_G2_neg'cpu'arguments :: ParamName
Bls12_381_G2_neg'memory'arguments :: ParamName
Bls12_381_G2_scalarMul'cpu'arguments'intercept :: ParamName
Bls12_381_G2_scalarMul'cpu'arguments'slope :: ParamName
Bls12_381_G2_scalarMul'memory'arguments :: ParamName
Bls12_381_G2_uncompress'cpu'arguments :: ParamName
Bls12_381_G2_uncompress'memory'arguments :: ParamName
Bls12_381_finalVerify'cpu'arguments :: ParamName
Bls12_381_finalVerify'memory'arguments :: ParamName
Bls12_381_millerLoop'cpu'arguments :: ParamName
Bls12_381_millerLoop'memory'arguments :: ParamName
Bls12_381_mulMlResult'cpu'arguments :: ParamName
Bls12_381_mulMlResult'memory'arguments :: ParamName
Keccak_256'cpu'arguments'intercept :: ParamName
Keccak_256'cpu'arguments'slope :: ParamName
Keccak_256'memory'arguments :: ParamName
Blake2b_224'cpu'arguments'intercept :: ParamName
Blake2b_224'cpu'arguments'slope :: ParamName
Blake2b_224'memory'arguments :: ParamName
IntegerToByteString'cpu'arguments'c0 :: ParamName
IntegerToByteString'cpu'arguments'c1 :: ParamName
IntegerToByteString'cpu'arguments'c2 :: ParamName
IntegerToByteString'memory'arguments'intercept :: ParamName
IntegerToByteString'memory'arguments'slope :: ParamName
ByteStringToInteger'cpu'arguments'c0 :: ParamName
ByteStringToInteger'cpu'arguments'c1 :: ParamName
ByteStringToInteger'cpu'arguments'c2 :: ParamName
ByteStringToInteger'memory'arguments'intercept :: ParamName
ByteStringToInteger'memory'arguments'slope :: ParamName
AndByteString'cpu'arguments'intercept :: ParamName
AndByteString'cpu'arguments'slope1 :: ParamName
AndByteString'cpu'arguments'slope2 :: ParamName
AndByteString'memory'arguments'intercept :: ParamName
AndByteString'memory'arguments'slope :: ParamName
OrByteString'cpu'arguments'intercept :: ParamName
OrByteString'cpu'arguments'slope1 :: ParamName
OrByteString'cpu'arguments'slope2 :: ParamName
OrByteString'memory'arguments'intercept :: ParamName
OrByteString'memory'arguments'slope :: ParamName
XorByteString'cpu'arguments'intercept :: ParamName
XorByteString'cpu'arguments'slope1 :: ParamName
XorByteString'cpu'arguments'slope2 :: ParamName
XorByteString'memory'arguments'intercept :: ParamName
XorByteString'memory'arguments'slope :: ParamName
ComplementByteString'cpu'arguments'intercept :: ParamName
ComplementByteString'cpu'arguments'slope :: ParamName
ComplementByteString'memory'arguments'intercept :: ParamName
ComplementByteString'memory'arguments'slope :: ParamName
ReadBit'cpu'arguments :: ParamName
ReadBit'memory'arguments :: ParamName
WriteBits'cpu'arguments'intercept :: ParamName
WriteBits'cpu'arguments'slope :: ParamName
WriteBits'memory'arguments'intercept :: ParamName
WriteBits'memory'arguments'slope :: ParamName
ReplicateByte'cpu'arguments'intercept :: ParamName
ReplicateByte'cpu'arguments'slope :: ParamName
ReplicateByte'memory'arguments'intercept :: ParamName
ReplicateByte'memory'arguments'slope :: ParamName
ShiftByteString'cpu'arguments'intercept :: ParamName
ShiftByteString'cpu'arguments'slope :: ParamName
ShiftByteString'memory'arguments'intercept :: ParamName
ShiftByteString'memory'arguments'slope :: ParamName
RotateByteString'cpu'arguments'intercept :: ParamName
RotateByteString'cpu'arguments'slope :: ParamName
RotateByteString'memory'arguments'intercept :: ParamName
RotateByteString'memory'arguments'slope :: ParamName
CountSetBits'cpu'arguments'intercept :: ParamName
CountSetBits'cpu'arguments'slope :: ParamName
CountSetBits'memory'arguments :: ParamName
FindFirstSetBit'cpu'arguments'intercept :: ParamName
FindFirstSetBit'cpu'arguments'slope :: ParamName
FindFirstSetBit'memory'arguments :: ParamName
Ripemd_160'cpu'arguments'intercept :: ParamName
Ripemd_160'cpu'arguments'slope :: ParamName
Ripemd_160'memory'arguments :: ParamName
data () => CostModelApplyError
CMUnknownParamError :: !Text -> CostModelApplyError
CMInternalReadError :: CostModelApplyError
CMInternalWriteError :: !String -> CostModelApplyError
type CostModelParams = Map Text Int64
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()

-- | The context that the currently-executing script can access.
data ScriptContext
ScriptContext :: TxInfo -> Redeemer -> ScriptInfo -> ScriptContext

-- | information about the transaction the currently-executing script is
--   included in
[scriptContextTxInfo] :: ScriptContext -> TxInfo

-- | Redeemer for the currently-executing script
[scriptContextRedeemer] :: ScriptContext -> Redeemer

-- | the purpose of the currently-executing script, along with information
--   associated with the purpose
[scriptContextScriptInfo] :: ScriptContext -> ScriptInfo

-- | A <a>ScriptPurpose</a> uniquely identifies a Plutus script within a
--   transaction.
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: Credential -> ScriptPurpose
Certifying :: Integer -> TxCert -> ScriptPurpose
Voting :: Voter -> ScriptPurpose
Proposing :: Integer -> ProposalProcedure -> ScriptPurpose

-- | Like <a>ScriptPurpose</a> but with an optional datum for spending
--   scripts.
data ScriptInfo
MintingScript :: CurrencySymbol -> ScriptInfo
SpendingScript :: TxOutRef -> Maybe Datum -> ScriptInfo
RewardingScript :: Credential -> ScriptInfo
CertifyingScript :: Integer -> TxCert -> ScriptInfo
VotingScript :: Voter -> ScriptInfo
ProposingScript :: Integer -> ProposalProcedure -> ScriptInfo
data () => BuiltinByteString
toBuiltin :: HasToBuiltin a => a -> ToBuiltin a
fromBuiltin :: HasFromBuiltin arep => arep -> FromBuiltin arep
toOpaque :: HasToOpaque a arep => a -> arep
fromOpaque :: HasFromOpaque arep a => arep -> a
newtype LedgerBytes
LedgerBytes :: BuiltinByteString -> LedgerBytes
[getLedgerBytes] :: LedgerBytes -> BuiltinByteString

-- | Lift a Haskell bytestring to the Plutus abstraction <a>LedgerBytes</a>
fromBytes :: ByteString -> LedgerBytes

-- | Staking credential used to assign rewards.
data StakingCredential

-- | The staking hash is the <a>Credential</a> required to unlock a
--   transaction output. Either a public key credential (<a>PubKeyHash</a>)
--   or a script credential (<a>ScriptHash</a>). Both are hashed with
--   <i>BLAKE2b-244</i>. 28 byte.
StakingHash :: Credential -> StakingCredential

-- | The certificate pointer, constructed by the given slot number,
--   transaction and certificate indices. NB: The fields should really be
--   all <tt>Word64</tt>, as they are implemented in <tt>Word64</tt>, but
--   <a>Integer</a> is our only integral type so we need to use it instead.
StakingPtr :: Integer -> Integer -> Integer -> StakingCredential

-- | Credentials required to unlock a transaction output.
data Credential

-- | The transaction that spends this output must be signed by the private
--   key. See <a>PubKeyHash</a>.
PubKeyCredential :: PubKeyHash -> Credential

-- | The transaction that spends this output must include the validator
--   script and be accepted by the validator. See <a>ScriptHash</a>.
ScriptCredential :: ScriptHash -> Credential

-- | The <a>Value</a> type represents a collection of amounts of different
--   currencies. We can think of <a>Value</a> as a vector space whose
--   dimensions are currencies.
--   
--   Operations on currencies are usually implemented <i>pointwise</i>.
--   That is, we apply the operation to the quantities for each currency in
--   turn. So when we add two <a>Value</a>s the resulting <a>Value</a> has,
--   for each currency, the sum of the quantities of <i>that particular</i>
--   currency in the argument <a>Value</a>. The effect of this is that the
--   currencies in the <a>Value</a> are "independent", and are operated on
--   separately.
--   
--   Whenever we need to get the quantity of a currency in a <a>Value</a>
--   where there is no explicit quantity of that currency in the
--   <a>Value</a>, then the quantity is taken to be zero.
--   
--   There is no 'Ord Value' instance since <a>Value</a> is only a partial
--   order, so <a>compare</a> can't do the right thing in some cases.
newtype Value
Value :: Map CurrencySymbol (Map TokenName Integer) -> Value
[getValue] :: Value -> Map CurrencySymbol (Map TokenName Integer)

-- | ByteString representing the currency, hashed with <i>BLAKE2b-224</i>.
--   It is empty for <tt>Ada</tt>, 28 bytes for <tt>MintingPolicyHash</tt>.
--   Forms an <a>AssetClass</a> along with <a>TokenName</a>. A <a>Value</a>
--   is a map from <a>CurrencySymbol</a>'s to a map from <a>TokenName</a>
--   to an <a>Integer</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype CurrencySymbol
CurrencySymbol :: BuiltinByteString -> CurrencySymbol
[unCurrencySymbol] :: CurrencySymbol -> BuiltinByteString

-- | ByteString of a name of a token. Shown as UTF-8 string when possible.
--   Should be no longer than 32 bytes, empty for Ada. Forms an
--   <a>AssetClass</a> along with a <a>CurrencySymbol</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TokenName
TokenName :: BuiltinByteString -> TokenName
[unTokenName] :: TokenName -> BuiltinByteString

-- | Make a <a>Value</a> containing only the given quantity of the given
--   currency.
singleton :: CurrencySymbol -> TokenName -> Integer -> Value

-- | Combine two <a>Value</a> maps with the argument function. Assumes the
--   well-definedness of the two maps.
unionWith :: (Integer -> Integer -> Integer) -> Value -> Value -> Value

-- | The <a>CurrencySymbol</a> of the <tt>Ada</tt> currency.
adaSymbol :: CurrencySymbol

-- | The <a>TokenName</a> of the <tt>Ada</tt> currency.
adaToken :: TokenName
newtype Lovelace
Lovelace :: Integer -> Lovelace
[getLovelace] :: Lovelace -> Integer

-- | POSIX time is measured as the number of <i>milliseconds</i> since
--   1970-01-01T00:00:00Z. This is not the same as Haskell's
--   <a>POSIXTime</a>
newtype POSIXTime
POSIXTime :: Integer -> POSIXTime
[getPOSIXTime] :: POSIXTime -> Integer

-- | An <a>Interval</a> of <a>POSIXTime</a>s.
type POSIXTimeRange = Interval POSIXTime

-- | An address may contain two credentials, the payment credential and
--   optionally a <a>StakingCredential</a>.
data Address
Address :: Credential -> Maybe StakingCredential -> Address

-- | the payment credential
[addressCredential] :: Address -> Credential

-- | the staking credential
[addressStakingCredential] :: Address -> Maybe StakingCredential

-- | The hash of a public key. This is frequently used to identify the
--   public key, rather than the key itself. Hashed with
--   <i>BLAKE2b-224</i>. 28 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype PubKeyHash
PubKeyHash :: BuiltinByteString -> PubKeyHash
[getPubKeyHash] :: PubKeyHash -> BuiltinByteString

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the Shelley ledger
--   specification.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | TxInfo for PlutusV3
data TxInfo
TxInfo :: [TxInInfo] -> [TxInInfo] -> [TxOut] -> Lovelace -> Value -> [TxCert] -> Map Credential Lovelace -> POSIXTimeRange -> [PubKeyHash] -> Map ScriptPurpose Redeemer -> Map DatumHash Datum -> TxId -> Map Voter (Map GovernanceActionId Vote) -> [ProposalProcedure] -> Maybe Lovelace -> Maybe Lovelace -> TxInfo
[txInfoInputs] :: TxInfo -> [TxInInfo]
[txInfoReferenceInputs] :: TxInfo -> [TxInInfo]
[txInfoOutputs] :: TxInfo -> [TxOut]
[txInfoFee] :: TxInfo -> Lovelace

-- | The <tt>Value</tt> minted by this transaction.
--   
--   <i>Invariant:</i> This field does not contain Ada with zero quantity,
--   unlike their namesakes in Plutus V1 and V2's ScriptContexts.
[txInfoMint] :: TxInfo -> Value
[txInfoTxCerts] :: TxInfo -> [TxCert]
[txInfoWdrl] :: TxInfo -> Map Credential Lovelace
[txInfoValidRange] :: TxInfo -> POSIXTimeRange
[txInfoSignatories] :: TxInfo -> [PubKeyHash]
[txInfoRedeemers] :: TxInfo -> Map ScriptPurpose Redeemer
[txInfoData] :: TxInfo -> Map DatumHash Datum
[txInfoId] :: TxInfo -> TxId
[txInfoVotes] :: TxInfo -> Map Voter (Map GovernanceActionId Vote)
[txInfoProposalProcedures] :: TxInfo -> [ProposalProcedure]
[txInfoCurrentTreasuryAmount] :: TxInfo -> Maybe Lovelace
[txInfoTreasuryDonation] :: TxInfo -> Maybe Lovelace

-- | A transaction output, consisting of a target address, a value,
--   optionally a datum/datum hash, and optionally a reference script.
data TxOut
TxOut :: Address -> Value -> OutputDatum -> Maybe ScriptHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatum] :: TxOut -> OutputDatum
[txOutReferenceScript] :: TxOut -> Maybe ScriptHash

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | The datum attached to an output: either nothing; a datum hash; or the
--   datum itself (an "inline datum").
data OutputDatum
NoOutputDatum :: OutputDatum
OutputDatumHash :: DatumHash -> OutputDatum
OutputDatum :: Datum -> OutputDatum

-- | An interval of <tt>a</tt>s.
--   
--   The interval may be either closed or open at either end, meaning that
--   the endpoints may or may not be included in the interval.
--   
--   The interval can also be unbounded on either side.
--   
--   The <a>Eq</a> instance gives equality of the intervals, not structural
--   equality. There is no <a>Ord</a> instance, but <a>contains</a> gives a
--   partial order.
--   
--   Note that some of the functions on <a>Interval</a> rely on <a>Enum</a>
--   in order to handle non-inclusive endpoints. For this reason, it may
--   not be safe to use <a>Interval</a>s with non-inclusive endpoints on
--   types whose <a>Enum</a> instances have partial methods.
data Interval a
Interval :: LowerBound a -> UpperBound a -> Interval a
[ivFrom] :: Interval a -> LowerBound a
[ivTo] :: Interval a -> UpperBound a

-- | A set extended with a positive and negative infinity.
data Extended a
NegInf :: Extended a
Finite :: a -> Extended a
PosInf :: Extended a

-- | Whether a bound is inclusive or not.
type Closure = Bool

-- | The upper bound of an interval.
data UpperBound a
UpperBound :: Extended a -> Closure -> UpperBound a

-- | The lower bound of an interval.
data LowerBound a
LowerBound :: Extended a -> Closure -> LowerBound a

-- | An <a>Interval</a> that covers every slot. In math. notation [-∞,+∞]
always :: Interval a

-- | <tt>from a</tt> is an <a>Interval</a> that includes all values that
--   are greater than or equal to <tt>a</tt>. In math. notation: [a,+∞]
from :: a -> Interval a

-- | <tt>to a</tt> is an <a>Interval</a> that includes all values that are
--   smaller than or equal to <tt>a</tt>. In math. notation: [-∞,a]
to :: a -> Interval a

-- | Construct a lower bound from a value.
--   
--   The resulting bound includes all values that are equal or greater than
--   the input value.
lowerBound :: a -> LowerBound a

-- | Construct an upper bound from a value.
--   
--   The resulting bound includes all values that are equal or smaller than
--   the input value.
upperBound :: a -> UpperBound a

-- | Construct a strict lower bound from a value.
--   
--   The resulting bound includes all values that are (strictly) greater
--   than the input value.
strictLowerBound :: a -> LowerBound a

-- | Construct a strict upper bound from a value.
--   
--   The resulting bound includes all values that are (strictly) smaller
--   than the input value.
strictUpperBound :: a -> UpperBound a
data () => Rational
ratio :: Integer -> Integer -> Maybe Rational
fromGHC :: Rational -> Rational
toGHC :: Rational -> Rational
data () => Map k v
unsafeFromList :: [(k, v)] -> Map k v

-- | Type representing the <i>BLAKE2b-224</i> hash of a script. 28 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype ScriptHash
ScriptHash :: BuiltinByteString -> ScriptHash
[getScriptHash] :: ScriptHash -> BuiltinByteString

-- | <a>Redeemer</a> is a wrapper around <tt>Data</tt> values that are used
--   as redeemers in transaction inputs.
newtype Redeemer
Redeemer :: BuiltinData -> Redeemer
[getRedeemer] :: Redeemer -> BuiltinData

-- | Type representing the <i>BLAKE2b-256</i> hash of a redeemer. 32 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype RedeemerHash
RedeemerHash :: BuiltinByteString -> RedeemerHash

-- | <a>Datum</a> is a wrapper around <tt>Data</tt> values which are used
--   as data in transaction outputs.
newtype Datum
Datum :: BuiltinData -> Datum
[getDatum] :: Datum -> BuiltinData

-- | Type representing the <i>BLAKE2b-256</i> hash of a datum. 32 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype DatumHash
DatumHash :: BuiltinByteString -> DatumHash
data () => Data
Constr :: Integer -> [Data] -> Data
Map :: [(Data, Data)] -> Data
List :: [Data] -> Data
I :: Integer -> Data
B :: ByteString -> Data
data () => BuiltinData
BuiltinData :: ~Data -> BuiltinData
class () => ToData a
toBuiltinData :: ToData a => a -> BuiltinData
class () => FromData a
fromBuiltinData :: FromData a => BuiltinData -> Maybe a
class () => UnsafeFromData a
unsafeFromBuiltinData :: UnsafeFromData a => BuiltinData -> a
toData :: ToData a => a -> Data
fromData :: FromData a => Data -> Maybe a
unsafeFromData :: UnsafeFromData a => Data -> a
dataToBuiltinData :: Data -> BuiltinData
builtinDataToData :: BuiltinData -> Data

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>MonadError</a> class. (If you are using the deprecated
--   <a>Control.Monad.Error</a> or <a>Control.Monad.Trans.Error</a>, you
--   may also have to define an <tt>Error</tt> instance.)
class Monad m => MonadError e (m :: Type -> Type) | m -> e

-- | Errors that can be thrown when evaluating a Plutus script.
data EvaluationError

-- | An error from the evaluator itself
CekError :: !CekEvaluationException NamedDeBruijn DefaultUni DefaultFun -> EvaluationError

-- | An error in the pre-evaluation step of converting from de-Bruijn
--   indices
DeBruijnError :: !FreeVariableError -> EvaluationError

-- | A deserialisation error TODO: make this error more informative when we
--   have more information about what went wrong
CodecError :: !ScriptDecodeError -> EvaluationError

-- | An error indicating that the cost model parameters didn't match what
--   we expected
CostModelParameterMismatch :: EvaluationError

-- | The script evaluated to a value that is not a valid return value.
InvalidReturnValue :: EvaluationError

-- | An error that occurred during script deserialization.
data ScriptDecodeError

-- | an error from the underlying CBOR/serialise library
CBORDeserialiseError :: !DeserialiseFailureInfo -> ScriptDecodeError

-- | Script was successfully parsed, but more (runaway) bytes encountered
--   after script's position
RemainderError :: !ByteString -> ScriptDecodeError

-- | the plutus version of the given script is not enabled yet
LedgerLanguageNotAvailableError :: !PlutusLedgerLanguage -> !MajorProtocolVersion -> !MajorProtocolVersion -> ScriptDecodeError

-- | the script's ledger language
[sdeAffectedLang] :: ScriptDecodeError -> !PlutusLedgerLanguage

-- | the major protocol version that will first introduce/enable the ledger
--   language
[sdeIntroPv] :: ScriptDecodeError -> !MajorProtocolVersion

-- | the current protocol version
[sdeThisPv] :: ScriptDecodeError -> !MajorProtocolVersion
PlutusCoreLanguageNotAvailableError :: !Version -> !PlutusLedgerLanguage -> !MajorProtocolVersion -> ScriptDecodeError

-- | the Plutus Core language of the script under execution.
[sdeAffectedVersion] :: ScriptDecodeError -> !Version

-- | the Plutus ledger language of the script under execution.
[sdeThisLang] :: ScriptDecodeError -> !PlutusLedgerLanguage

-- | the current protocol version
[sdeThisPv] :: ScriptDecodeError -> !MajorProtocolVersion


-- | Functions for working with <a>Value</a>.
module PlutusLedgerApi.V1.Data.Value

-- | ByteString representing the currency, hashed with <i>BLAKE2b-224</i>.
--   It is empty for <tt>Ada</tt>, 28 bytes for <tt>MintingPolicyHash</tt>.
--   Forms an <a>AssetClass</a> along with <a>TokenName</a>. A <a>Value</a>
--   is a map from <a>CurrencySymbol</a>'s to a map from <a>TokenName</a>
--   to an <a>Integer</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype CurrencySymbol
CurrencySymbol :: BuiltinByteString -> CurrencySymbol
[unCurrencySymbol] :: CurrencySymbol -> BuiltinByteString

-- | Creates <a>CurrencySymbol</a> from raw <tt>ByteString</tt>.
currencySymbol :: ByteString -> CurrencySymbol

-- | The <a>CurrencySymbol</a> of the <tt>Ada</tt> currency.
adaSymbol :: CurrencySymbol

-- | ByteString of a name of a token. Shown as UTF-8 string when possible.
--   Should be no longer than 32 bytes, empty for Ada. Forms an
--   <a>AssetClass</a> along with a <a>CurrencySymbol</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TokenName
TokenName :: BuiltinByteString -> TokenName
[unTokenName] :: TokenName -> BuiltinByteString

-- | Creates <a>TokenName</a> from raw <a>ByteString</a>.
tokenName :: ByteString -> TokenName

-- | Turn a TokenName to a hex-encoded <tt>String</tt>
--   
--   Compared to <tt>show</tt> , it will not surround the string with
--   double-quotes.
toString :: TokenName -> String

-- | The <a>TokenName</a> of the <tt>Ada</tt> currency.
adaToken :: TokenName

-- | An asset class, identified by a <a>CurrencySymbol</a> and a
--   <a>TokenName</a>.
newtype AssetClass
AssetClass :: (CurrencySymbol, TokenName) -> AssetClass
[unAssetClass] :: AssetClass -> (CurrencySymbol, TokenName)

-- | The curried version of <a>AssetClass</a> constructor
assetClass :: CurrencySymbol -> TokenName -> AssetClass

-- | A <a>Value</a> containing the given amount of the asset class.
assetClassValue :: AssetClass -> Integer -> Value

-- | Get the quantity of the given <a>AssetClass</a> class in the
--   <a>Value</a>.
assetClassValueOf :: Value -> AssetClass -> Integer

-- | The <a>Value</a> type represents a collection of amounts of different
--   currencies. We can think of <a>Value</a> as a vector space whose
--   dimensions are currencies.
--   
--   Operations on currencies are usually implemented <i>pointwise</i>.
--   That is, we apply the operation to the quantities for each currency in
--   turn. So when we add two <a>Value</a>s the resulting <a>Value</a> has,
--   for each currency, the sum of the quantities of <i>that particular</i>
--   currency in the argument <a>Value</a>. The effect of this is that the
--   currencies in the <a>Value</a> are "independent", and are operated on
--   separately.
--   
--   Whenever we need to get the quantity of a currency in a <a>Value</a>
--   where there is no explicit quantity of that currency in the
--   <a>Value</a>, then the quantity is taken to be zero.
--   
--   There is no 'Ord Value' instance since <a>Value</a> is only a partial
--   order, so <a>compare</a> can't do the right thing in some cases.
newtype Value
Value :: Map CurrencySymbol (Map TokenName Integer) -> Value
[getValue] :: Value -> Map CurrencySymbol (Map TokenName Integer)

-- | Make a <a>Value</a> containing only the given quantity of the given
--   currency.
singleton :: CurrencySymbol -> TokenName -> Integer -> Value

-- | Get the quantity of the given currency in the <a>Value</a>. Assumes
--   that the underlying map doesn't contain duplicate keys.
valueOf :: Value -> CurrencySymbol -> TokenName -> Integer

-- | Get the total value of the currency symbol in the <a>Value</a> map.
--   Assumes that the underlying map doesn't contain duplicate keys.
currencySymbolValueOf :: Value -> CurrencySymbol -> Integer

-- | A <a>Value</a> containing the given quantity of Lovelace.
lovelaceValue :: Lovelace -> Value

-- | Get the quantity of Lovelace in the <a>Value</a>.
lovelaceValueOf :: Value -> Lovelace
scale :: Module s v => s -> v -> v

-- | The list of <a>CurrencySymbol</a>s of a <a>Value</a>.
symbols :: Value -> BuiltinList BuiltinData

-- | Check whether one <a>Value</a> is greater than or equal to another.
--   See <a>Value</a> for an explanation of how operations on <a>Value</a>s
--   work.
geq :: Value -> Value -> Bool

-- | Check whether one <a>Value</a> is strictly greater than another. This
--   is *not* a pointwise operation. <tt>gt l r</tt> means <tt>geq l r
--   &amp;&amp; not (eq l r)</tt>.
gt :: Value -> Value -> Bool

-- | Check whether one <a>Value</a> is less than or equal to another. See
--   <a>Value</a> for an explanation of how operations on <a>Value</a>s
--   work.
leq :: Value -> Value -> Bool

-- | Check whether one <a>Value</a> is strictly less than another. This is
--   *not* a pointwise operation. <tt>lt l r</tt> means <tt>leq l r
--   &amp;&amp; not (eq l r)</tt>.
lt :: Value -> Value -> Bool

-- | Check whether a <a>Value</a> is zero.
isZero :: Value -> Bool

-- | Split a <a>Value</a> into its positive and negative parts. The first
--   element of the tuple contains the negative parts of the <a>Value</a>,
--   the second element contains the positive parts.
--   
--   <pre>
--   negate (fst (split a)) <tt>plus</tt> (snd (split a)) == a
--   </pre>
split :: Value -> (Value, Value)

-- | Combine two <a>Value</a> maps with the argument function. Assumes the
--   well-definedness of the two maps.
unionWith :: (Integer -> Integer -> Integer) -> Value -> Value -> Value

-- | Convert a <a>Value</a> to a simple list, keeping only the non-zero
--   amounts. Note that the result isn't sorted, meaning <tt>v1 == v2</tt>
--   doesn't generally imply <tt>flattenValue v1 == flattenValue v2</tt>.
--   Also assumes that there are no duplicate keys in the <a>Value</a>
--   <tt>Map</tt>.
flattenValue :: Value -> [(CurrencySymbol, TokenName, Integer)]
newtype Lovelace
Lovelace :: Integer -> Lovelace
[getLovelace] :: Lovelace -> Integer
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Value.Lovelace
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Value.Lovelace
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Value.Value
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Value.Value
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Value.AssetClass
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Value.AssetClass
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Value.TokenName
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Value.TokenName
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Value.CurrencySymbol
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Value.CurrencySymbol
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Data.Value.CurrencySymbol
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Data.Value.CurrencySymbol
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Data.Value.CurrencySymbol
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Data.Value.CurrencySymbol
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Data.Value.CurrencySymbol
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Data.Value.CurrencySymbol
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Data.Value.CurrencySymbol
instance GHC.Classes.Ord PlutusLedgerApi.V1.Data.Value.CurrencySymbol
instance GHC.Classes.Eq PlutusLedgerApi.V1.Data.Value.CurrencySymbol
instance Data.Data.Data PlutusLedgerApi.V1.Data.Value.CurrencySymbol
instance GHC.Generics.Generic PlutusLedgerApi.V1.Data.Value.CurrencySymbol
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Data.Value.CurrencySymbol
instance GHC.Show.Show PlutusLedgerApi.V1.Data.Value.CurrencySymbol
instance Data.String.IsString PlutusLedgerApi.V1.Data.Value.CurrencySymbol
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Data.Value.TokenName
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Data.Value.TokenName
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Data.Value.TokenName
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Data.Value.TokenName
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Data.Value.TokenName
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Data.Value.TokenName
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Data.Value.TokenName
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Data.Value.TokenName
instance GHC.Classes.Ord PlutusLedgerApi.V1.Data.Value.TokenName
instance GHC.Classes.Eq PlutusLedgerApi.V1.Data.Value.TokenName
instance Data.Data.Data PlutusLedgerApi.V1.Data.Value.TokenName
instance GHC.Generics.Generic PlutusLedgerApi.V1.Data.Value.TokenName
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Data.Value.AssetClass
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Data.Value.AssetClass
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Data.Value.AssetClass
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Data.Value.AssetClass
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Data.Value.AssetClass
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Data.Value.AssetClass
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Data.Value.AssetClass
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Data.Value.AssetClass
instance GHC.Show.Show PlutusLedgerApi.V1.Data.Value.AssetClass
instance GHC.Classes.Ord PlutusLedgerApi.V1.Data.Value.AssetClass
instance GHC.Classes.Eq PlutusLedgerApi.V1.Data.Value.AssetClass
instance Data.Data.Data PlutusLedgerApi.V1.Data.Value.AssetClass
instance GHC.Generics.Generic PlutusLedgerApi.V1.Data.Value.AssetClass
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Data.Value.Value
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Data.Value.Value
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Data.Value.Value
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Data.Value.Value
instance GHC.Show.Show PlutusLedgerApi.V1.Data.Value.Value
instance GHC.Generics.Generic PlutusLedgerApi.V1.Data.Value.Value
instance PlutusTx.Show.TH.Show PlutusLedgerApi.V1.Data.Value.Lovelace
instance PlutusTx.Numeric.AdditiveGroup PlutusLedgerApi.V1.Data.Value.Lovelace
instance PlutusTx.Numeric.AdditiveMonoid PlutusLedgerApi.V1.Data.Value.Lovelace
instance PlutusTx.Numeric.AdditiveSemigroup PlutusLedgerApi.V1.Data.Value.Lovelace
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Data.Value.Lovelace
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Data.Value.Lovelace
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Data.Value.Lovelace
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Data.Value.Lovelace
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Data.Value.Lovelace
instance GHC.Enum.Enum PlutusLedgerApi.V1.Data.Value.Lovelace
instance GHC.Real.Real PlutusLedgerApi.V1.Data.Value.Lovelace
instance GHC.Num.Num PlutusLedgerApi.V1.Data.Value.Lovelace
instance GHC.Show.Show PlutusLedgerApi.V1.Data.Value.Lovelace
instance GHC.Classes.Ord PlutusLedgerApi.V1.Data.Value.Lovelace
instance GHC.Classes.Eq PlutusLedgerApi.V1.Data.Value.Lovelace
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Data.Value.Lovelace
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Data.Value.Lovelace
instance GHC.Generics.Generic PlutusLedgerApi.V1.Data.Value.Lovelace
instance PlutusTx.Numeric.AdditiveSemigroup PlutusLedgerApi.V1.Data.Value.Value
instance PlutusTx.Numeric.AdditiveMonoid PlutusLedgerApi.V1.Data.Value.Value
instance PlutusTx.Numeric.AdditiveGroup PlutusLedgerApi.V1.Data.Value.Value
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusLedgerApi.V1.Data.Value.Value
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Data.Value.Value referencedTypes
instance GHC.Classes.Eq PlutusLedgerApi.V1.Data.Value.Value
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Data.Value.Value
instance GHC.Base.Semigroup PlutusLedgerApi.V1.Data.Value.Value
instance PlutusTx.Semigroup.Semigroup PlutusLedgerApi.V1.Data.Value.Value
instance GHC.Base.Monoid PlutusLedgerApi.V1.Data.Value.Value
instance PlutusTx.Monoid.Monoid PlutusLedgerApi.V1.Data.Value.Value
instance PlutusTx.Monoid.Group PlutusLedgerApi.V1.Data.Value.Value
instance PlutusTx.Numeric.Module GHC.Num.Integer.Integer PlutusLedgerApi.V1.Data.Value.Value
instance PlutusTx.Lattice.JoinSemiLattice PlutusLedgerApi.V1.Data.Value.Value
instance PlutusTx.Lattice.MeetSemiLattice PlutusLedgerApi.V1.Data.Value.Value
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Data.Value.AssetClass referencedTypes
instance Data.String.IsString PlutusLedgerApi.V1.Data.Value.TokenName
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Data.Value.TokenName referencedTypes
instance GHC.Show.Show PlutusLedgerApi.V1.Data.Value.TokenName
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusLedgerApi.V1.Data.Value.CurrencySymbol referencedTypes

module PlutusLedgerApi.V1.Data.Tx

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A tag indicating the type of script that we are pointing to.
--   
--   See also <a>ScriptPurpose</a>
data ScriptTag
Spend :: ScriptTag
Mint :: ScriptTag
Cert :: ScriptTag
Reward :: ScriptTag

-- | A redeemer pointer is a pair of a script type tag (<a>ScriptTag</a>)
--   <tt>t</tt> and an index <tt>i</tt>, picking out the i-th script of
--   type <tt>t</tt> in the transaction.
data RedeemerPtr
RedeemerPtr :: ScriptTag -> Integer -> RedeemerPtr

-- | Redeemers is a <a>Map</a> of redeemer pointer (<a>RedeemerPtr</a>) and
--   its <a>Redeemer</a>.
type Redeemers = Map RedeemerPtr Redeemer

-- | A transaction output, consisting of a target address (<a>Address</a>),
--   a value (<a>Value</a>), and optionally a datum hash
--   (<a>DatumHash</a>).
data TxOut
TxOut :: Address -> Value -> Maybe DatumHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatumHash] :: TxOut -> Maybe DatumHash

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | Whether the output is a pay-to-pubkey output.
isPubKeyOut :: TxOut -> Bool

-- | Whether the output is a pay-to-script output.
isPayToScriptOut :: TxOut -> Bool

-- | The address of a transaction output.
outAddress :: Lens' TxOut Address

-- | The value of a transaction output. | TODO: Compute address again
outValue :: Lens' TxOut Value

-- | The public key attached to a <a>TxOut</a>, if there is one.
txOutPubKey :: TxOut -> Maybe PubKeyHash

-- | The datum attached to a <a>TxOut</a>, if there is one.
txOutDatum :: TxOut -> Maybe DatumHash

-- | Create a transaction output locked by a public key.
pubKeyHashTxOut :: Value -> PubKeyHash -> TxOut
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Tx.TxOutRef
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Tx.TxOutRef
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Data.Tx.TxOutRef
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Data.Tx.TxOutRef
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Data.Tx.TxOutRef
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Tx.TxOut
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Tx.TxOut
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Data.Tx.TxOut
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Data.Tx.TxOut
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Data.Tx.TxOut
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Data.Tx.TxId
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Data.Tx.TxId
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Data.Tx.TxId
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Tx.TxId
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Tx.TxId
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Data.Tx.TxId
instance GHC.Show.Show PlutusLedgerApi.V1.Data.Tx.TxId
instance Data.String.IsString PlutusLedgerApi.V1.Data.Tx.TxId
instance PlutusTx.Ord.Ord PlutusLedgerApi.V1.Data.Tx.TxId
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Data.Tx.TxId
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Data.Tx.TxId
instance GHC.Generics.Generic PlutusLedgerApi.V1.Data.Tx.TxId
instance GHC.Classes.Ord PlutusLedgerApi.V1.Data.Tx.TxId
instance GHC.Classes.Eq PlutusLedgerApi.V1.Data.Tx.TxId
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Data.Tx.ScriptTag
instance GHC.Generics.Generic PlutusLedgerApi.V1.Data.Tx.ScriptTag
instance GHC.Classes.Ord PlutusLedgerApi.V1.Data.Tx.ScriptTag
instance GHC.Classes.Eq PlutusLedgerApi.V1.Data.Tx.ScriptTag
instance GHC.Show.Show PlutusLedgerApi.V1.Data.Tx.ScriptTag
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Data.Tx.RedeemerPtr
instance GHC.Generics.Generic PlutusLedgerApi.V1.Data.Tx.RedeemerPtr
instance GHC.Classes.Ord PlutusLedgerApi.V1.Data.Tx.RedeemerPtr
instance GHC.Classes.Eq PlutusLedgerApi.V1.Data.Tx.RedeemerPtr
instance GHC.Show.Show PlutusLedgerApi.V1.Data.Tx.RedeemerPtr
instance Control.DeepSeq.NFData PlutusLedgerApi.V1.Data.Tx.TxOutRef
instance GHC.Generics.Generic PlutusLedgerApi.V1.Data.Tx.TxOutRef
instance GHC.Classes.Ord PlutusLedgerApi.V1.Data.Tx.TxOutRef
instance GHC.Classes.Eq PlutusLedgerApi.V1.Data.Tx.TxOutRef
instance GHC.Show.Show PlutusLedgerApi.V1.Data.Tx.TxOutRef
instance GHC.Generics.Generic PlutusLedgerApi.V1.Data.Tx.TxOut
instance GHC.Classes.Eq PlutusLedgerApi.V1.Data.Tx.TxOut
instance GHC.Show.Show PlutusLedgerApi.V1.Data.Tx.TxOut
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Data.Tx.TxOut
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Data.Tx.TxOut
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Data.Tx.TxOutRef
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Data.Tx.TxOutRef

module PlutusLedgerApi.V2.Data.Tx

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A tag indicating the type of script that we are pointing to.
--   
--   See also <a>ScriptPurpose</a>
data ScriptTag
Spend :: ScriptTag
Mint :: ScriptTag
Cert :: ScriptTag
Reward :: ScriptTag

-- | A redeemer pointer is a pair of a script type tag (<a>ScriptTag</a>)
--   <tt>t</tt> and an index <tt>i</tt>, picking out the i-th script of
--   type <tt>t</tt> in the transaction.
data RedeemerPtr
RedeemerPtr :: ScriptTag -> Integer -> RedeemerPtr

-- | Redeemers is a <a>Map</a> of redeemer pointer (<a>RedeemerPtr</a>) and
--   its <a>Redeemer</a>.
type Redeemers = Map RedeemerPtr Redeemer

-- | A transaction output, consisting of a target address, a value,
--   optionally a datum/datum hash, and optionally a reference script.
data TxOut
TxOut :: Address -> Value -> OutputDatum -> Maybe ScriptHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatum] :: TxOut -> OutputDatum
[txOutReferenceScript] :: TxOut -> Maybe ScriptHash

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | The datum attached to an output: either nothing; a datum hash; or the
--   datum itself (an "inline datum").
data OutputDatum
NoOutputDatum :: OutputDatum
OutputDatumHash :: DatumHash -> OutputDatum
OutputDatum :: Datum -> OutputDatum

-- | Whether the output is a pay-to-pubkey output.
isPubKeyOut :: TxOut -> Bool

-- | Whether the output is a pay-to-script output.
isPayToScriptOut :: TxOut -> Bool

-- | The address of a transaction output.
outAddress :: Lens' TxOut Address

-- | The value of a transaction output. | TODO: Compute address again
outValue :: Lens' TxOut Value

-- | The public key attached to a <a>TxOut</a>, if there is one.
txOutPubKey :: TxOut -> Maybe PubKeyHash

-- | The datum attached to a <a>TxOut</a>.
outDatum :: Lens' TxOut OutputDatum

-- | The reference script attached to a <a>TxOut</a>.
outReferenceScript :: Lens' TxOut (Maybe ScriptHash)

-- | Create a transaction output locked by a public key.
pubKeyHashTxOut :: Value -> PubKeyHash -> TxOut
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Data.Tx.TxOut
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Data.Tx.TxOut
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V2.Data.Tx.TxOut
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V2.Data.Tx.TxOut
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V2.Data.Tx.TxOut
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Data.Tx.OutputDatum
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Data.Tx.OutputDatum
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V2.Data.Tx.OutputDatum
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V2.Data.Tx.OutputDatum
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V2.Data.Tx.OutputDatum
instance Control.DeepSeq.NFData PlutusLedgerApi.V2.Data.Tx.OutputDatum
instance GHC.Generics.Generic PlutusLedgerApi.V2.Data.Tx.OutputDatum
instance GHC.Classes.Eq PlutusLedgerApi.V2.Data.Tx.OutputDatum
instance GHC.Show.Show PlutusLedgerApi.V2.Data.Tx.OutputDatum
instance GHC.Generics.Generic PlutusLedgerApi.V2.Data.Tx.TxOut
instance GHC.Classes.Eq PlutusLedgerApi.V2.Data.Tx.TxOut
instance GHC.Show.Show PlutusLedgerApi.V2.Data.Tx.TxOut
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V2.Data.Tx.TxOut
instance PlutusTx.Eq.Eq PlutusLedgerApi.V2.Data.Tx.TxOut
instance PlutusTx.Eq.Eq PlutusLedgerApi.V2.Data.Tx.OutputDatum
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V2.Data.Tx.OutputDatum

module PlutusLedgerApi.V1.Data.Contexts

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> [(StakingCredential, Integer)] -> POSIXTimeRange -> [PubKeyHash] -> [(DatumHash, Datum)] -> TxId -> TxInfo

-- | Transaction inputs; cannot be an empty list
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals
[txInfoWdrl] :: TxInfo -> [(StakingCredential, Integer)]

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]

-- | The lookup table of datums attached to the transaction
[txInfoData] :: TxInfo -> [(DatumHash, Datum)]

-- | Hash of the pending transaction body (i.e. transaction excluding
--   witnesses)
[txInfoId] :: TxInfo -> TxId

-- | The context that the currently-executing script can access.
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext

-- | information about the transaction the currently-executing script is
--   included in
[scriptContextTxInfo] :: ScriptContext -> TxInfo

-- | the purpose of the currently-executing script
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A transaction output, consisting of a target address (<a>Address</a>),
--   a value (<a>Value</a>), and optionally a datum hash
--   (<a>DatumHash</a>).
data TxOut
TxOut :: Address -> Value -> Maybe DatumHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatumHash] :: TxOut -> Maybe DatumHash

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | Find the input currently being validated.
findOwnInput :: ScriptContext -> Maybe TxInInfo

-- | Find the data corresponding to a data hash, if there is one
findDatum :: DatumHash -> TxInfo -> Maybe Datum

-- | Find the hash of a datum, if it is part of the pending transaction's
--   hashes
findDatumHash :: Datum -> TxInfo -> Maybe DatumHash

-- | Given a UTXO reference and a transaction (<a>TxInfo</a>), resolve it
--   to one of the transaction's inputs (<a>TxInInfo</a>).
findTxInByTxOutRef :: TxOutRef -> TxInfo -> Maybe TxInInfo

-- | Finds all the outputs that pay to the same script address that we are
--   currently spending from, if any.
findContinuingOutputs :: ScriptContext -> [Integer]

-- | Get all the outputs that pay to the same script address we are
--   currently spending from, if any.
getContinuingOutputs :: ScriptContext -> [TxOut]

-- | Get the values paid to a public key address by a pending transaction.
pubKeyOutputsAt :: PubKeyHash -> TxInfo -> [Value]

-- | Get the total value paid to a public key address by a pending
--   transaction.
valuePaidTo :: TxInfo -> PubKeyHash -> Value

-- | Check if the pending transaction spends a specific transaction output
--   (identified by the hash of a transaction and an index into that
--   transactions' outputs)
spendsOutput :: TxInfo -> TxId -> Integer -> Bool

-- | Check if a transaction was signed by the given public key.
txSignedBy :: TxInfo -> PubKeyHash -> Bool

-- | Get the total value of inputs spent by this transaction.
valueSpent :: TxInfo -> Value

-- | Get the total value of outputs produced by this transaction.
valueProduced :: TxInfo -> Value

-- | The <a>CurrencySymbol</a> of the current validator script.
ownCurrencySymbol :: ScriptContext -> CurrencySymbol
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Data.Contexts.ScriptContext
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Data.Contexts.ScriptContext
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Data.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Contexts.ScriptContext
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Data.Contexts.ScriptPurpose
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Data.Contexts.ScriptPurpose
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Data.Contexts.ScriptPurpose
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Contexts.ScriptPurpose
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Contexts.ScriptPurpose
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Data.Contexts.TxInfo
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Data.Contexts.TxInfo
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Data.Contexts.TxInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Contexts.TxInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Contexts.TxInfo
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V1.Data.Contexts.TxInInfo
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V1.Data.Contexts.TxInInfo
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V1.Data.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V1.Data.Contexts.TxInInfo
instance GHC.Classes.Eq PlutusLedgerApi.V1.Data.Contexts.TxInInfo
instance GHC.Show.Show PlutusLedgerApi.V1.Data.Contexts.TxInInfo
instance GHC.Generics.Generic PlutusLedgerApi.V1.Data.Contexts.TxInInfo
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Data.Contexts.ScriptPurpose
instance GHC.Classes.Eq PlutusLedgerApi.V1.Data.Contexts.ScriptPurpose
instance GHC.Show.Show PlutusLedgerApi.V1.Data.Contexts.ScriptPurpose
instance GHC.Generics.Generic PlutusLedgerApi.V1.Data.Contexts.ScriptPurpose
instance GHC.Classes.Eq PlutusLedgerApi.V1.Data.Contexts.TxInfo
instance GHC.Show.Show PlutusLedgerApi.V1.Data.Contexts.TxInfo
instance GHC.Generics.Generic PlutusLedgerApi.V1.Data.Contexts.TxInfo
instance GHC.Show.Show PlutusLedgerApi.V1.Data.Contexts.ScriptContext
instance GHC.Classes.Eq PlutusLedgerApi.V1.Data.Contexts.ScriptContext
instance GHC.Generics.Generic PlutusLedgerApi.V1.Data.Contexts.ScriptContext
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Data.Contexts.ScriptContext
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Data.Contexts.ScriptContext
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Data.Contexts.TxInfo
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Data.Contexts.TxInfo
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Data.Contexts.ScriptPurpose
instance PlutusTx.Eq.Eq PlutusLedgerApi.V1.Data.Contexts.TxInInfo
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V1.Data.Contexts.TxInInfo

module PlutusLedgerApi.V2.Data.Contexts

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> Map StakingCredential Integer -> POSIXTimeRange -> [PubKeyHash] -> Map ScriptPurpose Redeemer -> Map DatumHash Datum -> TxId -> TxInfo

-- | Transaction inputs; cannot be an empty list
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | <i>Added in V2:</i> Transaction reference inputs
[txInfoReferenceInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals <i>V1-&gt;V2</i>: changed from assoc list to a
--   <a>AssocMap</a>
[txInfoWdrl] :: TxInfo -> Map StakingCredential Integer

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]

-- | <i>Added in V2:</i> a table of redeemers attached to the transaction
[txInfoRedeemers] :: TxInfo -> Map ScriptPurpose Redeemer

-- | The lookup table of datums attached to the transaction
--   <i>V1-&gt;V2</i>: changed from assoc list to a <a>AssocMap</a>
[txInfoData] :: TxInfo -> Map DatumHash Datum

-- | Hash of the pending transaction body (i.e. transaction excluding
--   witnesses)
[txInfoId] :: TxInfo -> TxId

-- | The context that the currently-executing script can access.
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext

-- | information about the transaction the currently-executing script is
--   included in
[scriptContextTxInfo] :: ScriptContext -> TxInfo

-- | the purpose of the currently-executing script
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A transaction output, consisting of a target address, a value,
--   optionally a datum/datum hash, and optionally a reference script.
data TxOut
TxOut :: Address -> Value -> OutputDatum -> Maybe ScriptHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatum] :: TxOut -> OutputDatum
[txOutReferenceScript] :: TxOut -> Maybe ScriptHash

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | Find the input currently being validated.
findOwnInput :: ScriptContext -> Maybe TxInInfo

-- | Find the data corresponding to a data hash, if there is one
findDatum :: DatumHash -> TxInfo -> Maybe Datum

-- | Find the hash of a datum, if it is part of the pending transaction's
--   hashes
findDatumHash :: Datum -> TxInfo -> Maybe DatumHash

-- | Given a UTXO reference and a transaction (<a>TxInfo</a>), resolve it
--   to one of the transaction's inputs (<a>TxInInfo</a>).
--   
--   Note: this only searches the true transaction inputs and not the
--   referenced transaction inputs.
findTxInByTxOutRef :: TxOutRef -> TxInfo -> Maybe TxInInfo

-- | Find the indices of all the outputs that pay to the same script
--   address we are currently spending from, if any.
findContinuingOutputs :: ScriptContext -> [Integer]

-- | Get all the outputs that pay to the same script address we are
--   currently spending from, if any.
getContinuingOutputs :: ScriptContext -> [TxOut]

-- | Get the values paid to a public key address by a pending transaction.
pubKeyOutputsAt :: PubKeyHash -> TxInfo -> [Value]

-- | Get the total value paid to a public key address by a pending
--   transaction.
valuePaidTo :: TxInfo -> PubKeyHash -> Value

-- | Check if the pending transaction spends a specific transaction output
--   (identified by the hash of a transaction and an index into that
--   transactions' outputs)
spendsOutput :: TxInfo -> TxId -> Integer -> Bool

-- | Check if a transaction was signed by the given public key.
txSignedBy :: TxInfo -> PubKeyHash -> Bool

-- | Get the total value of inputs spent by this transaction.
valueSpent :: TxInfo -> Value

-- | Get the total value of outputs produced by this transaction.
valueProduced :: TxInfo -> Value

-- | The <a>CurrencySymbol</a> of the current validator script.
ownCurrencySymbol :: ScriptContext -> CurrencySymbol
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V2.Data.Contexts.ScriptContext
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V2.Data.Contexts.ScriptContext
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V2.Data.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Data.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Data.Contexts.ScriptContext
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V2.Data.Contexts.TxInfo
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V2.Data.Contexts.TxInfo
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V2.Data.Contexts.TxInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Data.Contexts.TxInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Data.Contexts.TxInfo
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V2.Data.Contexts.TxInInfo
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V2.Data.Contexts.TxInInfo
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V2.Data.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Data.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V2.Data.Contexts.TxInInfo
instance GHC.Classes.Eq PlutusLedgerApi.V2.Data.Contexts.TxInInfo
instance GHC.Show.Show PlutusLedgerApi.V2.Data.Contexts.TxInInfo
instance GHC.Generics.Generic PlutusLedgerApi.V2.Data.Contexts.TxInInfo
instance GHC.Show.Show PlutusLedgerApi.V2.Data.Contexts.TxInfo
instance GHC.Generics.Generic PlutusLedgerApi.V2.Data.Contexts.TxInfo
instance GHC.Show.Show PlutusLedgerApi.V2.Data.Contexts.ScriptContext
instance GHC.Generics.Generic PlutusLedgerApi.V2.Data.Contexts.ScriptContext
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V2.Data.Contexts.ScriptContext
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V2.Data.Contexts.TxInfo
instance PlutusTx.Eq.Eq PlutusLedgerApi.V2.Data.Contexts.TxInInfo
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V2.Data.Contexts.TxInInfo


-- | The interface to Plutus V1 for the ledger.
module PlutusLedgerApi.Data.V1

-- | Scripts to the ledger are serialised bytestrings.
type SerialisedScript = ShortByteString

-- | A Plutus script ready to be evaluated on-chain, via
--   <tt>evaluateScriptRestricting</tt>.
data ScriptForEvaluation

-- | Get a <a>SerialisedScript</a> from a <a>ScriptForEvaluation</a>.
--   <i>O(1)</i>.
serialisedScript :: ScriptForEvaluation -> SerialisedScript

-- | Get a <a>ScriptNamedDeBruijn</a> from a <a>ScriptForEvaluation</a>.
--   <i>O(1)</i>.
deserialisedScript :: ScriptForEvaluation -> ScriptNamedDeBruijn

-- | Turns a program which was compiled using the 'PlutusTx' toolchain into
--   a binary format that is understood by the network and can be stored
--   on-chain.
serialiseCompiledCode :: forall a. CompiledCode a -> SerialisedScript

-- | Turns a program's AST (most likely manually constructed) into a binary
--   format that is understood by the network and can be stored on-chain.
serialiseUPLC :: Program DeBruijn DefaultUni DefaultFun () -> SerialisedScript

-- | The deserialization from a serialised script into a
--   <a>ScriptForEvaluation</a>, ready to be evaluated on-chain. Called
--   inside phase-1 validation (i.e., deserialisation error is a phase-1
--   error).
deserialiseScript :: forall m. MonadError ScriptDecodeError m => MajorProtocolVersion -> SerialisedScript -> m ScriptForEvaluation

-- | Deserialises a <a>SerialisedScript</a> back into an AST. Does *not* do
--   ledger-language-version-specific checks like for allowable builtins.
uncheckedDeserialiseUPLC :: SerialisedScript -> Program DeBruijn DefaultUni DefaultFun ()

-- | Evaluates a script, with a cost model and a budget that restricts how
--   many resources it can use according to the cost model. Also returns
--   the budget that was actually used.
--   
--   Can be used to calculate budgets for scripts, but even in this case
--   you must give a limit to guard against scripts that run for a long
--   time or loop.
evaluateScriptRestricting :: MajorProtocolVersion -> VerboseMode -> EvaluationContext -> ExBudget -> ScriptForEvaluation -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | Evaluates a script, returning the minimum budget that the script would
--   need to evaluate successfully. lalaThis will take as long as the
--   script takes, if you need to limit the execution time of the script
--   also, you can use <a>evaluateScriptRestricting</a>, which also returns
--   the used budget.
evaluateScriptCounting :: MajorProtocolVersion -> VerboseMode -> EvaluationContext -> ScriptForEvaluation -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | This represents the major component of the Cardano protocol version.
--   The ledger can only supply the major component of the protocol
--   version, not the minor component, and Plutus should only need to care
--   about the major component anyway. This relies on careful understanding
--   between us and the ledger as to what this means.
newtype MajorProtocolVersion
MajorProtocolVersion :: Int -> MajorProtocolVersion
[getMajorProtocolVersion] :: MajorProtocolVersion -> Int

-- | A simple toggle indicating whether or not we should accumulate logs
--   during script execution.
data VerboseMode

-- | accumulate all traces
Verbose :: VerboseMode

-- | don't accumulate anything
Quiet :: VerboseMode

-- | The type of the executed script's accumulated log output: a list of
--   <a>Text</a>.
--   
--   It will be an empty list if the <a>VerboseMode</a> is set to
--   <a>Quiet</a>.
type LogOutput = [Text]
data () => ExBudget
ExBudget :: ExCPU -> ExMemory -> ExBudget
[exBudgetCPU] :: ExBudget -> ExCPU
[exBudgetMemory] :: ExBudget -> ExMemory
newtype () => ExCPU
ExCPU :: CostingInteger -> ExCPU
newtype () => ExMemory
ExMemory :: CostingInteger -> ExMemory
data () => SatInt
fromSatInt :: Num a => SatInt -> a

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than being recomputed on every
--   evaluation.
--   
--   Different protocol versions may require different bundles of machine
--   parameters, which allows us for example to tweak the shape of the
--   costing function of a builtin, so that the builtin costs less.
--   Currently this means that we have to create multiple
--   <a>DefaultMachineParameters</a> per language version, which we put
--   into a cache (represented by an association list) in order to avoid
--   costly recomputation of machine parameters.
--   
--   In order to get the appropriate <a>DefaultMachineParameters</a> at
--   validation time we look it up in the cache using a semantics variant
--   as a key. We compute the semantics variant from the protocol version
--   using the stored function. Note that the semantics variant depends on
--   the language version too, but the latter is known statically (because
--   each language version has its own evaluation context), hence there's
--   no reason to require it to be provided at runtime.
--   
--   To say it differently, there's a matrix of semantics variants indexed
--   by (LL, PV) pairs and we cache its particular row corresponding to the
--   statically given LL in an <a>EvaluationContext</a>.
--   
--   The reason why we associate a <a>DefaultMachineParameters</a> with a
--   semantics variant rather than a protocol version are
--   
--   <ol>
--   <li>generally there are far more protocol versions than semantics
--   variants supported by a specific language version, so we save on
--   pointless duplication of bundles of machine parameters</li>
--   <li>builtins don't know anything about protocol versions, only
--   semantics variants. It is therefore more semantically precise to
--   associate bundles of machine parameters with semantics variants than
--   with protocol versions</li>
--   </ol>
data EvaluationContext

-- | Build the <a>EvaluationContext</a>.
--   
--   The input is a list of cost model parameters (which are integer
--   values) passed from the ledger.
--   
--   IMPORTANT: the cost model parameters <b>MUST</b> appear in the correct
--   order, matching the names in <a>ParamName</a>. If the parameters are
--   supplied in the wrong order then script cost calculations will be
--   incorrect.
--   
--   IMPORTANT: The evaluation context of every Plutus version must be
--   recreated upon a protocol update with the updated cost model
--   parameters.
mkEvaluationContext :: (MonadError CostModelApplyError m, MonadWriter [CostModelApplyWarn] m) => [Int64] -> m EvaluationContext

-- | The enumeration of all possible cost model parameter names for this
--   language version.
--   
--   IMPORTANT: The order of appearance of the data constructors here
--   matters. DO NOT REORDER. See Note [Quotation marks in cost model
--   parameter constructors] See Note [Cost model parameters from the
--   ledger's point of view]
data ParamName
AddInteger'cpu'arguments'intercept :: ParamName
AddInteger'cpu'arguments'slope :: ParamName
AddInteger'memory'arguments'intercept :: ParamName
AddInteger'memory'arguments'slope :: ParamName
AppendByteString'cpu'arguments'intercept :: ParamName
AppendByteString'cpu'arguments'slope :: ParamName
AppendByteString'memory'arguments'intercept :: ParamName
AppendByteString'memory'arguments'slope :: ParamName
AppendString'cpu'arguments'intercept :: ParamName
AppendString'cpu'arguments'slope :: ParamName
AppendString'memory'arguments'intercept :: ParamName
AppendString'memory'arguments'slope :: ParamName
BData'cpu'arguments :: ParamName
BData'memory'arguments :: ParamName
Blake2b_256'cpu'arguments'intercept :: ParamName
Blake2b_256'cpu'arguments'slope :: ParamName
Blake2b_256'memory'arguments :: ParamName
CekApplyCost'exBudgetCPU :: ParamName
CekApplyCost'exBudgetMemory :: ParamName
CekBuiltinCost'exBudgetCPU :: ParamName
CekBuiltinCost'exBudgetMemory :: ParamName
CekConstCost'exBudgetCPU :: ParamName
CekConstCost'exBudgetMemory :: ParamName
CekDelayCost'exBudgetCPU :: ParamName
CekDelayCost'exBudgetMemory :: ParamName
CekForceCost'exBudgetCPU :: ParamName
CekForceCost'exBudgetMemory :: ParamName
CekLamCost'exBudgetCPU :: ParamName
CekLamCost'exBudgetMemory :: ParamName
CekStartupCost'exBudgetCPU :: ParamName
CekStartupCost'exBudgetMemory :: ParamName
CekVarCost'exBudgetCPU :: ParamName
CekVarCost'exBudgetMemory :: ParamName
ChooseData'cpu'arguments :: ParamName
ChooseData'memory'arguments :: ParamName
ChooseList'cpu'arguments :: ParamName
ChooseList'memory'arguments :: ParamName
ChooseUnit'cpu'arguments :: ParamName
ChooseUnit'memory'arguments :: ParamName
ConsByteString'cpu'arguments'intercept :: ParamName
ConsByteString'cpu'arguments'slope :: ParamName
ConsByteString'memory'arguments'intercept :: ParamName
ConsByteString'memory'arguments'slope :: ParamName
ConstrData'cpu'arguments :: ParamName
ConstrData'memory'arguments :: ParamName
DecodeUtf8'cpu'arguments'intercept :: ParamName
DecodeUtf8'cpu'arguments'slope :: ParamName
DecodeUtf8'memory'arguments'intercept :: ParamName
DecodeUtf8'memory'arguments'slope :: ParamName
DivideInteger'cpu'arguments'constant :: ParamName
DivideInteger'cpu'arguments'model'arguments'intercept :: ParamName
DivideInteger'cpu'arguments'model'arguments'slope :: ParamName
DivideInteger'memory'arguments'intercept :: ParamName
DivideInteger'memory'arguments'minimum :: ParamName
DivideInteger'memory'arguments'slope :: ParamName
EncodeUtf8'cpu'arguments'intercept :: ParamName
EncodeUtf8'cpu'arguments'slope :: ParamName
EncodeUtf8'memory'arguments'intercept :: ParamName
EncodeUtf8'memory'arguments'slope :: ParamName
EqualsByteString'cpu'arguments'constant :: ParamName
EqualsByteString'cpu'arguments'intercept :: ParamName
EqualsByteString'cpu'arguments'slope :: ParamName
EqualsByteString'memory'arguments :: ParamName
EqualsData'cpu'arguments'intercept :: ParamName
EqualsData'cpu'arguments'slope :: ParamName
EqualsData'memory'arguments :: ParamName
EqualsInteger'cpu'arguments'intercept :: ParamName
EqualsInteger'cpu'arguments'slope :: ParamName
EqualsInteger'memory'arguments :: ParamName
EqualsString'cpu'arguments'constant :: ParamName
EqualsString'cpu'arguments'intercept :: ParamName
EqualsString'cpu'arguments'slope :: ParamName
EqualsString'memory'arguments :: ParamName
FstPair'cpu'arguments :: ParamName
FstPair'memory'arguments :: ParamName
HeadList'cpu'arguments :: ParamName
HeadList'memory'arguments :: ParamName
IData'cpu'arguments :: ParamName
IData'memory'arguments :: ParamName
IfThenElse'cpu'arguments :: ParamName
IfThenElse'memory'arguments :: ParamName
IndexByteString'cpu'arguments :: ParamName
IndexByteString'memory'arguments :: ParamName
LengthOfByteString'cpu'arguments :: ParamName
LengthOfByteString'memory'arguments :: ParamName
LessThanByteString'cpu'arguments'intercept :: ParamName
LessThanByteString'cpu'arguments'slope :: ParamName
LessThanByteString'memory'arguments :: ParamName
LessThanEqualsByteString'cpu'arguments'intercept :: ParamName
LessThanEqualsByteString'cpu'arguments'slope :: ParamName
LessThanEqualsByteString'memory'arguments :: ParamName
LessThanEqualsInteger'cpu'arguments'intercept :: ParamName
LessThanEqualsInteger'cpu'arguments'slope :: ParamName
LessThanEqualsInteger'memory'arguments :: ParamName
LessThanInteger'cpu'arguments'intercept :: ParamName
LessThanInteger'cpu'arguments'slope :: ParamName
LessThanInteger'memory'arguments :: ParamName
ListData'cpu'arguments :: ParamName
ListData'memory'arguments :: ParamName
MapData'cpu'arguments :: ParamName
MapData'memory'arguments :: ParamName
MkCons'cpu'arguments :: ParamName
MkCons'memory'arguments :: ParamName
MkNilData'cpu'arguments :: ParamName
MkNilData'memory'arguments :: ParamName
MkNilPairData'cpu'arguments :: ParamName
MkNilPairData'memory'arguments :: ParamName
MkPairData'cpu'arguments :: ParamName
MkPairData'memory'arguments :: ParamName
ModInteger'cpu'arguments'constant :: ParamName
ModInteger'cpu'arguments'model'arguments'intercept :: ParamName
ModInteger'cpu'arguments'model'arguments'slope :: ParamName
ModInteger'memory'arguments'intercept :: ParamName
ModInteger'memory'arguments'minimum :: ParamName
ModInteger'memory'arguments'slope :: ParamName
MultiplyInteger'cpu'arguments'intercept :: ParamName
MultiplyInteger'cpu'arguments'slope :: ParamName
MultiplyInteger'memory'arguments'intercept :: ParamName
MultiplyInteger'memory'arguments'slope :: ParamName
NullList'cpu'arguments :: ParamName
NullList'memory'arguments :: ParamName
QuotientInteger'cpu'arguments'constant :: ParamName
QuotientInteger'cpu'arguments'model'arguments'intercept :: ParamName
QuotientInteger'cpu'arguments'model'arguments'slope :: ParamName
QuotientInteger'memory'arguments'intercept :: ParamName
QuotientInteger'memory'arguments'minimum :: ParamName
QuotientInteger'memory'arguments'slope :: ParamName
RemainderInteger'cpu'arguments'constant :: ParamName
RemainderInteger'cpu'arguments'model'arguments'intercept :: ParamName
RemainderInteger'cpu'arguments'model'arguments'slope :: ParamName
RemainderInteger'memory'arguments'intercept :: ParamName
RemainderInteger'memory'arguments'minimum :: ParamName
RemainderInteger'memory'arguments'slope :: ParamName
Sha2_256'cpu'arguments'intercept :: ParamName
Sha2_256'cpu'arguments'slope :: ParamName
Sha2_256'memory'arguments :: ParamName
Sha3_256'cpu'arguments'intercept :: ParamName
Sha3_256'cpu'arguments'slope :: ParamName
Sha3_256'memory'arguments :: ParamName
SliceByteString'cpu'arguments'intercept :: ParamName
SliceByteString'cpu'arguments'slope :: ParamName
SliceByteString'memory'arguments'intercept :: ParamName
SliceByteString'memory'arguments'slope :: ParamName
SndPair'cpu'arguments :: ParamName
SndPair'memory'arguments :: ParamName
SubtractInteger'cpu'arguments'intercept :: ParamName
SubtractInteger'cpu'arguments'slope :: ParamName
SubtractInteger'memory'arguments'intercept :: ParamName
SubtractInteger'memory'arguments'slope :: ParamName
TailList'cpu'arguments :: ParamName
TailList'memory'arguments :: ParamName
Trace'cpu'arguments :: ParamName
Trace'memory'arguments :: ParamName
UnBData'cpu'arguments :: ParamName
UnBData'memory'arguments :: ParamName
UnConstrData'cpu'arguments :: ParamName
UnConstrData'memory'arguments :: ParamName
UnIData'cpu'arguments :: ParamName
UnIData'memory'arguments :: ParamName
UnListData'cpu'arguments :: ParamName
UnListData'memory'arguments :: ParamName
UnMapData'cpu'arguments :: ParamName
UnMapData'memory'arguments :: ParamName
VerifyEd25519Signature'cpu'arguments'intercept :: ParamName
VerifyEd25519Signature'cpu'arguments'slope :: ParamName
VerifyEd25519Signature'memory'arguments :: ParamName
data () => CostModelApplyError
CMUnknownParamError :: !Text -> CostModelApplyError
CMInternalReadError :: CostModelApplyError
CMInternalWriteError :: !String -> CostModelApplyError
type CostModelParams = Map Text Int64
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()

-- | The context that the currently-executing script can access.
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext

-- | information about the transaction the currently-executing script is
--   included in
[scriptContextTxInfo] :: ScriptContext -> TxInfo

-- | the purpose of the currently-executing script
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose
data () => BuiltinByteString
toBuiltin :: HasToBuiltin a => a -> ToBuiltin a
fromBuiltin :: HasFromBuiltin arep => arep -> FromBuiltin arep
newtype LedgerBytes
LedgerBytes :: BuiltinByteString -> LedgerBytes
[getLedgerBytes] :: LedgerBytes -> BuiltinByteString

-- | Lift a Haskell bytestring to the Plutus abstraction <a>LedgerBytes</a>
fromBytes :: ByteString -> LedgerBytes

-- | A representation of the ledger DCert. Some information is digested,
--   and not included
data DCert
DCertDelegRegKey :: StakingCredential -> DCert
DCertDelegDeRegKey :: StakingCredential -> DCert
DCertDelegDelegate :: StakingCredential -> PubKeyHash -> DCert

-- | A digest of the PoolParams
DCertPoolRegister :: PubKeyHash -> PubKeyHash -> DCert

-- | The retirement certificate and the Epoch in which the retirement will
--   take place
DCertPoolRetire :: PubKeyHash -> Integer -> DCert

-- | A really terse Digest
DCertGenesis :: DCert

-- | Another really terse Digest
DCertMir :: DCert

-- | Staking credential used to assign rewards.
data StakingCredential

-- | The staking hash is the <a>Credential</a> required to unlock a
--   transaction output. Either a public key credential (<a>PubKeyHash</a>)
--   or a script credential (<a>ScriptHash</a>). Both are hashed with
--   <i>BLAKE2b-244</i>. 28 byte.
StakingHash :: Credential -> StakingCredential

-- | The certificate pointer, constructed by the given slot number,
--   transaction and certificate indices. NB: The fields should really be
--   all <tt>Word64</tt>, as they are implemented in <tt>Word64</tt>, but
--   <a>Integer</a> is our only integral type so we need to use it instead.
StakingPtr :: Integer -> Integer -> Integer -> StakingCredential

-- | Credentials required to unlock a transaction output.
data Credential

-- | The transaction that spends this output must be signed by the private
--   key. See <a>PubKeyHash</a>.
PubKeyCredential :: PubKeyHash -> Credential

-- | The transaction that spends this output must include the validator
--   script and be accepted by the validator. See <a>ScriptHash</a>.
ScriptCredential :: ScriptHash -> Credential

-- | The <a>Value</a> type represents a collection of amounts of different
--   currencies. We can think of <a>Value</a> as a vector space whose
--   dimensions are currencies.
--   
--   Operations on currencies are usually implemented <i>pointwise</i>.
--   That is, we apply the operation to the quantities for each currency in
--   turn. So when we add two <a>Value</a>s the resulting <a>Value</a> has,
--   for each currency, the sum of the quantities of <i>that particular</i>
--   currency in the argument <a>Value</a>. The effect of this is that the
--   currencies in the <a>Value</a> are "independent", and are operated on
--   separately.
--   
--   Whenever we need to get the quantity of a currency in a <a>Value</a>
--   where there is no explicit quantity of that currency in the
--   <a>Value</a>, then the quantity is taken to be zero.
--   
--   There is no 'Ord Value' instance since <a>Value</a> is only a partial
--   order, so <a>compare</a> can't do the right thing in some cases.
newtype Value
Value :: Map CurrencySymbol (Map TokenName Integer) -> Value
[getValue] :: Value -> Map CurrencySymbol (Map TokenName Integer)

-- | ByteString representing the currency, hashed with <i>BLAKE2b-224</i>.
--   It is empty for <tt>Ada</tt>, 28 bytes for <tt>MintingPolicyHash</tt>.
--   Forms an <a>AssetClass</a> along with <a>TokenName</a>. A <a>Value</a>
--   is a map from <a>CurrencySymbol</a>'s to a map from <a>TokenName</a>
--   to an <a>Integer</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype CurrencySymbol
CurrencySymbol :: BuiltinByteString -> CurrencySymbol
[unCurrencySymbol] :: CurrencySymbol -> BuiltinByteString

-- | ByteString of a name of a token. Shown as UTF-8 string when possible.
--   Should be no longer than 32 bytes, empty for Ada. Forms an
--   <a>AssetClass</a> along with a <a>CurrencySymbol</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TokenName
TokenName :: BuiltinByteString -> TokenName
[unTokenName] :: TokenName -> BuiltinByteString

-- | Make a <a>Value</a> containing only the given quantity of the given
--   currency.
singleton :: CurrencySymbol -> TokenName -> Integer -> Value

-- | Combine two <a>Value</a> maps with the argument function. Assumes the
--   well-definedness of the two maps.
unionWith :: (Integer -> Integer -> Integer) -> Value -> Value -> Value

-- | The <a>CurrencySymbol</a> of the <tt>Ada</tt> currency.
adaSymbol :: CurrencySymbol

-- | The <a>TokenName</a> of the <tt>Ada</tt> currency.
adaToken :: TokenName
newtype Lovelace
Lovelace :: Integer -> Lovelace
[getLovelace] :: Lovelace -> Integer

-- | POSIX time is measured as the number of <i>milliseconds</i> since
--   1970-01-01T00:00:00Z. This is not the same as Haskell's
--   <a>POSIXTime</a>
newtype POSIXTime
POSIXTime :: Integer -> POSIXTime
[getPOSIXTime] :: POSIXTime -> Integer

-- | An <a>Interval</a> of <a>POSIXTime</a>s.
type POSIXTimeRange = Interval POSIXTime

-- | An address may contain two credentials, the payment credential and
--   optionally a <a>StakingCredential</a>.
data Address
Address :: Credential -> Maybe StakingCredential -> Address

-- | the payment credential
[addressCredential] :: Address -> Credential

-- | the staking credential
[addressStakingCredential] :: Address -> Maybe StakingCredential

-- | The hash of a public key. This is frequently used to identify the
--   public key, rather than the key itself. Hashed with
--   <i>BLAKE2b-224</i>. 28 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype PubKeyHash
PubKeyHash :: BuiltinByteString -> PubKeyHash
[getPubKeyHash] :: PubKeyHash -> BuiltinByteString

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> [(StakingCredential, Integer)] -> POSIXTimeRange -> [PubKeyHash] -> [(DatumHash, Datum)] -> TxId -> TxInfo

-- | Transaction inputs; cannot be an empty list
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals
[txInfoWdrl] :: TxInfo -> [(StakingCredential, Integer)]

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]

-- | The lookup table of datums attached to the transaction
[txInfoData] :: TxInfo -> [(DatumHash, Datum)]

-- | Hash of the pending transaction body (i.e. transaction excluding
--   witnesses)
[txInfoId] :: TxInfo -> TxId

-- | A transaction output, consisting of a target address (<a>Address</a>),
--   a value (<a>Value</a>), and optionally a datum hash
--   (<a>DatumHash</a>).
data TxOut
TxOut :: Address -> Value -> Maybe DatumHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatumHash] :: TxOut -> Maybe DatumHash

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | An interval of <tt>a</tt>s.
--   
--   The interval may be either closed or open at either end, meaning that
--   the endpoints may or may not be included in the interval.
--   
--   The interval can also be unbounded on either side.
--   
--   The <a>Eq</a> instance gives equality of the intervals, not structural
--   equality. There is no <a>Ord</a> instance, but <a>contains</a> gives a
--   partial order.
--   
--   Note that some of the functions on <a>Interval</a> rely on <a>Enum</a>
--   in order to handle non-inclusive endpoints. For this reason, it may
--   not be safe to use <a>Interval</a>s with non-inclusive endpoints on
--   types whose <a>Enum</a> instances have partial methods.
data Interval a
Interval :: LowerBound a -> UpperBound a -> Interval a
[ivFrom] :: Interval a -> LowerBound a
[ivTo] :: Interval a -> UpperBound a

-- | A set extended with a positive and negative infinity.
data Extended a
NegInf :: Extended a
Finite :: a -> Extended a
PosInf :: Extended a

-- | Whether a bound is inclusive or not.
type Closure = Bool

-- | The upper bound of an interval.
data UpperBound a
UpperBound :: Extended a -> Closure -> UpperBound a

-- | The lower bound of an interval.
data LowerBound a
LowerBound :: Extended a -> Closure -> LowerBound a

-- | An <a>Interval</a> that covers every slot. In math. notation [-∞,+∞]
always :: Interval a

-- | <tt>from a</tt> is an <a>Interval</a> that includes all values that
--   are greater than or equal to <tt>a</tt>. In math. notation: [a,+∞]
from :: a -> Interval a

-- | <tt>to a</tt> is an <a>Interval</a> that includes all values that are
--   smaller than or equal to <tt>a</tt>. In math. notation: [-∞,a]
to :: a -> Interval a

-- | Construct a lower bound from a value.
--   
--   The resulting bound includes all values that are equal or greater than
--   the input value.
lowerBound :: a -> LowerBound a

-- | Construct an upper bound from a value.
--   
--   The resulting bound includes all values that are equal or smaller than
--   the input value.
upperBound :: a -> UpperBound a

-- | Construct a strict lower bound from a value.
--   
--   The resulting bound includes all values that are (strictly) greater
--   than the input value.
strictLowerBound :: a -> LowerBound a

-- | Construct a strict upper bound from a value.
--   
--   The resulting bound includes all values that are (strictly) smaller
--   than the input value.
strictUpperBound :: a -> UpperBound a

-- | Type representing the <i>BLAKE2b-224</i> hash of a script. 28 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype ScriptHash
ScriptHash :: BuiltinByteString -> ScriptHash
[getScriptHash] :: ScriptHash -> BuiltinByteString

-- | <a>Redeemer</a> is a wrapper around <tt>Data</tt> values that are used
--   as redeemers in transaction inputs.
newtype Redeemer
Redeemer :: BuiltinData -> Redeemer
[getRedeemer] :: Redeemer -> BuiltinData

-- | Type representing the <i>BLAKE2b-256</i> hash of a redeemer. 32 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype RedeemerHash
RedeemerHash :: BuiltinByteString -> RedeemerHash

-- | <a>Datum</a> is a wrapper around <tt>Data</tt> values which are used
--   as data in transaction outputs.
newtype Datum
Datum :: BuiltinData -> Datum
[getDatum] :: Datum -> BuiltinData

-- | Type representing the <i>BLAKE2b-256</i> hash of a datum. 32 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype DatumHash
DatumHash :: BuiltinByteString -> DatumHash
data () => Data
Constr :: Integer -> [Data] -> Data
Map :: [(Data, Data)] -> Data
List :: [Data] -> Data
I :: Integer -> Data
B :: ByteString -> Data
data () => BuiltinData
BuiltinData :: ~Data -> BuiltinData
class () => ToData a
toBuiltinData :: ToData a => a -> BuiltinData
class () => FromData a
fromBuiltinData :: FromData a => BuiltinData -> Maybe a
class () => UnsafeFromData a
unsafeFromBuiltinData :: UnsafeFromData a => BuiltinData -> a
toData :: ToData a => a -> Data
fromData :: FromData a => Data -> Maybe a
dataToBuiltinData :: Data -> BuiltinData
builtinDataToData :: BuiltinData -> Data

-- | Errors that can be thrown when evaluating a Plutus script.
data EvaluationError

-- | An error from the evaluator itself
CekError :: !CekEvaluationException NamedDeBruijn DefaultUni DefaultFun -> EvaluationError

-- | An error in the pre-evaluation step of converting from de-Bruijn
--   indices
DeBruijnError :: !FreeVariableError -> EvaluationError

-- | A deserialisation error TODO: make this error more informative when we
--   have more information about what went wrong
CodecError :: !ScriptDecodeError -> EvaluationError

-- | An error indicating that the cost model parameters didn't match what
--   we expected
CostModelParameterMismatch :: EvaluationError

-- | The script evaluated to a value that is not a valid return value.
InvalidReturnValue :: EvaluationError

-- | An error that occurred during script deserialization.
data ScriptDecodeError

-- | an error from the underlying CBOR/serialise library
CBORDeserialiseError :: !DeserialiseFailureInfo -> ScriptDecodeError

-- | Script was successfully parsed, but more (runaway) bytes encountered
--   after script's position
RemainderError :: !ByteString -> ScriptDecodeError

-- | the plutus version of the given script is not enabled yet
LedgerLanguageNotAvailableError :: !PlutusLedgerLanguage -> !MajorProtocolVersion -> !MajorProtocolVersion -> ScriptDecodeError

-- | the script's ledger language
[sdeAffectedLang] :: ScriptDecodeError -> !PlutusLedgerLanguage

-- | the major protocol version that will first introduce/enable the ledger
--   language
[sdeIntroPv] :: ScriptDecodeError -> !MajorProtocolVersion

-- | the current protocol version
[sdeThisPv] :: ScriptDecodeError -> !MajorProtocolVersion
PlutusCoreLanguageNotAvailableError :: !Version -> !PlutusLedgerLanguage -> !MajorProtocolVersion -> ScriptDecodeError

-- | the Plutus Core language of the script under execution.
[sdeAffectedVersion] :: ScriptDecodeError -> !Version

-- | the Plutus ledger language of the script under execution.
[sdeThisLang] :: ScriptDecodeError -> !PlutusLedgerLanguage

-- | the current protocol version
[sdeThisPv] :: ScriptDecodeError -> !MajorProtocolVersion


-- | The interface to Plutus V2 for the ledger.
module PlutusLedgerApi.Data.V2

-- | Scripts to the ledger are serialised bytestrings.
type SerialisedScript = ShortByteString

-- | A Plutus script ready to be evaluated on-chain, via
--   <tt>evaluateScriptRestricting</tt>.
data ScriptForEvaluation

-- | Get a <a>SerialisedScript</a> from a <a>ScriptForEvaluation</a>.
--   <i>O(1)</i>.
serialisedScript :: ScriptForEvaluation -> SerialisedScript

-- | Get a <a>ScriptNamedDeBruijn</a> from a <a>ScriptForEvaluation</a>.
--   <i>O(1)</i>.
deserialisedScript :: ScriptForEvaluation -> ScriptNamedDeBruijn

-- | Turns a program which was compiled using the 'PlutusTx' toolchain into
--   a binary format that is understood by the network and can be stored
--   on-chain.
serialiseCompiledCode :: forall a. CompiledCode a -> SerialisedScript

-- | Turns a program's AST (most likely manually constructed) into a binary
--   format that is understood by the network and can be stored on-chain.
serialiseUPLC :: Program DeBruijn DefaultUni DefaultFun () -> SerialisedScript

-- | The deserialization from a serialised script into a
--   <tt>ScriptForEvaluation</tt>, ready to be evaluated on-chain. Called
--   inside phase-1 validation (i.e., deserialisation error is a phase-1
--   error).
deserialiseScript :: forall m. MonadError ScriptDecodeError m => MajorProtocolVersion -> SerialisedScript -> m ScriptForEvaluation

-- | Deserialises a <a>SerialisedScript</a> back into an AST. Does *not* do
--   ledger-language-version-specific checks like for allowable builtins.
uncheckedDeserialiseUPLC :: SerialisedScript -> Program DeBruijn DefaultUni DefaultFun ()

-- | Evaluates a script, with a cost model and a budget that restricts how
--   many resources it can use according to the cost model. Also returns
--   the budget that was actually used.
--   
--   Can be used to calculate budgets for scripts, but even in this case
--   you must give a limit to guard against scripts that run for a long
--   time or loop.
evaluateScriptRestricting :: MajorProtocolVersion -> VerboseMode -> EvaluationContext -> ExBudget -> ScriptForEvaluation -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | Evaluates a script, returning the minimum budget that the script would
--   need to evaluate successfully. This will take as long as the script
--   takes, if you need to limit the execution time of the script also, you
--   can use <a>evaluateScriptRestricting</a>, which also returns the used
--   budget.
evaluateScriptCounting :: MajorProtocolVersion -> VerboseMode -> EvaluationContext -> ScriptForEvaluation -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | This represents the major component of the Cardano protocol version.
--   The ledger can only supply the major component of the protocol
--   version, not the minor component, and Plutus should only need to care
--   about the major component anyway. This relies on careful understanding
--   between us and the ledger as to what this means.
newtype MajorProtocolVersion
MajorProtocolVersion :: Int -> MajorProtocolVersion
[getMajorProtocolVersion] :: MajorProtocolVersion -> Int

-- | A simple toggle indicating whether or not we should accumulate logs
--   during script execution.
data VerboseMode

-- | accumulate all traces
Verbose :: VerboseMode

-- | don't accumulate anything
Quiet :: VerboseMode

-- | The type of the executed script's accumulated log output: a list of
--   <a>Text</a>.
--   
--   It will be an empty list if the <a>VerboseMode</a> is set to
--   <a>Quiet</a>.
type LogOutput = [Text]
data () => ExBudget
ExBudget :: ExCPU -> ExMemory -> ExBudget
[exBudgetCPU] :: ExBudget -> ExCPU
[exBudgetMemory] :: ExBudget -> ExMemory
newtype () => ExCPU
ExCPU :: CostingInteger -> ExCPU
newtype () => ExMemory
ExMemory :: CostingInteger -> ExMemory
data () => SatInt
fromSatInt :: Num a => SatInt -> a

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than being recomputed on every
--   evaluation.
--   
--   Different protocol versions may require different bundles of machine
--   parameters, which allows us for example to tweak the shape of the
--   costing function of a builtin, so that the builtin costs less.
--   Currently this means that we have to create multiple
--   <a>DefaultMachineParameters</a> per language version, which we put
--   into a cache (represented by an association list) in order to avoid
--   costly recomputation of machine parameters.
--   
--   In order to get the appropriate <a>DefaultMachineParameters</a> at
--   validation time we look it up in the cache using a semantics variant
--   as a key. We compute the semantics variant from the protocol version
--   using the stored function. Note that the semantics variant depends on
--   the language version too, but the latter is known statically (because
--   each language version has its own evaluation context), hence there's
--   no reason to require it to be provided at runtime.
--   
--   To say it differently, there's a matrix of semantics variants indexed
--   by (LL, PV) pairs and we cache its particular row corresponding to the
--   statically given LL in an <a>EvaluationContext</a>.
--   
--   The reason why we associate a <a>DefaultMachineParameters</a> with a
--   semantics variant rather than a protocol version are
--   
--   <ol>
--   <li>generally there are far more protocol versions than semantics
--   variants supported by a specific language version, so we save on
--   pointless duplication of bundles of machine parameters</li>
--   <li>builtins don't know anything about protocol versions, only
--   semantics variants. It is therefore more semantically precise to
--   associate bundles of machine parameters with semantics variants than
--   with protocol versions</li>
--   </ol>
data EvaluationContext

-- | Build the <a>EvaluationContext</a>.
--   
--   The input is a list of cost model parameters (which are integer
--   values) passed from the ledger.
--   
--   IMPORTANT: the cost model parameters <b>MUST</b> appear in the correct
--   order, matching the names in <a>ParamName</a>. If the parameters are
--   supplied in the wrong order then script cost calculations will be
--   incorrect.
--   
--   IMPORTANT: The evaluation context of every Plutus version must be
--   recreated upon a protocol update with the updated cost model
--   parameters.
mkEvaluationContext :: (MonadError CostModelApplyError m, MonadWriter [CostModelApplyWarn] m) => [Int64] -> m EvaluationContext

-- | The enumeration of all possible cost model parameter names for this
--   language version.
--   
--   IMPORTANT: The order of appearance of the data constructors here
--   matters. DO NOT REORDER. See Note [Quotation marks in cost model
--   parameter constructors] See Note [Cost model parameters from the
--   ledger's point of view]
data ParamName
AddInteger'cpu'arguments'intercept :: ParamName
AddInteger'cpu'arguments'slope :: ParamName
AddInteger'memory'arguments'intercept :: ParamName
AddInteger'memory'arguments'slope :: ParamName
AppendByteString'cpu'arguments'intercept :: ParamName
AppendByteString'cpu'arguments'slope :: ParamName
AppendByteString'memory'arguments'intercept :: ParamName
AppendByteString'memory'arguments'slope :: ParamName
AppendString'cpu'arguments'intercept :: ParamName
AppendString'cpu'arguments'slope :: ParamName
AppendString'memory'arguments'intercept :: ParamName
AppendString'memory'arguments'slope :: ParamName
BData'cpu'arguments :: ParamName
BData'memory'arguments :: ParamName
Blake2b_256'cpu'arguments'intercept :: ParamName
Blake2b_256'cpu'arguments'slope :: ParamName
Blake2b_256'memory'arguments :: ParamName
CekApplyCost'exBudgetCPU :: ParamName
CekApplyCost'exBudgetMemory :: ParamName
CekBuiltinCost'exBudgetCPU :: ParamName
CekBuiltinCost'exBudgetMemory :: ParamName
CekConstCost'exBudgetCPU :: ParamName
CekConstCost'exBudgetMemory :: ParamName
CekDelayCost'exBudgetCPU :: ParamName
CekDelayCost'exBudgetMemory :: ParamName
CekForceCost'exBudgetCPU :: ParamName
CekForceCost'exBudgetMemory :: ParamName
CekLamCost'exBudgetCPU :: ParamName
CekLamCost'exBudgetMemory :: ParamName
CekStartupCost'exBudgetCPU :: ParamName
CekStartupCost'exBudgetMemory :: ParamName
CekVarCost'exBudgetCPU :: ParamName
CekVarCost'exBudgetMemory :: ParamName
ChooseData'cpu'arguments :: ParamName
ChooseData'memory'arguments :: ParamName
ChooseList'cpu'arguments :: ParamName
ChooseList'memory'arguments :: ParamName
ChooseUnit'cpu'arguments :: ParamName
ChooseUnit'memory'arguments :: ParamName
ConsByteString'cpu'arguments'intercept :: ParamName
ConsByteString'cpu'arguments'slope :: ParamName
ConsByteString'memory'arguments'intercept :: ParamName
ConsByteString'memory'arguments'slope :: ParamName
ConstrData'cpu'arguments :: ParamName
ConstrData'memory'arguments :: ParamName
DecodeUtf8'cpu'arguments'intercept :: ParamName
DecodeUtf8'cpu'arguments'slope :: ParamName
DecodeUtf8'memory'arguments'intercept :: ParamName
DecodeUtf8'memory'arguments'slope :: ParamName
DivideInteger'cpu'arguments'constant :: ParamName
DivideInteger'cpu'arguments'model'arguments'intercept :: ParamName
DivideInteger'cpu'arguments'model'arguments'slope :: ParamName
DivideInteger'memory'arguments'intercept :: ParamName
DivideInteger'memory'arguments'minimum :: ParamName
DivideInteger'memory'arguments'slope :: ParamName
EncodeUtf8'cpu'arguments'intercept :: ParamName
EncodeUtf8'cpu'arguments'slope :: ParamName
EncodeUtf8'memory'arguments'intercept :: ParamName
EncodeUtf8'memory'arguments'slope :: ParamName
EqualsByteString'cpu'arguments'constant :: ParamName
EqualsByteString'cpu'arguments'intercept :: ParamName
EqualsByteString'cpu'arguments'slope :: ParamName
EqualsByteString'memory'arguments :: ParamName
EqualsData'cpu'arguments'intercept :: ParamName
EqualsData'cpu'arguments'slope :: ParamName
EqualsData'memory'arguments :: ParamName
EqualsInteger'cpu'arguments'intercept :: ParamName
EqualsInteger'cpu'arguments'slope :: ParamName
EqualsInteger'memory'arguments :: ParamName
EqualsString'cpu'arguments'constant :: ParamName
EqualsString'cpu'arguments'intercept :: ParamName
EqualsString'cpu'arguments'slope :: ParamName
EqualsString'memory'arguments :: ParamName
FstPair'cpu'arguments :: ParamName
FstPair'memory'arguments :: ParamName
HeadList'cpu'arguments :: ParamName
HeadList'memory'arguments :: ParamName
IData'cpu'arguments :: ParamName
IData'memory'arguments :: ParamName
IfThenElse'cpu'arguments :: ParamName
IfThenElse'memory'arguments :: ParamName
IndexByteString'cpu'arguments :: ParamName
IndexByteString'memory'arguments :: ParamName
LengthOfByteString'cpu'arguments :: ParamName
LengthOfByteString'memory'arguments :: ParamName
LessThanByteString'cpu'arguments'intercept :: ParamName
LessThanByteString'cpu'arguments'slope :: ParamName
LessThanByteString'memory'arguments :: ParamName
LessThanEqualsByteString'cpu'arguments'intercept :: ParamName
LessThanEqualsByteString'cpu'arguments'slope :: ParamName
LessThanEqualsByteString'memory'arguments :: ParamName
LessThanEqualsInteger'cpu'arguments'intercept :: ParamName
LessThanEqualsInteger'cpu'arguments'slope :: ParamName
LessThanEqualsInteger'memory'arguments :: ParamName
LessThanInteger'cpu'arguments'intercept :: ParamName
LessThanInteger'cpu'arguments'slope :: ParamName
LessThanInteger'memory'arguments :: ParamName
ListData'cpu'arguments :: ParamName
ListData'memory'arguments :: ParamName
MapData'cpu'arguments :: ParamName
MapData'memory'arguments :: ParamName
MkCons'cpu'arguments :: ParamName
MkCons'memory'arguments :: ParamName
MkNilData'cpu'arguments :: ParamName
MkNilData'memory'arguments :: ParamName
MkNilPairData'cpu'arguments :: ParamName
MkNilPairData'memory'arguments :: ParamName
MkPairData'cpu'arguments :: ParamName
MkPairData'memory'arguments :: ParamName
ModInteger'cpu'arguments'constant :: ParamName
ModInteger'cpu'arguments'model'arguments'intercept :: ParamName
ModInteger'cpu'arguments'model'arguments'slope :: ParamName
ModInteger'memory'arguments'intercept :: ParamName
ModInteger'memory'arguments'minimum :: ParamName
ModInteger'memory'arguments'slope :: ParamName
MultiplyInteger'cpu'arguments'intercept :: ParamName
MultiplyInteger'cpu'arguments'slope :: ParamName
MultiplyInteger'memory'arguments'intercept :: ParamName
MultiplyInteger'memory'arguments'slope :: ParamName
NullList'cpu'arguments :: ParamName
NullList'memory'arguments :: ParamName
QuotientInteger'cpu'arguments'constant :: ParamName
QuotientInteger'cpu'arguments'model'arguments'intercept :: ParamName
QuotientInteger'cpu'arguments'model'arguments'slope :: ParamName
QuotientInteger'memory'arguments'intercept :: ParamName
QuotientInteger'memory'arguments'minimum :: ParamName
QuotientInteger'memory'arguments'slope :: ParamName
RemainderInteger'cpu'arguments'constant :: ParamName
RemainderInteger'cpu'arguments'model'arguments'intercept :: ParamName
RemainderInteger'cpu'arguments'model'arguments'slope :: ParamName
RemainderInteger'memory'arguments'intercept :: ParamName
RemainderInteger'memory'arguments'minimum :: ParamName
RemainderInteger'memory'arguments'slope :: ParamName
SerialiseData'cpu'arguments'intercept :: ParamName
SerialiseData'cpu'arguments'slope :: ParamName
SerialiseData'memory'arguments'intercept :: ParamName
SerialiseData'memory'arguments'slope :: ParamName
Sha2_256'cpu'arguments'intercept :: ParamName
Sha2_256'cpu'arguments'slope :: ParamName
Sha2_256'memory'arguments :: ParamName
Sha3_256'cpu'arguments'intercept :: ParamName
Sha3_256'cpu'arguments'slope :: ParamName
Sha3_256'memory'arguments :: ParamName
SliceByteString'cpu'arguments'intercept :: ParamName
SliceByteString'cpu'arguments'slope :: ParamName
SliceByteString'memory'arguments'intercept :: ParamName
SliceByteString'memory'arguments'slope :: ParamName
SndPair'cpu'arguments :: ParamName
SndPair'memory'arguments :: ParamName
SubtractInteger'cpu'arguments'intercept :: ParamName
SubtractInteger'cpu'arguments'slope :: ParamName
SubtractInteger'memory'arguments'intercept :: ParamName
SubtractInteger'memory'arguments'slope :: ParamName
TailList'cpu'arguments :: ParamName
TailList'memory'arguments :: ParamName
Trace'cpu'arguments :: ParamName
Trace'memory'arguments :: ParamName
UnBData'cpu'arguments :: ParamName
UnBData'memory'arguments :: ParamName
UnConstrData'cpu'arguments :: ParamName
UnConstrData'memory'arguments :: ParamName
UnIData'cpu'arguments :: ParamName
UnIData'memory'arguments :: ParamName
UnListData'cpu'arguments :: ParamName
UnListData'memory'arguments :: ParamName
UnMapData'cpu'arguments :: ParamName
UnMapData'memory'arguments :: ParamName
VerifyEcdsaSecp256k1Signature'cpu'arguments :: ParamName
VerifyEcdsaSecp256k1Signature'memory'arguments :: ParamName
VerifyEd25519Signature'cpu'arguments'intercept :: ParamName
VerifyEd25519Signature'cpu'arguments'slope :: ParamName
VerifyEd25519Signature'memory'arguments :: ParamName
VerifySchnorrSecp256k1Signature'cpu'arguments'intercept :: ParamName
VerifySchnorrSecp256k1Signature'cpu'arguments'slope :: ParamName
VerifySchnorrSecp256k1Signature'memory'arguments :: ParamName
IntegerToByteString'cpu'arguments'c0 :: ParamName
IntegerToByteString'cpu'arguments'c1 :: ParamName
IntegerToByteString'cpu'arguments'c2 :: ParamName
IntegerToByteString'memory'arguments'intercept :: ParamName
IntegerToByteString'memory'arguments'slope :: ParamName
ByteStringToInteger'cpu'arguments'c0 :: ParamName
ByteStringToInteger'cpu'arguments'c1 :: ParamName
ByteStringToInteger'cpu'arguments'c2 :: ParamName
ByteStringToInteger'memory'arguments'intercept :: ParamName
ByteStringToInteger'memory'arguments'slope :: ParamName
data () => CostModelApplyError
CMUnknownParamError :: !Text -> CostModelApplyError
CMInternalReadError :: CostModelApplyError
CMInternalWriteError :: !String -> CostModelApplyError
type CostModelParams = Map Text Int64
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()

-- | The context that the currently-executing script can access.
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext

-- | information about the transaction the currently-executing script is
--   included in
[scriptContextTxInfo] :: ScriptContext -> TxInfo

-- | the purpose of the currently-executing script
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose
data () => BuiltinByteString
toBuiltin :: HasToBuiltin a => a -> ToBuiltin a
fromBuiltin :: HasFromBuiltin arep => arep -> FromBuiltin arep
toOpaque :: HasToOpaque a arep => a -> arep
fromOpaque :: HasFromOpaque arep a => arep -> a
newtype LedgerBytes
LedgerBytes :: BuiltinByteString -> LedgerBytes
[getLedgerBytes] :: LedgerBytes -> BuiltinByteString

-- | Lift a Haskell bytestring to the Plutus abstraction <a>LedgerBytes</a>
fromBytes :: ByteString -> LedgerBytes

-- | A representation of the ledger DCert. Some information is digested,
--   and not included
data DCert
DCertDelegRegKey :: StakingCredential -> DCert
DCertDelegDeRegKey :: StakingCredential -> DCert
DCertDelegDelegate :: StakingCredential -> PubKeyHash -> DCert

-- | A digest of the PoolParams
DCertPoolRegister :: PubKeyHash -> PubKeyHash -> DCert

-- | The retirement certificate and the Epoch in which the retirement will
--   take place
DCertPoolRetire :: PubKeyHash -> Integer -> DCert

-- | A really terse Digest
DCertGenesis :: DCert

-- | Another really terse Digest
DCertMir :: DCert

-- | Staking credential used to assign rewards.
data StakingCredential

-- | The staking hash is the <a>Credential</a> required to unlock a
--   transaction output. Either a public key credential (<a>PubKeyHash</a>)
--   or a script credential (<a>ScriptHash</a>). Both are hashed with
--   <i>BLAKE2b-244</i>. 28 byte.
StakingHash :: Credential -> StakingCredential

-- | The certificate pointer, constructed by the given slot number,
--   transaction and certificate indices. NB: The fields should really be
--   all <tt>Word64</tt>, as they are implemented in <tt>Word64</tt>, but
--   <a>Integer</a> is our only integral type so we need to use it instead.
StakingPtr :: Integer -> Integer -> Integer -> StakingCredential

-- | Credentials required to unlock a transaction output.
data Credential

-- | The transaction that spends this output must be signed by the private
--   key. See <a>PubKeyHash</a>.
PubKeyCredential :: PubKeyHash -> Credential

-- | The transaction that spends this output must include the validator
--   script and be accepted by the validator. See <a>ScriptHash</a>.
ScriptCredential :: ScriptHash -> Credential

-- | The <a>Value</a> type represents a collection of amounts of different
--   currencies. We can think of <a>Value</a> as a vector space whose
--   dimensions are currencies.
--   
--   Operations on currencies are usually implemented <i>pointwise</i>.
--   That is, we apply the operation to the quantities for each currency in
--   turn. So when we add two <a>Value</a>s the resulting <a>Value</a> has,
--   for each currency, the sum of the quantities of <i>that particular</i>
--   currency in the argument <a>Value</a>. The effect of this is that the
--   currencies in the <a>Value</a> are "independent", and are operated on
--   separately.
--   
--   Whenever we need to get the quantity of a currency in a <a>Value</a>
--   where there is no explicit quantity of that currency in the
--   <a>Value</a>, then the quantity is taken to be zero.
--   
--   There is no 'Ord Value' instance since <a>Value</a> is only a partial
--   order, so <a>compare</a> can't do the right thing in some cases.
newtype Value
Value :: Map CurrencySymbol (Map TokenName Integer) -> Value
[getValue] :: Value -> Map CurrencySymbol (Map TokenName Integer)

-- | ByteString representing the currency, hashed with <i>BLAKE2b-224</i>.
--   It is empty for <tt>Ada</tt>, 28 bytes for <tt>MintingPolicyHash</tt>.
--   Forms an <a>AssetClass</a> along with <a>TokenName</a>. A <a>Value</a>
--   is a map from <a>CurrencySymbol</a>'s to a map from <a>TokenName</a>
--   to an <a>Integer</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype CurrencySymbol
CurrencySymbol :: BuiltinByteString -> CurrencySymbol
[unCurrencySymbol] :: CurrencySymbol -> BuiltinByteString

-- | ByteString of a name of a token. Shown as UTF-8 string when possible.
--   Should be no longer than 32 bytes, empty for Ada. Forms an
--   <a>AssetClass</a> along with a <a>CurrencySymbol</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TokenName
TokenName :: BuiltinByteString -> TokenName
[unTokenName] :: TokenName -> BuiltinByteString

-- | Make a <a>Value</a> containing only the given quantity of the given
--   currency.
singleton :: CurrencySymbol -> TokenName -> Integer -> Value

-- | Combine two <a>Value</a> maps with the argument function. Assumes the
--   well-definedness of the two maps.
unionWith :: (Integer -> Integer -> Integer) -> Value -> Value -> Value

-- | The <a>CurrencySymbol</a> of the <tt>Ada</tt> currency.
adaSymbol :: CurrencySymbol

-- | The <a>TokenName</a> of the <tt>Ada</tt> currency.
adaToken :: TokenName
newtype Lovelace
Lovelace :: Integer -> Lovelace
[getLovelace] :: Lovelace -> Integer

-- | POSIX time is measured as the number of <i>milliseconds</i> since
--   1970-01-01T00:00:00Z. This is not the same as Haskell's
--   <a>POSIXTime</a>
newtype POSIXTime
POSIXTime :: Integer -> POSIXTime
[getPOSIXTime] :: POSIXTime -> Integer

-- | An <a>Interval</a> of <a>POSIXTime</a>s.
type POSIXTimeRange = Interval POSIXTime

-- | An address may contain two credentials, the payment credential and
--   optionally a <a>StakingCredential</a>.
data Address
Address :: Credential -> Maybe StakingCredential -> Address

-- | the payment credential
[addressCredential] :: Address -> Credential

-- | the staking credential
[addressStakingCredential] :: Address -> Maybe StakingCredential

-- | The hash of a public key. This is frequently used to identify the
--   public key, rather than the key itself. Hashed with
--   <i>BLAKE2b-224</i>. 28 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype PubKeyHash
PubKeyHash :: BuiltinByteString -> PubKeyHash
[getPubKeyHash] :: PubKeyHash -> BuiltinByteString

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> Map StakingCredential Integer -> POSIXTimeRange -> [PubKeyHash] -> Map ScriptPurpose Redeemer -> Map DatumHash Datum -> TxId -> TxInfo

-- | Transaction inputs; cannot be an empty list
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | <i>Added in V2:</i> Transaction reference inputs
[txInfoReferenceInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals <i>V1-&gt;V2</i>: changed from assoc list to a
--   <a>AssocMap</a>
[txInfoWdrl] :: TxInfo -> Map StakingCredential Integer

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]

-- | <i>Added in V2:</i> a table of redeemers attached to the transaction
[txInfoRedeemers] :: TxInfo -> Map ScriptPurpose Redeemer

-- | The lookup table of datums attached to the transaction
--   <i>V1-&gt;V2</i>: changed from assoc list to a <a>AssocMap</a>
[txInfoData] :: TxInfo -> Map DatumHash Datum

-- | Hash of the pending transaction body (i.e. transaction excluding
--   witnesses)
[txInfoId] :: TxInfo -> TxId

-- | A transaction output, consisting of a target address, a value,
--   optionally a datum/datum hash, and optionally a reference script.
data TxOut
TxOut :: Address -> Value -> OutputDatum -> Maybe ScriptHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatum] :: TxOut -> OutputDatum
[txOutReferenceScript] :: TxOut -> Maybe ScriptHash

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | The datum attached to an output: either nothing; a datum hash; or the
--   datum itself (an "inline datum").
data OutputDatum
NoOutputDatum :: OutputDatum
OutputDatumHash :: DatumHash -> OutputDatum
OutputDatum :: Datum -> OutputDatum

-- | An interval of <tt>a</tt>s.
--   
--   The interval may be either closed or open at either end, meaning that
--   the endpoints may or may not be included in the interval.
--   
--   The interval can also be unbounded on either side.
--   
--   The <a>Eq</a> instance gives equality of the intervals, not structural
--   equality. There is no <a>Ord</a> instance, but <a>contains</a> gives a
--   partial order.
--   
--   Note that some of the functions on <a>Interval</a> rely on <a>Enum</a>
--   in order to handle non-inclusive endpoints. For this reason, it may
--   not be safe to use <a>Interval</a>s with non-inclusive endpoints on
--   types whose <a>Enum</a> instances have partial methods.
data Interval a
Interval :: LowerBound a -> UpperBound a -> Interval a
[ivFrom] :: Interval a -> LowerBound a
[ivTo] :: Interval a -> UpperBound a

-- | A set extended with a positive and negative infinity.
data Extended a
NegInf :: Extended a
Finite :: a -> Extended a
PosInf :: Extended a

-- | Whether a bound is inclusive or not.
type Closure = Bool

-- | The upper bound of an interval.
data UpperBound a
UpperBound :: Extended a -> Closure -> UpperBound a

-- | The lower bound of an interval.
data LowerBound a
LowerBound :: Extended a -> Closure -> LowerBound a

-- | An <a>Interval</a> that covers every slot. In math. notation [-∞,+∞]
always :: Interval a

-- | <tt>from a</tt> is an <a>Interval</a> that includes all values that
--   are greater than or equal to <tt>a</tt>. In math. notation: [a,+∞]
from :: a -> Interval a

-- | <tt>to a</tt> is an <a>Interval</a> that includes all values that are
--   smaller than or equal to <tt>a</tt>. In math. notation: [-∞,a]
to :: a -> Interval a

-- | Construct a lower bound from a value.
--   
--   The resulting bound includes all values that are equal or greater than
--   the input value.
lowerBound :: a -> LowerBound a

-- | Construct an upper bound from a value.
--   
--   The resulting bound includes all values that are equal or smaller than
--   the input value.
upperBound :: a -> UpperBound a

-- | Construct a strict lower bound from a value.
--   
--   The resulting bound includes all values that are (strictly) greater
--   than the input value.
strictLowerBound :: a -> LowerBound a

-- | Construct a strict upper bound from a value.
--   
--   The resulting bound includes all values that are (strictly) smaller
--   than the input value.
strictUpperBound :: a -> UpperBound a
data () => Map k a
unsafeFromList :: (ToData k, ToData a) => [(k, a)] -> Map k a

-- | Type representing the <i>BLAKE2b-224</i> hash of a script. 28 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype ScriptHash
ScriptHash :: BuiltinByteString -> ScriptHash
[getScriptHash] :: ScriptHash -> BuiltinByteString

-- | <a>Redeemer</a> is a wrapper around <tt>Data</tt> values that are used
--   as redeemers in transaction inputs.
newtype Redeemer
Redeemer :: BuiltinData -> Redeemer
[getRedeemer] :: Redeemer -> BuiltinData

-- | Type representing the <i>BLAKE2b-256</i> hash of a redeemer. 32 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype RedeemerHash
RedeemerHash :: BuiltinByteString -> RedeemerHash

-- | <a>Datum</a> is a wrapper around <tt>Data</tt> values which are used
--   as data in transaction outputs.
newtype Datum
Datum :: BuiltinData -> Datum
[getDatum] :: Datum -> BuiltinData

-- | Type representing the <i>BLAKE2b-256</i> hash of a datum. 32 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype DatumHash
DatumHash :: BuiltinByteString -> DatumHash
data () => Data
Constr :: Integer -> [Data] -> Data
Map :: [(Data, Data)] -> Data
List :: [Data] -> Data
I :: Integer -> Data
B :: ByteString -> Data
data () => BuiltinData
BuiltinData :: ~Data -> BuiltinData
class () => ToData a
toBuiltinData :: ToData a => a -> BuiltinData
class () => FromData a
fromBuiltinData :: FromData a => BuiltinData -> Maybe a
class () => UnsafeFromData a
unsafeFromBuiltinData :: UnsafeFromData a => BuiltinData -> a
toData :: ToData a => a -> Data
fromData :: FromData a => Data -> Maybe a
unsafeFromData :: UnsafeFromData a => Data -> a
dataToBuiltinData :: Data -> BuiltinData
builtinDataToData :: BuiltinData -> Data

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>MonadError</a> class. (If you are using the deprecated
--   <a>Control.Monad.Error</a> or <a>Control.Monad.Trans.Error</a>, you
--   may also have to define an <tt>Error</tt> instance.)
class Monad m => MonadError e (m :: Type -> Type) | m -> e

-- | Errors that can be thrown when evaluating a Plutus script.
data EvaluationError

-- | An error from the evaluator itself
CekError :: !CekEvaluationException NamedDeBruijn DefaultUni DefaultFun -> EvaluationError

-- | An error in the pre-evaluation step of converting from de-Bruijn
--   indices
DeBruijnError :: !FreeVariableError -> EvaluationError

-- | A deserialisation error TODO: make this error more informative when we
--   have more information about what went wrong
CodecError :: !ScriptDecodeError -> EvaluationError

-- | An error indicating that the cost model parameters didn't match what
--   we expected
CostModelParameterMismatch :: EvaluationError

-- | The script evaluated to a value that is not a valid return value.
InvalidReturnValue :: EvaluationError

-- | An error that occurred during script deserialization.
data ScriptDecodeError

-- | an error from the underlying CBOR/serialise library
CBORDeserialiseError :: !DeserialiseFailureInfo -> ScriptDecodeError

-- | Script was successfully parsed, but more (runaway) bytes encountered
--   after script's position
RemainderError :: !ByteString -> ScriptDecodeError

-- | the plutus version of the given script is not enabled yet
LedgerLanguageNotAvailableError :: !PlutusLedgerLanguage -> !MajorProtocolVersion -> !MajorProtocolVersion -> ScriptDecodeError

-- | the script's ledger language
[sdeAffectedLang] :: ScriptDecodeError -> !PlutusLedgerLanguage

-- | the major protocol version that will first introduce/enable the ledger
--   language
[sdeIntroPv] :: ScriptDecodeError -> !MajorProtocolVersion

-- | the current protocol version
[sdeThisPv] :: ScriptDecodeError -> !MajorProtocolVersion
PlutusCoreLanguageNotAvailableError :: !Version -> !PlutusLedgerLanguage -> !MajorProtocolVersion -> ScriptDecodeError

-- | the Plutus Core language of the script under execution.
[sdeAffectedVersion] :: ScriptDecodeError -> !Version

-- | the Plutus ledger language of the script under execution.
[sdeThisLang] :: ScriptDecodeError -> !PlutusLedgerLanguage

-- | the current protocol version
[sdeThisPv] :: ScriptDecodeError -> !MajorProtocolVersion

module PlutusLedgerApi.V3.Data.Contexts
newtype ColdCommitteeCredential
ColdCommitteeCredential :: Credential -> ColdCommitteeCredential
newtype HotCommitteeCredential
HotCommitteeCredential :: Credential -> HotCommitteeCredential
newtype DRepCredential
DRepCredential :: Credential -> DRepCredential
data DRep
DRep :: DRepCredential -> DRep
DRepAlwaysAbstain :: DRep
DRepAlwaysNoConfidence :: DRep
data Delegatee
DelegStake :: PubKeyHash -> Delegatee
DelegVote :: DRep -> Delegatee
DelegStakeVote :: PubKeyHash -> DRep -> Delegatee
data TxCert

-- | Register staking credential with an optional deposit amount
TxCertRegStaking :: Credential -> Maybe Lovelace -> TxCert

-- | Un-Register staking credential with an optional refund amount
TxCertUnRegStaking :: Credential -> Maybe Lovelace -> TxCert

-- | Delegate staking credential to a Delegatee
TxCertDelegStaking :: Credential -> Delegatee -> TxCert

-- | Register and delegate staking credential to a Delegatee in one
--   certificate. Noter that deposit is mandatory.
TxCertRegDeleg :: Credential -> Delegatee -> Lovelace -> TxCert

-- | Register a DRep with a deposit value. The optional anchor is omitted.
TxCertRegDRep :: DRepCredential -> Lovelace -> TxCert

-- | Update a DRep. The optional anchor is omitted.
TxCertUpdateDRep :: DRepCredential -> TxCert

-- | UnRegister a DRep with mandatory refund value
TxCertUnRegDRep :: DRepCredential -> Lovelace -> TxCert

-- | A digest of the PoolParams
TxCertPoolRegister :: PubKeyHash -> PubKeyHash -> TxCert

-- | The retirement certificate and the Epoch in which the retirement will
--   take place
TxCertPoolRetire :: PubKeyHash -> Integer -> TxCert

-- | Authorize a Hot credential for a specific Committee member's cold
--   credential
TxCertAuthHotCommittee :: ColdCommitteeCredential -> HotCommitteeCredential -> TxCert
TxCertResignColdCommittee :: ColdCommitteeCredential -> TxCert
data Voter
CommitteeVoter :: HotCommitteeCredential -> Voter
DRepVoter :: DRepCredential -> Voter
StakePoolVoter :: PubKeyHash -> Voter

-- | A vote. The optional anchor is omitted.
data Vote
VoteNo :: Vote
VoteYes :: Vote
Abstain :: Vote

-- | Similar to TxOutRef, but for GovActions
data GovernanceActionId
GovernanceActionId :: TxId -> Integer -> GovernanceActionId
[gaidTxId] :: GovernanceActionId -> TxId
[gaidGovActionIx] :: GovernanceActionId -> Integer
data Committee
Committee :: Map ColdCommitteeCredential Integer -> Rational -> Committee

-- | Committee members with epoch number when each of them expires
[committeeMembers] :: Committee -> Map ColdCommitteeCredential Integer

-- | Quorum of the committee that is necessary for a successful vote
[committeeQuorum] :: Committee -> Rational

-- | A constitution. The optional anchor is omitted.
newtype Constitution
Constitution :: Maybe ScriptHash -> Constitution
[constitutionScript] :: Constitution -> Maybe ScriptHash
data ProtocolVersion
ProtocolVersion :: Integer -> Integer -> ProtocolVersion
[pvMajor] :: ProtocolVersion -> Integer
[pvMinor] :: ProtocolVersion -> Integer

-- | A Plutus Data object containing proposed parameter changes. The Data
--   object contains a <tt>Map</tt> with one entry per changed parameter,
--   from the parameter ID to the new value. Unchanged parameters are not
--   included.
--   
--   The mapping from parameter IDs to parameters can be found in
--   <a>conway.cddl</a>.
--   
--   <i>Invariant:</i> This map is non-empty, and the keys are stored in
--   ascending order.
newtype ChangedParameters
ChangedParameters :: BuiltinData -> ChangedParameters
[getChangedParameters] :: ChangedParameters -> BuiltinData
data GovernanceAction

-- | Hash of the constitution script
ParameterChange :: Maybe GovernanceActionId -> ChangedParameters -> Maybe ScriptHash -> GovernanceAction

-- | proposal to update protocol version
HardForkInitiation :: Maybe GovernanceActionId -> ProtocolVersion -> GovernanceAction

-- | Hash of the constitution script
TreasuryWithdrawals :: Map Credential Lovelace -> Maybe ScriptHash -> GovernanceAction
NoConfidence :: Maybe GovernanceActionId -> GovernanceAction
UpdateCommittee :: Maybe GovernanceActionId -> [ColdCommitteeCredential] -> Map ColdCommitteeCredential Integer -> Rational -> GovernanceAction
NewConstitution :: Maybe GovernanceActionId -> Constitution -> GovernanceAction
InfoAction :: GovernanceAction

-- | A proposal procedure. The optional anchor is omitted.
data ProposalProcedure
ProposalProcedure :: Lovelace -> Credential -> GovernanceAction -> ProposalProcedure
[ppDeposit] :: ProposalProcedure -> Lovelace
[ppReturnAddr] :: ProposalProcedure -> Credential
[ppGovernanceAction] :: ProposalProcedure -> GovernanceAction

-- | A <a>ScriptPurpose</a> uniquely identifies a Plutus script within a
--   transaction.
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: Credential -> ScriptPurpose
Certifying :: Integer -> TxCert -> ScriptPurpose
Voting :: Voter -> ScriptPurpose
Proposing :: Integer -> ProposalProcedure -> ScriptPurpose

-- | Like <a>ScriptPurpose</a> but with an optional datum for spending
--   scripts.
data ScriptInfo
MintingScript :: CurrencySymbol -> ScriptInfo
SpendingScript :: TxOutRef -> Maybe Datum -> ScriptInfo
RewardingScript :: Credential -> ScriptInfo
CertifyingScript :: Integer -> TxCert -> ScriptInfo
VotingScript :: Voter -> ScriptInfo
ProposingScript :: Integer -> ProposalProcedure -> ScriptInfo

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | TxInfo for PlutusV3
data TxInfo
TxInfo :: [TxInInfo] -> [TxInInfo] -> [TxOut] -> Lovelace -> Value -> [TxCert] -> Map Credential Lovelace -> POSIXTimeRange -> [PubKeyHash] -> Map ScriptPurpose Redeemer -> Map DatumHash Datum -> TxId -> Map Voter (Map GovernanceActionId Vote) -> [ProposalProcedure] -> Maybe Lovelace -> Maybe Lovelace -> TxInfo
[txInfoInputs] :: TxInfo -> [TxInInfo]
[txInfoReferenceInputs] :: TxInfo -> [TxInInfo]
[txInfoOutputs] :: TxInfo -> [TxOut]
[txInfoFee] :: TxInfo -> Lovelace

-- | The <tt>Value</tt> minted by this transaction.
--   
--   <i>Invariant:</i> This field does not contain Ada with zero quantity,
--   unlike their namesakes in Plutus V1 and V2's ScriptContexts.
[txInfoMint] :: TxInfo -> Value
[txInfoTxCerts] :: TxInfo -> [TxCert]
[txInfoWdrl] :: TxInfo -> Map Credential Lovelace
[txInfoValidRange] :: TxInfo -> POSIXTimeRange
[txInfoSignatories] :: TxInfo -> [PubKeyHash]
[txInfoRedeemers] :: TxInfo -> Map ScriptPurpose Redeemer
[txInfoData] :: TxInfo -> Map DatumHash Datum
[txInfoId] :: TxInfo -> TxId
[txInfoVotes] :: TxInfo -> Map Voter (Map GovernanceActionId Vote)
[txInfoProposalProcedures] :: TxInfo -> [ProposalProcedure]
[txInfoCurrentTreasuryAmount] :: TxInfo -> Maybe Lovelace
[txInfoTreasuryDonation] :: TxInfo -> Maybe Lovelace

-- | The context that the currently-executing script can access.
data ScriptContext
ScriptContext :: TxInfo -> Redeemer -> ScriptInfo -> ScriptContext

-- | information about the transaction the currently-executing script is
--   included in
[scriptContextTxInfo] :: ScriptContext -> TxInfo

-- | Redeemer for the currently-executing script
[scriptContextRedeemer] :: ScriptContext -> Redeemer

-- | the purpose of the currently-executing script, along with information
--   associated with the purpose
[scriptContextScriptInfo] :: ScriptContext -> ScriptInfo

-- | Find the input currently being validated.
findOwnInput :: ScriptContext -> Maybe TxInInfo

-- | Find the data corresponding to a data hash, if there is one
findDatum :: DatumHash -> TxInfo -> Maybe Datum

-- | Find the hash of a datum, if it is part of the pending transaction's
--   hashes
findDatumHash :: Datum -> TxInfo -> Maybe DatumHash

-- | Given a UTXO reference and a transaction (<a>TxInfo</a>), resolve it
--   to one of the transaction's inputs (<a>TxInInfo</a>).
--   
--   Note: this only searches the true transaction inputs and not the
--   referenced transaction inputs.
findTxInByTxOutRef :: TxOutRef -> TxInfo -> Maybe TxInInfo

-- | Find the indices of all the outputs that pay to the same script
--   address we are currently spending from, if any.
findContinuingOutputs :: ScriptContext -> [Integer]

-- | Get all the outputs that pay to the same script address we are
--   currently spending from, if any.
getContinuingOutputs :: ScriptContext -> [TxOut]

-- | Check if a transaction was signed by the given public key.
txSignedBy :: TxInfo -> PubKeyHash -> Bool

-- | Get the values paid to a public key address by a pending transaction.
pubKeyOutputsAt :: PubKeyHash -> TxInfo -> [Value]

-- | Get the total value paid to a public key address by a pending
--   transaction.
valuePaidTo :: TxInfo -> PubKeyHash -> Value

-- | Get the total value of inputs spent by this transaction.
valueSpent :: TxInfo -> Value

-- | Get the total value of outputs produced by this transaction.
valueProduced :: TxInfo -> Value

-- | The <tt>CurrencySymbol</tt> of the current validator script.
ownCurrencySymbol :: ScriptContext -> CurrencySymbol

-- | Check if the pending transaction spends a specific transaction output
--   (identified by the hash of a transaction and an index into that
--   transactions' outputs)
spendsOutput :: TxInfo -> TxId -> Integer -> Bool
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Data.Contexts.ScriptContext
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Data.Contexts.ScriptContext
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Data.Contexts.ScriptContext
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Data.Contexts.TxInfo
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Data.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.ScriptContext
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Data.Contexts.ScriptInfo
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Data.Contexts.ScriptInfo
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Data.Contexts.ScriptInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.ScriptInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.ScriptInfo
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Data.Contexts.TxInfo
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Data.Contexts.TxInfo
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Data.Contexts.TxInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.TxInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.TxInfo
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Data.Contexts.TxInInfo
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Data.Contexts.TxInInfo
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Data.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.TxInInfo
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Data.Contexts.ScriptPurpose
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Data.Contexts.ScriptPurpose
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Data.Contexts.ScriptPurpose
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.ScriptPurpose
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.ScriptPurpose
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Data.Contexts.ProposalProcedure
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Data.Contexts.ProposalProcedure
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Data.Contexts.ProposalProcedure
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.ProposalProcedure
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.ProposalProcedure
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Data.Contexts.GovernanceAction
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Data.Contexts.GovernanceAction
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Data.Contexts.GovernanceAction
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.GovernanceAction
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.GovernanceAction
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.ChangedParameters
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.ChangedParameters
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Data.Contexts.ProtocolVersion
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Data.Contexts.ProtocolVersion
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Data.Contexts.ProtocolVersion
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.ProtocolVersion
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.ProtocolVersion
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Data.Contexts.Constitution
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Data.Contexts.Constitution
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Data.Contexts.Constitution
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.Constitution
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.Constitution
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Data.Contexts.Committee
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Data.Contexts.Committee
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Data.Contexts.Committee
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.Committee
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.Committee
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Data.Contexts.GovernanceActionId
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Data.Contexts.GovernanceActionId
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Data.Contexts.GovernanceActionId
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.GovernanceActionId
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.GovernanceActionId
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Data.Contexts.Vote
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Data.Contexts.Vote
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Data.Contexts.Vote
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.Vote
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.Vote
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Data.Contexts.Voter
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Data.Contexts.Voter
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Data.Contexts.Voter
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.Voter
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.Voter
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Data.Contexts.TxCert
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Data.Contexts.TxCert
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Data.Contexts.TxCert
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.TxCert
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.TxCert
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Data.Contexts.Delegatee
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Data.Contexts.Delegatee
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Data.Contexts.Delegatee
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.Delegatee
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.Delegatee
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Data.Contexts.DRep
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Data.Contexts.DRep
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Data.Contexts.DRep
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.DRep
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.DRep
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.DRepCredential
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.DRepCredential
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.HotCommitteeCredential
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.HotCommitteeCredential
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.ColdCommitteeCredential
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusLedgerApi.V3.Data.Contexts.ColdCommitteeCredential
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Data.Contexts.ColdCommitteeCredential
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Data.Contexts.ColdCommitteeCredential
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Data.Contexts.ColdCommitteeCredential
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Data.Contexts.ColdCommitteeCredential
instance GHC.Show.Show PlutusLedgerApi.V3.Data.Contexts.ColdCommitteeCredential
instance GHC.Classes.Eq PlutusLedgerApi.V3.Data.Contexts.ColdCommitteeCredential
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Data.Contexts.ColdCommitteeCredential
instance GHC.Generics.Generic PlutusLedgerApi.V3.Data.Contexts.ColdCommitteeCredential
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Data.Contexts.HotCommitteeCredential
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Data.Contexts.HotCommitteeCredential
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Data.Contexts.HotCommitteeCredential
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Data.Contexts.HotCommitteeCredential
instance GHC.Show.Show PlutusLedgerApi.V3.Data.Contexts.HotCommitteeCredential
instance GHC.Classes.Eq PlutusLedgerApi.V3.Data.Contexts.HotCommitteeCredential
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Data.Contexts.HotCommitteeCredential
instance GHC.Generics.Generic PlutusLedgerApi.V3.Data.Contexts.HotCommitteeCredential
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Data.Contexts.DRepCredential
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Data.Contexts.DRepCredential
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Data.Contexts.DRepCredential
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Data.Contexts.DRepCredential
instance GHC.Show.Show PlutusLedgerApi.V3.Data.Contexts.DRepCredential
instance GHC.Classes.Eq PlutusLedgerApi.V3.Data.Contexts.DRepCredential
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Data.Contexts.DRepCredential
instance GHC.Generics.Generic PlutusLedgerApi.V3.Data.Contexts.DRepCredential
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Data.Contexts.DRep
instance GHC.Classes.Eq PlutusLedgerApi.V3.Data.Contexts.DRep
instance GHC.Show.Show PlutusLedgerApi.V3.Data.Contexts.DRep
instance GHC.Generics.Generic PlutusLedgerApi.V3.Data.Contexts.DRep
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Data.Contexts.Delegatee
instance GHC.Classes.Eq PlutusLedgerApi.V3.Data.Contexts.Delegatee
instance GHC.Show.Show PlutusLedgerApi.V3.Data.Contexts.Delegatee
instance GHC.Generics.Generic PlutusLedgerApi.V3.Data.Contexts.Delegatee
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Data.Contexts.TxCert
instance GHC.Classes.Eq PlutusLedgerApi.V3.Data.Contexts.TxCert
instance GHC.Show.Show PlutusLedgerApi.V3.Data.Contexts.TxCert
instance GHC.Generics.Generic PlutusLedgerApi.V3.Data.Contexts.TxCert
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Data.Contexts.Voter
instance GHC.Classes.Eq PlutusLedgerApi.V3.Data.Contexts.Voter
instance GHC.Show.Show PlutusLedgerApi.V3.Data.Contexts.Voter
instance GHC.Generics.Generic PlutusLedgerApi.V3.Data.Contexts.Voter
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Data.Contexts.Vote
instance GHC.Classes.Eq PlutusLedgerApi.V3.Data.Contexts.Vote
instance GHC.Show.Show PlutusLedgerApi.V3.Data.Contexts.Vote
instance GHC.Generics.Generic PlutusLedgerApi.V3.Data.Contexts.Vote
instance GHC.Classes.Eq PlutusLedgerApi.V3.Data.Contexts.GovernanceActionId
instance GHC.Show.Show PlutusLedgerApi.V3.Data.Contexts.GovernanceActionId
instance GHC.Generics.Generic PlutusLedgerApi.V3.Data.Contexts.GovernanceActionId
instance GHC.Show.Show PlutusLedgerApi.V3.Data.Contexts.Committee
instance GHC.Generics.Generic PlutusLedgerApi.V3.Data.Contexts.Committee
instance GHC.Classes.Eq PlutusLedgerApi.V3.Data.Contexts.Constitution
instance GHC.Show.Show PlutusLedgerApi.V3.Data.Contexts.Constitution
instance GHC.Generics.Generic PlutusLedgerApi.V3.Data.Contexts.Constitution
instance GHC.Classes.Eq PlutusLedgerApi.V3.Data.Contexts.ProtocolVersion
instance GHC.Show.Show PlutusLedgerApi.V3.Data.Contexts.ProtocolVersion
instance GHC.Generics.Generic PlutusLedgerApi.V3.Data.Contexts.ProtocolVersion
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Data.Contexts.ChangedParameters
instance PlutusTx.IsData.Class.UnsafeFromData PlutusLedgerApi.V3.Data.Contexts.ChangedParameters
instance PlutusTx.IsData.Class.FromData PlutusLedgerApi.V3.Data.Contexts.ChangedParameters
instance PlutusTx.IsData.Class.ToData PlutusLedgerApi.V3.Data.Contexts.ChangedParameters
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Data.Contexts.ChangedParameters
instance GHC.Classes.Ord PlutusLedgerApi.V3.Data.Contexts.ChangedParameters
instance GHC.Classes.Eq PlutusLedgerApi.V3.Data.Contexts.ChangedParameters
instance GHC.Show.Show PlutusLedgerApi.V3.Data.Contexts.ChangedParameters
instance GHC.Generics.Generic PlutusLedgerApi.V3.Data.Contexts.ChangedParameters
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Data.Contexts.GovernanceAction
instance GHC.Show.Show PlutusLedgerApi.V3.Data.Contexts.GovernanceAction
instance GHC.Generics.Generic PlutusLedgerApi.V3.Data.Contexts.GovernanceAction
instance GHC.Show.Show PlutusLedgerApi.V3.Data.Contexts.ProposalProcedure
instance GHC.Generics.Generic PlutusLedgerApi.V3.Data.Contexts.ProposalProcedure
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Data.Contexts.ScriptPurpose
instance GHC.Show.Show PlutusLedgerApi.V3.Data.Contexts.ScriptPurpose
instance GHC.Generics.Generic PlutusLedgerApi.V3.Data.Contexts.ScriptPurpose
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Data.Contexts.ScriptInfo
instance GHC.Show.Show PlutusLedgerApi.V3.Data.Contexts.ScriptInfo
instance GHC.Generics.Generic PlutusLedgerApi.V3.Data.Contexts.ScriptInfo
instance GHC.Classes.Eq PlutusLedgerApi.V3.Data.Contexts.TxInInfo
instance GHC.Show.Show PlutusLedgerApi.V3.Data.Contexts.TxInInfo
instance GHC.Generics.Generic PlutusLedgerApi.V3.Data.Contexts.TxInInfo
instance GHC.Show.Show PlutusLedgerApi.V3.Data.Contexts.TxInfo
instance GHC.Generics.Generic PlutusLedgerApi.V3.Data.Contexts.TxInfo
instance GHC.Show.Show PlutusLedgerApi.V3.Data.Contexts.ScriptContext
instance GHC.Generics.Generic PlutusLedgerApi.V3.Data.Contexts.ScriptContext
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Data.Contexts.TxInInfo
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Data.Contexts.TxInInfo
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Data.Contexts.ProposalProcedure
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Data.Contexts.ProtocolVersion
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Data.Contexts.ProtocolVersion
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Data.Contexts.Constitution
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Data.Contexts.Constitution
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Data.Contexts.Committee
instance Prettyprinter.Internal.Pretty PlutusLedgerApi.V3.Data.Contexts.GovernanceActionId
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Data.Contexts.GovernanceActionId
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Data.Contexts.Vote
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Data.Contexts.Voter
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Data.Contexts.TxCert
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Data.Contexts.Delegatee
instance PlutusTx.Eq.Eq PlutusLedgerApi.V3.Data.Contexts.DRep


-- | The interface to Plutus V3 for the ledger.
module PlutusLedgerApi.Data.V3

-- | Scripts to the ledger are serialised bytestrings.
type SerialisedScript = ShortByteString

-- | A Plutus script ready to be evaluated on-chain, via
--   <tt>evaluateScriptRestricting</tt>.
data ScriptForEvaluation

-- | Get a <a>SerialisedScript</a> from a <a>ScriptForEvaluation</a>.
--   <i>O(1)</i>.
serialisedScript :: ScriptForEvaluation -> SerialisedScript

-- | Get a <a>ScriptNamedDeBruijn</a> from a <a>ScriptForEvaluation</a>.
--   <i>O(1)</i>.
deserialisedScript :: ScriptForEvaluation -> ScriptNamedDeBruijn

-- | Turns a program which was compiled using the 'PlutusTx' toolchain into
--   a binary format that is understood by the network and can be stored
--   on-chain.
serialiseCompiledCode :: forall a. CompiledCode a -> SerialisedScript

-- | Turns a program's AST (most likely manually constructed) into a binary
--   format that is understood by the network and can be stored on-chain.
serialiseUPLC :: Program DeBruijn DefaultUni DefaultFun () -> SerialisedScript

-- | The deserialization from a serialised script into a
--   <tt>ScriptForEvaluation</tt>, ready to be evaluated on-chain. Called
--   inside phase-1 validation (i.e., deserialisation error is a phase-1
--   error).
deserialiseScript :: forall m. MonadError ScriptDecodeError m => MajorProtocolVersion -> SerialisedScript -> m ScriptForEvaluation

-- | Deserialises a <a>SerialisedScript</a> back into an AST. Does *not* do
--   ledger-language-version-specific checks like for allowable builtins.
uncheckedDeserialiseUPLC :: SerialisedScript -> Program DeBruijn DefaultUni DefaultFun ()

-- | Evaluates a script, with a cost model and a budget that restricts how
--   many resources it can use according to the cost model. Also returns
--   the budget that was actually used.
--   
--   Can be used to calculate budgets for scripts, but even in this case
--   you must give a limit to guard against scripts that run for a long
--   time or loop.
evaluateScriptRestricting :: MajorProtocolVersion -> VerboseMode -> EvaluationContext -> ExBudget -> ScriptForEvaluation -> Data -> (LogOutput, Either EvaluationError ExBudget)

-- | Evaluates a script, returning the minimum budget that the script would
--   need to evaluate successfully. This will take as long as the script
--   takes, if you need to limit the execution time of the script also, you
--   can use <a>evaluateScriptRestricting</a>, which also returns the used
--   budget.
evaluateScriptCounting :: MajorProtocolVersion -> VerboseMode -> EvaluationContext -> ScriptForEvaluation -> Data -> (LogOutput, Either EvaluationError ExBudget)
newtype ColdCommitteeCredential
ColdCommitteeCredential :: Credential -> ColdCommitteeCredential
newtype HotCommitteeCredential
HotCommitteeCredential :: Credential -> HotCommitteeCredential
newtype DRepCredential
DRepCredential :: Credential -> DRepCredential
data DRep
DRep :: DRepCredential -> DRep
DRepAlwaysAbstain :: DRep
DRepAlwaysNoConfidence :: DRep
data Delegatee
DelegStake :: PubKeyHash -> Delegatee
DelegVote :: DRep -> Delegatee
DelegStakeVote :: PubKeyHash -> DRep -> Delegatee
data TxCert

-- | Register staking credential with an optional deposit amount
TxCertRegStaking :: Credential -> Maybe Lovelace -> TxCert

-- | Un-Register staking credential with an optional refund amount
TxCertUnRegStaking :: Credential -> Maybe Lovelace -> TxCert

-- | Delegate staking credential to a Delegatee
TxCertDelegStaking :: Credential -> Delegatee -> TxCert

-- | Register and delegate staking credential to a Delegatee in one
--   certificate. Noter that deposit is mandatory.
TxCertRegDeleg :: Credential -> Delegatee -> Lovelace -> TxCert

-- | Register a DRep with a deposit value. The optional anchor is omitted.
TxCertRegDRep :: DRepCredential -> Lovelace -> TxCert

-- | Update a DRep. The optional anchor is omitted.
TxCertUpdateDRep :: DRepCredential -> TxCert

-- | UnRegister a DRep with mandatory refund value
TxCertUnRegDRep :: DRepCredential -> Lovelace -> TxCert

-- | A digest of the PoolParams
TxCertPoolRegister :: PubKeyHash -> PubKeyHash -> TxCert

-- | The retirement certificate and the Epoch in which the retirement will
--   take place
TxCertPoolRetire :: PubKeyHash -> Integer -> TxCert

-- | Authorize a Hot credential for a specific Committee member's cold
--   credential
TxCertAuthHotCommittee :: ColdCommitteeCredential -> HotCommitteeCredential -> TxCert
TxCertResignColdCommittee :: ColdCommitteeCredential -> TxCert
data Voter
CommitteeVoter :: HotCommitteeCredential -> Voter
DRepVoter :: DRepCredential -> Voter
StakePoolVoter :: PubKeyHash -> Voter

-- | A vote. The optional anchor is omitted.
data Vote
VoteNo :: Vote
VoteYes :: Vote
Abstain :: Vote

-- | Similar to TxOutRef, but for GovActions
data GovernanceActionId
GovernanceActionId :: TxId -> Integer -> GovernanceActionId
[gaidTxId] :: GovernanceActionId -> TxId
[gaidGovActionIx] :: GovernanceActionId -> Integer
data Committee
Committee :: Map ColdCommitteeCredential Integer -> Rational -> Committee

-- | Committee members with epoch number when each of them expires
[committeeMembers] :: Committee -> Map ColdCommitteeCredential Integer

-- | Quorum of the committee that is necessary for a successful vote
[committeeQuorum] :: Committee -> Rational

-- | A constitution. The optional anchor is omitted.
newtype Constitution
Constitution :: Maybe ScriptHash -> Constitution
[constitutionScript] :: Constitution -> Maybe ScriptHash
data ProtocolVersion
ProtocolVersion :: Integer -> Integer -> ProtocolVersion
[pvMajor] :: ProtocolVersion -> Integer
[pvMinor] :: ProtocolVersion -> Integer
data GovernanceAction

-- | Hash of the constitution script
ParameterChange :: Maybe GovernanceActionId -> ChangedParameters -> Maybe ScriptHash -> GovernanceAction

-- | proposal to update protocol version
HardForkInitiation :: Maybe GovernanceActionId -> ProtocolVersion -> GovernanceAction

-- | Hash of the constitution script
TreasuryWithdrawals :: Map Credential Lovelace -> Maybe ScriptHash -> GovernanceAction
NoConfidence :: Maybe GovernanceActionId -> GovernanceAction
UpdateCommittee :: Maybe GovernanceActionId -> [ColdCommitteeCredential] -> Map ColdCommitteeCredential Integer -> Rational -> GovernanceAction
NewConstitution :: Maybe GovernanceActionId -> Constitution -> GovernanceAction
InfoAction :: GovernanceAction

-- | A Plutus Data object containing proposed parameter changes. The Data
--   object contains a <tt>Map</tt> with one entry per changed parameter,
--   from the parameter ID to the new value. Unchanged parameters are not
--   included.
--   
--   The mapping from parameter IDs to parameters can be found in
--   <a>conway.cddl</a>.
--   
--   <i>Invariant:</i> This map is non-empty, and the keys are stored in
--   ascending order.
newtype ChangedParameters
ChangedParameters :: BuiltinData -> ChangedParameters
[getChangedParameters] :: ChangedParameters -> BuiltinData

-- | A proposal procedure. The optional anchor is omitted.
data ProposalProcedure
ProposalProcedure :: Lovelace -> Credential -> GovernanceAction -> ProposalProcedure
[ppDeposit] :: ProposalProcedure -> Lovelace
[ppReturnAddr] :: ProposalProcedure -> Credential
[ppGovernanceAction] :: ProposalProcedure -> GovernanceAction

-- | This represents the major component of the Cardano protocol version.
--   The ledger can only supply the major component of the protocol
--   version, not the minor component, and Plutus should only need to care
--   about the major component anyway. This relies on careful understanding
--   between us and the ledger as to what this means.
newtype MajorProtocolVersion
MajorProtocolVersion :: Int -> MajorProtocolVersion
[getMajorProtocolVersion] :: MajorProtocolVersion -> Int

-- | A simple toggle indicating whether or not we should accumulate logs
--   during script execution.
data VerboseMode

-- | accumulate all traces
Verbose :: VerboseMode

-- | don't accumulate anything
Quiet :: VerboseMode

-- | The type of the executed script's accumulated log output: a list of
--   <a>Text</a>.
--   
--   It will be an empty list if the <a>VerboseMode</a> is set to
--   <a>Quiet</a>.
type LogOutput = [Text]
data () => ExBudget
ExBudget :: ExCPU -> ExMemory -> ExBudget
[exBudgetCPU] :: ExBudget -> ExCPU
[exBudgetMemory] :: ExBudget -> ExMemory
newtype () => ExCPU
ExCPU :: CostingInteger -> ExCPU
newtype () => ExMemory
ExMemory :: CostingInteger -> ExMemory
data () => SatInt
fromSatInt :: Num a => SatInt -> a

-- | An opaque type that contains all the static parameters that the
--   evaluator needs to evaluate a script. This is so that they can be
--   computed once and cached, rather than being recomputed on every
--   evaluation.
--   
--   Different protocol versions may require different bundles of machine
--   parameters, which allows us for example to tweak the shape of the
--   costing function of a builtin, so that the builtin costs less.
--   Currently this means that we have to create multiple
--   <a>DefaultMachineParameters</a> per language version, which we put
--   into a cache (represented by an association list) in order to avoid
--   costly recomputation of machine parameters.
--   
--   In order to get the appropriate <a>DefaultMachineParameters</a> at
--   validation time we look it up in the cache using a semantics variant
--   as a key. We compute the semantics variant from the protocol version
--   using the stored function. Note that the semantics variant depends on
--   the language version too, but the latter is known statically (because
--   each language version has its own evaluation context), hence there's
--   no reason to require it to be provided at runtime.
--   
--   To say it differently, there's a matrix of semantics variants indexed
--   by (LL, PV) pairs and we cache its particular row corresponding to the
--   statically given LL in an <a>EvaluationContext</a>.
--   
--   The reason why we associate a <a>DefaultMachineParameters</a> with a
--   semantics variant rather than a protocol version are
--   
--   <ol>
--   <li>generally there are far more protocol versions than semantics
--   variants supported by a specific language version, so we save on
--   pointless duplication of bundles of machine parameters</li>
--   <li>builtins don't know anything about protocol versions, only
--   semantics variants. It is therefore more semantically precise to
--   associate bundles of machine parameters with semantics variants than
--   with protocol versions</li>
--   </ol>
data EvaluationContext

-- | Build the <a>EvaluationContext</a>.
--   
--   The input is a list of cost model parameters (which are integer
--   values) passed from the ledger.
--   
--   IMPORTANT: the cost model parameters <b>MUST</b> appear in the correct
--   order, matching the names in <a>ParamName</a>. If the parameters are
--   supplied in the wrong order then script cost calculations will be
--   incorrect.
--   
--   IMPORTANT: The evaluation context of every Plutus version must be
--   recreated upon a protocol update with the updated cost model
--   parameters.
mkEvaluationContext :: (MonadError CostModelApplyError m, MonadWriter [CostModelApplyWarn] m) => [Int64] -> m EvaluationContext

-- | The enumeration of all possible cost model parameter names for this
--   language version.
--   
--   IMPORTANT: The order of appearance of the data constructors here
--   matters. DO NOT REORDER. See Note [Quotation marks in cost model
--   parameter constructors] See Note [Cost model parameters from the
--   ledger's point of view]
data ParamName
AddInteger'cpu'arguments'intercept :: ParamName
AddInteger'cpu'arguments'slope :: ParamName
AddInteger'memory'arguments'intercept :: ParamName
AddInteger'memory'arguments'slope :: ParamName
AppendByteString'cpu'arguments'intercept :: ParamName
AppendByteString'cpu'arguments'slope :: ParamName
AppendByteString'memory'arguments'intercept :: ParamName
AppendByteString'memory'arguments'slope :: ParamName
AppendString'cpu'arguments'intercept :: ParamName
AppendString'cpu'arguments'slope :: ParamName
AppendString'memory'arguments'intercept :: ParamName
AppendString'memory'arguments'slope :: ParamName
BData'cpu'arguments :: ParamName
BData'memory'arguments :: ParamName
Blake2b_256'cpu'arguments'intercept :: ParamName
Blake2b_256'cpu'arguments'slope :: ParamName
Blake2b_256'memory'arguments :: ParamName
CekApplyCost'exBudgetCPU :: ParamName
CekApplyCost'exBudgetMemory :: ParamName
CekBuiltinCost'exBudgetCPU :: ParamName
CekBuiltinCost'exBudgetMemory :: ParamName
CekConstCost'exBudgetCPU :: ParamName
CekConstCost'exBudgetMemory :: ParamName
CekDelayCost'exBudgetCPU :: ParamName
CekDelayCost'exBudgetMemory :: ParamName
CekForceCost'exBudgetCPU :: ParamName
CekForceCost'exBudgetMemory :: ParamName
CekLamCost'exBudgetCPU :: ParamName
CekLamCost'exBudgetMemory :: ParamName
CekStartupCost'exBudgetCPU :: ParamName
CekStartupCost'exBudgetMemory :: ParamName
CekVarCost'exBudgetCPU :: ParamName
CekVarCost'exBudgetMemory :: ParamName
ChooseData'cpu'arguments :: ParamName
ChooseData'memory'arguments :: ParamName
ChooseList'cpu'arguments :: ParamName
ChooseList'memory'arguments :: ParamName
ChooseUnit'cpu'arguments :: ParamName
ChooseUnit'memory'arguments :: ParamName
ConsByteString'cpu'arguments'intercept :: ParamName
ConsByteString'cpu'arguments'slope :: ParamName
ConsByteString'memory'arguments'intercept :: ParamName
ConsByteString'memory'arguments'slope :: ParamName
ConstrData'cpu'arguments :: ParamName
ConstrData'memory'arguments :: ParamName
DecodeUtf8'cpu'arguments'intercept :: ParamName
DecodeUtf8'cpu'arguments'slope :: ParamName
DecodeUtf8'memory'arguments'intercept :: ParamName
DecodeUtf8'memory'arguments'slope :: ParamName
DivideInteger'cpu'arguments'constant :: ParamName
DivideInteger'cpu'arguments'model'arguments'c00 :: ParamName
DivideInteger'cpu'arguments'model'arguments'c01 :: ParamName
DivideInteger'cpu'arguments'model'arguments'c02 :: ParamName
DivideInteger'cpu'arguments'model'arguments'c10 :: ParamName
DivideInteger'cpu'arguments'model'arguments'c11 :: ParamName
DivideInteger'cpu'arguments'model'arguments'c20 :: ParamName
DivideInteger'cpu'arguments'model'arguments'minimum :: ParamName
DivideInteger'memory'arguments'intercept :: ParamName
DivideInteger'memory'arguments'minimum :: ParamName
DivideInteger'memory'arguments'slope :: ParamName
EncodeUtf8'cpu'arguments'intercept :: ParamName
EncodeUtf8'cpu'arguments'slope :: ParamName
EncodeUtf8'memory'arguments'intercept :: ParamName
EncodeUtf8'memory'arguments'slope :: ParamName
EqualsByteString'cpu'arguments'constant :: ParamName
EqualsByteString'cpu'arguments'intercept :: ParamName
EqualsByteString'cpu'arguments'slope :: ParamName
EqualsByteString'memory'arguments :: ParamName
EqualsData'cpu'arguments'intercept :: ParamName
EqualsData'cpu'arguments'slope :: ParamName
EqualsData'memory'arguments :: ParamName
EqualsInteger'cpu'arguments'intercept :: ParamName
EqualsInteger'cpu'arguments'slope :: ParamName
EqualsInteger'memory'arguments :: ParamName
EqualsString'cpu'arguments'constant :: ParamName
EqualsString'cpu'arguments'intercept :: ParamName
EqualsString'cpu'arguments'slope :: ParamName
EqualsString'memory'arguments :: ParamName
FstPair'cpu'arguments :: ParamName
FstPair'memory'arguments :: ParamName
HeadList'cpu'arguments :: ParamName
HeadList'memory'arguments :: ParamName
IData'cpu'arguments :: ParamName
IData'memory'arguments :: ParamName
IfThenElse'cpu'arguments :: ParamName
IfThenElse'memory'arguments :: ParamName
IndexByteString'cpu'arguments :: ParamName
IndexByteString'memory'arguments :: ParamName
LengthOfByteString'cpu'arguments :: ParamName
LengthOfByteString'memory'arguments :: ParamName
LessThanByteString'cpu'arguments'intercept :: ParamName
LessThanByteString'cpu'arguments'slope :: ParamName
LessThanByteString'memory'arguments :: ParamName
LessThanEqualsByteString'cpu'arguments'intercept :: ParamName
LessThanEqualsByteString'cpu'arguments'slope :: ParamName
LessThanEqualsByteString'memory'arguments :: ParamName
LessThanEqualsInteger'cpu'arguments'intercept :: ParamName
LessThanEqualsInteger'cpu'arguments'slope :: ParamName
LessThanEqualsInteger'memory'arguments :: ParamName
LessThanInteger'cpu'arguments'intercept :: ParamName
LessThanInteger'cpu'arguments'slope :: ParamName
LessThanInteger'memory'arguments :: ParamName
ListData'cpu'arguments :: ParamName
ListData'memory'arguments :: ParamName
MapData'cpu'arguments :: ParamName
MapData'memory'arguments :: ParamName
MkCons'cpu'arguments :: ParamName
MkCons'memory'arguments :: ParamName
MkNilData'cpu'arguments :: ParamName
MkNilData'memory'arguments :: ParamName
MkNilPairData'cpu'arguments :: ParamName
MkNilPairData'memory'arguments :: ParamName
MkPairData'cpu'arguments :: ParamName
MkPairData'memory'arguments :: ParamName
ModInteger'cpu'arguments'constant :: ParamName
ModInteger'cpu'arguments'model'arguments'c00 :: ParamName
ModInteger'cpu'arguments'model'arguments'c01 :: ParamName
ModInteger'cpu'arguments'model'arguments'c02 :: ParamName
ModInteger'cpu'arguments'model'arguments'c10 :: ParamName
ModInteger'cpu'arguments'model'arguments'c11 :: ParamName
ModInteger'cpu'arguments'model'arguments'c20 :: ParamName
ModInteger'cpu'arguments'model'arguments'minimum :: ParamName
ModInteger'memory'arguments'intercept :: ParamName
ModInteger'memory'arguments'slope :: ParamName
MultiplyInteger'cpu'arguments'intercept :: ParamName
MultiplyInteger'cpu'arguments'slope :: ParamName
MultiplyInteger'memory'arguments'intercept :: ParamName
MultiplyInteger'memory'arguments'slope :: ParamName
NullList'cpu'arguments :: ParamName
NullList'memory'arguments :: ParamName
QuotientInteger'cpu'arguments'constant :: ParamName
QuotientInteger'cpu'arguments'model'arguments'c00 :: ParamName
QuotientInteger'cpu'arguments'model'arguments'c01 :: ParamName
QuotientInteger'cpu'arguments'model'arguments'c02 :: ParamName
QuotientInteger'cpu'arguments'model'arguments'c10 :: ParamName
QuotientInteger'cpu'arguments'model'arguments'c11 :: ParamName
QuotientInteger'cpu'arguments'model'arguments'c20 :: ParamName
QuotientInteger'cpu'arguments'model'arguments'minimum :: ParamName
QuotientInteger'memory'arguments'intercept :: ParamName
QuotientInteger'memory'arguments'minimum :: ParamName
QuotientInteger'memory'arguments'slope :: ParamName
RemainderInteger'cpu'arguments'constant :: ParamName
RemainderInteger'cpu'arguments'model'arguments'c00 :: ParamName
RemainderInteger'cpu'arguments'model'arguments'c01 :: ParamName
RemainderInteger'cpu'arguments'model'arguments'c02 :: ParamName
RemainderInteger'cpu'arguments'model'arguments'c10 :: ParamName
RemainderInteger'cpu'arguments'model'arguments'c11 :: ParamName
RemainderInteger'cpu'arguments'model'arguments'c20 :: ParamName
RemainderInteger'cpu'arguments'model'arguments'minimum :: ParamName
RemainderInteger'memory'arguments'intercept :: ParamName
RemainderInteger'memory'arguments'slope :: ParamName
SerialiseData'cpu'arguments'intercept :: ParamName
SerialiseData'cpu'arguments'slope :: ParamName
SerialiseData'memory'arguments'intercept :: ParamName
SerialiseData'memory'arguments'slope :: ParamName
Sha2_256'cpu'arguments'intercept :: ParamName
Sha2_256'cpu'arguments'slope :: ParamName
Sha2_256'memory'arguments :: ParamName
Sha3_256'cpu'arguments'intercept :: ParamName
Sha3_256'cpu'arguments'slope :: ParamName
Sha3_256'memory'arguments :: ParamName
SliceByteString'cpu'arguments'intercept :: ParamName
SliceByteString'cpu'arguments'slope :: ParamName
SliceByteString'memory'arguments'intercept :: ParamName
SliceByteString'memory'arguments'slope :: ParamName
SndPair'cpu'arguments :: ParamName
SndPair'memory'arguments :: ParamName
SubtractInteger'cpu'arguments'intercept :: ParamName
SubtractInteger'cpu'arguments'slope :: ParamName
SubtractInteger'memory'arguments'intercept :: ParamName
SubtractInteger'memory'arguments'slope :: ParamName
TailList'cpu'arguments :: ParamName
TailList'memory'arguments :: ParamName
Trace'cpu'arguments :: ParamName
Trace'memory'arguments :: ParamName
UnBData'cpu'arguments :: ParamName
UnBData'memory'arguments :: ParamName
UnConstrData'cpu'arguments :: ParamName
UnConstrData'memory'arguments :: ParamName
UnIData'cpu'arguments :: ParamName
UnIData'memory'arguments :: ParamName
UnListData'cpu'arguments :: ParamName
UnListData'memory'arguments :: ParamName
UnMapData'cpu'arguments :: ParamName
UnMapData'memory'arguments :: ParamName
VerifyEcdsaSecp256k1Signature'cpu'arguments :: ParamName
VerifyEcdsaSecp256k1Signature'memory'arguments :: ParamName
VerifyEd25519Signature'cpu'arguments'intercept :: ParamName
VerifyEd25519Signature'cpu'arguments'slope :: ParamName
VerifyEd25519Signature'memory'arguments :: ParamName
VerifySchnorrSecp256k1Signature'cpu'arguments'intercept :: ParamName
VerifySchnorrSecp256k1Signature'cpu'arguments'slope :: ParamName
VerifySchnorrSecp256k1Signature'memory'arguments :: ParamName
CekConstrCost'exBudgetCPU :: ParamName
CekConstrCost'exBudgetMemory :: ParamName
CekCaseCost'exBudgetCPU :: ParamName
CekCaseCost'exBudgetMemory :: ParamName
Bls12_381_G1_add'cpu'arguments :: ParamName
Bls12_381_G1_add'memory'arguments :: ParamName
Bls12_381_G1_compress'cpu'arguments :: ParamName
Bls12_381_G1_compress'memory'arguments :: ParamName
Bls12_381_G1_equal'cpu'arguments :: ParamName
Bls12_381_G1_equal'memory'arguments :: ParamName
Bls12_381_G1_hashToGroup'cpu'arguments'intercept :: ParamName
Bls12_381_G1_hashToGroup'cpu'arguments'slope :: ParamName
Bls12_381_G1_hashToGroup'memory'arguments :: ParamName
Bls12_381_G1_neg'cpu'arguments :: ParamName
Bls12_381_G1_neg'memory'arguments :: ParamName
Bls12_381_G1_scalarMul'cpu'arguments'intercept :: ParamName
Bls12_381_G1_scalarMul'cpu'arguments'slope :: ParamName
Bls12_381_G1_scalarMul'memory'arguments :: ParamName
Bls12_381_G1_uncompress'cpu'arguments :: ParamName
Bls12_381_G1_uncompress'memory'arguments :: ParamName
Bls12_381_G2_add'cpu'arguments :: ParamName
Bls12_381_G2_add'memory'arguments :: ParamName
Bls12_381_G2_compress'cpu'arguments :: ParamName
Bls12_381_G2_compress'memory'arguments :: ParamName
Bls12_381_G2_equal'cpu'arguments :: ParamName
Bls12_381_G2_equal'memory'arguments :: ParamName
Bls12_381_G2_hashToGroup'cpu'arguments'intercept :: ParamName
Bls12_381_G2_hashToGroup'cpu'arguments'slope :: ParamName
Bls12_381_G2_hashToGroup'memory'arguments :: ParamName
Bls12_381_G2_neg'cpu'arguments :: ParamName
Bls12_381_G2_neg'memory'arguments :: ParamName
Bls12_381_G2_scalarMul'cpu'arguments'intercept :: ParamName
Bls12_381_G2_scalarMul'cpu'arguments'slope :: ParamName
Bls12_381_G2_scalarMul'memory'arguments :: ParamName
Bls12_381_G2_uncompress'cpu'arguments :: ParamName
Bls12_381_G2_uncompress'memory'arguments :: ParamName
Bls12_381_finalVerify'cpu'arguments :: ParamName
Bls12_381_finalVerify'memory'arguments :: ParamName
Bls12_381_millerLoop'cpu'arguments :: ParamName
Bls12_381_millerLoop'memory'arguments :: ParamName
Bls12_381_mulMlResult'cpu'arguments :: ParamName
Bls12_381_mulMlResult'memory'arguments :: ParamName
Keccak_256'cpu'arguments'intercept :: ParamName
Keccak_256'cpu'arguments'slope :: ParamName
Keccak_256'memory'arguments :: ParamName
Blake2b_224'cpu'arguments'intercept :: ParamName
Blake2b_224'cpu'arguments'slope :: ParamName
Blake2b_224'memory'arguments :: ParamName
IntegerToByteString'cpu'arguments'c0 :: ParamName
IntegerToByteString'cpu'arguments'c1 :: ParamName
IntegerToByteString'cpu'arguments'c2 :: ParamName
IntegerToByteString'memory'arguments'intercept :: ParamName
IntegerToByteString'memory'arguments'slope :: ParamName
ByteStringToInteger'cpu'arguments'c0 :: ParamName
ByteStringToInteger'cpu'arguments'c1 :: ParamName
ByteStringToInteger'cpu'arguments'c2 :: ParamName
ByteStringToInteger'memory'arguments'intercept :: ParamName
ByteStringToInteger'memory'arguments'slope :: ParamName
AndByteString'cpu'arguments'intercept :: ParamName
AndByteString'cpu'arguments'slope1 :: ParamName
AndByteString'cpu'arguments'slope2 :: ParamName
AndByteString'memory'arguments'intercept :: ParamName
AndByteString'memory'arguments'slope :: ParamName
OrByteString'cpu'arguments'intercept :: ParamName
OrByteString'cpu'arguments'slope1 :: ParamName
OrByteString'cpu'arguments'slope2 :: ParamName
OrByteString'memory'arguments'intercept :: ParamName
OrByteString'memory'arguments'slope :: ParamName
XorByteString'cpu'arguments'intercept :: ParamName
XorByteString'cpu'arguments'slope1 :: ParamName
XorByteString'cpu'arguments'slope2 :: ParamName
XorByteString'memory'arguments'intercept :: ParamName
XorByteString'memory'arguments'slope :: ParamName
ComplementByteString'cpu'arguments'intercept :: ParamName
ComplementByteString'cpu'arguments'slope :: ParamName
ComplementByteString'memory'arguments'intercept :: ParamName
ComplementByteString'memory'arguments'slope :: ParamName
ReadBit'cpu'arguments :: ParamName
ReadBit'memory'arguments :: ParamName
WriteBits'cpu'arguments'intercept :: ParamName
WriteBits'cpu'arguments'slope :: ParamName
WriteBits'memory'arguments'intercept :: ParamName
WriteBits'memory'arguments'slope :: ParamName
ReplicateByte'cpu'arguments'intercept :: ParamName
ReplicateByte'cpu'arguments'slope :: ParamName
ReplicateByte'memory'arguments'intercept :: ParamName
ReplicateByte'memory'arguments'slope :: ParamName
ShiftByteString'cpu'arguments'intercept :: ParamName
ShiftByteString'cpu'arguments'slope :: ParamName
ShiftByteString'memory'arguments'intercept :: ParamName
ShiftByteString'memory'arguments'slope :: ParamName
RotateByteString'cpu'arguments'intercept :: ParamName
RotateByteString'cpu'arguments'slope :: ParamName
RotateByteString'memory'arguments'intercept :: ParamName
RotateByteString'memory'arguments'slope :: ParamName
CountSetBits'cpu'arguments'intercept :: ParamName
CountSetBits'cpu'arguments'slope :: ParamName
CountSetBits'memory'arguments :: ParamName
FindFirstSetBit'cpu'arguments'intercept :: ParamName
FindFirstSetBit'cpu'arguments'slope :: ParamName
FindFirstSetBit'memory'arguments :: ParamName
Ripemd_160'cpu'arguments'intercept :: ParamName
Ripemd_160'cpu'arguments'slope :: ParamName
Ripemd_160'memory'arguments :: ParamName
data () => CostModelApplyError
CMUnknownParamError :: !Text -> CostModelApplyError
CMInternalReadError :: CostModelApplyError
CMInternalWriteError :: !String -> CostModelApplyError
type CostModelParams = Map Text Int64
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()

-- | The context that the currently-executing script can access.
data ScriptContext
ScriptContext :: TxInfo -> Redeemer -> ScriptInfo -> ScriptContext

-- | information about the transaction the currently-executing script is
--   included in
[scriptContextTxInfo] :: ScriptContext -> TxInfo

-- | Redeemer for the currently-executing script
[scriptContextRedeemer] :: ScriptContext -> Redeemer

-- | the purpose of the currently-executing script, along with information
--   associated with the purpose
[scriptContextScriptInfo] :: ScriptContext -> ScriptInfo

-- | A <a>ScriptPurpose</a> uniquely identifies a Plutus script within a
--   transaction.
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: Credential -> ScriptPurpose
Certifying :: Integer -> TxCert -> ScriptPurpose
Voting :: Voter -> ScriptPurpose
Proposing :: Integer -> ProposalProcedure -> ScriptPurpose

-- | Like <a>ScriptPurpose</a> but with an optional datum for spending
--   scripts.
data ScriptInfo
MintingScript :: CurrencySymbol -> ScriptInfo
SpendingScript :: TxOutRef -> Maybe Datum -> ScriptInfo
RewardingScript :: Credential -> ScriptInfo
CertifyingScript :: Integer -> TxCert -> ScriptInfo
VotingScript :: Voter -> ScriptInfo
ProposingScript :: Integer -> ProposalProcedure -> ScriptInfo
data () => BuiltinByteString
toBuiltin :: HasToBuiltin a => a -> ToBuiltin a
fromBuiltin :: HasFromBuiltin arep => arep -> FromBuiltin arep
toOpaque :: HasToOpaque a arep => a -> arep
fromOpaque :: HasFromOpaque arep a => arep -> a
newtype LedgerBytes
LedgerBytes :: BuiltinByteString -> LedgerBytes
[getLedgerBytes] :: LedgerBytes -> BuiltinByteString

-- | Lift a Haskell bytestring to the Plutus abstraction <a>LedgerBytes</a>
fromBytes :: ByteString -> LedgerBytes

-- | Staking credential used to assign rewards.
data StakingCredential

-- | The staking hash is the <a>Credential</a> required to unlock a
--   transaction output. Either a public key credential (<a>PubKeyHash</a>)
--   or a script credential (<a>ScriptHash</a>). Both are hashed with
--   <i>BLAKE2b-244</i>. 28 byte.
StakingHash :: Credential -> StakingCredential

-- | The certificate pointer, constructed by the given slot number,
--   transaction and certificate indices. NB: The fields should really be
--   all <tt>Word64</tt>, as they are implemented in <tt>Word64</tt>, but
--   <a>Integer</a> is our only integral type so we need to use it instead.
StakingPtr :: Integer -> Integer -> Integer -> StakingCredential

-- | Credentials required to unlock a transaction output.
data Credential

-- | The transaction that spends this output must be signed by the private
--   key. See <a>PubKeyHash</a>.
PubKeyCredential :: PubKeyHash -> Credential

-- | The transaction that spends this output must include the validator
--   script and be accepted by the validator. See <a>ScriptHash</a>.
ScriptCredential :: ScriptHash -> Credential

-- | The <a>Value</a> type represents a collection of amounts of different
--   currencies. We can think of <a>Value</a> as a vector space whose
--   dimensions are currencies.
--   
--   Operations on currencies are usually implemented <i>pointwise</i>.
--   That is, we apply the operation to the quantities for each currency in
--   turn. So when we add two <a>Value</a>s the resulting <a>Value</a> has,
--   for each currency, the sum of the quantities of <i>that particular</i>
--   currency in the argument <a>Value</a>. The effect of this is that the
--   currencies in the <a>Value</a> are "independent", and are operated on
--   separately.
--   
--   Whenever we need to get the quantity of a currency in a <a>Value</a>
--   where there is no explicit quantity of that currency in the
--   <a>Value</a>, then the quantity is taken to be zero.
--   
--   There is no 'Ord Value' instance since <a>Value</a> is only a partial
--   order, so <a>compare</a> can't do the right thing in some cases.
newtype Value
Value :: Map CurrencySymbol (Map TokenName Integer) -> Value
[getValue] :: Value -> Map CurrencySymbol (Map TokenName Integer)

-- | ByteString representing the currency, hashed with <i>BLAKE2b-224</i>.
--   It is empty for <tt>Ada</tt>, 28 bytes for <tt>MintingPolicyHash</tt>.
--   Forms an <a>AssetClass</a> along with <a>TokenName</a>. A <a>Value</a>
--   is a map from <a>CurrencySymbol</a>'s to a map from <a>TokenName</a>
--   to an <a>Integer</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype CurrencySymbol
CurrencySymbol :: BuiltinByteString -> CurrencySymbol
[unCurrencySymbol] :: CurrencySymbol -> BuiltinByteString

-- | ByteString of a name of a token. Shown as UTF-8 string when possible.
--   Should be no longer than 32 bytes, empty for Ada. Forms an
--   <a>AssetClass</a> along with a <a>CurrencySymbol</a>.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype TokenName
TokenName :: BuiltinByteString -> TokenName
[unTokenName] :: TokenName -> BuiltinByteString

-- | Make a <a>Value</a> containing only the given quantity of the given
--   currency.
singleton :: CurrencySymbol -> TokenName -> Integer -> Value

-- | Combine two <a>Value</a> maps with the argument function. Assumes the
--   well-definedness of the two maps.
unionWith :: (Integer -> Integer -> Integer) -> Value -> Value -> Value

-- | The <a>CurrencySymbol</a> of the <tt>Ada</tt> currency.
adaSymbol :: CurrencySymbol

-- | The <a>TokenName</a> of the <tt>Ada</tt> currency.
adaToken :: TokenName
newtype Lovelace
Lovelace :: Integer -> Lovelace
[getLovelace] :: Lovelace -> Integer

-- | POSIX time is measured as the number of <i>milliseconds</i> since
--   1970-01-01T00:00:00Z. This is not the same as Haskell's
--   <a>POSIXTime</a>
newtype POSIXTime
POSIXTime :: Integer -> POSIXTime
[getPOSIXTime] :: POSIXTime -> Integer

-- | An <a>Interval</a> of <a>POSIXTime</a>s.
type POSIXTimeRange = Interval POSIXTime

-- | An address may contain two credentials, the payment credential and
--   optionally a <a>StakingCredential</a>.
data Address
Address :: Credential -> Maybe StakingCredential -> Address

-- | the payment credential
[addressCredential] :: Address -> Credential

-- | the staking credential
[addressStakingCredential] :: Address -> Maybe StakingCredential

-- | The hash of a public key. This is frequently used to identify the
--   public key, rather than the key itself. Hashed with
--   <i>BLAKE2b-224</i>. 28 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype PubKeyHash
PubKeyHash :: BuiltinByteString -> PubKeyHash
[getPubKeyHash] :: PubKeyHash -> BuiltinByteString

-- | A transaction ID, i.e. the hash of a transaction. Hashed with
--   BLAKE2b-256. 32 byte.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the Shelley ledger
--   specification.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | TxInfo for PlutusV3
data TxInfo
TxInfo :: [TxInInfo] -> [TxInInfo] -> [TxOut] -> Lovelace -> Value -> [TxCert] -> Map Credential Lovelace -> POSIXTimeRange -> [PubKeyHash] -> Map ScriptPurpose Redeemer -> Map DatumHash Datum -> TxId -> Map Voter (Map GovernanceActionId Vote) -> [ProposalProcedure] -> Maybe Lovelace -> Maybe Lovelace -> TxInfo
[txInfoInputs] :: TxInfo -> [TxInInfo]
[txInfoReferenceInputs] :: TxInfo -> [TxInInfo]
[txInfoOutputs] :: TxInfo -> [TxOut]
[txInfoFee] :: TxInfo -> Lovelace

-- | The <tt>Value</tt> minted by this transaction.
--   
--   <i>Invariant:</i> This field does not contain Ada with zero quantity,
--   unlike their namesakes in Plutus V1 and V2's ScriptContexts.
[txInfoMint] :: TxInfo -> Value
[txInfoTxCerts] :: TxInfo -> [TxCert]
[txInfoWdrl] :: TxInfo -> Map Credential Lovelace
[txInfoValidRange] :: TxInfo -> POSIXTimeRange
[txInfoSignatories] :: TxInfo -> [PubKeyHash]
[txInfoRedeemers] :: TxInfo -> Map ScriptPurpose Redeemer
[txInfoData] :: TxInfo -> Map DatumHash Datum
[txInfoId] :: TxInfo -> TxId
[txInfoVotes] :: TxInfo -> Map Voter (Map GovernanceActionId Vote)
[txInfoProposalProcedures] :: TxInfo -> [ProposalProcedure]
[txInfoCurrentTreasuryAmount] :: TxInfo -> Maybe Lovelace
[txInfoTreasuryDonation] :: TxInfo -> Maybe Lovelace

-- | A transaction output, consisting of a target address, a value,
--   optionally a datum/datum hash, and optionally a reference script.
data TxOut
TxOut :: Address -> Value -> OutputDatum -> Maybe ScriptHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatum] :: TxOut -> OutputDatum
[txOutReferenceScript] :: TxOut -> Maybe ScriptHash

-- | A reference to a transaction output. This is a pair of a transaction
--   ID (<a>TxId</a>), and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef

-- | The transaction ID.
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | The datum attached to an output: either nothing; a datum hash; or the
--   datum itself (an "inline datum").
data OutputDatum
NoOutputDatum :: OutputDatum
OutputDatumHash :: DatumHash -> OutputDatum
OutputDatum :: Datum -> OutputDatum

-- | An interval of <tt>a</tt>s.
--   
--   The interval may be either closed or open at either end, meaning that
--   the endpoints may or may not be included in the interval.
--   
--   The interval can also be unbounded on either side.
--   
--   The <a>Eq</a> instance gives equality of the intervals, not structural
--   equality. There is no <a>Ord</a> instance, but <a>contains</a> gives a
--   partial order.
--   
--   Note that some of the functions on <a>Interval</a> rely on <a>Enum</a>
--   in order to handle non-inclusive endpoints. For this reason, it may
--   not be safe to use <a>Interval</a>s with non-inclusive endpoints on
--   types whose <a>Enum</a> instances have partial methods.
data Interval a
Interval :: LowerBound a -> UpperBound a -> Interval a
[ivFrom] :: Interval a -> LowerBound a
[ivTo] :: Interval a -> UpperBound a

-- | A set extended with a positive and negative infinity.
data Extended a
NegInf :: Extended a
Finite :: a -> Extended a
PosInf :: Extended a

-- | Whether a bound is inclusive or not.
type Closure = Bool

-- | The upper bound of an interval.
data UpperBound a
UpperBound :: Extended a -> Closure -> UpperBound a

-- | The lower bound of an interval.
data LowerBound a
LowerBound :: Extended a -> Closure -> LowerBound a

-- | An <a>Interval</a> that covers every slot. In math. notation [-∞,+∞]
always :: Interval a

-- | <tt>from a</tt> is an <a>Interval</a> that includes all values that
--   are greater than or equal to <tt>a</tt>. In math. notation: [a,+∞]
from :: a -> Interval a

-- | <tt>to a</tt> is an <a>Interval</a> that includes all values that are
--   smaller than or equal to <tt>a</tt>. In math. notation: [-∞,a]
to :: a -> Interval a

-- | Construct a lower bound from a value.
--   
--   The resulting bound includes all values that are equal or greater than
--   the input value.
lowerBound :: a -> LowerBound a

-- | Construct an upper bound from a value.
--   
--   The resulting bound includes all values that are equal or smaller than
--   the input value.
upperBound :: a -> UpperBound a

-- | Construct a strict lower bound from a value.
--   
--   The resulting bound includes all values that are (strictly) greater
--   than the input value.
strictLowerBound :: a -> LowerBound a

-- | Construct a strict upper bound from a value.
--   
--   The resulting bound includes all values that are (strictly) smaller
--   than the input value.
strictUpperBound :: a -> UpperBound a
data () => Rational
ratio :: Integer -> Integer -> Maybe Rational
fromGHC :: Rational -> Rational
toGHC :: Rational -> Rational
data () => Map k a
unsafeFromList :: (ToData k, ToData a) => [(k, a)] -> Map k a

-- | Type representing the <i>BLAKE2b-224</i> hash of a script. 28 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype ScriptHash
ScriptHash :: BuiltinByteString -> ScriptHash
[getScriptHash] :: ScriptHash -> BuiltinByteString

-- | <a>Redeemer</a> is a wrapper around <tt>Data</tt> values that are used
--   as redeemers in transaction inputs.
newtype Redeemer
Redeemer :: BuiltinData -> Redeemer
[getRedeemer] :: Redeemer -> BuiltinData

-- | Type representing the <i>BLAKE2b-256</i> hash of a redeemer. 32 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype RedeemerHash
RedeemerHash :: BuiltinByteString -> RedeemerHash

-- | <a>Datum</a> is a wrapper around <tt>Data</tt> values which are used
--   as data in transaction outputs.
newtype Datum
Datum :: BuiltinData -> Datum
[getDatum] :: Datum -> BuiltinData

-- | Type representing the <i>BLAKE2b-256</i> hash of a datum. 32 bytes.
--   
--   This is a simple type without any validation, <b>use with caution</b>.
--   You may want to add checks for its invariants. See the <a>Shelley
--   ledger specification</a>.
newtype DatumHash
DatumHash :: BuiltinByteString -> DatumHash
data () => Data
Constr :: Integer -> [Data] -> Data
Map :: [(Data, Data)] -> Data
List :: [Data] -> Data
I :: Integer -> Data
B :: ByteString -> Data
data () => BuiltinData
BuiltinData :: ~Data -> BuiltinData
class () => ToData a
toBuiltinData :: ToData a => a -> BuiltinData
class () => FromData a
fromBuiltinData :: FromData a => BuiltinData -> Maybe a
class () => UnsafeFromData a
unsafeFromBuiltinData :: UnsafeFromData a => BuiltinData -> a
toData :: ToData a => a -> Data
fromData :: FromData a => Data -> Maybe a
unsafeFromData :: UnsafeFromData a => Data -> a
dataToBuiltinData :: Data -> BuiltinData
builtinDataToData :: BuiltinData -> Data

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>MonadError</a> class. (If you are using the deprecated
--   <a>Control.Monad.Error</a> or <a>Control.Monad.Trans.Error</a>, you
--   may also have to define an <tt>Error</tt> instance.)
class Monad m => MonadError e (m :: Type -> Type) | m -> e

-- | Errors that can be thrown when evaluating a Plutus script.
data EvaluationError

-- | An error from the evaluator itself
CekError :: !CekEvaluationException NamedDeBruijn DefaultUni DefaultFun -> EvaluationError

-- | An error in the pre-evaluation step of converting from de-Bruijn
--   indices
DeBruijnError :: !FreeVariableError -> EvaluationError

-- | A deserialisation error TODO: make this error more informative when we
--   have more information about what went wrong
CodecError :: !ScriptDecodeError -> EvaluationError

-- | An error indicating that the cost model parameters didn't match what
--   we expected
CostModelParameterMismatch :: EvaluationError

-- | The script evaluated to a value that is not a valid return value.
InvalidReturnValue :: EvaluationError

-- | An error that occurred during script deserialization.
data ScriptDecodeError

-- | an error from the underlying CBOR/serialise library
CBORDeserialiseError :: !DeserialiseFailureInfo -> ScriptDecodeError

-- | Script was successfully parsed, but more (runaway) bytes encountered
--   after script's position
RemainderError :: !ByteString -> ScriptDecodeError

-- | the plutus version of the given script is not enabled yet
LedgerLanguageNotAvailableError :: !PlutusLedgerLanguage -> !MajorProtocolVersion -> !MajorProtocolVersion -> ScriptDecodeError

-- | the script's ledger language
[sdeAffectedLang] :: ScriptDecodeError -> !PlutusLedgerLanguage

-- | the major protocol version that will first introduce/enable the ledger
--   language
[sdeIntroPv] :: ScriptDecodeError -> !MajorProtocolVersion

-- | the current protocol version
[sdeThisPv] :: ScriptDecodeError -> !MajorProtocolVersion
PlutusCoreLanguageNotAvailableError :: !Version -> !PlutusLedgerLanguage -> !MajorProtocolVersion -> ScriptDecodeError

-- | the Plutus Core language of the script under execution.
[sdeAffectedVersion] :: ScriptDecodeError -> !Version

-- | the Plutus ledger language of the script under execution.
[sdeThisLang] :: ScriptDecodeError -> !PlutusLedgerLanguage

-- | the current protocol version
[sdeThisPv] :: ScriptDecodeError -> !MajorProtocolVersion
