-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Libraries for Plutus Tx and its prelude
--   
--   Libraries for Plutus Tx and its prelude
@package plutus-tx
@version 1.36.0.0

module Data.Aeson.Extra

-- | Build a JSON object omitting optional keys if a corresponding value is
--   <a>Nothing</a>.
--   
--   Example: <tt> buildObject $ requiredField "field1" <tt>a</tt> .
--   requiredField "field2" <tt>c</tt> . optionalField "field3" (Just
--   "hello") . optionalField "field4" Nothing </tt> builds this JSON
--   object: <tt> { "field1": <tt>a</tt>, "field2": <tt>c</tt>, "field3":
--   "hello" } </tt> omitting optional <tt>field4</tt>.
buildObject :: (Object -> Object) -> Value
optionalField :: ToJSON a => Key -> Maybe a -> Object -> Object
requiredField :: ToJSON a => Key -> a -> Object -> Object

-- | A field label modifier that strips a prefix from the camelCased field
--   name; &gt;&gt;&gt; stripPrefix "preamble" "preambleTitle" "title"
stripPrefix :: String -> String -> String

module PlutusTx.Blueprint.Definition.Id

-- | A reference to a Schema definition.
data DefinitionId

-- | Creates a <a>DefinitionId</a> from a type with a kind <a>Type</a>.
definitionIdFromType :: forall (t :: Type). Typeable t => DefinitionId

-- | Creates a <a>DefinitionId</a> from a type with a kind other than
--   <a>Type</a>. Example: &gt; definitionIdFromTypeK <tt>(Type -&gt; Type)
--   </tt>Maybe
definitionIdFromTypeK :: forall k (t :: k). Typeable (t :: k) => DefinitionId
definitionIdToText :: DefinitionId -> Text
definitionIdUnit :: DefinitionId
definitionIdList :: DefinitionId
definitionIdTuple2 :: DefinitionId
definitionIdTuple3 :: DefinitionId
instance Data.Aeson.Types.ToJSON.ToJSONKey PlutusTx.Blueprint.Definition.Id.DefinitionId
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Blueprint.Definition.Id.DefinitionId
instance GHC.Classes.Ord PlutusTx.Blueprint.Definition.Id.DefinitionId
instance GHC.Classes.Eq PlutusTx.Blueprint.Definition.Id.DefinitionId
instance Data.Data.Data PlutusTx.Blueprint.Definition.Id.DefinitionId
instance GHC.Generics.Generic PlutusTx.Blueprint.Definition.Id.DefinitionId
instance GHC.Show.Show PlutusTx.Blueprint.Definition.Id.DefinitionId
instance GHC.Base.Semigroup PlutusTx.Blueprint.Definition.Id.DefinitionId

module PlutusTx.Blueprint.Definition.TF
type family IfStuckUnroll (e :: [Type]) (t :: [Type]) :: [Type]
type family IfStuckRep e (rep :: Type -> Type) :: Type -> Type

-- | Insert <tt>x</tt> into <tt>xs</tt> unless it's already there.
type family Insert x xs

-- | Concatenates two type-level lists
type family Concat (as :: [k]) (bs :: [k]) :: [k]

-- | Concatenates two type-level lists removing duplicates.
type family (as :: [k]) ++ (bs :: [k]) :: [k]
infixr 5 ++
type family Reverse (xs :: [k]) :: [k]
type family Append (xs :: [k]) (ys :: [k]) :: [k]
type family Nub xs
type family NubHelper acc xs

module PlutusTx.Blueprint.PlutusVersion

-- | A "Plutus Version", as defined by the CIP-0057 | | This version
--   corresponds to the "Plutus Ledger Language Version" | defined by the
--   plutus-tx-plugin.
data PlutusVersion
PlutusV1 :: PlutusVersion
PlutusV2 :: PlutusVersion
PlutusV3 :: PlutusVersion
instance GHC.Show.Show PlutusTx.Blueprint.PlutusVersion.PlutusVersion
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Blueprint.PlutusVersion.PlutusVersion

module PlutusTx.Blueprint.Preamble

-- | Meta-information about the contract
data Preamble
MkPreamble :: Text -> Maybe Text -> Text -> PlutusVersion -> Maybe Text -> Preamble

-- | A short and descriptive title of the contract application
[preambleTitle] :: Preamble -> Text

-- | A more elaborate description
[preambleDescription] :: Preamble -> Maybe Text

-- | A version number for the project.
[preambleVersion] :: Preamble -> Text

-- | The Plutus version assumed for all validators
[preamblePlutusVersion] :: Preamble -> PlutusVersion

-- | A license under which the specification and contract code is
--   distributed
[preambleLicense] :: Preamble -> Maybe Text
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Blueprint.Preamble.Preamble
instance GHC.Generics.Generic PlutusTx.Blueprint.Preamble.Preamble
instance GHC.Show.Show PlutusTx.Blueprint.Preamble.Preamble

module PlutusTx.Blueprint.Purpose

-- | As per CIP-57, a validator arguments (redeemer, datum) and validator
--   parameters all must specify a purpose that indicates in which context
--   they are used.
data Purpose
Spend :: Purpose
Mint :: Purpose
Withdraw :: Purpose
Publish :: Purpose
purposeToText :: Purpose -> Text
instance Language.Haskell.TH.Syntax.Lift PlutusTx.Blueprint.Purpose.Purpose
instance GHC.Show.Show PlutusTx.Blueprint.Purpose.Purpose
instance GHC.Classes.Ord PlutusTx.Blueprint.Purpose.Purpose
instance GHC.Classes.Eq PlutusTx.Blueprint.Purpose.Purpose
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Blueprint.Purpose.Purpose

module PlutusTx.Blueprint.Schema.Annotation

-- | Additional information optionally attached to any datatype schema
--   definition.
data SchemaInfo
MkSchemaInfo :: Maybe String -> Maybe String -> Maybe String -> SchemaInfo
[title] :: SchemaInfo -> Maybe String
[description] :: SchemaInfo -> Maybe String
[comment] :: SchemaInfo -> Maybe String
emptySchemaInfo :: SchemaInfo
annotationsToSchemaInfo :: [SchemaAnn] -> Either SchemaInfoError SchemaInfo

-- | Annotation that can be attached to a schema definition.
data SchemaAnn
MkSchemaAnnTitle :: SchemaTitle -> SchemaAnn
MkSchemaAnnDescription :: SchemaDescription -> SchemaAnn
MkSchemaAnnComment :: SchemaComment -> SchemaAnn

-- | An annotation for the "title" schema attribute.
--   
--   This annotation could be attached to a type or constructor: <tt> {-#
--   ANN type MyFoo (SchemaTitle "My Foo Title") #-} {-# ANN MkMyFoo
--   (SchemaTitle <a>Title</a>) #-} newtype MyFoo = MkMyFoo Int </tt>
newtype SchemaTitle
SchemaTitle :: String -> SchemaTitle
[schemaTitleToString] :: SchemaTitle -> String

-- | An annotation for the "description" schema attribute.
--   
--   This annotation could be attached to a type or constructor: <tt> {-#
--   ANN type MyFoo (SchemaDescription "My Foo Description") #-} {-# ANN
--   MkMyFoo (SchemaDescription <a>Description</a>) #-} newtype MyFoo =
--   MkMyFoo Int </tt>
newtype SchemaDescription
SchemaDescription :: String -> SchemaDescription
[schemaDescriptionToString] :: SchemaDescription -> String

-- | An annotation for the "$comment" schema attribute.
--   
--   This annotation could be attached to a type or constructor: <tt> {-#
--   ANN type MyFoo (SchemaComment "My Foo Comment") #-} {-# ANN MkMyFoo
--   (SchemaComment <a>Comment</a>) #-} newtype MyFoo = MkMyFoo Int </tt>
newtype SchemaComment
SchemaComment :: String -> SchemaComment
[schemaCommentToString] :: SchemaComment -> String
instance Language.Haskell.TH.Syntax.Lift PlutusTx.Blueprint.Schema.Annotation.SchemaInfo
instance Data.Data.Data PlutusTx.Blueprint.Schema.Annotation.SchemaInfo
instance GHC.Generics.Generic PlutusTx.Blueprint.Schema.Annotation.SchemaInfo
instance GHC.Show.Show PlutusTx.Blueprint.Schema.Annotation.SchemaInfo
instance GHC.Classes.Ord PlutusTx.Blueprint.Schema.Annotation.SchemaInfo
instance GHC.Classes.Eq PlutusTx.Blueprint.Schema.Annotation.SchemaInfo
instance Language.Haskell.TH.Syntax.Lift PlutusTx.Blueprint.Schema.Annotation.SchemaTitle
instance Data.Data.Data PlutusTx.Blueprint.Schema.Annotation.SchemaTitle
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Blueprint.Schema.Annotation.SchemaTitle
instance GHC.Show.Show PlutusTx.Blueprint.Schema.Annotation.SchemaTitle
instance GHC.Classes.Ord PlutusTx.Blueprint.Schema.Annotation.SchemaTitle
instance GHC.Classes.Eq PlutusTx.Blueprint.Schema.Annotation.SchemaTitle
instance Language.Haskell.TH.Syntax.Lift PlutusTx.Blueprint.Schema.Annotation.SchemaDescription
instance Data.Data.Data PlutusTx.Blueprint.Schema.Annotation.SchemaDescription
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Blueprint.Schema.Annotation.SchemaDescription
instance GHC.Show.Show PlutusTx.Blueprint.Schema.Annotation.SchemaDescription
instance GHC.Classes.Ord PlutusTx.Blueprint.Schema.Annotation.SchemaDescription
instance GHC.Classes.Eq PlutusTx.Blueprint.Schema.Annotation.SchemaDescription
instance Language.Haskell.TH.Syntax.Lift PlutusTx.Blueprint.Schema.Annotation.SchemaComment
instance Data.Data.Data PlutusTx.Blueprint.Schema.Annotation.SchemaComment
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Blueprint.Schema.Annotation.SchemaComment
instance GHC.Show.Show PlutusTx.Blueprint.Schema.Annotation.SchemaComment
instance GHC.Classes.Ord PlutusTx.Blueprint.Schema.Annotation.SchemaComment
instance GHC.Classes.Eq PlutusTx.Blueprint.Schema.Annotation.SchemaComment
instance Language.Haskell.TH.Syntax.Lift PlutusTx.Blueprint.Schema.Annotation.SchemaAnn
instance Data.Data.Data PlutusTx.Blueprint.Schema.Annotation.SchemaAnn
instance GHC.Generics.Generic PlutusTx.Blueprint.Schema.Annotation.SchemaAnn
instance GHC.Show.Show PlutusTx.Blueprint.Schema.Annotation.SchemaAnn
instance GHC.Classes.Ord PlutusTx.Blueprint.Schema.Annotation.SchemaAnn
instance GHC.Classes.Eq PlutusTx.Blueprint.Schema.Annotation.SchemaAnn

module PlutusTx.Blueprint.Schema

-- | Blueprint schema definition, as defined by the CIP-0057:
--   <a>https://github.com/cardano-foundation/CIPs/tree/master/CIP-0057#core-vocabulary</a>
--   
--   The <tt>referencedTypes</tt> phantom type parameter is used to track
--   the types used in the contract making sure their schemas are included
--   in the blueprint and that they are referenced in a type-safe way.
data Schema (referencedTypes :: [Type])
SchemaInteger :: SchemaInfo -> IntegerSchema -> Schema (referencedTypes :: [Type])
SchemaBytes :: SchemaInfo -> BytesSchema -> Schema (referencedTypes :: [Type])
SchemaList :: SchemaInfo -> ListSchema referencedTypes -> Schema (referencedTypes :: [Type])
SchemaMap :: SchemaInfo -> MapSchema referencedTypes -> Schema (referencedTypes :: [Type])
SchemaConstructor :: SchemaInfo -> ConstructorSchema referencedTypes -> Schema (referencedTypes :: [Type])
SchemaBuiltInData :: SchemaInfo -> Schema (referencedTypes :: [Type])
SchemaBuiltInUnit :: SchemaInfo -> Schema (referencedTypes :: [Type])
SchemaBuiltInBoolean :: SchemaInfo -> Schema (referencedTypes :: [Type])
SchemaBuiltInInteger :: SchemaInfo -> Schema (referencedTypes :: [Type])
SchemaBuiltInBytes :: SchemaInfo -> Schema (referencedTypes :: [Type])
SchemaBuiltInString :: SchemaInfo -> Schema (referencedTypes :: [Type])
SchemaBuiltInPair :: SchemaInfo -> PairSchema referencedTypes -> Schema (referencedTypes :: [Type])
SchemaBuiltInList :: SchemaInfo -> Schema referencedTypes -> Schema (referencedTypes :: [Type])
SchemaOneOf :: NonEmpty (Schema referencedTypes) -> Schema (referencedTypes :: [Type])
SchemaAnyOf :: NonEmpty (Schema referencedTypes) -> Schema (referencedTypes :: [Type])
SchemaAllOf :: NonEmpty (Schema referencedTypes) -> Schema (referencedTypes :: [Type])
SchemaNot :: Schema referencedTypes -> Schema (referencedTypes :: [Type])
SchemaDefinitionRef :: DefinitionId -> Schema (referencedTypes :: [Type])
withSchemaInfo :: (SchemaInfo -> SchemaInfo) -> Schema referencedTypes -> Schema referencedTypes
data IntegerSchema
MkIntegerSchema :: Maybe Integer -> Maybe Integer -> Maybe Integer -> Maybe Integer -> Maybe Integer -> IntegerSchema

-- | An instance is valid if division by this value results in an integer.
[$sel:multipleOf:MkIntegerSchema] :: IntegerSchema -> Maybe Integer

-- | An instance is valid only if it is greater than or exactly equal to
--   "minimum".
[$sel:minimum:MkIntegerSchema] :: IntegerSchema -> Maybe Integer

-- | An instance is valid only if it is less than or exactly equal to
--   "maximum".
[$sel:maximum:MkIntegerSchema] :: IntegerSchema -> Maybe Integer

-- | An instance is valid only if it is strictly greater than
--   "exclusiveMinimum".
[$sel:exclusiveMinimum:MkIntegerSchema] :: IntegerSchema -> Maybe Integer

-- | An instance is valid only if it is strictly less than
--   "exclusiveMaximum".
[$sel:exclusiveMaximum:MkIntegerSchema] :: IntegerSchema -> Maybe Integer
emptyIntegerSchema :: IntegerSchema
data BytesSchema
MkBytesSchema :: [ByteString] -> Maybe Natural -> Maybe Natural -> BytesSchema

-- | An instance validates successfully if once hex-encoded, its value
--   matches one of the specified values.
[$sel:enum:MkBytesSchema] :: BytesSchema -> [ByteString]

-- | An instance is valid if its length is greater than, or equal to, this
--   value.
[$sel:minLength:MkBytesSchema] :: BytesSchema -> Maybe Natural

-- | An instance is valid if its length is less than, or equal to, this
--   value.
[$sel:maxLength:MkBytesSchema] :: BytesSchema -> Maybe Natural
emptyBytesSchema :: BytesSchema
data ListSchema (referencedTypes :: [Type])
MkListSchema :: Schema referencedTypes -> Maybe Natural -> Maybe Natural -> Maybe Bool -> ListSchema (referencedTypes :: [Type])

-- | Element schema
[$sel:itemSchema:MkListSchema] :: ListSchema (referencedTypes :: [Type]) -> Schema referencedTypes

-- | An array instance is valid if its size is greater than, or equal to,
--   this value.
[$sel:minItems:MkListSchema] :: ListSchema (referencedTypes :: [Type]) -> Maybe Natural

-- | An array instance is valid if its size is less than, or equal to, this
--   value.
[$sel:maxItems:MkListSchema] :: ListSchema (referencedTypes :: [Type]) -> Maybe Natural

-- | If this value is false, the instance validates successfully. If it is
--   set to True, the instance validates successfully if all of its
--   elements are unique.
[$sel:uniqueItems:MkListSchema] :: ListSchema (referencedTypes :: [Type]) -> Maybe Bool
mkListSchema :: Schema referencedTypes -> ListSchema referencedTypes
data MapSchema (referencedTypes :: [Type])
MkMapSchema :: Schema referencedTypes -> Schema referencedTypes -> Maybe Natural -> Maybe Natural -> MapSchema (referencedTypes :: [Type])

-- | Key schema
[$sel:keySchema:MkMapSchema] :: MapSchema (referencedTypes :: [Type]) -> Schema referencedTypes

-- | Value schema
[$sel:valueSchema:MkMapSchema] :: MapSchema (referencedTypes :: [Type]) -> Schema referencedTypes

-- | A map instance is valid if its size is greater than, or equal to, this
--   value.
[$sel:minItems:MkMapSchema] :: MapSchema (referencedTypes :: [Type]) -> Maybe Natural

-- | A map instance is valid if its size is less than, or equal to, this
--   value.
[$sel:maxItems:MkMapSchema] :: MapSchema (referencedTypes :: [Type]) -> Maybe Natural
data ConstructorSchema (referencedTypes :: [Type])
MkConstructorSchema :: Natural -> [Schema referencedTypes] -> ConstructorSchema (referencedTypes :: [Type])

-- | Constructor index
[$sel:index:MkConstructorSchema] :: ConstructorSchema (referencedTypes :: [Type]) -> Natural

-- | Field schemas
[$sel:fieldSchemas:MkConstructorSchema] :: ConstructorSchema (referencedTypes :: [Type]) -> [Schema referencedTypes]
data PairSchema (referencedTypes :: [Type])
MkPairSchema :: Schema referencedTypes -> Schema referencedTypes -> PairSchema (referencedTypes :: [Type])

-- | Schema of the first element
[$sel:left:MkPairSchema] :: PairSchema (referencedTypes :: [Type]) -> Schema referencedTypes

-- | Schema of the second element
[$sel:right:MkPairSchema] :: PairSchema (referencedTypes :: [Type]) -> Schema referencedTypes
instance Data.Data.Data PlutusTx.Blueprint.Schema.IntegerSchema
instance GHC.Generics.Generic PlutusTx.Blueprint.Schema.IntegerSchema
instance GHC.Show.Show PlutusTx.Blueprint.Schema.IntegerSchema
instance GHC.Classes.Ord PlutusTx.Blueprint.Schema.IntegerSchema
instance GHC.Classes.Eq PlutusTx.Blueprint.Schema.IntegerSchema
instance Data.Data.Data PlutusTx.Blueprint.Schema.BytesSchema
instance GHC.Generics.Generic PlutusTx.Blueprint.Schema.BytesSchema
instance GHC.Show.Show PlutusTx.Blueprint.Schema.BytesSchema
instance GHC.Classes.Ord PlutusTx.Blueprint.Schema.BytesSchema
instance GHC.Classes.Eq PlutusTx.Blueprint.Schema.BytesSchema
instance Data.Typeable.Internal.Typeable referencedTypes => Data.Data.Data (PlutusTx.Blueprint.Schema.ListSchema referencedTypes)
instance GHC.Generics.Generic (PlutusTx.Blueprint.Schema.ListSchema referencedTypes)
instance GHC.Show.Show (PlutusTx.Blueprint.Schema.ListSchema referencedTypes)
instance GHC.Classes.Ord (PlutusTx.Blueprint.Schema.ListSchema referencedTypes)
instance GHC.Classes.Eq (PlutusTx.Blueprint.Schema.ListSchema referencedTypes)
instance Data.Typeable.Internal.Typeable referencedTypes => Data.Data.Data (PlutusTx.Blueprint.Schema.MapSchema referencedTypes)
instance GHC.Generics.Generic (PlutusTx.Blueprint.Schema.MapSchema referencedTypes)
instance GHC.Show.Show (PlutusTx.Blueprint.Schema.MapSchema referencedTypes)
instance GHC.Classes.Ord (PlutusTx.Blueprint.Schema.MapSchema referencedTypes)
instance GHC.Classes.Eq (PlutusTx.Blueprint.Schema.MapSchema referencedTypes)
instance Data.Typeable.Internal.Typeable referencedTypes => Data.Data.Data (PlutusTx.Blueprint.Schema.ConstructorSchema referencedTypes)
instance GHC.Generics.Generic (PlutusTx.Blueprint.Schema.ConstructorSchema referencedTypes)
instance GHC.Show.Show (PlutusTx.Blueprint.Schema.ConstructorSchema referencedTypes)
instance GHC.Classes.Ord (PlutusTx.Blueprint.Schema.ConstructorSchema referencedTypes)
instance GHC.Classes.Eq (PlutusTx.Blueprint.Schema.ConstructorSchema referencedTypes)
instance Data.Typeable.Internal.Typeable referencedTypes => Data.Data.Data (PlutusTx.Blueprint.Schema.Schema referencedTypes)
instance GHC.Generics.Generic (PlutusTx.Blueprint.Schema.Schema referencedTypes)
instance GHC.Show.Show (PlutusTx.Blueprint.Schema.Schema referencedTypes)
instance GHC.Classes.Ord (PlutusTx.Blueprint.Schema.Schema referencedTypes)
instance GHC.Classes.Eq (PlutusTx.Blueprint.Schema.Schema referencedTypes)
instance Data.Typeable.Internal.Typeable referencedTypes => Data.Data.Data (PlutusTx.Blueprint.Schema.PairSchema referencedTypes)
instance GHC.Generics.Generic (PlutusTx.Blueprint.Schema.PairSchema referencedTypes)
instance GHC.Show.Show (PlutusTx.Blueprint.Schema.PairSchema referencedTypes)
instance GHC.Classes.Ord (PlutusTx.Blueprint.Schema.PairSchema referencedTypes)
instance GHC.Classes.Eq (PlutusTx.Blueprint.Schema.PairSchema referencedTypes)
instance Data.Typeable.Internal.Typeable referencedTypes => Control.Lens.Plated.Plated (PlutusTx.Blueprint.Schema.Schema referencedTypes)
instance Data.Aeson.Types.ToJSON.ToJSON (PlutusTx.Blueprint.Schema.Schema referencedTypes)

module PlutusTx.Blueprint.Parameter

-- | Blueprint that defines validator's compile-time parameter.
--   
--   The <tt>referencedTypes</tt> phantom type parameter is used to track
--   the types used in the contract making sure their schemas are included
--   in the blueprint and that they are referenced in a type-safe way.
data ParameterBlueprint (referencedTypes :: [Type])
MkParameterBlueprint :: Maybe Text -> Maybe Text -> Set Purpose -> Schema referencedTypes -> ParameterBlueprint (referencedTypes :: [Type])

-- | A short and descriptive name for the parameter.
[parameterTitle] :: ParameterBlueprint (referencedTypes :: [Type]) -> Maybe Text

-- | An informative description of the parameter.
[parameterDescription] :: ParameterBlueprint (referencedTypes :: [Type]) -> Maybe Text

-- | One of "spend", "mint", "withdraw" or "publish", or a oneOf applicator
--   of those.
[parameterPurpose] :: ParameterBlueprint (referencedTypes :: [Type]) -> Set Purpose

-- | A Plutus Data Schema.
[parameterSchema] :: ParameterBlueprint (referencedTypes :: [Type]) -> Schema referencedTypes
oneOfASet :: ToJSON a => Set a -> Maybe Value
instance GHC.Classes.Ord (PlutusTx.Blueprint.Parameter.ParameterBlueprint referencedTypes)
instance GHC.Classes.Eq (PlutusTx.Blueprint.Parameter.ParameterBlueprint referencedTypes)
instance GHC.Show.Show (PlutusTx.Blueprint.Parameter.ParameterBlueprint referencedTypes)
instance Data.Aeson.Types.ToJSON.ToJSON (PlutusTx.Blueprint.Parameter.ParameterBlueprint referencedTypes)


-- | This module provides a functionality to derive and reference schema
--   definitions.
module PlutusTx.Blueprint.Definition.Internal

-- | A schema definition of a type <tt>t</tt> with a list of referenced
--   types <tt>ts</tt>.
data Definition t ts
MkDefinition :: DefinitionId -> Schema ts -> Definition t ts

-- | A registry of schema definitions.
data Definitions ts
[NoDefinitions] :: Definitions ts
[AddDefinition] :: Definition t ts -> Definitions ts -> Definitions ts

-- | Add a schema definition to a registry.
addDefinition :: Definitions ts -> Definition t ts -> Definitions ts
definitionsToMap :: Definitions ts -> (forall xs. Schema xs -> v) -> Map DefinitionId v

-- | A constraint that checks if a schema definition is present in a list
--   of schema definitions. Gives a user-friendly error message if the
--   schema definition is not found.
type HasSchemaDefinition t ts = HasSchemaDefinition' t ts ts
type family HasSchemaDefinition' n xs xs0
instance forall k (t :: k) (ts :: [*]). GHC.Show.Show (PlutusTx.Blueprint.Definition.Internal.Definition t ts)
instance GHC.Show.Show (PlutusTx.Blueprint.Definition.Internal.Definitions ts)

module PlutusTx.Blueprint.Argument

-- | Blueprint that defines a validator's runtime argument: datum or
--   redeemer.
data ArgumentBlueprint (referencedTypes :: [Type])
MkArgumentBlueprint :: Maybe Text -> Maybe Text -> Set Purpose -> Schema referencedTypes -> ArgumentBlueprint (referencedTypes :: [Type])

-- | A short and descriptive name for the redeemer or datum.
[argumentTitle] :: ArgumentBlueprint (referencedTypes :: [Type]) -> Maybe Text

-- | An informative description of the redeemer or datum.
[argumentDescription] :: ArgumentBlueprint (referencedTypes :: [Type]) -> Maybe Text

-- | A possibly empty set of purposes for the redeemer or datum.
[argumentPurpose] :: ArgumentBlueprint (referencedTypes :: [Type]) -> Set Purpose

-- | A Plutus Data Schema.
[argumentSchema] :: ArgumentBlueprint (referencedTypes :: [Type]) -> Schema referencedTypes
instance GHC.Classes.Ord (PlutusTx.Blueprint.Argument.ArgumentBlueprint referencedTypes)
instance GHC.Classes.Eq (PlutusTx.Blueprint.Argument.ArgumentBlueprint referencedTypes)
instance GHC.Show.Show (PlutusTx.Blueprint.Argument.ArgumentBlueprint referencedTypes)
instance Data.Aeson.Types.ToJSON.ToJSON (PlutusTx.Blueprint.Argument.ArgumentBlueprint referencedTypes)

module PlutusTx.Blueprint.Validator

-- | A blueprint of a validator, as defined by the CIP-0057
--   
--   The <tt>referencedTypes</tt> phantom type parameter is used to track
--   the types used in the contract making sure their schemas are included
--   in the blueprint and that they are referenced in a type-safe way.
data ValidatorBlueprint (referencedTypes :: [Type])
MkValidatorBlueprint :: Text -> Maybe Text -> ArgumentBlueprint referencedTypes -> Maybe (ArgumentBlueprint referencedTypes) -> [ParameterBlueprint referencedTypes] -> Maybe CompiledValidator -> ValidatorBlueprint (referencedTypes :: [Type])

-- | A short and descriptive name for the validator.
[validatorTitle] :: ValidatorBlueprint (referencedTypes :: [Type]) -> Text

-- | An informative description of the validator.
[validatorDescription] :: ValidatorBlueprint (referencedTypes :: [Type]) -> Maybe Text

-- | A description of the redeemer format expected by this validator.
[validatorRedeemer] :: ValidatorBlueprint (referencedTypes :: [Type]) -> ArgumentBlueprint referencedTypes

-- | A description of the datum format expected by this validator.
[validatorDatum] :: ValidatorBlueprint (referencedTypes :: [Type]) -> Maybe (ArgumentBlueprint referencedTypes)

-- | A list of parameters required by the script.
[validatorParameters] :: ValidatorBlueprint (referencedTypes :: [Type]) -> [ParameterBlueprint referencedTypes]

-- | A full compiled and CBOR-encoded serialized flat script together with
--   its hash.
[validatorCompiled] :: ValidatorBlueprint (referencedTypes :: [Type]) -> Maybe CompiledValidator
data CompiledValidator
MkCompiledValidator :: ByteString -> ByteString -> CompiledValidator
[compiledValidatorCode] :: CompiledValidator -> ByteString
[compiledValidatorHash] :: CompiledValidator -> ByteString
compiledValidator :: PlutusVersion -> ByteString -> CompiledValidator
instance GHC.Classes.Ord PlutusTx.Blueprint.Validator.CompiledValidator
instance GHC.Classes.Eq PlutusTx.Blueprint.Validator.CompiledValidator
instance GHC.Show.Show PlutusTx.Blueprint.Validator.CompiledValidator
instance GHC.Classes.Ord (PlutusTx.Blueprint.Validator.ValidatorBlueprint referencedTypes)
instance GHC.Classes.Eq (PlutusTx.Blueprint.Validator.ValidatorBlueprint referencedTypes)
instance GHC.Show.Show (PlutusTx.Blueprint.Validator.ValidatorBlueprint referencedTypes)
instance Data.Aeson.Types.ToJSON.ToJSON (PlutusTx.Blueprint.Validator.ValidatorBlueprint referencedTypes)

module PlutusTx.Bool
data () => Bool
False :: Bool
True :: Bool

-- | Logical AND. Short-circuits if the first argument evaluates to
--   <a>False</a>.
--   
--   <pre>
--   &gt;&gt;&gt; True &amp;&amp; False
--   False
--   </pre>
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Logical OR. Short-circuits if the first argument evaluates to
--   <a>True</a>.
--   
--   <pre>
--   &gt;&gt;&gt; True || False
--   True
--   </pre>
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Logical negation
--   
--   <pre>
--   &gt;&gt;&gt; not True
--   False
--   </pre>
not :: Bool -> Bool

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool


-- | Plutus Tx basic functions.
module PlutusTx.Base

-- | Plutus Tx version of <a>fst</a>
fst :: (a, b) -> a

-- | Plutus Tx version of <a>snd</a>
snd :: (a, b) -> b
curry :: ((a, b) -> c) -> a -> b -> c
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | Plutus Tx version of 'Data.Function.($)'.
($) :: (a -> b) -> a -> b
infixr 0 $

-- | Plutus Tx version of <a>flip</a>.
flip :: (a -> b -> c) -> b -> a -> c

-- | Plutus Tx version of <a>until</a>.
until :: (a -> Bool) -> (a -> a) -> a -> a

-- | Plutus Tx version of 'Prelude.(.)'.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | Plutus Tx version of <a>const</a>.
const :: a -> b -> a

-- | Plutus Tx version of <a>id</a>.
id :: a -> a


-- | This module contains the special Haskell names that are used to map to
--   builtin types or functions in Plutus Core.
--   
--   Most users should not use this module directly, but rather use
--   <a>Builtins</a>.
module PlutusTx.Builtins.Internal
error :: BuiltinUnit -> a
data BuiltinBool
BuiltinBool :: ~Bool -> BuiltinBool
true :: BuiltinBool
false :: BuiltinBool
ifThenElse :: BuiltinBool -> a -> a -> a
data BuiltinUnit
BuiltinUnit :: ~() -> BuiltinUnit
unitval :: BuiltinUnit
chooseUnit :: BuiltinUnit -> a -> a
type BuiltinInteger = Integer
addInteger :: BuiltinInteger -> BuiltinInteger -> BuiltinInteger
subtractInteger :: BuiltinInteger -> BuiltinInteger -> BuiltinInteger
multiplyInteger :: BuiltinInteger -> BuiltinInteger -> BuiltinInteger
divideInteger :: BuiltinInteger -> BuiltinInteger -> BuiltinInteger
modInteger :: BuiltinInteger -> BuiltinInteger -> BuiltinInteger
quotientInteger :: BuiltinInteger -> BuiltinInteger -> BuiltinInteger
remainderInteger :: BuiltinInteger -> BuiltinInteger -> BuiltinInteger
lessThanInteger :: BuiltinInteger -> BuiltinInteger -> BuiltinBool
lessThanEqualsInteger :: BuiltinInteger -> BuiltinInteger -> BuiltinBool
equalsInteger :: BuiltinInteger -> BuiltinInteger -> BuiltinBool

-- | An opaque type representing Plutus Core ByteStrings.
data BuiltinByteString
BuiltinByteString :: ~ByteString -> BuiltinByteString
appendByteString :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString
consByteString :: BuiltinInteger -> BuiltinByteString -> BuiltinByteString
sliceByteString :: BuiltinInteger -> BuiltinInteger -> BuiltinByteString -> BuiltinByteString
lengthOfByteString :: BuiltinByteString -> BuiltinInteger
indexByteString :: BuiltinByteString -> BuiltinInteger -> BuiltinInteger
emptyByteString :: BuiltinByteString
sha2_256 :: BuiltinByteString -> BuiltinByteString
sha3_256 :: BuiltinByteString -> BuiltinByteString
blake2b_224 :: BuiltinByteString -> BuiltinByteString
blake2b_256 :: BuiltinByteString -> BuiltinByteString
keccak_256 :: BuiltinByteString -> BuiltinByteString
ripemd_160 :: BuiltinByteString -> BuiltinByteString
verifyEd25519Signature :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString -> BuiltinBool
verifyEcdsaSecp256k1Signature :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString -> BuiltinBool
verifySchnorrSecp256k1Signature :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString -> BuiltinBool
traceAll :: forall (a :: Type) (f :: Type -> Type). Foldable f => f Text -> a -> a
equalsByteString :: BuiltinByteString -> BuiltinByteString -> BuiltinBool
lessThanByteString :: BuiltinByteString -> BuiltinByteString -> BuiltinBool
lessThanEqualsByteString :: BuiltinByteString -> BuiltinByteString -> BuiltinBool
decodeUtf8 :: BuiltinByteString -> BuiltinString
data BuiltinString
BuiltinString :: ~Text -> BuiltinString
appendString :: BuiltinString -> BuiltinString -> BuiltinString
emptyString :: BuiltinString
equalsString :: BuiltinString -> BuiltinString -> BuiltinBool
trace :: BuiltinString -> a -> a
encodeUtf8 :: BuiltinString -> BuiltinByteString
data BuiltinPair a b
BuiltinPair :: ~(a, b) -> BuiltinPair a b
fst :: BuiltinPair a b -> a
snd :: BuiltinPair a b -> b
mkPairData :: BuiltinData -> BuiltinData -> BuiltinPair BuiltinData BuiltinData
data BuiltinList a
BuiltinList :: ~[a] -> BuiltinList a
null :: BuiltinList a -> BuiltinBool
head :: BuiltinList a -> a
tail :: BuiltinList a -> BuiltinList a
chooseList :: BuiltinList a -> b -> b -> b
mkNilData :: BuiltinUnit -> BuiltinList BuiltinData
mkNilPairData :: BuiltinUnit -> BuiltinList (BuiltinPair BuiltinData BuiltinData)
mkCons :: a -> BuiltinList a -> BuiltinList a

-- | A type corresponding to the Plutus Core builtin equivalent of
--   <a>Data</a>.
--   
--   The point of this type is to be an opaque equivalent of <a>Data</a>,
--   so as to ensure that it is only used in ways that the compiler can
--   handle.
--   
--   As such, you should use this type in your on-chain code, and in any
--   data structures that you want to be representable on-chain.
--   
--   For off-chain usage, there are conversion functions
--   <a>builtinDataToData</a> and <a>dataToBuiltinData</a>, but note that
--   these will not work on-chain.
data BuiltinData
BuiltinData :: ~Data -> BuiltinData

-- | Convert a <a>BuiltinData</a> into a <a>Data</a>. Only works off-chain.
builtinDataToData :: BuiltinData -> Data

-- | Convert a <a>Data</a> into a <a>BuiltinData</a>. Only works off-chain.
dataToBuiltinData :: Data -> BuiltinData
chooseData :: forall a. BuiltinData -> a -> a -> a -> a -> a -> a
mkConstr :: BuiltinInteger -> BuiltinList BuiltinData -> BuiltinData
mkMap :: BuiltinList (BuiltinPair BuiltinData BuiltinData) -> BuiltinData
mkList :: BuiltinList BuiltinData -> BuiltinData
mkI :: BuiltinInteger -> BuiltinData
mkB :: BuiltinByteString -> BuiltinData
unsafeDataAsConstr :: BuiltinData -> BuiltinPair BuiltinInteger (BuiltinList BuiltinData)
unsafeDataAsMap :: BuiltinData -> BuiltinList (BuiltinPair BuiltinData BuiltinData)
unsafeDataAsList :: BuiltinData -> BuiltinList BuiltinData
unsafeDataAsI :: BuiltinData -> BuiltinInteger
unsafeDataAsB :: BuiltinData -> BuiltinByteString
equalsData :: BuiltinData -> BuiltinData -> BuiltinBool
serialiseData :: BuiltinData -> BuiltinByteString
data BuiltinBLS12_381_G1_Element
BuiltinBLS12_381_G1_Element :: ~Element -> BuiltinBLS12_381_G1_Element
bls12_381_G1_equals :: BuiltinBLS12_381_G1_Element -> BuiltinBLS12_381_G1_Element -> BuiltinBool
bls12_381_G1_add :: BuiltinBLS12_381_G1_Element -> BuiltinBLS12_381_G1_Element -> BuiltinBLS12_381_G1_Element
bls12_381_G1_neg :: BuiltinBLS12_381_G1_Element -> BuiltinBLS12_381_G1_Element
bls12_381_G1_scalarMul :: BuiltinInteger -> BuiltinBLS12_381_G1_Element -> BuiltinBLS12_381_G1_Element
bls12_381_G1_compress :: BuiltinBLS12_381_G1_Element -> BuiltinByteString
bls12_381_G1_uncompress :: BuiltinByteString -> BuiltinBLS12_381_G1_Element
bls12_381_G1_hashToGroup :: BuiltinByteString -> BuiltinByteString -> BuiltinBLS12_381_G1_Element
bls12_381_G1_compressed_zero :: BuiltinByteString
bls12_381_G1_compressed_generator :: BuiltinByteString
data BuiltinBLS12_381_G2_Element
BuiltinBLS12_381_G2_Element :: ~Element -> BuiltinBLS12_381_G2_Element
bls12_381_G2_equals :: BuiltinBLS12_381_G2_Element -> BuiltinBLS12_381_G2_Element -> BuiltinBool
bls12_381_G2_add :: BuiltinBLS12_381_G2_Element -> BuiltinBLS12_381_G2_Element -> BuiltinBLS12_381_G2_Element
bls12_381_G2_neg :: BuiltinBLS12_381_G2_Element -> BuiltinBLS12_381_G2_Element
bls12_381_G2_scalarMul :: BuiltinInteger -> BuiltinBLS12_381_G2_Element -> BuiltinBLS12_381_G2_Element
bls12_381_G2_compress :: BuiltinBLS12_381_G2_Element -> BuiltinByteString
bls12_381_G2_uncompress :: BuiltinByteString -> BuiltinBLS12_381_G2_Element
bls12_381_G2_hashToGroup :: BuiltinByteString -> BuiltinByteString -> BuiltinBLS12_381_G2_Element
bls12_381_G2_compressed_zero :: BuiltinByteString
bls12_381_G2_compressed_generator :: BuiltinByteString
data BuiltinBLS12_381_MlResult
BuiltinBLS12_381_MlResult :: ~MlResult -> BuiltinBLS12_381_MlResult
bls12_381_millerLoop :: BuiltinBLS12_381_G1_Element -> BuiltinBLS12_381_G2_Element -> BuiltinBLS12_381_MlResult
bls12_381_mulMlResult :: BuiltinBLS12_381_MlResult -> BuiltinBLS12_381_MlResult -> BuiltinBLS12_381_MlResult
bls12_381_finalVerify :: BuiltinBLS12_381_MlResult -> BuiltinBLS12_381_MlResult -> BuiltinBool
integerToByteString :: BuiltinBool -> BuiltinInteger -> BuiltinInteger -> BuiltinByteString
byteStringToInteger :: BuiltinBool -> BuiltinByteString -> BuiltinInteger
shiftByteString :: BuiltinByteString -> BuiltinInteger -> BuiltinByteString
rotateByteString :: BuiltinByteString -> BuiltinInteger -> BuiltinByteString
countSetBits :: BuiltinByteString -> BuiltinInteger
findFirstSetBit :: BuiltinByteString -> BuiltinInteger
andByteString :: BuiltinBool -> BuiltinByteString -> BuiltinByteString -> BuiltinByteString
orByteString :: BuiltinBool -> BuiltinByteString -> BuiltinByteString -> BuiltinByteString
xorByteString :: BuiltinBool -> BuiltinByteString -> BuiltinByteString -> BuiltinByteString
complementByteString :: BuiltinByteString -> BuiltinByteString
readBit :: BuiltinByteString -> BuiltinInteger -> BuiltinBool
writeBits :: BuiltinByteString -> BuiltinList BuiltinInteger -> BuiltinBool -> BuiltinByteString
replicateByte :: BuiltinInteger -> BuiltinInteger -> BuiltinByteString
expModInteger :: BuiltinInteger -> BuiltinInteger -> BuiltinInteger -> BuiltinInteger
instance Data.Data.Data PlutusTx.Builtins.Internal.BuiltinBool
instance Data.Data.Data PlutusTx.Builtins.Internal.BuiltinUnit
instance Data.Data.Data PlutusTx.Builtins.Internal.BuiltinByteString
instance Data.Data.Data PlutusTx.Builtins.Internal.BuiltinString
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (PlutusTx.Builtins.Internal.BuiltinPair a b)
instance Data.Data.Data a => Data.Data.Data (PlutusTx.Builtins.Internal.BuiltinList a)
instance GHC.Generics.Generic PlutusTx.Builtins.Internal.BuiltinData
instance Data.Data.Data PlutusTx.Builtins.Internal.BuiltinData
instance GHC.Show.Show PlutusTx.Builtins.Internal.BuiltinBLS12_381_MlResult
instance GHC.Classes.Eq PlutusTx.Builtins.Internal.BuiltinBLS12_381_MlResult
instance Control.DeepSeq.NFData PlutusTx.Builtins.Internal.BuiltinBLS12_381_MlResult
instance Prettyprinter.Internal.Pretty PlutusTx.Builtins.Internal.BuiltinBLS12_381_MlResult
instance GHC.Show.Show PlutusTx.Builtins.Internal.BuiltinBLS12_381_G2_Element
instance GHC.Classes.Eq PlutusTx.Builtins.Internal.BuiltinBLS12_381_G2_Element
instance Control.DeepSeq.NFData PlutusTx.Builtins.Internal.BuiltinBLS12_381_G2_Element
instance Prettyprinter.Internal.Pretty PlutusTx.Builtins.Internal.BuiltinBLS12_381_G2_Element
instance GHC.Show.Show PlutusTx.Builtins.Internal.BuiltinBLS12_381_G1_Element
instance GHC.Classes.Eq PlutusTx.Builtins.Internal.BuiltinBLS12_381_G1_Element
instance Control.DeepSeq.NFData PlutusTx.Builtins.Internal.BuiltinBLS12_381_G1_Element
instance Prettyprinter.Internal.Pretty PlutusTx.Builtins.Internal.BuiltinBLS12_381_G1_Element
instance GHC.Show.Show PlutusTx.Builtins.Internal.BuiltinData
instance GHC.Classes.Eq PlutusTx.Builtins.Internal.BuiltinData
instance GHC.Classes.Ord PlutusTx.Builtins.Internal.BuiltinData
instance Control.DeepSeq.NFData PlutusTx.Builtins.Internal.BuiltinData
instance Prettyprinter.Internal.Pretty PlutusTx.Builtins.Internal.BuiltinData
instance GHC.Show.Show a => GHC.Show.Show (PlutusTx.Builtins.Internal.BuiltinList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (PlutusTx.Builtins.Internal.BuiltinList a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (PlutusTx.Builtins.Internal.BuiltinList a)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (PlutusTx.Builtins.Internal.BuiltinPair a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (PlutusTx.Builtins.Internal.BuiltinPair a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (PlutusTx.Builtins.Internal.BuiltinPair a b)
instance GHC.Show.Show PlutusTx.Builtins.Internal.BuiltinString
instance GHC.Classes.Eq PlutusTx.Builtins.Internal.BuiltinString
instance GHC.Classes.Ord PlutusTx.Builtins.Internal.BuiltinString
instance GHC.Show.Show PlutusTx.Builtins.Internal.BuiltinByteString
instance GHC.Classes.Eq PlutusTx.Builtins.Internal.BuiltinByteString
instance GHC.Classes.Ord PlutusTx.Builtins.Internal.BuiltinByteString
instance GHC.Base.Semigroup PlutusTx.Builtins.Internal.BuiltinByteString
instance GHC.Base.Monoid PlutusTx.Builtins.Internal.BuiltinByteString
instance Data.Hashable.Class.Hashable PlutusTx.Builtins.Internal.BuiltinByteString
instance Codec.Serialise.Class.Serialise PlutusTx.Builtins.Internal.BuiltinByteString
instance Control.DeepSeq.NFData PlutusTx.Builtins.Internal.BuiltinByteString
instance Data.ByteArray.Types.ByteArrayAccess PlutusTx.Builtins.Internal.BuiltinByteString
instance Data.ByteArray.Types.ByteArray PlutusTx.Builtins.Internal.BuiltinByteString
instance Prettyprinter.Internal.Pretty PlutusTx.Builtins.Internal.BuiltinByteString

module PlutusTx.Builtins.HasOpaque
stringToBuiltinByteString :: String -> BuiltinByteString
stringToBuiltinString :: String -> BuiltinString

-- | A class for converting values of transparent Haskell-defined built-in
--   types (such as <tt>()</tt>, <a>Bool</a>, '[]' etc) to their opaque
--   Plutus Tx counterparts. Instances for built-in types that are not
--   transparent are provided as well, simply as identities, since those
--   types are already opaque.
class HasToOpaque a arep | a -> arep
toOpaque :: HasToOpaque a arep => a -> arep
toOpaque :: (HasToOpaque a arep, a ~ arep) => a -> arep

-- | A class for converting values of opaque Plutus Tx types to their
--   transparent Haskell-defined counterparts (a.k.a. pattern-matchable)
--   built-in types (such as <tt>()</tt>, <a>Bool</a>, '[]' etc). If no
--   transparent counterpart exists, then the implementation is identity.
class HasFromOpaque arep a | arep -> a
fromOpaque :: HasFromOpaque arep a => arep -> a
fromOpaque :: (HasFromOpaque arep a, a ~ arep) => arep -> a

-- | The empty list of elements of the given type that gets spotted by the
--   plugin (grep for <a>mkNilOpaque</a> in the plugin code) and replaced
--   by the actual empty list constant for types that are supported (a
--   subset of built-in types).
mkNilOpaque :: BuiltinList a
class MkNil arep
mkNil :: MkNil arep => BuiltinList arep
instance PlutusTx.Builtins.HasOpaque.MkNil PlutusTx.Builtins.Internal.BuiltinInteger
instance PlutusTx.Builtins.HasOpaque.MkNil PlutusTx.Builtins.Internal.BuiltinBool
instance PlutusTx.Builtins.HasOpaque.MkNil PlutusTx.Builtins.Internal.BuiltinData
instance PlutusTx.Builtins.HasOpaque.MkNil (PlutusTx.Builtins.Internal.BuiltinPair PlutusTx.Builtins.Internal.BuiltinData PlutusTx.Builtins.Internal.BuiltinData)
instance (PlutusTx.Builtins.HasOpaque.HasToOpaque a arep, PlutusTx.Builtins.HasOpaque.MkNil arep) => PlutusTx.Builtins.HasOpaque.HasToOpaque [a] (PlutusTx.Builtins.Internal.BuiltinList arep)
instance PlutusTx.Builtins.HasOpaque.HasFromOpaque PlutusTx.Builtins.Internal.BuiltinInteger PlutusTx.Builtins.Internal.BuiltinInteger
instance PlutusTx.Builtins.HasOpaque.HasFromOpaque PlutusTx.Builtins.Internal.BuiltinByteString PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusTx.Builtins.HasOpaque.HasFromOpaque PlutusTx.Builtins.Internal.BuiltinString PlutusTx.Builtins.Internal.BuiltinString
instance PlutusTx.Builtins.HasOpaque.HasFromOpaque PlutusTx.Builtins.Internal.BuiltinUnit ()
instance PlutusTx.Builtins.HasOpaque.HasFromOpaque PlutusTx.Builtins.Internal.BuiltinBool GHC.Types.Bool
instance PlutusTx.Builtins.HasOpaque.HasFromOpaque arep a => PlutusTx.Builtins.HasOpaque.HasFromOpaque (PlutusTx.Builtins.Internal.BuiltinList arep) [a]
instance (PlutusTx.Builtins.HasOpaque.HasFromOpaque arep a, PlutusTx.Builtins.HasOpaque.HasFromOpaque brep b) => PlutusTx.Builtins.HasOpaque.HasFromOpaque (PlutusTx.Builtins.Internal.BuiltinPair arep brep) (a, b)
instance PlutusTx.Builtins.HasOpaque.HasFromOpaque PlutusTx.Builtins.Internal.BuiltinData PlutusTx.Builtins.Internal.BuiltinData
instance PlutusTx.Builtins.HasOpaque.HasFromOpaque PlutusTx.Builtins.Internal.BuiltinBLS12_381_G1_Element PlutusTx.Builtins.Internal.BuiltinBLS12_381_G1_Element
instance PlutusTx.Builtins.HasOpaque.HasFromOpaque PlutusTx.Builtins.Internal.BuiltinBLS12_381_G2_Element PlutusTx.Builtins.Internal.BuiltinBLS12_381_G2_Element
instance PlutusTx.Builtins.HasOpaque.HasFromOpaque PlutusTx.Builtins.Internal.BuiltinBLS12_381_MlResult PlutusTx.Builtins.Internal.BuiltinBLS12_381_MlResult
instance PlutusTx.Builtins.HasOpaque.HasToOpaque PlutusTx.Builtins.Internal.BuiltinInteger PlutusTx.Builtins.Internal.BuiltinInteger
instance PlutusTx.Builtins.HasOpaque.HasToOpaque PlutusTx.Builtins.Internal.BuiltinByteString PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusTx.Builtins.HasOpaque.HasToOpaque PlutusTx.Builtins.Internal.BuiltinString PlutusTx.Builtins.Internal.BuiltinString
instance PlutusTx.Builtins.HasOpaque.HasToOpaque () PlutusTx.Builtins.Internal.BuiltinUnit
instance PlutusTx.Builtins.HasOpaque.HasToOpaque GHC.Types.Bool PlutusTx.Builtins.Internal.BuiltinBool
instance PlutusTx.Builtins.HasOpaque.HasToOpaque (PlutusTx.Builtins.Internal.BuiltinData, PlutusTx.Builtins.Internal.BuiltinData) (PlutusTx.Builtins.Internal.BuiltinPair PlutusTx.Builtins.Internal.BuiltinData PlutusTx.Builtins.Internal.BuiltinData)
instance PlutusTx.Builtins.HasOpaque.HasToOpaque PlutusTx.Builtins.Internal.BuiltinData PlutusTx.Builtins.Internal.BuiltinData
instance PlutusTx.Builtins.HasOpaque.HasToOpaque PlutusTx.Builtins.Internal.BuiltinBLS12_381_G1_Element PlutusTx.Builtins.Internal.BuiltinBLS12_381_G1_Element
instance PlutusTx.Builtins.HasOpaque.HasToOpaque PlutusTx.Builtins.Internal.BuiltinBLS12_381_G2_Element PlutusTx.Builtins.Internal.BuiltinBLS12_381_G2_Element
instance PlutusTx.Builtins.HasOpaque.HasToOpaque PlutusTx.Builtins.Internal.BuiltinBLS12_381_MlResult PlutusTx.Builtins.Internal.BuiltinBLS12_381_MlResult
instance Data.String.IsString PlutusTx.Builtins.Internal.BuiltinByteString
instance Data.String.IsString PlutusTx.Builtins.Internal.BuiltinString

module PlutusTx.Builtins.HasBuiltin
useToOpaque :: a -> a
useFromOpaque :: a -> a

-- | A class for converting values of Haskell-defined built-in types to
--   their Plutus Tx counterparts.
class DefaultUni `Contains` a => HasToBuiltin a where {
    type ToBuiltin a;
}
toBuiltin :: HasToBuiltin a => a -> ToBuiltin a

-- | A class for converting values of Plutus Tx built-in types to their
--   Haskell-defined counterparts.
class HasToBuiltin (FromBuiltin arep) => HasFromBuiltin arep where {
    type FromBuiltin arep;
}
fromBuiltin :: HasFromBuiltin arep => arep -> FromBuiltin arep
instance PlutusTx.Builtins.HasBuiltin.HasFromBuiltin PlutusTx.Builtins.Internal.BuiltinInteger
instance PlutusTx.Builtins.HasBuiltin.HasFromBuiltin PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusTx.Builtins.HasBuiltin.HasFromBuiltin PlutusTx.Builtins.Internal.BuiltinString
instance PlutusTx.Builtins.HasBuiltin.HasFromBuiltin PlutusTx.Builtins.Internal.BuiltinUnit
instance PlutusTx.Builtins.HasBuiltin.HasFromBuiltin PlutusTx.Builtins.Internal.BuiltinBool
instance PlutusTx.Builtins.HasBuiltin.HasFromBuiltin a => PlutusTx.Builtins.HasBuiltin.HasFromBuiltin (PlutusTx.Builtins.Internal.BuiltinList a)
instance (PlutusTx.Builtins.HasBuiltin.HasFromBuiltin a, PlutusTx.Builtins.HasBuiltin.HasFromBuiltin b) => PlutusTx.Builtins.HasBuiltin.HasFromBuiltin (PlutusTx.Builtins.Internal.BuiltinPair a b)
instance PlutusTx.Builtins.HasBuiltin.HasFromBuiltin PlutusTx.Builtins.Internal.BuiltinData
instance PlutusTx.Builtins.HasBuiltin.HasFromBuiltin PlutusTx.Builtins.Internal.BuiltinBLS12_381_G1_Element
instance PlutusTx.Builtins.HasBuiltin.HasFromBuiltin PlutusTx.Builtins.Internal.BuiltinBLS12_381_G2_Element
instance PlutusTx.Builtins.HasBuiltin.HasFromBuiltin PlutusTx.Builtins.Internal.BuiltinBLS12_381_MlResult
instance PlutusTx.Builtins.HasBuiltin.HasToBuiltin GHC.Num.Integer.Integer
instance PlutusTx.Builtins.HasBuiltin.HasToBuiltin Data.ByteString.Internal.Type.ByteString
instance PlutusTx.Builtins.HasBuiltin.HasToBuiltin Data.Text.Internal.Text
instance PlutusTx.Builtins.HasBuiltin.HasToBuiltin ()
instance PlutusTx.Builtins.HasBuiltin.HasToBuiltin GHC.Types.Bool
instance PlutusTx.Builtins.HasBuiltin.HasToBuiltin a => PlutusTx.Builtins.HasBuiltin.HasToBuiltin [a]
instance (PlutusTx.Builtins.HasBuiltin.HasToBuiltin a, PlutusTx.Builtins.HasBuiltin.HasToBuiltin b) => PlutusTx.Builtins.HasBuiltin.HasToBuiltin (a, b)
instance PlutusTx.Builtins.HasBuiltin.HasToBuiltin PlutusCore.Data.Data
instance PlutusTx.Builtins.HasBuiltin.HasToBuiltin PlutusCore.Crypto.BLS12_381.G1.Element
instance PlutusTx.Builtins.HasBuiltin.HasToBuiltin PlutusCore.Crypto.BLS12_381.G2.Element
instance PlutusTx.Builtins.HasBuiltin.HasToBuiltin PlutusCore.Crypto.BLS12_381.Pairing.MlResult

module PlutusTx.Blueprint.Definition.Unroll

-- | Designates a class of types that could be used as a Blueprint
--   Definition. Each such type: - could be unrolled to a list of all
--   nested types (including the type itself). - has a unique
--   <a>DefinitionId</a>.
class HasBlueprintDefinition (t :: Type) where {
    type Unroll t :: [Type];
    type Unroll t = Insert t (GUnroll (IfStuckRep (RepIsStuckError t) (Rep t)));
}
definitionId :: HasBlueprintDefinition t => DefinitionId
definitionId :: (HasBlueprintDefinition t, Typeable t) => DefinitionId

-- | Compile-time error that happens when a type couldn't be unrolled
--   (<a>Unroll</a> TF is "stuck")
type family UnrollIsStuckError x

-- | Compile-time error that happens when type's generic representation is
--   not defined (<a>Rep</a> TF is "stuck")
type family RepIsStuckError x

-- | Same as <a>Unroll</a> but with a nicer error message
type Unrolled t = Reverse (IfStuckUnroll (UnrollIsStuckError t) (Unroll t))

-- | Unrolls all types in the list <tt>xs</tt>
type family UnrollAll xs :: [Type]

-- | Unroll a generic representation of a type into a list of all nested
--   types.
type family GUnroll (t :: Type -> Type) :: [Type]
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition GHC.Base.Void
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition ()
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition GHC.Types.Bool
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition GHC.Types.Int
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition GHC.Num.Integer.Integer
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusTx.Builtins.Internal.BuiltinData
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusTx.Builtins.Internal.BuiltinUnit
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusTx.Builtins.Internal.BuiltinString
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition a => PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition (PlutusTx.Builtins.Internal.BuiltinList a)
instance (PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition a, PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition b) => PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition (PlutusTx.Builtins.Internal.BuiltinPair a b)
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition a => PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition (GHC.Maybe.Maybe a)
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition a => PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition [a]
instance (PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition a, PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition b) => PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition (a, b)
instance (PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition a, PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition b, PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition c) => PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition (a, b, c)

module PlutusTx.Coverage
data CoverageAnnotation
CoverLocation :: CovLoc -> CoverageAnnotation
CoverBool :: CovLoc -> Bool -> CoverageAnnotation

-- | This type keeps track of all coverage annotations and where they have
--   been inserted / what annotations are expected to be found when
--   executing a piece of code.
newtype CoverageIndex
CoverageIndex :: Map CoverageAnnotation CoverageMetadata -> CoverageIndex
[_coverageMetadata] :: CoverageIndex -> Map CoverageAnnotation CoverageMetadata
newtype CoverageMetadata
CoverageMetadata :: Set Metadata -> CoverageMetadata
[_metadataSet] :: CoverageMetadata -> Set Metadata
data Metadata
ApplicationHeadSymbol :: String -> Metadata

-- | Location that is not interesting to cover. This is not generated by
--   the compiler, but can be added later using <a>addCoverageMetadata</a>.
IgnoredAnnotation :: Metadata
newtype CoverageData
CoverageData :: Set CoverageAnnotation -> CoverageData
[_coveredAnnotations] :: CoverageData -> Set CoverageAnnotation
data CoverageReport
CoverageReport :: CoverageIndex -> CoverageData -> CoverageReport
[_coverageIndex] :: CoverageReport -> CoverageIndex
[_coverageData] :: CoverageReport -> CoverageData

-- | A source location for coverage
data CovLoc
CovLoc :: String -> Int -> Int -> Int -> Int -> CovLoc
[_covLocFile] :: CovLoc -> String
[_covLocStartLine] :: CovLoc -> Int
[_covLocEndLine] :: CovLoc -> Int
[_covLocStartCol] :: CovLoc -> Int
[_covLocEndCol] :: CovLoc -> Int
covLocFile :: Lens' CovLoc String
covLocStartLine :: Lens' CovLoc Int
covLocEndLine :: Lens' CovLoc Int
covLocStartCol :: Lens' CovLoc Int
covLocEndCol :: Lens' CovLoc Int
metadataSet :: Iso' CoverageMetadata (Set Metadata)
coverageAnnotations :: Getter CoverageIndex (Set CoverageAnnotation)
ignoredAnnotations :: Getter CoverageIndex (Set CoverageAnnotation)
coverageMetadata :: Iso' CoverageIndex (Map CoverageAnnotation CoverageMetadata)
coveredAnnotations :: Iso' CoverageData (Set CoverageAnnotation)

-- | Add metadata to a coverage annotation. Does nothing if the annotation
--   is not in the index.
addCoverageMetadata :: CoverageAnnotation -> Metadata -> CoverageIndex -> CoverageIndex

-- | Include a location coverage annotation in the index
addLocationToCoverageIndex :: MonadWriter CoverageIndex m => CovLoc -> m CoverageAnnotation

-- | Include a boolean coverage annotation in the index
addBoolCaseToCoverageIndex :: MonadWriter CoverageIndex m => CovLoc -> Bool -> CoverageMetadata -> m CoverageAnnotation
coverageDataFromLogMsg :: String -> CoverageData
instance GHC.Base.Semigroup PlutusTx.Coverage.CoverageReport
instance GHC.Base.Monoid PlutusTx.Coverage.CoverageReport
instance Prettyprinter.Internal.Pretty PlutusTx.Coverage.CoverageReport
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Coverage.CoverageReport
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Coverage.CoverageReport
instance Control.DeepSeq.NFData PlutusTx.Coverage.CoverageReport
instance GHC.Generics.Generic PlutusTx.Coverage.CoverageReport
instance GHC.Show.Show PlutusTx.Coverage.CoverageReport
instance GHC.Classes.Eq PlutusTx.Coverage.CoverageReport
instance GHC.Classes.Ord PlutusTx.Coverage.CoverageReport
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Coverage.CoverageData
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Coverage.CoverageData
instance Control.DeepSeq.NFData PlutusTx.Coverage.CoverageData
instance GHC.Base.Monoid PlutusTx.Coverage.CoverageData
instance GHC.Base.Semigroup PlutusTx.Coverage.CoverageData
instance GHC.Generics.Generic PlutusTx.Coverage.CoverageData
instance GHC.Show.Show PlutusTx.Coverage.CoverageData
instance GHC.Classes.Eq PlutusTx.Coverage.CoverageData
instance GHC.Classes.Ord PlutusTx.Coverage.CoverageData
instance GHC.Base.Semigroup PlutusTx.Coverage.CoverageIndex
instance GHC.Base.Monoid PlutusTx.Coverage.CoverageIndex
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Coverage.CoverageIndex
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Coverage.CoverageIndex
instance Control.DeepSeq.NFData PlutusTx.Coverage.CoverageIndex
instance Flat.Class.Flat PlutusTx.Coverage.CoverageIndex
instance Codec.Serialise.Class.Serialise PlutusTx.Coverage.CoverageIndex
instance GHC.Generics.Generic PlutusTx.Coverage.CoverageIndex
instance GHC.Show.Show PlutusTx.Coverage.CoverageIndex
instance GHC.Classes.Eq PlutusTx.Coverage.CoverageIndex
instance GHC.Classes.Ord PlutusTx.Coverage.CoverageIndex
instance Prettyprinter.Internal.Pretty PlutusTx.Coverage.CoverageMetadata
instance Data.Aeson.Types.FromJSON.FromJSONKey PlutusTx.Coverage.CoverageAnnotation
instance Data.Aeson.Types.ToJSON.ToJSONKey PlutusTx.Coverage.CoverageAnnotation
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Coverage.CoverageAnnotation
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Coverage.CoverageAnnotation
instance Control.DeepSeq.NFData PlutusTx.Coverage.CoverageAnnotation
instance Flat.Class.Flat PlutusTx.Coverage.CoverageAnnotation
instance Codec.Serialise.Class.Serialise PlutusTx.Coverage.CoverageAnnotation
instance GHC.Generics.Generic PlutusTx.Coverage.CoverageAnnotation
instance GHC.Read.Read PlutusTx.Coverage.CoverageAnnotation
instance GHC.Show.Show PlutusTx.Coverage.CoverageAnnotation
instance GHC.Classes.Eq PlutusTx.Coverage.CoverageAnnotation
instance GHC.Classes.Ord PlutusTx.Coverage.CoverageAnnotation
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Coverage.Metadata
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Coverage.Metadata
instance Control.DeepSeq.NFData PlutusTx.Coverage.Metadata
instance Flat.Class.Flat PlutusTx.Coverage.Metadata
instance Codec.Serialise.Class.Serialise PlutusTx.Coverage.Metadata
instance GHC.Generics.Generic PlutusTx.Coverage.Metadata
instance GHC.Show.Show PlutusTx.Coverage.Metadata
instance GHC.Classes.Eq PlutusTx.Coverage.Metadata
instance GHC.Classes.Ord PlutusTx.Coverage.Metadata
instance Flat.Class.Flat PlutusTx.Coverage.CoverageMetadata
instance GHC.Base.Monoid PlutusTx.Coverage.CoverageMetadata
instance GHC.Base.Semigroup PlutusTx.Coverage.CoverageMetadata
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Coverage.CoverageMetadata
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Coverage.CoverageMetadata
instance Control.DeepSeq.NFData PlutusTx.Coverage.CoverageMetadata
instance Codec.Serialise.Class.Serialise PlutusTx.Coverage.CoverageMetadata
instance GHC.Generics.Generic PlutusTx.Coverage.CoverageMetadata
instance GHC.Show.Show PlutusTx.Coverage.CoverageMetadata
instance GHC.Classes.Eq PlutusTx.Coverage.CoverageMetadata
instance GHC.Classes.Ord PlutusTx.Coverage.CoverageMetadata
instance Prettyprinter.Internal.Pretty PlutusTx.Coverage.Metadata
instance Prettyprinter.Internal.Pretty PlutusTx.Coverage.CoverageAnnotation
instance Prettyprinter.Internal.Pretty PlutusTx.Coverage.CovLoc
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Coverage.CovLoc
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Coverage.CovLoc
instance Control.DeepSeq.NFData PlutusTx.Coverage.CovLoc
instance Flat.Class.Flat PlutusTx.Coverage.CovLoc
instance Codec.Serialise.Class.Serialise PlutusTx.Coverage.CovLoc
instance GHC.Generics.Generic PlutusTx.Coverage.CovLoc
instance GHC.Read.Read PlutusTx.Coverage.CovLoc
instance GHC.Show.Show PlutusTx.Coverage.CovLoc
instance GHC.Classes.Eq PlutusTx.Coverage.CovLoc
instance GHC.Classes.Ord PlutusTx.Coverage.CovLoc

module PlutusTx.Either

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data () => Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | Return <a>True</a> if the given value is a <a>Left</a>-value,
--   <a>False</a> otherwise.
isLeft :: Either a b -> Bool

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
isRight :: Either a b -> Bool

-- | Plutus Tx version of <a>either</a>
either :: (a -> c) -> (b -> c) -> Either a b -> c

module PlutusTx.Functor

-- | Plutus Tx version of <a>Functor</a>.
class Functor f

-- | Plutus Tx version of <a>fmap</a>.
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Plutus Tx version of <a>(&lt;$&gt;)</a>.
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Plutus Tx version of <a>(&lt;&amp;&gt;)</a>.
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | Plutus Tx version of <a>(&lt;$)</a>.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$
instance PlutusTx.Functor.Functor []
instance PlutusTx.Functor.Functor GHC.Maybe.Maybe
instance PlutusTx.Functor.Functor (Data.Either.Either c)
instance PlutusTx.Functor.Functor ((,) c)
instance PlutusTx.Functor.Functor Data.Functor.Identity.Identity
instance PlutusTx.Functor.Functor (Data.Functor.Const.Const m)

module PlutusTx.Integer

-- | Arbitrary precision integers. In contrast with fixed-size integral
--   types such as <a>Int</a>, the <a>Integer</a> type represents the
--   entire infinite range of integers.
--   
--   Integers are stored in a kind of sign-magnitude form, hence do not
--   expect two's complement form when using bit operations.
--   
--   If the value is small (fit into an <a>Int</a>), <a>IS</a> constructor
--   is used. Otherwise <a>Integer</a> and <a>IN</a> constructors are used
--   to store a <a>BigNat</a> representing respectively the positive or the
--   negative value magnitude.
--   
--   Invariant: <a>Integer</a> and <a>IN</a> are used iff value doesn't fit
--   in <a>IS</a>
data () => Integer


-- | Primitive names and functions for working with Plutus Core builtins.
module PlutusTx.Builtins

-- | An opaque type representing Plutus Core ByteStrings.
data BuiltinByteString

-- | Concatenates two <tt>ByteString</tt>s.
appendByteString :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString

-- | Adds a byte to the front of a <tt>ByteString</tt>.
consByteString :: Integer -> BuiltinByteString -> BuiltinByteString

-- | Returns the substring of a <tt>ByteString</tt> from index
--   <tt>start</tt> of length <tt>n</tt>.
sliceByteString :: Integer -> Integer -> BuiltinByteString -> BuiltinByteString

-- | Returns the length of a <tt>ByteString</tt>.
lengthOfByteString :: BuiltinByteString -> Integer

-- | Returns the byte of a <tt>ByteString</tt> at index.
indexByteString :: BuiltinByteString -> Integer -> Integer

-- | An empty <tt>ByteString</tt>.
emptyByteString :: BuiltinByteString

-- | Check if two <tt>ByteString</tt>s are equal.
equalsByteString :: BuiltinByteString -> BuiltinByteString -> Bool

-- | Check if one <tt>ByteString</tt> is less than another.
lessThanByteString :: BuiltinByteString -> BuiltinByteString -> Bool

-- | Check if one <tt>ByteString</tt> is less than or equal to another.
lessThanEqualsByteString :: BuiltinByteString -> BuiltinByteString -> Bool

-- | Check if one <tt>ByteString</tt> is greater than another.
greaterThanByteString :: BuiltinByteString -> BuiltinByteString -> Bool

-- | Check if one <tt>ByteString</tt> is greater than another.
greaterThanEqualsByteString :: BuiltinByteString -> BuiltinByteString -> Bool

-- | The SHA2-256 hash of a <tt>ByteString</tt>
sha2_256 :: BuiltinByteString -> BuiltinByteString

-- | The SHA3-256 hash of a <tt>ByteString</tt>
sha3_256 :: BuiltinByteString -> BuiltinByteString

-- | The BLAKE2B-224 hash of a <tt>ByteString</tt>
blake2b_224 :: BuiltinByteString -> BuiltinByteString

-- | The BLAKE2B-256 hash of a <tt>ByteString</tt>
blake2b_256 :: BuiltinByteString -> BuiltinByteString

-- | The KECCAK-256 hash of a <tt>ByteString</tt>
keccak_256 :: BuiltinByteString -> BuiltinByteString

-- | The RIPEMD-160 hash of a <tt>ByteString</tt>
ripemd_160 :: BuiltinByteString -> BuiltinByteString

-- | Ed25519 signature verification. Verify that the signature is a
--   signature of the message by the public key. This will fail if key or
--   the signature are not of the expected length.
verifyEd25519Signature :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString -> Bool

-- | Given an ECDSA SECP256k1 verification key, an ECDSA SECP256k1
--   signature, and an ECDSA SECP256k1 message hash (all as
--   <a>BuiltinByteString</a>s), verify the hash with that key and
--   signature.
--   
--   <h1>Note</h1>
--   
--   There are additional well-formation requirements for the arguments
--   beyond their length:
--   
--   <ul>
--   <li>The first byte of the public key must correspond to the sign of
--   the <i>y</i> coordinate: this is <tt>0x02</tt> if <i>y</i> is even,
--   and <tt>0x03</tt> otherwise.</li>
--   <li>The remaining bytes of the public key must correspond to the
--   <i>x</i> coordinate, as a big-endian integer.</li>
--   <li>The first 32 bytes of the signature must correspond to the
--   big-endian integer representation of _r_.</li>
--   <li>The last 32 bytes of the signature must correspond to the
--   big-endian integer representation of _s_.</li>
--   </ul>
--   
--   While this primitive <i>accepts</i> a hash, any caller should only
--   pass it hashes that they computed themselves: specifically, they
--   should receive the <i>message</i> from a sender and hash it, rather
--   than receiving the <i>hash</i> from said sender. Failure to do so can
--   be <a>dangerous</a>. Other than length, we make no requirements of
--   what hash gets used.
--   
--   <h1>See also</h1>
--   
--   <ul>
--   <li><a><tt>secp256k1_ec_pubkey_serialize</tt></a>; this implements the
--   format for the verification key that we accept, given a length
--   argument of 33 and the <tt>SECP256K1_EC_COMPRESSED</tt> flag.</li>
--   <li><a><tt>secp256k1_ecdsa_serialize_compact</tt></a>; this implements
--   the format for the signature that we accept.</li>
--   </ul>
verifyEcdsaSecp256k1Signature :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString -> Bool

-- | Given a Schnorr SECP256k1 verification key, a Schnorr SECP256k1
--   signature, and a message (all as <a>BuiltinByteString</a>s), verify
--   the message with that key and signature.
--   
--   <h1>Note</h1>
--   
--   There are additional well-formation requirements for the arguments
--   beyond their length. Throughout, we refer to co-ordinates of the point
--   <tt>R</tt>.
--   
--   <ul>
--   <li>The bytes of the public key must correspond to the <i>x</i>
--   coordinate, as a big-endian integer, as specified in BIP-340.</li>
--   <li>The first 32 bytes of the signature must correspond to the
--   <i>x</i> coordinate, as a big-endian integer, as specified in
--   BIP-340.</li>
--   <li>The last 32 bytes of the signature must correspond to the bytes of
--   <i>s</i>, as a big-endian integer, as specified in BIP-340.</li>
--   </ul>
--   
--   <h1>See also</h1>
--   
--   <ul>
--   <li><a>BIP-340</a></li>
--   <li><a><tt>secp256k1_xonly_pubkey_serialize</tt></a>; this implements
--   the format for the verification key that we accept.</li>
--   <li><a><tt>secp256k1_schnorrsig_sign</tt></a>; this implements the
--   signing logic for signatures this builtin can verify.</li>
--   </ul>
verifySchnorrSecp256k1Signature :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString -> Bool

-- | Converts a ByteString to a String.
decodeUtf8 :: BuiltinByteString -> BuiltinString

-- | Arbitrary precision integers. In contrast with fixed-size integral
--   types such as <a>Int</a>, the <a>Integer</a> type represents the
--   entire infinite range of integers.
--   
--   Integers are stored in a kind of sign-magnitude form, hence do not
--   expect two's complement form when using bit operations.
--   
--   If the value is small (fit into an <a>Int</a>), <a>IS</a> constructor
--   is used. Otherwise <a>Integer</a> and <a>IN</a> constructors are used
--   to store a <a>BigNat</a> representing respectively the positive or the
--   negative value magnitude.
--   
--   Invariant: <a>Integer</a> and <a>IN</a> are used iff value doesn't fit
--   in <a>IS</a>
data () => Integer

-- | Add two <a>Integer</a>s.
addInteger :: Integer -> Integer -> Integer

-- | Subtract two <a>Integer</a>s.
subtractInteger :: Integer -> Integer -> Integer

-- | Multiply two <a>Integer</a>s.
multiplyInteger :: Integer -> Integer -> Integer

-- | Divide two integers.
divideInteger :: Integer -> Integer -> Integer

-- | Integer modulo operation.
modInteger :: Integer -> Integer -> Integer

-- | Quotient of two integers.
quotientInteger :: Integer -> Integer -> Integer

-- | Take the remainder of dividing two <a>Integer</a>s.
remainderInteger :: Integer -> Integer -> Integer

-- | Check whether one <a>Integer</a> is greater than another.
greaterThanInteger :: Integer -> Integer -> Bool

-- | Check whether one <a>Integer</a> is greater than or equal to another.
greaterThanEqualsInteger :: Integer -> Integer -> Bool

-- | Check whether one <a>Integer</a> is less than another.
lessThanInteger :: Integer -> Integer -> Bool

-- | Check whether one <a>Integer</a> is less than or equal to another.
lessThanEqualsInteger :: Integer -> Integer -> Bool

-- | Check if two <a>Integer</a>s are equal.
equalsInteger :: Integer -> Integer -> Bool

-- | FIXME
--   
--   <h1>See also</h1>
--   
--   <ul>
--   <li><a>Operation description</a></li>
--   </ul>
expModInteger :: Integer -> Integer -> Integer -> Integer

-- | Aborts evaluation with an error.
error :: () -> a

-- | A type corresponding to the Plutus Core builtin equivalent of
--   <a>Data</a>.
--   
--   The point of this type is to be an opaque equivalent of <a>Data</a>,
--   so as to ensure that it is only used in ways that the compiler can
--   handle.
--   
--   As such, you should use this type in your on-chain code, and in any
--   data structures that you want to be representable on-chain.
--   
--   For off-chain usage, there are conversion functions
--   <a>builtinDataToData</a> and <a>dataToBuiltinData</a>, but note that
--   these will not work on-chain.
data BuiltinData

-- | Given five values for the five different constructors of
--   <a>BuiltinData</a>, selects one depending on which corresponds to the
--   actual constructor of the given value.
chooseData :: forall a. BuiltinData -> a -> a -> a -> a -> a -> a

-- | Given a <a>BuiltinData</a> value and matching functions for the five
--   constructors, applies the appropriate matcher to the arguments of the
--   constructor and returns the result.
matchData :: BuiltinData -> (Integer -> [BuiltinData] -> r) -> ([(BuiltinData, BuiltinData)] -> r) -> ([BuiltinData] -> r) -> (Integer -> r) -> (BuiltinByteString -> r) -> r

-- | Given a <a>BuiltinData</a> value and matching functions for the five
--   constructors, applies the appropriate matcher to the arguments of the
--   constructor and returns the result.
matchData' :: BuiltinData -> (Integer -> BuiltinList BuiltinData -> r) -> (BuiltinList (BuiltinPair BuiltinData BuiltinData) -> r) -> (BuiltinList BuiltinData -> r) -> (Integer -> r) -> (BuiltinByteString -> r) -> r

-- | Check if two <a>BuiltinData</a>s are equal.
equalsData :: BuiltinData -> BuiltinData -> Bool

-- | Convert a String into a ByteString.
serialiseData :: BuiltinData -> BuiltinByteString

-- | Constructs a <a>BuiltinData</a> value with the <tt>Constr</tt>
--   constructor.
mkConstr :: Integer -> [BuiltinData] -> BuiltinData

-- | Constructs a <a>BuiltinData</a> value with the <tt>Map</tt>
--   constructor.
mkMap :: [(BuiltinData, BuiltinData)] -> BuiltinData

-- | Constructs a <a>BuiltinData</a> value with the <tt>List</tt>
--   constructor.
mkList :: [BuiltinData] -> BuiltinData

-- | Constructs a <a>BuiltinData</a> value with the <tt>I</tt> constructor.
mkI :: Integer -> BuiltinData

-- | Constructs a <a>BuiltinData</a> value with the <tt>B</tt> constructor.
mkB :: BuiltinByteString -> BuiltinData

-- | Deconstructs a <a>BuiltinData</a> as a <tt>Constr</tt>, or fails if it
--   is not one.
unsafeDataAsConstr :: BuiltinData -> (Integer, [BuiltinData])

-- | Deconstructs a <a>BuiltinData</a> as a <tt>Map</tt>, or fails if it is
--   not one.
unsafeDataAsMap :: BuiltinData -> [(BuiltinData, BuiltinData)]

-- | Deconstructs a <a>BuiltinData</a> as a <tt>List</tt>, or fails if it
--   is not one.
unsafeDataAsList :: BuiltinData -> [BuiltinData]

-- | Deconstructs a <a>BuiltinData</a> as an <tt>I</tt>, or fails if it is
--   not one.
unsafeDataAsI :: BuiltinData -> Integer

-- | Deconstructs a <a>BuiltinData</a> as a <tt>B</tt>, or fails if it is
--   not one.
unsafeDataAsB :: BuiltinData -> BuiltinByteString

-- | Convert a <a>BuiltinData</a> into a <a>Data</a>. Only works off-chain.
builtinDataToData :: BuiltinData -> Data

-- | Convert a <a>Data</a> into a <a>BuiltinData</a>. Only works off-chain.
dataToBuiltinData :: Data -> BuiltinData
data BuiltinString

-- | Append two <tt>String</tt>s.
appendString :: BuiltinString -> BuiltinString -> BuiltinString

-- | An empty <tt>String</tt>.
emptyString :: BuiltinString

-- | Check if two strings are equal
equalsString :: BuiltinString -> BuiltinString -> Bool

-- | Convert a String into a ByteString.
encodeUtf8 :: BuiltinString -> BuiltinByteString

-- | Turn a builtin pair into a normal pair, useful in patterns.
pairToPair :: BuiltinPair a b -> (a, b)
mkNil :: MkNil arep => BuiltinList arep

-- | The empty list of elements of the given type that gets spotted by the
--   plugin (grep for <a>mkNilOpaque</a> in the plugin code) and replaced
--   by the actual empty list constant for types that are supported (a
--   subset of built-in types).
mkNilOpaque :: BuiltinList a
null :: forall a. BuiltinList a -> Bool
matchList :: forall a r. BuiltinList a -> (() -> r) -> (a -> BuiltinList a -> r) -> r

-- | Like <a>matchList</a> but evaluates <tt>nilCase</tt> strictly.
matchList' :: forall a r. BuiltinList a -> r -> (a -> BuiltinList a -> r) -> r
headMaybe :: BuiltinList a -> Maybe a
head :: BuiltinList a -> a
tail :: BuiltinList a -> BuiltinList a

-- | Uncons a builtin list, failing if the list is empty, useful in
--   patterns.
uncons :: BuiltinList a -> Maybe (a, BuiltinList a)

-- | Uncons a builtin list, failing if the list is empty, useful in
--   patterns.
unsafeUncons :: BuiltinList a -> (a, BuiltinList a)

-- | Emit the given string as a trace message before evaluating the
--   argument.
trace :: BuiltinString -> a -> a
data BuiltinBLS12_381_G1_Element
bls12_381_G1_equals :: BuiltinBLS12_381_G1_Element -> BuiltinBLS12_381_G1_Element -> Bool
bls12_381_G1_add :: BuiltinBLS12_381_G1_Element -> BuiltinBLS12_381_G1_Element -> BuiltinBLS12_381_G1_Element
bls12_381_G1_scalarMul :: Integer -> BuiltinBLS12_381_G1_Element -> BuiltinBLS12_381_G1_Element
bls12_381_G1_neg :: BuiltinBLS12_381_G1_Element -> BuiltinBLS12_381_G1_Element
bls12_381_G1_compress :: BuiltinBLS12_381_G1_Element -> BuiltinByteString
bls12_381_G1_uncompress :: BuiltinByteString -> BuiltinBLS12_381_G1_Element
bls12_381_G1_hashToGroup :: BuiltinByteString -> BuiltinByteString -> BuiltinBLS12_381_G1_Element
bls12_381_G1_compressed_zero :: BuiltinByteString
bls12_381_G1_compressed_generator :: BuiltinByteString
data BuiltinBLS12_381_G2_Element
bls12_381_G2_equals :: BuiltinBLS12_381_G2_Element -> BuiltinBLS12_381_G2_Element -> Bool
bls12_381_G2_add :: BuiltinBLS12_381_G2_Element -> BuiltinBLS12_381_G2_Element -> BuiltinBLS12_381_G2_Element
bls12_381_G2_scalarMul :: Integer -> BuiltinBLS12_381_G2_Element -> BuiltinBLS12_381_G2_Element
bls12_381_G2_neg :: BuiltinBLS12_381_G2_Element -> BuiltinBLS12_381_G2_Element
bls12_381_G2_compress :: BuiltinBLS12_381_G2_Element -> BuiltinByteString
bls12_381_G2_uncompress :: BuiltinByteString -> BuiltinBLS12_381_G2_Element
bls12_381_G2_hashToGroup :: BuiltinByteString -> BuiltinByteString -> BuiltinBLS12_381_G2_Element
bls12_381_G2_compressed_zero :: BuiltinByteString
bls12_381_G2_compressed_generator :: BuiltinByteString
data BuiltinBLS12_381_MlResult
bls12_381_millerLoop :: BuiltinBLS12_381_G1_Element -> BuiltinBLS12_381_G2_Element -> BuiltinBLS12_381_MlResult
bls12_381_mulMlResult :: BuiltinBLS12_381_MlResult -> BuiltinBLS12_381_MlResult -> BuiltinBLS12_381_MlResult
bls12_381_finalVerify :: BuiltinBLS12_381_MlResult -> BuiltinBLS12_381_MlResult -> Bool
fromOpaque :: HasFromOpaque arep a => arep -> a
toOpaque :: HasToOpaque a arep => a -> arep
useToOpaque :: a -> a
useFromOpaque :: a -> a
fromBuiltin :: HasFromBuiltin arep => arep -> FromBuiltin arep
toBuiltin :: HasToBuiltin a => a -> ToBuiltin a

-- | Byte ordering.
data () => ByteOrder

-- | most-significant-byte occurs in lowest address.
BigEndian :: ByteOrder

-- | least-significant-byte occurs in lowest address.
LittleEndian :: ByteOrder

-- | Convert a <tt>BuiltinInteger</tt> into a <a>BuiltinByteString</a>, as
--   described in <a>CIP-121</a>. The first argument indicates the
--   endianness of the conversion and the third argument is the integer to
--   be converted, which must be non-negative. The second argument must
--   also be non-negative and it indicates the required width of the
--   output. If the width is zero then the output is the smallest
--   bytestring which can contain the converted input (and in this case,
--   the integer 0 encodes to the empty bytestring). If the width is
--   nonzero then the output bytestring will be padded to the required
--   width with 0x00 bytes (on the left for big-endian conversions and on
--   the right for little-endian conversions); if the input integer is too
--   big to fit into a bytestring of the specified width then the
--   conversion will fail. Conversion will also fail if the specified width
--   is greater than 8192 or the input integer is too big to fit into a
--   bytestring of length 8192.
integerToByteString :: ByteOrder -> Integer -> Integer -> BuiltinByteString

-- | Convert a <a>BuiltinByteString</a> to a <tt>BuiltinInteger</tt>, as
--   described in <a>CIP-121</a>. The first argument indicates the
--   endianness of the conversion and the second is the bytestring to be
--   converted. There is no limitation on the size of the bytestring. The
--   empty bytestring is converted to the integer 0.
byteStringToInteger :: ByteOrder -> BuiltinByteString -> Integer

-- | Perform logical AND on two <a>BuiltinByteString</a> arguments, as
--   described in <a>CIP-122</a>.
--   
--   The first argument indicates whether padding semantics should be used
--   or not; if <a>False</a>, truncation semantics will be used instead.
--   
--   <h1>See also</h1>
--   
--   <ul>
--   <li><a>Padding and truncation semantics</a></li>
--   <li><a>Bit indexing scheme</a></li>
--   </ul>
andByteString :: Bool -> BuiltinByteString -> BuiltinByteString -> BuiltinByteString

-- | Perform logical OR on two <a>BuiltinByteString</a> arguments, as
--   described <a>here</a>.
--   
--   The first argument indicates whether padding semantics should be used
--   or not; if <a>False</a>, truncation semantics will be used instead.
--   
--   <h1>See also</h1>
--   
--   <ul>
--   <li><a>Padding and truncation semantics</a></li>
--   <li><a>Bit indexing scheme</a></li>
--   </ul>
orByteString :: Bool -> BuiltinByteString -> BuiltinByteString -> BuiltinByteString

-- | Perform logical XOR on two <a>BuiltinByteString</a> arguments, as
--   described <a>here</a>.
--   
--   The first argument indicates whether padding semantics should be used
--   or not; if <a>False</a>, truncation semantics will be used instead.
--   
--   <h1>See also</h1>
--   
--   <ul>
--   <li><a>Padding and truncation semantics</a></li>
--   <li><a>Bit indexing scheme</a></li>
--   </ul>
xorByteString :: Bool -> BuiltinByteString -> BuiltinByteString -> BuiltinByteString

-- | Perform logical complement on a <a>BuiltinByteString</a>, as described
--   <a>here</a>.
--   
--   <h1>See also</h1>
--   
--   <ul>
--   <li><a>Bit indexing scheme</a></li>
--   </ul>
complementByteString :: BuiltinByteString -> BuiltinByteString

-- | Read a bit at the _bit_ index given by the <a>Integer</a> argument in
--   the <a>BuiltinByteString</a> argument. The result will be <a>True</a>
--   if the corresponding bit is set, and <a>False</a> if it is clear. Will
--   error if given an out-of-bounds index argument; that is, if the index
--   is either negative, or equal to or greater than the total number of
--   bits in the <a>BuiltinByteString</a> argument.
--   
--   <h1>See also</h1>
--   
--   <ul>
--   <li><a>Bit indexing scheme</a></li>
--   <li><a>Operation description</a></li>
--   </ul>
readBit :: BuiltinByteString -> Integer -> Bool

-- | Given a <a>BuiltinByteString</a>, a list of indexes to change, and a
--   boolean value <tt>b</tt> to change those indexes to, set the
--   <i>bit</i> at each of the specified index as follows:
--   
--   <ul>
--   <li>If <tt>b</tt> is <a>True</a>, set that bit;</li>
--   <li>Otherwise, clear that bit.</li>
--   </ul>
--   
--   Will error if any of the indexes are out-of-bounds: that is, if the
--   index is either negative, or equal to or greater than the total number
--   of bits in the <a>BuiltinByteString</a> argument.
--   
--   <h1>Note</h1>
--   
--   This differs slightly from the description of the <a>corresponding
--   operation in CIP-122</a>; instead of a single changelist argument
--   comprised of pairs, we instead pass a single list of indexes to
--   change, and a single boolean value to change those indexes to. The
--   original proposal allowed one to set and clear bits in a single
--   operation, but constructing the list of boolean values for the updates
--   was somewhat expensive. If it's really necessary to set some bits and
--   clear others then it is easier to call the function twice, once to set
--   bits and and once to clear them.
--   
--   <h1>See also</h1>
--   
--   <ul>
--   <li><a>Bit indexing scheme</a></li>
--   <li><a>Operation description</a></li>
--   </ul>
writeBits :: BuiltinByteString -> [Integer] -> Bool -> BuiltinByteString

-- | Given a length (first argument) and a byte (second argument), produce
--   a <a>BuiltinByteString</a> of that length, with that byte in every
--   position. Will error if given a negative length, or a second argument
--   that isn't a byte (less than 0, greater than 255).
--   
--   <h1>See also</h1>
--   
--   <ul>
--   <li><a>Operation description</a></li>
--   </ul>
replicateByte :: Integer -> Integer -> BuiltinByteString

-- | Shift a <a>BuiltinByteString</a>, as per <a>CIP-123</a>.
shiftByteString :: BuiltinByteString -> Integer -> BuiltinByteString

-- | Rotate a <a>BuiltinByteString</a>, as per <a>CIP-123</a>.
rotateByteString :: BuiltinByteString -> Integer -> BuiltinByteString

-- | Count the set bits in a <a>BuiltinByteString</a>, as per
--   <a>CIP-123</a>.
countSetBits :: BuiltinByteString -> Integer

-- | Find the lowest index of a set bit in a <a>BuiltinByteString</a>, as
--   per <a>CIP-123</a>.
--   
--   If given a <a>BuiltinByteString</a> which consists only of zero bytes
--   (including the empty <a>BuiltinByteString</a>, this returns
--   <tt>-1</tt>.
findFirstSetBit :: BuiltinByteString -> Integer

module PlutusTx.ErrorCodes

-- | All error codes used in the plutus prelude associated with a
--   human-readable description.
plutusPreludeErrorCodes :: Map BuiltinString String

-- | The error happens in TH generation of indexed data
reconstructCaseError :: BuiltinString

-- | Error case of <tt>unsafeFromBuiltinData</tt>
voidIsNotSupportedError :: BuiltinString

-- | Ratio number can't have a zero denominator
ratioHasZeroDenominatorError :: BuiltinString

-- | <tt>check</tt> input is <tt>False</tt>
checkHasFailedError :: BuiltinString

-- | PlutusTx.List.!!: negative index
negativeIndexError :: BuiltinString

-- | PlutusTx.List.!!: index too large
indexTooLargeError :: BuiltinString

-- | PlutusTx.List.head: empty list
headEmptyListError :: BuiltinString

-- | PlutusTx.List.tail: empty list
tailEmptyListError :: BuiltinString

-- | PlutusTx.Enum.().succ: bad argument
succVoidBadArgumentError :: BuiltinString

-- | PlutusTx.Enum.().pred: bad argument
predVoidBadArgumentError :: BuiltinString

-- | PlutusTx.Enum.().toEnum: bad argument
toEnumVoidBadArgumentError :: BuiltinString

-- | PlutusTx.Enum.Bool.succ: bad argument
succBoolBadArgumentError :: BuiltinString

-- | PlutusTx.Enum.Bool.pred: bad argument
predBoolBadArgumentError :: BuiltinString

-- | PlutusTx.Enum.Bool.toEnum: bad argument
toEnumBoolBadArgumentError :: BuiltinString

-- | PlutusTx.Enum.Ordering.succ: bad argument
succOrderingBadArgumentError :: BuiltinString

-- | PlutusTx.Enum.Ordering.pred: bad argument
predOrderingBadArgumentError :: BuiltinString

-- | PlutusTx.Enum.Ordering.toEnum: bad argument
toEnumOrderingBadArgumentError :: BuiltinString

-- | PlutusTx.List.last: empty list
lastEmptyListError :: BuiltinString

-- | PlutusTx.Ratio.recip: reciprocal of zero
reciprocalOfZeroError :: BuiltinString

-- | PlutusTx.List.indexBuiltinList: negative index
builtinListNegativeIndexError :: BuiltinString

-- | PlutusTx.List.indexBuiltinList: index too large
builtinListIndexTooLargeError :: BuiltinString

module PlutusTx.Blueprint.Class

-- | A class of types that have a Blueprint schema definition and can
--   reference other schema definitions of other types.
class HasBlueprintSchema (t :: Type) (referencedTypes :: [Type])
schema :: HasBlueprintSchema t referencedTypes => Schema referencedTypes
instance PlutusTx.Blueprint.Class.HasBlueprintSchema GHC.Types.Int referencedTypes
instance PlutusTx.Blueprint.Class.HasBlueprintSchema GHC.Num.Integer.Integer referencedTypes
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusTx.Builtins.Internal.BuiltinData referencedTypes
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusTx.Builtins.Internal.BuiltinUnit referencedTypes
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusTx.Builtins.Internal.BuiltinBool referencedTypes
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusTx.Builtins.Internal.BuiltinString referencedTypes
instance PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusTx.Builtins.Internal.BuiltinByteString referencedTypes
instance PlutusTx.Blueprint.Class.HasBlueprintSchema Data.ByteString.Internal.Type.ByteString referencedTypes
instance PlutusTx.Blueprint.Class.HasBlueprintSchema a referencedTypes => PlutusTx.Blueprint.Class.HasBlueprintSchema [a] referencedTypes
instance PlutusTx.Blueprint.Class.HasBlueprintSchema a referencedTypes => PlutusTx.Blueprint.Class.HasBlueprintSchema (PlutusTx.Builtins.Internal.BuiltinList a) referencedTypes
instance (PlutusTx.Blueprint.Class.HasBlueprintSchema a referencedTypes, PlutusTx.Blueprint.Class.HasBlueprintSchema b referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema (PlutusTx.Builtins.Internal.BuiltinPair a b) referencedTypes

module PlutusTx.Blueprint.Definition.Derive

-- | Derive a <a>Definitions</a> value for a list of types.
deriveDefinitions :: forall ts. DefinitionsFor (UnrollAll ts) => Definitions (UnrollAll ts)

-- | Construct a <a>Schema</a> that is a reference to a schema definition.
definitionRef :: forall t ts. HasBlueprintDefinition t => Schema ts

-- | This class and its two instances are used internally to derive
--   <a>Definitions</a> for a given list of types.
type DefinitionsFor ts = DefinitionsFor' ts ts
definitionsFor :: forall ts. DefinitionsFor ts => Definitions ts
class DefinitionsFor' referencedTypes acc
definitionsFor' :: DefinitionsFor' referencedTypes acc => Definitions referencedTypes
instance PlutusTx.Blueprint.Definition.Derive.DefinitionsFor' referencedTypes '[]
instance (PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition t, PlutusTx.Blueprint.Class.HasBlueprintSchema t referencedTypes, PlutusTx.Blueprint.Definition.Derive.DefinitionsFor' referencedTypes ts) => PlutusTx.Blueprint.Definition.Derive.DefinitionsFor' referencedTypes (t : ts)


-- | This module provides a functionality to derive and reference schema
--   definitions.
module PlutusTx.Blueprint.Definition

module PlutusTx.Blueprint.Contract

-- | A blueprint of a smart contract, as defined by the CIP-0057
--   
--   The <tt>referencedTypes</tt> type variable is used to track the types
--   used in the contract making sure their schemas are included in the
--   blueprint and that they are referenced in a type-safe way. See Note
--   [<a>Unrolling</a> types] for more details.
data ContractBlueprint
[MkContractBlueprint] :: forall referencedTypes. Maybe Text -> Preamble -> Set (ValidatorBlueprint referencedTypes) -> Definitions referencedTypes -> ContractBlueprint
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Blueprint.Contract.ContractBlueprint

module PlutusTx.Blueprint.Write
encodeBlueprint :: ContractBlueprint -> ByteString
writeBlueprint :: FilePath -> ContractBlueprint -> IO ()

module PlutusTx.Blueprint

module PlutusTx.Lift.Class

-- | Class for types which have a corresponding Plutus IR type. Instances
--   should always be derived, do not write your own instance!
class Typeable uni (a :: k)

-- | Get the Plutus IR type corresponding to this type.
typeRep :: Typeable uni a => Proxy a -> RTCompile uni fun (Type TyName uni ())

-- | Class for types which can be lifted into Plutus IR. Instances should
--   be derived, do not write your own instance!
class Lift uni a

-- | Get a Plutus IR term corresponding to the given value.
lift :: Lift uni a => a -> RTCompile uni fun (Term TyName Name uni fun ())
type RTCompile uni fun = DefT Name uni fun () Quote
instance (TypeError ...) => PlutusTx.Lift.Class.Lift uni GHC.Types.Int
instance PlutusCore.Core.Type.HasTermLevel uni GHC.Num.Integer.Integer => PlutusTx.Lift.Class.Lift uni PlutusTx.Builtins.Internal.BuiltinInteger
instance PlutusCore.Core.Type.HasTermLevel uni Data.ByteString.Internal.Type.ByteString => PlutusTx.Lift.Class.Lift uni PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusCore.Core.Type.HasTermLevel uni Data.Text.Internal.Text => PlutusTx.Lift.Class.Lift uni PlutusTx.Builtins.Internal.BuiltinString
instance PlutusCore.Core.Type.HasTermLevel uni () => PlutusTx.Lift.Class.Lift uni PlutusTx.Builtins.Internal.BuiltinUnit
instance PlutusCore.Core.Type.HasTermLevel uni GHC.Types.Bool => PlutusTx.Lift.Class.Lift uni PlutusTx.Builtins.Internal.BuiltinBool
instance (PlutusTx.Builtins.HasBuiltin.HasFromBuiltin arep, PlutusCore.Core.Type.HasTermLevel uni [PlutusTx.Builtins.HasBuiltin.FromBuiltin arep]) => PlutusTx.Lift.Class.Lift uni (PlutusTx.Builtins.Internal.BuiltinList arep)
instance (PlutusTx.Builtins.HasBuiltin.HasFromBuiltin arep, PlutusTx.Builtins.HasBuiltin.HasFromBuiltin brep, PlutusCore.Core.Type.HasTermLevel uni (PlutusTx.Builtins.HasBuiltin.FromBuiltin arep, PlutusTx.Builtins.HasBuiltin.FromBuiltin brep)) => PlutusTx.Lift.Class.Lift uni (PlutusTx.Builtins.Internal.BuiltinPair arep brep)
instance PlutusCore.Core.Type.HasTermLevel uni PlutusCore.Data.Data => PlutusTx.Lift.Class.Lift uni PlutusTx.Builtins.Internal.BuiltinData
instance PlutusCore.Core.Type.HasTermLevel uni PlutusCore.Crypto.BLS12_381.G1.Element => PlutusTx.Lift.Class.Lift uni PlutusTx.Builtins.Internal.BuiltinBLS12_381_G1_Element
instance PlutusCore.Core.Type.HasTermLevel uni PlutusCore.Crypto.BLS12_381.G2.Element => PlutusTx.Lift.Class.Lift uni PlutusTx.Builtins.Internal.BuiltinBLS12_381_G2_Element
instance PlutusCore.Core.Type.HasTermLevel uni PlutusCore.Crypto.BLS12_381.Pairing.MlResult => PlutusTx.Lift.Class.Lift uni PlutusTx.Builtins.Internal.BuiltinBLS12_381_MlResult
instance forall (uni :: * -> *) k (f :: * -> k) a. (PlutusTx.Lift.Class.Typeable uni f, PlutusTx.Lift.Class.Typeable uni a) => PlutusTx.Lift.Class.Typeable uni (f a)
instance PlutusTx.Lift.Class.Typeable uni (->)
instance (TypeError ...) => PlutusTx.Lift.Class.Typeable uni GHC.Types.Int
instance PlutusCore.Builtin.KnownTypeAst.HasTypeLevel uni GHC.Num.Integer.Integer => PlutusTx.Lift.Class.Typeable uni PlutusTx.Builtins.Internal.BuiltinInteger
instance PlutusCore.Builtin.KnownTypeAst.HasTypeLevel uni Data.ByteString.Internal.Type.ByteString => PlutusTx.Lift.Class.Typeable uni PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusCore.Builtin.KnownTypeAst.HasTypeLevel uni Data.Text.Internal.Text => PlutusTx.Lift.Class.Typeable uni PlutusTx.Builtins.Internal.BuiltinString
instance PlutusCore.Builtin.KnownTypeAst.HasTypeLevel uni () => PlutusTx.Lift.Class.Typeable uni PlutusTx.Builtins.Internal.BuiltinUnit
instance PlutusCore.Builtin.KnownTypeAst.HasTypeLevel uni GHC.Types.Bool => PlutusTx.Lift.Class.Typeable uni PlutusTx.Builtins.Internal.BuiltinBool
instance PlutusCore.Builtin.KnownTypeAst.HasTypeLevel uni [] => PlutusTx.Lift.Class.Typeable uni PlutusTx.Builtins.Internal.BuiltinList
instance PlutusCore.Builtin.KnownTypeAst.HasTypeLevel uni (,) => PlutusTx.Lift.Class.Typeable uni PlutusTx.Builtins.Internal.BuiltinPair
instance PlutusCore.Builtin.KnownTypeAst.HasTypeLevel uni PlutusCore.Data.Data => PlutusTx.Lift.Class.Typeable uni PlutusTx.Builtins.Internal.BuiltinData
instance PlutusCore.Builtin.KnownTypeAst.HasTypeLevel uni PlutusCore.Crypto.BLS12_381.G1.Element => PlutusTx.Lift.Class.Typeable uni PlutusTx.Builtins.Internal.BuiltinBLS12_381_G1_Element
instance PlutusCore.Builtin.KnownTypeAst.HasTypeLevel uni PlutusCore.Crypto.BLS12_381.G2.Element => PlutusTx.Lift.Class.Typeable uni PlutusTx.Builtins.Internal.BuiltinBLS12_381_G2_Element
instance PlutusCore.Builtin.KnownTypeAst.HasTypeLevel uni PlutusCore.Crypto.BLS12_381.Pairing.MlResult => PlutusTx.Lift.Class.Typeable uni PlutusTx.Builtins.Internal.BuiltinBLS12_381_MlResult

module PlutusTx.These

-- | A <a>These</a> <tt>a</tt> <tt>b</tt> is either an <tt>a</tt>, or a
--   <tt>b</tt> or an <tt>a</tt> and a <tt>b</tt>. Plutus version of
--   <a>These</a>.
data These a b
This :: a -> These a b
That :: b -> These a b
These :: a -> b -> These a b
these :: (a -> c) -> (b -> c) -> (a -> b -> c) -> These a b -> c

-- | Consume a 'These a b' value.
theseWithDefault :: a -> b -> (a -> b -> c) -> These a b -> c
instance (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b) => PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition (PlutusTx.These.These a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (PlutusTx.These.These a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (PlutusTx.These.These a b)
instance GHC.Generics.Generic (PlutusTx.These.These a b)

module PlutusTx.Eq

-- | The <a>Eq</a> class defines equality (<a>==</a>).
class Eq a
(==) :: Eq a => a -> a -> Bool
infix 4 ==
(/=) :: Eq a => a -> a -> Bool
infix 4 /=
instance PlutusTx.Eq.Eq GHC.Num.Integer.Integer
instance PlutusTx.Eq.Eq PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusTx.Eq.Eq PlutusTx.Builtins.Internal.BuiltinData
instance PlutusTx.Eq.Eq PlutusTx.Builtins.Internal.BuiltinString
instance PlutusTx.Eq.Eq PlutusTx.Builtins.Internal.BuiltinBLS12_381_G1_Element
instance PlutusTx.Eq.Eq PlutusTx.Builtins.Internal.BuiltinBLS12_381_G2_Element
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq [a]
instance PlutusTx.Eq.Eq GHC.Types.Bool
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (GHC.Maybe.Maybe a)
instance (PlutusTx.Eq.Eq a, PlutusTx.Eq.Eq b) => PlutusTx.Eq.Eq (Data.Either.Either a b)
instance PlutusTx.Eq.Eq ()
instance (PlutusTx.Eq.Eq a, PlutusTx.Eq.Eq b) => PlutusTx.Eq.Eq (a, b)
instance (PlutusTx.Eq.Eq a, PlutusTx.Eq.Eq b) => PlutusTx.Eq.Eq (PlutusTx.These.These a b)

module PlutusTx.Ord

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 <
infix 4 <=
infix 4 >
infix 4 >=
data () => Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering
instance PlutusTx.Ord.Ord GHC.Num.Integer.Integer
instance PlutusTx.Ord.Ord PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusTx.Ord.Ord a => PlutusTx.Ord.Ord [a]
instance PlutusTx.Ord.Ord GHC.Types.Bool
instance PlutusTx.Ord.Ord a => PlutusTx.Ord.Ord (GHC.Maybe.Maybe a)
instance (PlutusTx.Ord.Ord a, PlutusTx.Ord.Ord b) => PlutusTx.Ord.Ord (Data.Either.Either a b)
instance PlutusTx.Ord.Ord ()
instance (PlutusTx.Ord.Ord a, PlutusTx.Ord.Ord b) => PlutusTx.Ord.Ord (a, b)
instance (PlutusTx.Ord.Ord a, PlutusTx.Ord.Ord b) => PlutusTx.Ord.Ord (PlutusTx.These.These a b)
instance PlutusTx.Eq.Eq GHC.Types.Ordering

module PlutusTx.Trace

-- | Emit the given string as a trace message before evaluating the
--   argument.
trace :: BuiltinString -> a -> a

-- | Log a message and then terminate the evaluation with an error.
traceError :: BuiltinString -> a

-- | Emit the given <a>BuiltinString</a> only if the argument evaluates to
--   <a>False</a>.
traceIfFalse :: BuiltinString -> Bool -> Bool

-- | Emit the given <a>BuiltinString</a> only if the argument evaluates to
--   <a>True</a>.
traceIfTrue :: BuiltinString -> Bool -> Bool

-- | Emit one of two <a>BuiltinString</a> depending on whether or not the
--   argument evaluates to <a>True</a> or <a>False</a>.
traceBool :: BuiltinString -> BuiltinString -> Bool -> Bool

module PlutusTx.List

-- | Plutus Tx version of <a>uncons</a>.
uncons :: [a] -> Maybe (a, [a])

-- | Test whether a list is empty.
null :: [a] -> Bool

-- | Plutus Tx version of <a>map</a>.
--   
--   <pre>
--   &gt;&gt;&gt; map (\i -&gt; i + 1) [1, 2, 3]
--   [2,3,4]
--   </pre>
map :: forall a b. (a -> b) -> [a] -> [b]

-- | Returns the conjunction of a list of Bools.
and :: [Bool] -> Bool

-- | Returns the disjunction of a list of Bools.
or :: [Bool] -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
any :: forall a. (a -> Bool) -> [a] -> Bool

-- | Determines whether all elements of the list satisfy the predicate.
all :: forall a. (a -> Bool) -> [a] -> Bool

-- | Does the element occur in the list?
elem :: Eq a => a -> [a] -> Bool

-- | The negation of <a>elem</a>.
notElem :: Eq a => a -> [a] -> Bool

-- | Returns the leftmost element matching the predicate, or <a>Nothing</a>
--   if there's no such element.
find :: forall a. (a -> Bool) -> [a] -> Maybe a

-- | Plutus Tx version of <a>filter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; filter (&gt; 1) [1, 2, 3, 4]
--   [2,3,4]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | Plutus Tx version of <a>listToMaybe</a>.
listToMaybe :: [a] -> Maybe a

-- | Return the element in the list, if there is precisely one.
uniqueElement :: [a] -> Maybe a

-- | Plutus Tx version of <a>findIndices</a>.
findIndices :: (a -> Bool) -> [a] -> [Integer]

-- | Plutus Tx version of <a>findIndex</a>.
findIndex :: (a -> Bool) -> [a] -> Maybe Integer

-- | Plutus Tx version of <a>foldr</a>.
--   
--   <pre>
--   &gt;&gt;&gt; foldr (\i s -&gt; s + i) 0 [1, 2, 3, 4]
--   10
--   </pre>
foldr :: forall a b. (a -> b -> b) -> b -> [a] -> b

-- | Plutus Tx velsion of <a>foldl</a>.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\s i -&gt; s + i) 0 [1, 2, 3, 4]
--   10
--   </pre>
foldl :: forall a b. (b -> a -> b) -> b -> [a] -> b

-- | Cons each element of the first list to the second one in reverse order
--   (i.e. the last element of the first list is the head of the result).
--   
--   <pre>
--   revAppend xs ys === reverse xs ++ ys
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; revAppend "abc" "de"
--   "cbade"
--   </pre>
revAppend :: forall a. [a] -> [a] -> [a]

-- | Plutus Tx version of <a>reverse</a>.
reverse :: [a] -> [a]

-- | Plutus Tx version of <a>concat</a>.
--   
--   <pre>
--   &gt;&gt;&gt; concat [[1, 2], [3], [4, 5]]
--   [1,2,3,4,5]
--   </pre>
concat :: [[a]] -> [a]

-- | Plutus Tx version of <a>concatMap</a>.
concatMap :: (a -> [b]) -> [a] -> [b]

-- | Plutus Tx version of <a>zip</a>.
zip :: [a] -> [b] -> [(a, b)]

-- | Plutus Tx version of <a>unzip</a>.
unzip :: [(a, b)] -> ([a], [b])

-- | Plutus Tx version of <a>(++)</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [0, 1, 2] ++ [1, 2, 3, 4]
--   [0,1,2,1,2,3,4]
--   </pre>
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | Plutus Tx version of <a>(!!)</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [10, 11, 12] !! 2
--   12
--   </pre>
(!!) :: forall a. [a] -> Integer -> a
infixl 9 !!

-- | Index operator for builtin lists.
--   
--   <pre>
--   &gt;&gt;&gt; indexBuiltinList (toBuiltin [10, 11, 12]) 2
--   12
--   </pre>
indexBuiltinList :: forall a. BuiltinList a -> Integer -> a

-- | Plutus Tx version of <a>head</a>.
head :: [a] -> a

-- | Plutus Tx version of <a>last</a>.
last :: [a] -> a

-- | Plutus Tx version of <a>tail</a>.
tail :: [a] -> [a]

-- | Plutus Tx version of <a>take</a>.
take :: Integer -> [a] -> [a]

-- | Plutus Tx version of <a>drop</a>.
drop :: Integer -> [a] -> [a]

-- | Plutus Tx version of <a>splitAt</a>.
splitAt :: Integer -> [a] -> ([a], [a])

-- | Plutus Tx version of <a>nub</a>.
nub :: Eq a => [a] -> [a]

-- | Plutus Tx version of <a>nubBy</a>.
nubBy :: (a -> a -> Bool) -> [a] -> [a]

-- | Plutus Tx version of <a>zipWith</a>.
zipWith :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]

-- | Plutus Tx version of <a>dropWhile</a>.
dropWhile :: forall a. (a -> Bool) -> [a] -> [a]

-- | Plutus Tx version of <a>replicate</a>.
replicate :: forall a. Integer -> a -> [a]

-- | Plutus Tx version of <a>partition</a>.
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | Plutus Tx version of <a>sort</a>.
sort :: Ord a => [a] -> [a]

-- | Plutus Tx version of <a>sortBy</a>.
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

module PlutusTx.Semigroup

-- | Plutus Tx version of <a>Semigroup</a>.
class Semigroup a

-- | Plutus Tx version of <a>(&lt;&gt;)</a>.
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>
newtype Max a
Max :: a -> Max a
[getMax] :: Max a -> a
newtype Min a
Min :: a -> Min a
[getMin] :: Min a -> a
instance PlutusTx.Functor.Functor PlutusTx.Semigroup.Min
instance PlutusTx.Ord.Ord a => PlutusTx.Semigroup.Semigroup (PlutusTx.Semigroup.Min a)
instance PlutusTx.Functor.Functor PlutusTx.Semigroup.Max
instance PlutusTx.Ord.Ord a => PlutusTx.Semigroup.Semigroup (PlutusTx.Semigroup.Max a)
instance PlutusTx.Semigroup.Semigroup PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusTx.Semigroup.Semigroup PlutusTx.Builtins.Internal.BuiltinString
instance PlutusTx.Semigroup.Semigroup [a]
instance (PlutusTx.Semigroup.Semigroup a, PlutusTx.Semigroup.Semigroup b) => PlutusTx.Semigroup.Semigroup (a, b)
instance PlutusTx.Semigroup.Semigroup a => PlutusTx.Semigroup.Semigroup (GHC.Maybe.Maybe a)
instance PlutusTx.Semigroup.Semigroup GHC.Types.Ordering
instance PlutusTx.Semigroup.Semigroup ()
instance PlutusTx.Semigroup.Semigroup a => PlutusTx.Semigroup.Semigroup (Data.Semigroup.Internal.Dual a)
instance PlutusTx.Semigroup.Semigroup (Data.Semigroup.Internal.Endo a)
instance PlutusTx.Semigroup.Semigroup (Data.Monoid.First a)

module PlutusTx.Maybe

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data () => Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a

-- | Check if a <a>Maybe</a> <tt>a</tt> is <tt>Just a</tt>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   
--   &gt;&gt;&gt; isJust (Just "plutus")
--   True
--   </pre>
isJust :: Maybe a -> Bool

-- | Check if a <a>Maybe</a> <tt>a</tt> is <tt>Nothing</tt>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   
--   &gt;&gt;&gt; isNothing (Just "plutus")
--   False
--   </pre>
isNothing :: Maybe a -> Bool

-- | Plutus Tx version of <a>maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; maybe "platypus" (\s -&gt; s) (Just "plutus")
--   "plutus"
--   
--   &gt;&gt;&gt; maybe "platypus" (\s -&gt; s) Nothing
--   "platypus"
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | Plutus Tx version of <a>fromMaybe</a>
fromMaybe :: a -> Maybe a -> a

-- | Plutus Tx version of <a>mapMaybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe (\i -&gt; if i == 2 then Just '2' else Nothing) [1, 2, 3, 4]
--   "2"
--   </pre>
mapMaybe :: (a -> Maybe b) -> [a] -> [b]

module PlutusTx.Monoid

-- | Plutus Tx version of <a>Monoid</a>.
class Semigroup a => Monoid a

-- | Plutus Tx version of <a>mempty</a>.
mempty :: Monoid a => a

-- | Plutus Tx version of <a>mappend</a>.
mappend :: Monoid a => a -> a -> a

-- | Plutus Tx version of <a>mconcat</a>.
mconcat :: Monoid a => [a] -> a
class Monoid a => Group a
inv :: Group a => a -> a
gsub :: Group a => a -> a -> a
instance PlutusTx.Monoid.Monoid PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusTx.Monoid.Monoid PlutusTx.Builtins.Internal.BuiltinString
instance PlutusTx.Monoid.Monoid [a]
instance PlutusTx.Semigroup.Semigroup a => PlutusTx.Monoid.Monoid (GHC.Maybe.Maybe a)
instance PlutusTx.Monoid.Monoid ()
instance (PlutusTx.Monoid.Monoid a, PlutusTx.Monoid.Monoid b) => PlutusTx.Monoid.Monoid (a, b)
instance PlutusTx.Monoid.Monoid a => PlutusTx.Monoid.Monoid (Data.Semigroup.Internal.Dual a)
instance PlutusTx.Monoid.Monoid (Data.Semigroup.Internal.Endo a)
instance PlutusTx.Monoid.Monoid (Data.Monoid.First a)

module PlutusTx.Numeric

-- | A <a>Semigroup</a> that it is sensible to describe using addition.
class AdditiveSemigroup a
(+) :: AdditiveSemigroup a => a -> a -> a
infixl 6 +

-- | A <a>Monoid</a> that it is sensible to describe using addition and
--   zero.
class AdditiveSemigroup a => AdditiveMonoid a
zero :: AdditiveMonoid a => a

-- | A <a>Group</a> that it is sensible to describe using addition, zero,
--   and subtraction.
class AdditiveMonoid a => AdditiveGroup a
(-) :: AdditiveGroup a => a -> a -> a
infixl 6 -

-- | A <a>Semigroup</a> that it is sensible to describe using
--   multiplication.
class MultiplicativeSemigroup a
(*) :: MultiplicativeSemigroup a => a -> a -> a
infixl 7 *

-- | A <a>Semigroup</a> that it is sensible to describe using
--   multiplication and one.
class MultiplicativeSemigroup a => MultiplicativeMonoid a
one :: MultiplicativeMonoid a => a

-- | A semiring.
type Semiring a = (AdditiveMonoid a, MultiplicativeMonoid a)

-- | A ring.
type Ring a = (AdditiveGroup a, MultiplicativeMonoid a)

-- | A module, with a type of scalars which can be used to scale the
--   values.
class (Ring s, AdditiveGroup v) => Module s v | v -> s
scale :: Module s v => s -> v -> v

-- | A newtype wrapper to derive <a>Additive</a> classes via.
newtype Additive a
Additive :: a -> Additive a

-- | A newtype wrapper to derive <a>Multiplicative</a> classes via.
newtype Multiplicative a
Multiplicative :: a -> Multiplicative a
negate :: AdditiveGroup a => a -> a

-- | Simultaneous div and mod.
divMod :: Integer -> Integer -> (Integer, Integer)

-- | Simultaneous quot and rem.
quotRem :: Integer -> Integer -> (Integer, Integer)

-- | Absolute value for any <a>AdditiveGroup</a>.
abs :: (Ord n, AdditiveGroup n) => n -> n
instance PlutusTx.Semigroup.Semigroup a => PlutusTx.Numeric.MultiplicativeSemigroup (PlutusTx.Numeric.Multiplicative a)
instance PlutusTx.Monoid.Monoid a => PlutusTx.Numeric.MultiplicativeMonoid (PlutusTx.Numeric.Multiplicative a)
instance PlutusTx.Numeric.MultiplicativeMonoid GHC.Num.Integer.Integer
instance PlutusTx.Numeric.MultiplicativeMonoid GHC.Types.Bool
instance PlutusTx.Numeric.MultiplicativeMonoid a => PlutusTx.Monoid.Monoid (Data.Semigroup.Internal.Product a)
instance PlutusTx.Numeric.MultiplicativeSemigroup GHC.Num.Integer.Integer
instance PlutusTx.Numeric.MultiplicativeSemigroup GHC.Types.Bool
instance PlutusTx.Numeric.MultiplicativeSemigroup a => PlutusTx.Semigroup.Semigroup (Data.Semigroup.Internal.Product a)
instance PlutusTx.Semigroup.Semigroup a => PlutusTx.Numeric.AdditiveSemigroup (PlutusTx.Numeric.Additive a)
instance PlutusTx.Monoid.Monoid a => PlutusTx.Numeric.AdditiveMonoid (PlutusTx.Numeric.Additive a)
instance PlutusTx.Monoid.Group a => PlutusTx.Numeric.AdditiveGroup (PlutusTx.Numeric.Additive a)
instance PlutusTx.Numeric.AdditiveGroup GHC.Num.Integer.Integer
instance PlutusTx.Numeric.AdditiveMonoid GHC.Num.Integer.Integer
instance PlutusTx.Numeric.AdditiveMonoid GHC.Types.Bool
instance PlutusTx.Numeric.AdditiveMonoid a => PlutusTx.Monoid.Monoid (Data.Semigroup.Internal.Sum a)
instance PlutusTx.Numeric.AdditiveSemigroup GHC.Num.Integer.Integer
instance PlutusTx.Numeric.AdditiveSemigroup GHC.Types.Bool
instance PlutusTx.Numeric.AdditiveSemigroup a => PlutusTx.Semigroup.Semigroup (Data.Semigroup.Internal.Sum a)

module PlutusTx.Lattice

-- | A join semi-lattice, i.e. a partially ordered set equipped with a
--   binary operation <a>(\/)</a>.
--   
--   Note that the mathematical definition would require an ordering
--   constraint - we omit that so we can define instances for e.g.
--   <tt>(-&gt;)</tt>.
class JoinSemiLattice a
(\/) :: JoinSemiLattice a => a -> a -> a

-- | A meet semi-lattice, i.e. a partially ordered set equipped with a
--   binary operation <a>(/\)</a>.
--   
--   Note that the mathematical definition would require an ordering
--   constraint - we omit that so we can define instances for e.g.
--   <tt>(-&gt;)</tt>.
class MeetSemiLattice a
(/\) :: MeetSemiLattice a => a -> a -> a

-- | A lattice.
type Lattice a = (JoinSemiLattice a, MeetSemiLattice a)

-- | A bounded join semi-lattice, i.e. a join semi-lattice augmented with a
--   distinguished element <a>bottom</a> which is the unit of <a>(\/)</a>.
class JoinSemiLattice a => BoundedJoinSemiLattice a
bottom :: BoundedJoinSemiLattice a => a

-- | A bounded meet semi-lattice, i.e. a meet semi-lattice augmented with a
--   distinguished element <a>top</a> which is the unit of <a>(/\)</a>.
class MeetSemiLattice a => BoundedMeetSemiLattice a
top :: BoundedMeetSemiLattice a => a

-- | A bounded lattice.
type BoundedLattice a = (BoundedJoinSemiLattice a, BoundedMeetSemiLattice a)

-- | A wrapper witnessing that a join semi-lattice is a monoid with
--   <a>(\/)</a> and <a>bottom</a>.
newtype Join a
Join :: a -> Join a

-- | A wrapper witnessing that a meet semi-lattice is a monoid with
--   <a>(/\)</a> and <a>top</a>.
newtype Meet a
Meet :: a -> Meet a
instance PlutusTx.Lattice.MeetSemiLattice a => PlutusTx.Semigroup.Semigroup (PlutusTx.Lattice.Meet a)
instance PlutusTx.Lattice.BoundedMeetSemiLattice a => PlutusTx.Monoid.Monoid (PlutusTx.Lattice.Meet a)
instance PlutusTx.Lattice.JoinSemiLattice a => PlutusTx.Semigroup.Semigroup (PlutusTx.Lattice.Join a)
instance PlutusTx.Lattice.BoundedJoinSemiLattice a => PlutusTx.Monoid.Monoid (PlutusTx.Lattice.Join a)
instance PlutusTx.Lattice.BoundedMeetSemiLattice GHC.Types.Bool
instance (PlutusTx.Lattice.BoundedMeetSemiLattice a, PlutusTx.Lattice.BoundedMeetSemiLattice b) => PlutusTx.Lattice.BoundedMeetSemiLattice (a, b)
instance PlutusTx.Lattice.BoundedMeetSemiLattice b => PlutusTx.Lattice.BoundedMeetSemiLattice (a -> b)
instance PlutusTx.Lattice.BoundedJoinSemiLattice GHC.Types.Bool
instance (PlutusTx.Lattice.BoundedJoinSemiLattice a, PlutusTx.Lattice.BoundedJoinSemiLattice b) => PlutusTx.Lattice.BoundedJoinSemiLattice (a, b)
instance PlutusTx.Lattice.BoundedJoinSemiLattice b => PlutusTx.Lattice.BoundedJoinSemiLattice (a -> b)
instance PlutusTx.Lattice.MeetSemiLattice GHC.Types.Bool
instance (PlutusTx.Lattice.MeetSemiLattice a, PlutusTx.Lattice.MeetSemiLattice b) => PlutusTx.Lattice.MeetSemiLattice (a, b)
instance PlutusTx.Lattice.MeetSemiLattice b => PlutusTx.Lattice.MeetSemiLattice (a -> b)
instance PlutusTx.Lattice.JoinSemiLattice GHC.Types.Bool
instance (PlutusTx.Lattice.JoinSemiLattice a, PlutusTx.Lattice.JoinSemiLattice b) => PlutusTx.Lattice.JoinSemiLattice (a, b)
instance PlutusTx.Lattice.JoinSemiLattice b => PlutusTx.Lattice.JoinSemiLattice (a -> b)

module PlutusTx.Code

-- | A compiled Plutus Tx program. The last type parameter indicates the
--   type of the Haskell expression that was compiled, and hence the type
--   of the compiled code.
--   
--   Note: the compiled PLC program does *not* have normalized types, if
--   you want to put it on the chain you must normalize the types first.
data CompiledCodeIn uni fun a

-- | Serialized UPLC code and possibly serialized PIR code with metadata
--   used for program coverage.
SerializedCode :: ByteString -> Maybe ByteString -> CoverageIndex -> CompiledCodeIn uni fun a

-- | Deserialized UPLC program, and possibly deserialized PIR program with
--   metadata used for program coverage.
DeserializedCode :: Program NamedDeBruijn uni fun SrcSpans -> Maybe (Program TyName Name uni fun SrcSpans) -> CoverageIndex -> CompiledCodeIn uni fun a

-- | <a>CompiledCodeIn</a> instantiated with default built-in types and
--   functions.
type CompiledCode = CompiledCodeIn DefaultUni DefaultFun

-- | Apply a compiled function to a compiled argument. Will fail if the
--   versions don't match.
applyCode :: (Closed uni, uni `Everywhere` Flat, Flat fun, Pretty fun, Everywhere uni PrettyConst, PrettyBy RenderContext (SomeTypeIn uni)) => CompiledCodeIn uni fun (a -> b) -> CompiledCodeIn uni fun a -> Either String (CompiledCodeIn uni fun b)

-- | Apply a compiled function to a compiled argument. Will throw if the
--   versions don't match, should only be used in non-production code.
unsafeApplyCode :: (Closed uni, uni `Everywhere` Flat, Flat fun, Pretty fun, Everywhere uni PrettyConst, PrettyBy RenderContext (SomeTypeIn uni)) => CompiledCodeIn uni fun (a -> b) -> CompiledCodeIn uni fun a -> CompiledCodeIn uni fun b

-- | The size of a <a>CompiledCodeIn</a>, in AST nodes.
sizePlc :: (Closed uni, uni `Everywhere` Flat, Flat fun) => CompiledCodeIn uni fun a -> Integer
newtype ImpossibleDeserialisationFailure
ImpossibleDeserialisationFailure :: DecodeException -> ImpossibleDeserialisationFailure

-- | Get the actual Plutus Core program out of a <a>CompiledCodeIn</a>.
getPlc :: (Closed uni, uni `Everywhere` Flat, Flat fun) => CompiledCodeIn uni fun a -> Program NamedDeBruijn uni fun SrcSpans
getPlcNoAnn :: (Closed uni, uni `Everywhere` Flat, Flat fun) => CompiledCodeIn uni fun a -> Program NamedDeBruijn uni fun ()

-- | Get the Plutus IR program, if there is one, out of a
--   <a>CompiledCodeIn</a>.
getPir :: (Closed uni, uni `Everywhere` Flat, Flat fun) => CompiledCodeIn uni fun a -> Maybe (Program TyName Name uni fun SrcSpans)
getPirNoAnn :: (Closed uni, uni `Everywhere` Flat, Flat fun) => CompiledCodeIn uni fun a -> Maybe (Program TyName Name uni fun ())
getCovIdx :: CompiledCodeIn uni fun a -> CoverageIndex
instance GHC.Exception.Type.Exception PlutusTx.Code.ImpossibleDeserialisationFailure
instance GHC.Show.Show PlutusTx.Code.ImpossibleDeserialisationFailure

module PlutusTx.Lift

-- | Get a Plutus Core term corresponding to the given value.
safeLift :: forall a e uni fun m. (Lift uni a, AsTypeError e (Term TyName Name uni fun ()) uni fun (Provenance ()), GEq uni, AsTypeErrorExt e uni (Provenance ()), AsFreeVariableError e, AsError e uni fun (Provenance ()), MonadError e m, MonadQuote m, Typecheckable uni fun, PrettyUni uni, Pretty fun, Default (CostingPart uni fun), Default (BuiltinsInfo uni fun), Default (RewriteRules uni fun), Hashable fun) => Version -> a -> m (Term TyName Name uni fun (), Term NamedDeBruijn uni fun ())

-- | Get a Plutus Core program corresponding to the given value.
safeLiftProgram :: (Lift uni a, AsTypeError e (Term TyName Name uni fun ()) uni fun (Provenance ()), GEq uni, AsTypeErrorExt e uni (Provenance ()), AsFreeVariableError e, AsError e uni fun (Provenance ()), MonadError e m, MonadQuote m, Typecheckable uni fun, PrettyUni uni, Pretty fun, Default (CostingPart uni fun), Default (BuiltinsInfo uni fun), Default (RewriteRules uni fun), Hashable fun) => Version -> a -> m (Program TyName Name uni fun (), Program NamedDeBruijn uni fun ())
safeLiftCode :: (Lift uni a, AsTypeError e (Term TyName Name uni fun ()) uni fun (Provenance ()), GEq uni, AsTypeErrorExt e uni (Provenance ()), AsFreeVariableError e, AsError e uni fun (Provenance ()), MonadError e m, MonadQuote m, Typecheckable uni fun, PrettyUni uni, Pretty fun, Default (CostingPart uni fun), Default (BuiltinsInfo uni fun), Default (RewriteRules uni fun), Hashable fun) => Version -> a -> m (CompiledCodeIn uni fun a)

-- | Get a Plutus Core term corresponding to the given value, throwing any
--   errors that occur as exceptions and ignoring fresh names.
lift :: (Lift uni a, ThrowableBuiltins uni fun, Typecheckable uni fun, GEq uni, Default (CostingPart uni fun), Default (BuiltinsInfo uni fun), Default (RewriteRules uni fun), Hashable fun) => Version -> a -> (Term TyName Name uni fun (), Term NamedDeBruijn uni fun ())

-- | Get a Plutus Core program corresponding to the given value, throwing
--   any errors that occur as exceptions and ignoring fresh names.
liftProgram :: (Lift uni a, ThrowableBuiltins uni fun, Typecheckable uni fun, GEq uni, Default (CostingPart uni fun), Default (BuiltinsInfo uni fun), Default (RewriteRules uni fun), Hashable fun) => Version -> a -> (Program TyName Name uni fun (), Program NamedDeBruijn uni fun ())

-- | Get a Plutus Core program in the default universe with the default
--   version, corresponding to the given value, throwing any errors that
--   occur as exceptions and ignoring fresh names.
liftProgramDef :: Lift DefaultUni a => a -> (Program TyName Name DefaultUni DefaultFun (), Program NamedDeBruijn DefaultUni DefaultFun ())

-- | Get a Plutus Core program corresponding to the given value as a
--   <a>CompiledCodeIn</a>, throwing any errors that occur as exceptions
--   and ignoring fresh names.
liftCode :: (Lift uni a, GEq uni, ThrowableBuiltins uni fun, Typecheckable uni fun, Default (CostingPart uni fun), Default (BuiltinsInfo uni fun), Default (RewriteRules uni fun), Hashable fun) => Version -> a -> CompiledCodeIn uni fun a

-- | Get a Plutus Core program with the default version, corresponding to
--   the given value as a <a>CompiledCodeIn</a>, throwing any errors that
--   occur as exceptions and ignoring fresh names.
liftCodeDef :: (Lift uni a, GEq uni, ThrowableBuiltins uni fun, Typecheckable uni fun, Default (CostingPart uni fun), Default (BuiltinsInfo uni fun), Default (RewriteRules uni fun), Hashable fun) => a -> CompiledCodeIn uni fun a

-- | Check that PLC term has the given type.
typeCheckAgainst :: forall e a uni fun m. (Typeable uni a, AsTypeError e (Term TyName Name uni fun ()) uni fun (Provenance ()), AsTypeErrorExt e uni (Provenance ()), AsError e uni fun (Provenance ()), MonadError e m, MonadQuote m, GEq uni, Typecheckable uni fun, PrettyUni uni, Pretty fun, Default (CostingPart uni fun), Default (BuiltinsInfo uni fun), Default (RewriteRules uni fun)) => Proxy a -> Program TyName Name uni fun () -> m ()

-- | Try to interpret a PLC program as a <a>CompiledCodeIn</a> of the given
--   type. Returns successfully iff the program has the right type.
typeCode :: forall e a uni fun m. (Typeable uni a, AsTypeError e (Term TyName Name uni fun ()) uni fun (Provenance ()), AsTypeErrorExt e uni (Provenance ()), AsFreeVariableError e, AsError e uni fun (Provenance ()), MonadError e m, MonadQuote m, GEq uni, Typecheckable uni fun, PrettyUni uni, Pretty fun, Default (CostingPart uni fun), Default (BuiltinsInfo uni fun), Default (RewriteRules uni fun), Hashable fun) => Proxy a -> Program TyName Name uni fun () -> m (CompiledCodeIn uni fun a)
makeTypeable :: Type -> Name -> Q [Dec]
makeLift :: Name -> Q [Dec]
data LiftError
UnsupportedLiftKind :: !Kind -> LiftError
UnsupportedLiftType :: !Type -> LiftError
UserLiftError :: !Text -> LiftError
LiftMissingDataCons :: !Name -> LiftError
LiftMissingVar :: !Name -> LiftError

module PlutusTx.Applicative

-- | Plutus Tx version of <a>Applicative</a>.
class Functor f => Applicative f

-- | Plutus Tx version of <a>pure</a>.
pure :: Applicative f => a -> f a

-- | Plutus Tx version of <a>(&lt;*&gt;)</a>.
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
infixl 4 <*>

-- | Plutus Tx version of <a>liftA2</a>.
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Plutus Tx version of <a>(*&gt;)</a>.
(*>) :: Applicative f => f a -> f b -> f b
infixl 4 *>

-- | Plutus Tx version of <a>(&lt;*)</a>.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*

-- | Plutus Tx version of <a>unless</a>.
unless :: Applicative f => Bool -> f () -> f ()
instance PlutusTx.Applicative.Applicative GHC.Maybe.Maybe
instance PlutusTx.Applicative.Applicative (Data.Either.Either a)
instance PlutusTx.Applicative.Applicative []
instance PlutusTx.Applicative.Applicative Data.Functor.Identity.Identity
instance PlutusTx.Monoid.Monoid m => PlutusTx.Applicative.Applicative (Data.Functor.Const.Const m)

module PlutusTx.Foldable

-- | Plutus Tx version of <a>Foldable</a>.
class Foldable t

-- | Plutus Tx version of <a>foldr</a>.
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Plutus Tx version of <a>traverse_</a>.
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()

-- | Plutus Tx version of <a>for_</a>.
for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()

-- | Plutus Tx version of <a>sequenceA_</a>.
sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()

-- | Plutus Tx version of <a>asum</a>.
asum :: (Foldable t, Alternative f) => t (f a) -> f a

-- | Plutus Tx version of <a>concat</a>.
concat :: Foldable t => t [a] -> [a]

-- | Plutus Tx version of <a>concatMap</a>.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | Plutus Tx version of <a>foldMap</a>.
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Plutus Tx version of <a>fold</a>.
fold :: (Foldable t, Monoid m) => t m -> m

-- | Plutus Tx version of <a>foldl</a>.
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Plutus Tx version of <a>toList</a>.
toList :: Foldable t => t a -> [a]

-- | Plutus Tx version of <a>length</a>.
length :: Foldable t => t a -> Integer

-- | Plutus Tx version of <a>sum</a>.
sum :: (Foldable t, AdditiveMonoid a) => t a -> a

-- | Plutus Tx version of <a>product</a>.
product :: (Foldable t, MultiplicativeMonoid a) => t a -> a
instance PlutusTx.Foldable.Foldable []
instance PlutusTx.Foldable.Foldable GHC.Maybe.Maybe
instance PlutusTx.Foldable.Foldable (Data.Either.Either c)
instance PlutusTx.Foldable.Foldable ((,) c)
instance PlutusTx.Foldable.Foldable Data.Functor.Identity.Identity
instance PlutusTx.Foldable.Foldable (Data.Functor.Const.Const c)

module PlutusTx.Show.TH

-- | Conversion of values to <a>BuiltinString</a>s. Unlike
--   <tt>GHC.Show.Show</tt>, there is no <tt>showList</tt> method, because
--   there is no <a>Show</a> instance for <a>String</a>.
class Show a
showsPrec :: Show a => Integer -> a -> ShowS
show :: Show a => a -> BuiltinString

-- | Currently the only way to concatenate <a>BuiltinString</a>s is
--   <a>appendString</a>, whose cost is linear in the total length of the
--   two strings. A naive concatenation of multiple <a>BuiltinString</a>s
--   costs <tt>O(n^2)</tt> in the worst case, where <tt>n</tt> is the total
--   length. By collecting the <a>BuiltinString</a>s in a list and
--   concatenating them in the end, the cost can be reduced to
--   <tt>O(n*logn)</tt>. If we add a <tt>concatStrings</tt> builtin
--   function in the future, the cost can be further reduced to
--   <tt>O(n)</tt>.
--   
--   Like <a>ShowS</a>, the purpose of the function type here is to turn
--   list concatenation into function composition.
type ShowS = [BuiltinString] -> [BuiltinString]
showString :: BuiltinString -> ShowS
showSpace :: ShowS
showCommaSpace :: ShowS
showParen :: Bool -> ShowS -> ShowS
appPrec :: Integer
appPrec1 :: Integer
concatBuiltinStrings :: [BuiltinString] -> BuiltinString

-- | Derive <a>Show</a> instance. Adapted from
--   <tt>Text.Show.Deriving.deriveShow</tt>.
deriveShow :: Name -> Q [Dec]

-- | Derive <a>showsPrec</a> definition for each data constructor.
deriveShowsPrec :: [ConstructorInfo] -> [Q Dec]
deriveShowsPrecBody :: [ConstructorInfo] -> Q Exp

-- | Derive <a>showsPrec</a> body for a single data constructor.
deriveMatchForCon :: Name -> ConstructorInfo -> Q Match

-- | Derive the <a>showsPrec</a> expression for showing a single
--   constructor argument.
deriveShowExpForArg :: Integer -> Name -> Q Exp

-- | Add parens if it is an infix data constructor.
parenInfixConName :: Name -> String

module PlutusTx.IsData.Class

-- | A typeclass for types that can be converted to and from
--   <a>BuiltinData</a>.
class ToData (a :: Type)

-- | Convert a value to <a>BuiltinData</a>.
toBuiltinData :: ToData a => a -> BuiltinData
class FromData (a :: Type)

-- | Convert a value from <a>BuiltinData</a>, returning <a>Nothing</a> if
--   this fails.
fromBuiltinData :: FromData a => BuiltinData -> Maybe a
class UnsafeFromData (a :: Type)

-- | Convert a value from <a>BuiltinData</a>, calling <a>error</a> if this
--   fails. This is typically much faster than <a>fromBuiltinData</a>.
--   
--   When implementing this function, make sure to call
--   <a>unsafeFromBuiltinData</a> rather than <a>fromBuiltinData</a> when
--   converting substructures!
--   
--   This is a simple type without any validation, <b>use with caution</b>.
unsafeFromBuiltinData :: UnsafeFromData a => BuiltinData -> a

-- | Convert a value to <a>Data</a>.
toData :: ToData a => a -> Data

-- | Convert a value from <a>Data</a>, returning <a>Nothing</a> if this
--   fails.
fromData :: FromData a => Data -> Maybe a

-- | Convert a value from <a>Data</a>, throwing if this fails.
unsafeFromData :: UnsafeFromData a => Data -> a
instance PlutusTx.IsData.Class.UnsafeFromData PlutusTx.Builtins.Internal.BuiltinData
instance (TypeError ...) => PlutusTx.IsData.Class.UnsafeFromData GHC.Types.Int
instance PlutusTx.IsData.Class.UnsafeFromData GHC.Num.Integer.Integer
instance PlutusTx.IsData.Class.UnsafeFromData PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData [a]
instance PlutusTx.IsData.Class.UnsafeFromData GHC.Base.Void
instance PlutusTx.IsData.Class.UnsafeFromData PlutusTx.Builtins.Internal.BuiltinBLS12_381_G1_Element
instance PlutusTx.IsData.Class.UnsafeFromData PlutusTx.Builtins.Internal.BuiltinBLS12_381_G2_Element
instance (TypeError ...) => PlutusTx.IsData.Class.UnsafeFromData PlutusTx.Builtins.Internal.BuiltinBLS12_381_MlResult
instance PlutusTx.IsData.Class.FromData PlutusTx.Builtins.Internal.BuiltinData
instance (TypeError ...) => PlutusTx.IsData.Class.FromData GHC.Types.Int
instance PlutusTx.IsData.Class.FromData GHC.Num.Integer.Integer
instance PlutusTx.IsData.Class.FromData PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData [a]
instance PlutusTx.IsData.Class.FromData GHC.Base.Void
instance PlutusTx.IsData.Class.FromData PlutusTx.Builtins.Internal.BuiltinBLS12_381_G1_Element
instance PlutusTx.IsData.Class.FromData PlutusTx.Builtins.Internal.BuiltinBLS12_381_G2_Element
instance (TypeError ...) => PlutusTx.IsData.Class.FromData PlutusTx.Builtins.Internal.BuiltinBLS12_381_MlResult
instance PlutusTx.IsData.Class.ToData PlutusTx.Builtins.Internal.BuiltinData
instance (TypeError ...) => PlutusTx.IsData.Class.ToData GHC.Types.Int
instance PlutusTx.IsData.Class.ToData GHC.Num.Integer.Integer
instance PlutusTx.IsData.Class.ToData PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData [a]
instance PlutusTx.IsData.Class.ToData GHC.Base.Void
instance PlutusTx.IsData.Class.ToData PlutusTx.Builtins.Internal.BuiltinBLS12_381_G1_Element
instance PlutusTx.IsData.Class.ToData PlutusTx.Builtins.Internal.BuiltinBLS12_381_G2_Element
instance (TypeError ...) => PlutusTx.IsData.Class.ToData PlutusTx.Builtins.Internal.BuiltinBLS12_381_MlResult

module PlutusTx.Blueprint.TH

-- | Generate a <tt>ToData</tt>, <tt>FromData</tt>,
--   <tt>UnsafeFromData</tt>, <a>HasBlueprintSchema</a> instances for a
--   type, using an explicit mapping of constructor names to indices. Use
--   this for types where you need to keep the representation stable.
makeIsDataSchemaIndexed :: Name -> [(Name, Natural)] -> Q [InstanceDec]
unstableMakeIsDataSchema :: Name -> Q [Dec]
makeHasSchemaInstance :: Name -> [(Name, Natural)] -> Q [InstanceDec]

-- | Make a clause for the <a>schema</a> function.
mkSchemaClause :: Type -> [(ConstructorInfo, SchemaInfo, Natural)] -> ClauseQ
deriveParameterBlueprint :: Name -> Set Purpose -> ExpQ
deriveArgumentBlueprint :: Name -> Set Purpose -> ExpQ
lookupAnn :: Data a => Name -> Q [a]
lookupSchemaTitle :: Name -> Q (Maybe SchemaTitle)
lookupSchemaDescription :: Name -> Q (Maybe SchemaDescription)

module PlutusTx.IsData

-- | Generate a <a>FromData</a> and a <a>ToData</a> instance for a type.
--   This may not be stable in the face of constructor additions,
--   renamings, etc. Use <a>makeIsDataIndexed</a> if you need stability.
unstableMakeIsData :: Name -> Q [Dec]

-- | Generate a <a>ToData</a>, 'FromData and a <a>UnsafeFromData</a>
--   instances for a type, using an explicit mapping of constructor names
--   to indices. Use this for types where you need to keep the
--   representation stable.
makeIsDataIndexed :: Name -> [(Name, Int)] -> Q [Dec]
mkConstrCreateExpr :: Integer -> [Name] -> ExpQ
mkUnsafeConstrMatchPattern :: Integer -> [Name] -> PatQ
mkConstrPartsMatchPattern :: Integer -> [Name] -> PatQ
mkUnsafeConstrPartsMatchPattern :: Integer -> [Name] -> PatQ

module PlutusTx.Ratio

-- | Represents an arbitrary-precision ratio.
--   
--   The following two invariants are maintained:
--   
--   <ol>
--   <li>The denominator is greater than zero.</li>
--   <li>The numerator and denominator are coprime.</li>
--   </ol>
data Rational

-- | Makes a <a>Rational</a> from a numerator and a denominator.
--   
--   <h1>Important note</h1>
--   
--   If given a zero denominator, this function will error. If you don't
--   mind a size increase, and care about safety, use <a>ratio</a> instead.
unsafeRatio :: Integer -> Integer -> Rational

-- | Converts an <a>Integer</a> into the equivalent <a>Rational</a>.
fromInteger :: Integer -> Rational

-- | Safely constructs a <a>Rational</a> from a numerator and a
--   denominator. Returns <tt>Nothing</tt> if given a zero denominator.
ratio :: Integer -> Integer -> Maybe Rational

-- | Returns the numerator of its argument.
--   
--   <h1>Note</h1>
--   
--   It is <i>not</i> true in general that <tt><a>numerator</a>
--   <tt>&lt;$&gt;</tt> <a>ratio</a> x y = x</tt>; this will only hold if
--   <tt>x</tt> and <tt>y</tt> are coprime. This is due to <a>Rational</a>
--   normalizing the numerator and denominator.
numerator :: Rational -> Integer

-- | Returns the denominator of its argument. This will always be greater
--   than, or equal to, 1, although the type does not describe this.
--   
--   <h1>Note</h1>
--   
--   It is <i>not</i> true in general that <tt><a>denominator</a>
--   <tt>&lt;$&gt;</tt> <a>ratio</a> x y = y</tt>; this will only hold if
--   <tt>x</tt> and <tt>y</tt> are coprime. This is due to <a>Rational</a>
--   normalizing the numerator and denominator.
denominator :: Rational -> Integer

-- | <tt><a>round</a> r</tt> returns the nearest <a>Integer</a> value to
--   <tt>r</tt>. If <tt>r</tt> is equidistant between two values, the even
--   value will be given.
round :: Rational -> Integer

-- | Returns the whole-number part of its argument, dropping any leftover
--   fractional part. More precisely, <tt><a>truncate</a> r = n</tt> where
--   <tt>(n, _) = <a>properFraction</a> r</tt>, but is much more efficient.
truncate :: Rational -> Integer

-- | <tt><a>properFraction</a> r</tt> returns the pair <tt>(n, f)</tt>,
--   such that all of the following hold:
--   
--   <ul>
--   <li><tt><a>fromInteger</a> n <a>+</a> f = r</tt>;</li>
--   <li><tt>n</tt> and <tt>f</tt> both have the same sign as <tt>r</tt>;
--   and</li>
--   <li><tt><a>abs</a> f <a>&lt;</a> <a>one</a></tt>.</li>
--   </ul>
properFraction :: Rational -> (Integer, Rational)

-- | Gives the reciprocal of the argument; specifically, for <tt>r
--   <a>/=</a> <a>zero</a></tt>, <tt>r <a>*</a> <a>recip</a> r =
--   <a>one</a></tt>.
--   
--   <h1>Important note</h1>
--   
--   The reciprocal of zero is mathematically undefined; thus,
--   <tt><a>recip</a> <a>zero</a></tt> will error. Use with care.
recip :: Rational -> Rational

-- | Returns the absolute value of its argument.
--   
--   <h1>Note</h1>
--   
--   This is specialized for <a>Rational</a>; use this instead of the
--   generic version in <tt>PlutusTx.Numeric</tt>, as said generic version
--   produces much larger on-chain code than the specialized version here.
abs :: Rational -> Rational

-- | Produces the additive inverse of its argument.
--   
--   <h1>Note</h1>
--   
--   This is specialized for <a>Rational</a>; use this instead of the
--   generic version of this function, as it is significantly smaller
--   on-chain.
negate :: Rational -> Rational

-- | <ol>
--   <li>5</li>
--   </ol>
half :: Rational

-- | Converts a GHC <a>Rational</a>, preserving value. Does not work
--   on-chain.
fromGHC :: Rational -> Rational

-- | Converts a <a>Rational</a> to a GHC <a>Rational</a>, preserving value.
--   Does not work on-chain.
toGHC :: Rational -> Rational

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>.
gcd :: Integer -> Integer -> Integer
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusTx.Ratio.Rational
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusTx.Ratio.Rational
instance GHC.Generics.Generic PlutusTx.Ratio.Rational
instance GHC.Show.Show PlutusTx.Ratio.Rational
instance GHC.Classes.Eq PlutusTx.Ratio.Rational
instance Prettyprinter.Internal.Pretty PlutusTx.Ratio.Rational
instance PlutusTx.Eq.Eq PlutusTx.Ratio.Rational
instance PlutusTx.Ord.Ord PlutusTx.Ratio.Rational
instance GHC.Classes.Ord PlutusTx.Ratio.Rational
instance PlutusTx.Numeric.AdditiveSemigroup PlutusTx.Ratio.Rational
instance PlutusTx.Numeric.AdditiveMonoid PlutusTx.Ratio.Rational
instance PlutusTx.Numeric.AdditiveGroup PlutusTx.Ratio.Rational
instance PlutusTx.Numeric.MultiplicativeSemigroup PlutusTx.Ratio.Rational
instance PlutusTx.Numeric.MultiplicativeMonoid PlutusTx.Ratio.Rational
instance PlutusTx.Numeric.Module GHC.Num.Integer.Integer PlutusTx.Ratio.Rational
instance PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition PlutusTx.Ratio.Rational
instance PlutusTx.Blueprint.Definition.Internal.HasSchemaDefinition GHC.Num.Integer.Integer referencedTypes => PlutusTx.Blueprint.Class.HasBlueprintSchema PlutusTx.Ratio.Rational referencedTypes
instance PlutusTx.IsData.Class.ToData PlutusTx.Ratio.Rational
instance PlutusTx.IsData.Class.FromData PlutusTx.Ratio.Rational
instance PlutusTx.IsData.Class.UnsafeFromData PlutusTx.Ratio.Rational
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Ratio.Rational
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Ratio.Rational

module PlutusTx.AsData

-- | <a>asData</a> takes a datatype declaration and "backs it" by
--   <tt>BuiltinData</tt>. It does this by replacing the datatype with a
--   newtype around <tt>BuiltinData</tt>, and providing pattern synonyms
--   that match the behaviour of the original datatype.
--   
--   Since <tt>BuiltinData</tt> can only contain <tt>BuiltinData</tt>, the
--   pattern synonyms encode and decode all the fields using
--   <tt>toBuiltinData</tt> and <tt>unsafeFromBuiltinData</tt>. That means
--   that these operations are called on every pattern match or
--   construction. This *can* be very efficient if, for example, the
--   datatypes for the fields have also been defined with <a>asData</a>,
--   and so have trivial conversions to/from <tt>BuiltinData</tt> (or have
--   very cheap conversions, like <a>Integer</a> and <tt>ByteString</tt>).
--   But it can be very expensive otherwise, so take care.
--   
--   Deriving clauses are transferred from the quoted declaration to the
--   generated newtype declaration. Note that you may therefore need to do
--   strange things like use <tt>deriving newtype</tt> on a data
--   declaration.
--   
--   Example: <tt> $(asData [d| data Example a = Ex1 Integer | Ex2 a a
--   deriving newtype (Eq) |]) </tt> becomes @ newtype Example a = Example
--   BuiltinData deriving newtype (Eq)
--   
--   pattern Ex1 :: (ToData a, UnsafeFromData a) =&gt; Integer -&gt;
--   Example a pattern Ex1 i <a>Example (unsafeDataAsConstr -</a> ((==) 0
--   -&gt; True, [unsafeFromBuiltinData -&gt; i])) where Ex1 i = Example
--   (mkConstr 0 [toBuiltinData i])
--   
--   pattern Ex2 :: (ToData a, UnsafeFromData a) =&gt; a -&gt; a -&gt;
--   Example a pattern Ex2 a1 a2 <a>Example (unsafeDataAsConstr -</a> ((==)
--   1 -&gt; True, [ unsafeFromBuiltinData -&gt; a1 , unsafeFromBuiltinData
--   -&gt; a2 ])) where Ex2 a1 a2 = Example (mkConstr 1 [toBuiltinData a1,
--   toBuiltinData a2])
--   
--   {-# COMPLETE Ex1, Ex2 #-} @
asData :: Q [Dec] -> Q [Dec]
asDataFor :: Dec -> Q [Dec]

module PlutusTx.Enum

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
class Enum a

-- | The successor of a value. For numeric types, <a>succ</a> adds 1.
--   
--   For types that implement <a>Ord</a>, <tt>succ x</tt> should be the
--   least element that is greater than <tt>x</tt>, and <a>error</a> if
--   there is none.
succ :: Enum a => a -> a

-- | The predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
--   
--   For types that implement <a>Ord</a>, <tt>pred x</tt> should be the
--   greatest element that is less than <tt>x</tt>, and <a>error</a> if
--   there is none.
pred :: Enum a => a -> a

-- | Convert from an <a>Integer</a>.
toEnum :: Enum a => Integer -> a

-- | Convert to an <a>Integer</a>.
fromEnum :: Enum a => a -> Integer

-- | Construct a list from the given range (corresponds to [a..b]).
enumFromTo :: Enum a => a -> a -> [a]

-- | Construct a list from the given range (corresponds to [a,b..c]). This
--   has the same semantics as the Haskell version,so if a==b and c&gt;=b
--   then you get an infinite list, which you probably don't want in Plutus
--   Core.
enumFromThenTo :: Enum a => a -> a -> a -> [a]
instance PlutusTx.Enum.Enum GHC.Num.Integer.Integer
instance PlutusTx.Enum.Enum ()
instance PlutusTx.Enum.Enum GHC.Types.Bool
instance PlutusTx.Enum.Enum GHC.Types.Ordering

module PlutusTx.Traversable

-- | Plutus Tx version of <a>Traversable</a>.
class (Functor t, Foldable t) => Traversable t

-- | Plutus Tx version of <a>traverse</a>.
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Plutus Tx version of <a>sequenceA</a>.
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Plutus Tx version of <a>mapM</a>.
mapM :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Plutus Tx version of <a>sequence</a>.
sequence :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Plutus Tx version of <a>for</a>.
for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)

-- | Plutus Tx version of <a>fmapDefault</a>.
fmapDefault :: forall t a b. Traversable t => (a -> b) -> t a -> t b

-- | Plutus Tx version of <a>foldMapDefault</a>.
foldMapDefault :: forall t m a. (Traversable t, Monoid m) => (a -> m) -> t a -> m
instance PlutusTx.Traversable.Traversable []
instance PlutusTx.Traversable.Traversable GHC.Maybe.Maybe
instance PlutusTx.Traversable.Traversable (Data.Either.Either c)
instance PlutusTx.Traversable.Traversable ((,) c)
instance PlutusTx.Traversable.Traversable Data.Functor.Identity.Identity
instance PlutusTx.Traversable.Traversable (Data.Functor.Const.Const c)

module PlutusTx.Prelude

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: Monad m => m a -> (a -> m b) -> m b
infixl 1 >>=

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: Monad m => m a -> m b -> m b
infixl 1 >>

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
data BuiltinUnit
data BuiltinString

-- | Append two <tt>String</tt>s.
appendString :: BuiltinString -> BuiltinString -> BuiltinString

-- | An empty <tt>String</tt>.
emptyString :: BuiltinString

-- | Check if two strings are equal
equalsString :: BuiltinString -> BuiltinString -> Bool

-- | Convert a String into a ByteString.
encodeUtf8 :: BuiltinString -> BuiltinByteString

-- | Aborts evaluation with an error.
error :: () -> a

-- | Checks a <a>Bool</a> and aborts if it is false.
check :: Bool -> BuiltinUnit

-- | Arbitrary precision integers. In contrast with fixed-size integral
--   types such as <a>Int</a>, the <a>Integer</a> type represents the
--   entire infinite range of integers.
--   
--   Integers are stored in a kind of sign-magnitude form, hence do not
--   expect two's complement form when using bit operations.
--   
--   If the value is small (fit into an <a>Int</a>), <a>IS</a> constructor
--   is used. Otherwise <a>Integer</a> and <a>IN</a> constructors are used
--   to store a <a>BigNat</a> representing respectively the positive or the
--   negative value magnitude.
--   
--   Invariant: <a>Integer</a> and <a>IN</a> are used iff value doesn't fit
--   in <a>IS</a>
data () => Integer

-- | Integer division, rounding downwards
--   
--   <pre>
--   &gt;&gt;&gt; divide (-41) 5
--   -9
--   </pre>
divide :: Integer -> Integer -> Integer

-- | Integer remainder, always positive for a positive divisor
--   
--   <pre>
--   &gt;&gt;&gt; modulo (-41) 5
--   4
--   </pre>
modulo :: Integer -> Integer -> Integer

-- | Integer division, rouding towards zero
--   
--   <pre>
--   &gt;&gt;&gt; quotient (-41) 5
--   -8
--   </pre>
quotient :: Integer -> Integer -> Integer

-- | Integer remainder, same sign as dividend
--   
--   <pre>
--   &gt;&gt;&gt; remainder (-41) 5
--   -1
--   </pre>
remainder :: Integer -> Integer -> Integer
even :: Integer -> Bool
odd :: Integer -> Bool

-- | FIXME
expMod :: Integer -> Integer -> Integer -> Integer

-- | Plutus Tx version of <a>zipWith</a>.
zipWith :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]

-- | Plutus Tx version of <a>sortBy</a>.
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | Plutus Tx version of <a>head</a>.
head :: [a] -> a

-- | Plutus Tx version of <a>filter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; filter (&gt; 1) [1, 2, 3, 4]
--   [2,3,4]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | Plutus Tx version of <a>(++)</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [0, 1, 2] ++ [1, 2, 3, 4]
--   [0,1,2,1,2,3,4]
--   </pre>
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | Plutus Tx version of <a>zip</a>.
zip :: [a] -> [b] -> [(a, b)]

-- | Plutus Tx version of <a>map</a>.
--   
--   <pre>
--   &gt;&gt;&gt; map (\i -&gt; i + 1) [1, 2, 3]
--   [2,3,4]
--   </pre>
map :: forall a b. (a -> b) -> [a] -> [b]

-- | Plutus Tx version of <a>listToMaybe</a>.
listToMaybe :: [a] -> Maybe a

-- | Plutus Tx version of <a>uncons</a>.
uncons :: [a] -> Maybe (a, [a])

-- | Plutus Tx version of <a>tail</a>.
tail :: [a] -> [a]

-- | Plutus Tx version of <a>last</a>.
last :: [a] -> a

-- | Test whether a list is empty.
null :: [a] -> Bool

-- | Plutus Tx version of <a>replicate</a>.
replicate :: forall a. Integer -> a -> [a]

-- | Plutus Tx version of <a>dropWhile</a>.
dropWhile :: forall a. (a -> Bool) -> [a] -> [a]

-- | Plutus Tx version of <a>take</a>.
take :: Integer -> [a] -> [a]

-- | Plutus Tx version of <a>drop</a>.
drop :: Integer -> [a] -> [a]

-- | Plutus Tx version of <a>splitAt</a>.
splitAt :: Integer -> [a] -> ([a], [a])

-- | Plutus Tx version of <a>reverse</a>.
reverse :: [a] -> [a]

-- | Returns the conjunction of a list of Bools.
and :: [Bool] -> Bool

-- | Returns the disjunction of a list of Bools.
or :: [Bool] -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
any :: forall a. (a -> Bool) -> [a] -> Bool

-- | Determines whether all elements of the list satisfy the predicate.
all :: forall a. (a -> Bool) -> [a] -> Bool

-- | Does the element occur in the list?
elem :: Eq a => a -> [a] -> Bool

-- | The negation of <a>elem</a>.
notElem :: Eq a => a -> [a] -> Bool

-- | Plutus Tx version of <a>(!!)</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [10, 11, 12] !! 2
--   12
--   </pre>
(!!) :: forall a. [a] -> Integer -> a
infixl 9 !!

-- | Plutus Tx version of <a>unzip</a>.
unzip :: [(a, b)] -> ([a], [b])

-- | Returns the leftmost element matching the predicate, or <a>Nothing</a>
--   if there's no such element.
find :: forall a. (a -> Bool) -> [a] -> Maybe a

-- | Plutus Tx version of <a>findIndex</a>.
findIndex :: (a -> Bool) -> [a] -> Maybe Integer

-- | Plutus Tx version of <a>findIndices</a>.
findIndices :: (a -> Bool) -> [a] -> [Integer]

-- | Plutus Tx version of <a>nub</a>.
nub :: Eq a => [a] -> [a]

-- | Plutus Tx version of <a>nubBy</a>.
nubBy :: (a -> a -> Bool) -> [a] -> [a]

-- | Plutus Tx version of <a>partition</a>.
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | Plutus Tx version of <a>sort</a>.
sort :: Ord a => [a] -> [a]

-- | Return the element in the list, if there is precisely one.
uniqueElement :: [a] -> Maybe a

-- | Cons each element of the first list to the second one in reverse order
--   (i.e. the last element of the first list is the head of the result).
--   
--   <pre>
--   revAppend xs ys === reverse xs ++ ys
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; revAppend "abc" "de"
--   "cbade"
--   </pre>
revAppend :: forall a. [a] -> [a] -> [a]

-- | Index operator for builtin lists.
--   
--   <pre>
--   &gt;&gt;&gt; indexBuiltinList (toBuiltin [10, 11, 12]) 2
--   12
--   </pre>
indexBuiltinList :: forall a. BuiltinList a -> Integer -> a

-- | An opaque type representing Plutus Core ByteStrings.
data BuiltinByteString

-- | Concatenates two <tt>ByteString</tt>s.
appendByteString :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString

-- | Adds a byte to the front of a <tt>ByteString</tt>.
consByteString :: Integer -> BuiltinByteString -> BuiltinByteString

-- | Returns the n length prefix of a <tt>ByteString</tt>.
takeByteString :: Integer -> BuiltinByteString -> BuiltinByteString

-- | Returns the suffix of a <tt>ByteString</tt> after n elements.
dropByteString :: Integer -> BuiltinByteString -> BuiltinByteString

-- | Returns the substring of a <tt>ByteString</tt> from index
--   <tt>start</tt> of length <tt>n</tt>.
sliceByteString :: Integer -> Integer -> BuiltinByteString -> BuiltinByteString

-- | Returns the length of a <tt>ByteString</tt>.
lengthOfByteString :: BuiltinByteString -> Integer

-- | Returns the byte of a <tt>ByteString</tt> at index.
indexByteString :: BuiltinByteString -> Integer -> Integer

-- | An empty <tt>ByteString</tt>.
emptyByteString :: BuiltinByteString

-- | Converts a ByteString to a String.
decodeUtf8 :: BuiltinByteString -> BuiltinString

-- | Perform logical AND on two <a>BuiltinByteString</a> arguments, as
--   described in <a>CIP-122</a>.
--   
--   The first argument indicates whether padding semantics should be used
--   or not; if <a>False</a>, truncation semantics will be used instead.
--   
--   <h1>See also</h1>
--   
--   <ul>
--   <li><a>Padding and truncation semantics</a></li>
--   <li><a>Bit indexing scheme</a></li>
--   </ul>
andByteString :: Bool -> BuiltinByteString -> BuiltinByteString -> BuiltinByteString

-- | Perform logical OR on two <a>BuiltinByteString</a> arguments, as
--   described <a>here</a>.
--   
--   The first argument indicates whether padding semantics should be used
--   or not; if <a>False</a>, truncation semantics will be used instead.
--   
--   <h1>See also</h1>
--   
--   <ul>
--   <li><a>Padding and truncation semantics</a></li>
--   <li><a>Bit indexing scheme</a></li>
--   </ul>
orByteString :: Bool -> BuiltinByteString -> BuiltinByteString -> BuiltinByteString

-- | Perform logical XOR on two <a>BuiltinByteString</a> arguments, as
--   described <a>here</a>.
--   
--   The first argument indicates whether padding semantics should be used
--   or not; if <a>False</a>, truncation semantics will be used instead.
--   
--   <h1>See also</h1>
--   
--   <ul>
--   <li><a>Padding and truncation semantics</a></li>
--   <li><a>Bit indexing scheme</a></li>
--   </ul>
xorByteString :: Bool -> BuiltinByteString -> BuiltinByteString -> BuiltinByteString

-- | Perform logical complement on a <a>BuiltinByteString</a>, as described
--   <a>here</a>.
--   
--   <h1>See also</h1>
--   
--   <ul>
--   <li><a>Bit indexing scheme</a></li>
--   </ul>
complementByteString :: BuiltinByteString -> BuiltinByteString

-- | Read a bit at the _bit_ index given by the <a>Integer</a> argument in
--   the <a>BuiltinByteString</a> argument. The result will be <a>True</a>
--   if the corresponding bit is set, and <a>False</a> if it is clear. Will
--   error if given an out-of-bounds index argument; that is, if the index
--   is either negative, or equal to or greater than the total number of
--   bits in the <a>BuiltinByteString</a> argument.
--   
--   <h1>See also</h1>
--   
--   <ul>
--   <li><a>Bit indexing scheme</a></li>
--   <li><a>Operation description</a></li>
--   </ul>
readBit :: BuiltinByteString -> Integer -> Bool

-- | Given a <a>BuiltinByteString</a>, a list of indexes to change, and a
--   boolean value <tt>b</tt> to change those indexes to, set the
--   <i>bit</i> at each of the specified index as follows:
--   
--   <ul>
--   <li>If <tt>b</tt> is <a>True</a>, set that bit;</li>
--   <li>Otherwise, clear that bit.</li>
--   </ul>
--   
--   Will error if any of the indexes are out-of-bounds: that is, if the
--   index is either negative, or equal to or greater than the total number
--   of bits in the <a>BuiltinByteString</a> argument.
--   
--   <h1>Note</h1>
--   
--   This differs slightly from the description of the <a>corresponding
--   operation in CIP-122</a>; instead of a single changelist argument
--   comprised of pairs, we instead pass a single list of indexes to
--   change, and a single boolean value to change those indexes to. The
--   original proposal allowed one to set and clear bits in a single
--   operation, but constructing the list of boolean values for the updates
--   was somewhat expensive. If it's really necessary to set some bits and
--   clear others then it is easier to call the function twice, once to set
--   bits and and once to clear them.
--   
--   <h1>See also</h1>
--   
--   <ul>
--   <li><a>Bit indexing scheme</a></li>
--   <li><a>Operation description</a></li>
--   </ul>
writeBits :: BuiltinByteString -> [Integer] -> Bool -> BuiltinByteString

-- | Shift a <a>BuiltinByteString</a>, as per <a>CIP-123</a>.
shiftByteString :: BuiltinByteString -> Integer -> BuiltinByteString

-- | Rotate a <a>BuiltinByteString</a>, as per <a>CIP-123</a>.
rotateByteString :: BuiltinByteString -> Integer -> BuiltinByteString

-- | Count the set bits in a <a>BuiltinByteString</a>, as per
--   <a>CIP-123</a>.
countSetBits :: BuiltinByteString -> Integer

-- | Find the lowest index of a set bit in a <a>BuiltinByteString</a>, as
--   per <a>CIP-123</a>.
--   
--   If given a <a>BuiltinByteString</a> which consists only of zero bytes
--   (including the empty <a>BuiltinByteString</a>, this returns
--   <tt>-1</tt>.
findFirstSetBit :: BuiltinByteString -> Integer

-- | The SHA2-256 hash of a <tt>ByteString</tt>
sha2_256 :: BuiltinByteString -> BuiltinByteString

-- | The SHA3-256 hash of a <tt>ByteString</tt>
sha3_256 :: BuiltinByteString -> BuiltinByteString

-- | The BLAKE2B-224 hash of a <tt>ByteString</tt>
blake2b_224 :: BuiltinByteString -> BuiltinByteString

-- | The BLAKE2B-256 hash of a <tt>ByteString</tt>
blake2b_256 :: BuiltinByteString -> BuiltinByteString

-- | The KECCAK-256 hash of a <tt>ByteString</tt>
keccak_256 :: BuiltinByteString -> BuiltinByteString

-- | The RIPEMD-160 hash of a <tt>ByteString</tt>
ripemd_160 :: BuiltinByteString -> BuiltinByteString

-- | Ed25519 signature verification. Verify that the signature is a
--   signature of the message by the public key. This will fail if key or
--   the signature are not of the expected length.
verifyEd25519Signature :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString -> Bool

-- | Given an ECDSA SECP256k1 verification key, an ECDSA SECP256k1
--   signature, and an ECDSA SECP256k1 message hash (all as
--   <a>BuiltinByteString</a>s), verify the hash with that key and
--   signature.
--   
--   <h1>Note</h1>
--   
--   There are additional well-formation requirements for the arguments
--   beyond their length:
--   
--   <ul>
--   <li>The first byte of the public key must correspond to the sign of
--   the <i>y</i> coordinate: this is <tt>0x02</tt> if <i>y</i> is even,
--   and <tt>0x03</tt> otherwise.</li>
--   <li>The remaining bytes of the public key must correspond to the
--   <i>x</i> coordinate, as a big-endian integer.</li>
--   <li>The first 32 bytes of the signature must correspond to the
--   big-endian integer representation of _r_.</li>
--   <li>The last 32 bytes of the signature must correspond to the
--   big-endian integer representation of _s_.</li>
--   </ul>
--   
--   While this primitive <i>accepts</i> a hash, any caller should only
--   pass it hashes that they computed themselves: specifically, they
--   should receive the <i>message</i> from a sender and hash it, rather
--   than receiving the <i>hash</i> from said sender. Failure to do so can
--   be <a>dangerous</a>. Other than length, we make no requirements of
--   what hash gets used.
--   
--   <h1>See also</h1>
--   
--   <ul>
--   <li><a><tt>secp256k1_ec_pubkey_serialize</tt></a>; this implements the
--   format for the verification key that we accept, given a length
--   argument of 33 and the <tt>SECP256K1_EC_COMPRESSED</tt> flag.</li>
--   <li><a><tt>secp256k1_ecdsa_serialize_compact</tt></a>; this implements
--   the format for the signature that we accept.</li>
--   </ul>
verifyEcdsaSecp256k1Signature :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString -> Bool

-- | Given a Schnorr SECP256k1 verification key, a Schnorr SECP256k1
--   signature, and a message (all as <a>BuiltinByteString</a>s), verify
--   the message with that key and signature.
--   
--   <h1>Note</h1>
--   
--   There are additional well-formation requirements for the arguments
--   beyond their length. Throughout, we refer to co-ordinates of the point
--   <tt>R</tt>.
--   
--   <ul>
--   <li>The bytes of the public key must correspond to the <i>x</i>
--   coordinate, as a big-endian integer, as specified in BIP-340.</li>
--   <li>The first 32 bytes of the signature must correspond to the
--   <i>x</i> coordinate, as a big-endian integer, as specified in
--   BIP-340.</li>
--   <li>The last 32 bytes of the signature must correspond to the bytes of
--   <i>s</i>, as a big-endian integer, as specified in BIP-340.</li>
--   </ul>
--   
--   <h1>See also</h1>
--   
--   <ul>
--   <li><a>BIP-340</a></li>
--   <li><a><tt>secp256k1_xonly_pubkey_serialize</tt></a>; this implements
--   the format for the verification key that we accept.</li>
--   <li><a><tt>secp256k1_schnorrsig_sign</tt></a>; this implements the
--   signing logic for signatures this builtin can verify.</li>
--   </ul>
verifySchnorrSecp256k1Signature :: BuiltinByteString -> BuiltinByteString -> BuiltinByteString -> Bool

-- | Represents an arbitrary-precision ratio.
--   
--   The following two invariants are maintained:
--   
--   <ol>
--   <li>The denominator is greater than zero.</li>
--   <li>The numerator and denominator are coprime.</li>
--   </ol>
data Rational

-- | Makes a <a>Rational</a> from a numerator and a denominator.
--   
--   <h1>Important note</h1>
--   
--   If given a zero denominator, this function will error. If you don't
--   mind a size increase, and care about safety, use <a>ratio</a> instead.
unsafeRatio :: Integer -> Integer -> Rational

-- | Safely constructs a <a>Rational</a> from a numerator and a
--   denominator. Returns <tt>Nothing</tt> if given a zero denominator.
ratio :: Integer -> Integer -> Maybe Rational

-- | Converts an <a>Integer</a> into the equivalent <a>Rational</a>.
fromInteger :: Integer -> Rational

-- | <tt><a>round</a> r</tt> returns the nearest <a>Integer</a> value to
--   <tt>r</tt>. If <tt>r</tt> is equidistant between two values, the even
--   value will be given.
round :: Rational -> Integer

-- | A type corresponding to the Plutus Core builtin equivalent of
--   <a>Data</a>.
--   
--   The point of this type is to be an opaque equivalent of <a>Data</a>,
--   so as to ensure that it is only used in ways that the compiler can
--   handle.
--   
--   As such, you should use this type in your on-chain code, and in any
--   data structures that you want to be representable on-chain.
--   
--   For off-chain usage, there are conversion functions
--   <a>builtinDataToData</a> and <a>dataToBuiltinData</a>, but note that
--   these will not work on-chain.
data BuiltinData
data BuiltinBLS12_381_G1_Element
bls12_381_G1_equals :: BuiltinBLS12_381_G1_Element -> BuiltinBLS12_381_G1_Element -> Bool
bls12_381_G1_add :: BuiltinBLS12_381_G1_Element -> BuiltinBLS12_381_G1_Element -> BuiltinBLS12_381_G1_Element
bls12_381_G1_neg :: BuiltinBLS12_381_G1_Element -> BuiltinBLS12_381_G1_Element
bls12_381_G1_scalarMul :: Integer -> BuiltinBLS12_381_G1_Element -> BuiltinBLS12_381_G1_Element
bls12_381_G1_compress :: BuiltinBLS12_381_G1_Element -> BuiltinByteString
bls12_381_G1_uncompress :: BuiltinByteString -> BuiltinBLS12_381_G1_Element
bls12_381_G1_hashToGroup :: BuiltinByteString -> BuiltinByteString -> BuiltinBLS12_381_G1_Element
bls12_381_G1_compressed_zero :: BuiltinByteString
bls12_381_G1_compressed_generator :: BuiltinByteString
data BuiltinBLS12_381_G2_Element
bls12_381_G2_equals :: BuiltinBLS12_381_G2_Element -> BuiltinBLS12_381_G2_Element -> Bool
bls12_381_G2_add :: BuiltinBLS12_381_G2_Element -> BuiltinBLS12_381_G2_Element -> BuiltinBLS12_381_G2_Element
bls12_381_G2_neg :: BuiltinBLS12_381_G2_Element -> BuiltinBLS12_381_G2_Element
bls12_381_G2_scalarMul :: Integer -> BuiltinBLS12_381_G2_Element -> BuiltinBLS12_381_G2_Element
bls12_381_G2_compress :: BuiltinBLS12_381_G2_Element -> BuiltinByteString
bls12_381_G2_uncompress :: BuiltinByteString -> BuiltinBLS12_381_G2_Element
bls12_381_G2_hashToGroup :: BuiltinByteString -> BuiltinByteString -> BuiltinBLS12_381_G2_Element
bls12_381_G2_compressed_zero :: BuiltinByteString
bls12_381_G2_compressed_generator :: BuiltinByteString
data BuiltinBLS12_381_MlResult
bls12_381_millerLoop :: BuiltinBLS12_381_G1_Element -> BuiltinBLS12_381_G2_Element -> BuiltinBLS12_381_MlResult
bls12_381_mulMlResult :: BuiltinBLS12_381_MlResult -> BuiltinBLS12_381_MlResult -> BuiltinBLS12_381_MlResult
bls12_381_finalVerify :: BuiltinBLS12_381_MlResult -> BuiltinBLS12_381_MlResult -> Bool
fromBuiltin :: HasFromBuiltin arep => arep -> FromBuiltin arep
toBuiltin :: HasToBuiltin a => a -> ToBuiltin a
fromOpaque :: HasFromOpaque arep a => arep -> a
toOpaque :: HasToOpaque a arep => a -> arep

-- | Convert a <tt>BuiltinInteger</tt> into a <a>BuiltinByteString</a>, as
--   described in <a>CIP-121</a>. The first argument indicates the
--   endianness of the conversion and the third argument is the integer to
--   be converted, which must be non-negative. The second argument must
--   also be non-negative and it indicates the required width of the
--   output. If the width is zero then the output is the smallest
--   bytestring which can contain the converted input (and in this case,
--   the integer 0 encodes to the empty bytestring). If the width is
--   nonzero then the output bytestring will be padded to the required
--   width with 0x00 bytes (on the left for big-endian conversions and on
--   the right for little-endian conversions); if the input integer is too
--   big to fit into a bytestring of the specified width then the
--   conversion will fail. Conversion will also fail if the specified width
--   is greater than 8192 or the input integer is too big to fit into a
--   bytestring of length 8192.
integerToByteString :: ByteOrder -> Integer -> Integer -> BuiltinByteString

-- | Convert a <a>BuiltinByteString</a> to a <tt>BuiltinInteger</tt>, as
--   described in <a>CIP-121</a>. The first argument indicates the
--   endianness of the conversion and the second is the bytestring to be
--   converted. There is no limitation on the size of the bytestring. The
--   empty bytestring is converted to the integer 0.
byteStringToInteger :: ByteOrder -> BuiltinByteString -> Integer

module PlutusTx.Sqrt

-- | Integer square-root representation, discarding imaginary integers.
data Sqrt

-- | The number was negative, so we don't even attempt to compute it; just
--   note that the result would be imaginary.
Imaginary :: Sqrt

-- | An exact integer result. The <a>rsqrt</a> of 4 is 'Exactly 2'.
Exactly :: Integer -> Sqrt

-- | The Integer component (i.e. the floor) of a non-integral result. The
--   'rsqrt 2' is 'Approximately 1'.
Approximately :: Integer -> Sqrt

-- | Calculates the sqrt of a ratio of integers. As x / 0 is undefined,
--   calling this function with `d=0` results in an error.
rsqrt :: Rational -> Sqrt

-- | Calculates the integer-component of the sqrt of <tt>n</tt>.
isqrt :: Integer -> Sqrt
instance PlutusTx.IsData.Class.ToData PlutusTx.Sqrt.Sqrt
instance PlutusTx.IsData.Class.FromData PlutusTx.Sqrt.Sqrt
instance PlutusTx.IsData.Class.UnsafeFromData PlutusTx.Sqrt.Sqrt
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusTx.Sqrt.Sqrt
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusTx.Sqrt.Sqrt
instance GHC.Classes.Eq PlutusTx.Sqrt.Sqrt
instance GHC.Show.Show PlutusTx.Sqrt.Sqrt

module PlutusTx.Show

-- | Conversion of values to <a>BuiltinString</a>s. Unlike
--   <tt>GHC.Show.Show</tt>, there is no <tt>showList</tt> method, because
--   there is no <a>Show</a> instance for <a>String</a>.
class Show a
showsPrec :: Show a => Integer -> a -> ShowS
show :: Show a => a -> BuiltinString

-- | Currently the only way to concatenate <a>BuiltinString</a>s is
--   <a>appendString</a>, whose cost is linear in the total length of the
--   two strings. A naive concatenation of multiple <a>BuiltinString</a>s
--   costs <tt>O(n^2)</tt> in the worst case, where <tt>n</tt> is the total
--   length. By collecting the <a>BuiltinString</a>s in a list and
--   concatenating them in the end, the cost can be reduced to
--   <tt>O(n*logn)</tt>. If we add a <tt>concatStrings</tt> builtin
--   function in the future, the cost can be further reduced to
--   <tt>O(n)</tt>.
--   
--   Like <a>ShowS</a>, the purpose of the function type here is to turn
--   list concatenation into function composition.
type ShowS = [BuiltinString] -> [BuiltinString]

-- | Convert a non-negative integer to individual digits.
toDigits :: Integer -> [Integer]
showString :: BuiltinString -> ShowS
showSpace :: ShowS
showCommaSpace :: ShowS
showParen :: Bool -> ShowS -> ShowS
appPrec :: Integer
appPrec1 :: Integer

-- | Derive <a>Show</a> instance. Adapted from
--   <tt>Text.Show.Deriving.deriveShow</tt>.
deriveShow :: Name -> Q [Dec]
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b) => PlutusTx.Show.TH.Show (PlutusTx.These.These a b)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b) => PlutusTx.Show.TH.Show (Data.Either.Either a b)
instance PlutusTx.Show.TH.Show a => PlutusTx.Show.TH.Show (GHC.Maybe.Maybe a)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f, PlutusTx.Show.TH.Show g, PlutusTx.Show.TH.Show h, PlutusTx.Show.TH.Show i, PlutusTx.Show.TH.Show j, PlutusTx.Show.TH.Show k, PlutusTx.Show.TH.Show l, PlutusTx.Show.TH.Show m, PlutusTx.Show.TH.Show n, PlutusTx.Show.TH.Show o, PlutusTx.Show.TH.Show p, PlutusTx.Show.TH.Show q, PlutusTx.Show.TH.Show r, PlutusTx.Show.TH.Show s, PlutusTx.Show.TH.Show t, PlutusTx.Show.TH.Show u, PlutusTx.Show.TH.Show v, PlutusTx.Show.TH.Show w, PlutusTx.Show.TH.Show x, PlutusTx.Show.TH.Show y, PlutusTx.Show.TH.Show z, PlutusTx.Show.TH.Show t26) => PlutusTx.Show.TH.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f, PlutusTx.Show.TH.Show g, PlutusTx.Show.TH.Show h, PlutusTx.Show.TH.Show i, PlutusTx.Show.TH.Show j, PlutusTx.Show.TH.Show k, PlutusTx.Show.TH.Show l, PlutusTx.Show.TH.Show m, PlutusTx.Show.TH.Show n, PlutusTx.Show.TH.Show o, PlutusTx.Show.TH.Show p, PlutusTx.Show.TH.Show q, PlutusTx.Show.TH.Show r, PlutusTx.Show.TH.Show s, PlutusTx.Show.TH.Show t, PlutusTx.Show.TH.Show u, PlutusTx.Show.TH.Show v, PlutusTx.Show.TH.Show w, PlutusTx.Show.TH.Show x, PlutusTx.Show.TH.Show y, PlutusTx.Show.TH.Show z) => PlutusTx.Show.TH.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f, PlutusTx.Show.TH.Show g, PlutusTx.Show.TH.Show h, PlutusTx.Show.TH.Show i, PlutusTx.Show.TH.Show j, PlutusTx.Show.TH.Show k, PlutusTx.Show.TH.Show l, PlutusTx.Show.TH.Show m, PlutusTx.Show.TH.Show n, PlutusTx.Show.TH.Show o, PlutusTx.Show.TH.Show p, PlutusTx.Show.TH.Show q, PlutusTx.Show.TH.Show r, PlutusTx.Show.TH.Show s, PlutusTx.Show.TH.Show t, PlutusTx.Show.TH.Show u, PlutusTx.Show.TH.Show v, PlutusTx.Show.TH.Show w, PlutusTx.Show.TH.Show x, PlutusTx.Show.TH.Show y) => PlutusTx.Show.TH.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f, PlutusTx.Show.TH.Show g, PlutusTx.Show.TH.Show h, PlutusTx.Show.TH.Show i, PlutusTx.Show.TH.Show j, PlutusTx.Show.TH.Show k, PlutusTx.Show.TH.Show l, PlutusTx.Show.TH.Show m, PlutusTx.Show.TH.Show n, PlutusTx.Show.TH.Show o, PlutusTx.Show.TH.Show p, PlutusTx.Show.TH.Show q, PlutusTx.Show.TH.Show r, PlutusTx.Show.TH.Show s, PlutusTx.Show.TH.Show t, PlutusTx.Show.TH.Show u, PlutusTx.Show.TH.Show v, PlutusTx.Show.TH.Show w, PlutusTx.Show.TH.Show x) => PlutusTx.Show.TH.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f, PlutusTx.Show.TH.Show g, PlutusTx.Show.TH.Show h, PlutusTx.Show.TH.Show i, PlutusTx.Show.TH.Show j, PlutusTx.Show.TH.Show k, PlutusTx.Show.TH.Show l, PlutusTx.Show.TH.Show m, PlutusTx.Show.TH.Show n, PlutusTx.Show.TH.Show o, PlutusTx.Show.TH.Show p, PlutusTx.Show.TH.Show q, PlutusTx.Show.TH.Show r, PlutusTx.Show.TH.Show s, PlutusTx.Show.TH.Show t, PlutusTx.Show.TH.Show u, PlutusTx.Show.TH.Show v, PlutusTx.Show.TH.Show w) => PlutusTx.Show.TH.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f, PlutusTx.Show.TH.Show g, PlutusTx.Show.TH.Show h, PlutusTx.Show.TH.Show i, PlutusTx.Show.TH.Show j, PlutusTx.Show.TH.Show k, PlutusTx.Show.TH.Show l, PlutusTx.Show.TH.Show m, PlutusTx.Show.TH.Show n, PlutusTx.Show.TH.Show o, PlutusTx.Show.TH.Show p, PlutusTx.Show.TH.Show q, PlutusTx.Show.TH.Show r, PlutusTx.Show.TH.Show s, PlutusTx.Show.TH.Show t, PlutusTx.Show.TH.Show u, PlutusTx.Show.TH.Show v) => PlutusTx.Show.TH.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f, PlutusTx.Show.TH.Show g, PlutusTx.Show.TH.Show h, PlutusTx.Show.TH.Show i, PlutusTx.Show.TH.Show j, PlutusTx.Show.TH.Show k, PlutusTx.Show.TH.Show l, PlutusTx.Show.TH.Show m, PlutusTx.Show.TH.Show n, PlutusTx.Show.TH.Show o, PlutusTx.Show.TH.Show p, PlutusTx.Show.TH.Show q, PlutusTx.Show.TH.Show r, PlutusTx.Show.TH.Show s, PlutusTx.Show.TH.Show t, PlutusTx.Show.TH.Show u) => PlutusTx.Show.TH.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f, PlutusTx.Show.TH.Show g, PlutusTx.Show.TH.Show h, PlutusTx.Show.TH.Show i, PlutusTx.Show.TH.Show j, PlutusTx.Show.TH.Show k, PlutusTx.Show.TH.Show l, PlutusTx.Show.TH.Show m, PlutusTx.Show.TH.Show n, PlutusTx.Show.TH.Show o, PlutusTx.Show.TH.Show p, PlutusTx.Show.TH.Show q, PlutusTx.Show.TH.Show r, PlutusTx.Show.TH.Show s, PlutusTx.Show.TH.Show t) => PlutusTx.Show.TH.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f, PlutusTx.Show.TH.Show g, PlutusTx.Show.TH.Show h, PlutusTx.Show.TH.Show i, PlutusTx.Show.TH.Show j, PlutusTx.Show.TH.Show k, PlutusTx.Show.TH.Show l, PlutusTx.Show.TH.Show m, PlutusTx.Show.TH.Show n, PlutusTx.Show.TH.Show o, PlutusTx.Show.TH.Show p, PlutusTx.Show.TH.Show q, PlutusTx.Show.TH.Show r, PlutusTx.Show.TH.Show s) => PlutusTx.Show.TH.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f, PlutusTx.Show.TH.Show g, PlutusTx.Show.TH.Show h, PlutusTx.Show.TH.Show i, PlutusTx.Show.TH.Show j, PlutusTx.Show.TH.Show k, PlutusTx.Show.TH.Show l, PlutusTx.Show.TH.Show m, PlutusTx.Show.TH.Show n, PlutusTx.Show.TH.Show o, PlutusTx.Show.TH.Show p, PlutusTx.Show.TH.Show q, PlutusTx.Show.TH.Show r) => PlutusTx.Show.TH.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f, PlutusTx.Show.TH.Show g, PlutusTx.Show.TH.Show h, PlutusTx.Show.TH.Show i, PlutusTx.Show.TH.Show j, PlutusTx.Show.TH.Show k, PlutusTx.Show.TH.Show l, PlutusTx.Show.TH.Show m, PlutusTx.Show.TH.Show n, PlutusTx.Show.TH.Show o, PlutusTx.Show.TH.Show p, PlutusTx.Show.TH.Show q) => PlutusTx.Show.TH.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f, PlutusTx.Show.TH.Show g, PlutusTx.Show.TH.Show h, PlutusTx.Show.TH.Show i, PlutusTx.Show.TH.Show j, PlutusTx.Show.TH.Show k, PlutusTx.Show.TH.Show l, PlutusTx.Show.TH.Show m, PlutusTx.Show.TH.Show n, PlutusTx.Show.TH.Show o, PlutusTx.Show.TH.Show p) => PlutusTx.Show.TH.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f, PlutusTx.Show.TH.Show g, PlutusTx.Show.TH.Show h, PlutusTx.Show.TH.Show i, PlutusTx.Show.TH.Show j, PlutusTx.Show.TH.Show k, PlutusTx.Show.TH.Show l, PlutusTx.Show.TH.Show m, PlutusTx.Show.TH.Show n, PlutusTx.Show.TH.Show o) => PlutusTx.Show.TH.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f, PlutusTx.Show.TH.Show g, PlutusTx.Show.TH.Show h, PlutusTx.Show.TH.Show i, PlutusTx.Show.TH.Show j, PlutusTx.Show.TH.Show k, PlutusTx.Show.TH.Show l, PlutusTx.Show.TH.Show m, PlutusTx.Show.TH.Show n) => PlutusTx.Show.TH.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f, PlutusTx.Show.TH.Show g, PlutusTx.Show.TH.Show h, PlutusTx.Show.TH.Show i, PlutusTx.Show.TH.Show j, PlutusTx.Show.TH.Show k, PlutusTx.Show.TH.Show l, PlutusTx.Show.TH.Show m) => PlutusTx.Show.TH.Show (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f, PlutusTx.Show.TH.Show g, PlutusTx.Show.TH.Show h, PlutusTx.Show.TH.Show i, PlutusTx.Show.TH.Show j, PlutusTx.Show.TH.Show k, PlutusTx.Show.TH.Show l) => PlutusTx.Show.TH.Show (a, b, c, d, e, f, g, h, i, j, k, l)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f, PlutusTx.Show.TH.Show g, PlutusTx.Show.TH.Show h, PlutusTx.Show.TH.Show i, PlutusTx.Show.TH.Show j, PlutusTx.Show.TH.Show k) => PlutusTx.Show.TH.Show (a, b, c, d, e, f, g, h, i, j, k)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f, PlutusTx.Show.TH.Show g, PlutusTx.Show.TH.Show h, PlutusTx.Show.TH.Show i, PlutusTx.Show.TH.Show j) => PlutusTx.Show.TH.Show (a, b, c, d, e, f, g, h, i, j)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f, PlutusTx.Show.TH.Show g, PlutusTx.Show.TH.Show h, PlutusTx.Show.TH.Show i) => PlutusTx.Show.TH.Show (a, b, c, d, e, f, g, h, i)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f, PlutusTx.Show.TH.Show g, PlutusTx.Show.TH.Show h) => PlutusTx.Show.TH.Show (a, b, c, d, e, f, g, h)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f, PlutusTx.Show.TH.Show g) => PlutusTx.Show.TH.Show (a, b, c, d, e, f, g)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e, PlutusTx.Show.TH.Show f) => PlutusTx.Show.TH.Show (a, b, c, d, e, f)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d, PlutusTx.Show.TH.Show e) => PlutusTx.Show.TH.Show (a, b, c, d, e)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c, PlutusTx.Show.TH.Show d) => PlutusTx.Show.TH.Show (a, b, c, d)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b, PlutusTx.Show.TH.Show c) => PlutusTx.Show.TH.Show (a, b, c)
instance (PlutusTx.Show.TH.Show a, PlutusTx.Show.TH.Show b) => PlutusTx.Show.TH.Show (a, b)
instance PlutusTx.Show.TH.Show GHC.Num.Integer.Integer
instance PlutusTx.Show.TH.Show PlutusTx.Builtins.Internal.BuiltinByteString
instance PlutusTx.Show.TH.Show PlutusTx.Builtins.Internal.BuiltinString
instance PlutusTx.Show.TH.Show PlutusTx.Builtins.Internal.BuiltinData
instance PlutusTx.Show.TH.Show GHC.Types.Bool
instance PlutusTx.Show.TH.Show ()
instance PlutusTx.Show.TH.Show a => PlutusTx.Show.TH.Show [a]

module PlutusTx.Data.AssocMap

-- | A map associating keys and values backed by <a>BuiltinData</a>.
--   
--   This implementation has the following characteristics:
--   
--   <ul>
--   <li>The <a>toBuiltinData</a> and <a>unsafeFromBuiltinData</a>
--   operations are no-op.</li>
--   <li>Other operations are slower than <tt>PlutusTx.AssocMap.Map</tt>,
--   although equality checks on keys can be faster due to
--   <a>equalsData</a>.</li>
--   <li>Many operations involve converting the keys and/or values to/from
--   <a>BuiltinData</a>.</li>
--   </ul>
--   
--   Therefore this implementation is likely a better choice than
--   <a>PlutusTx.AssocMap.Map</a> if it is part of a data type defined
--   using <tt>asData</tt>, and the key and value types have efficient
--   <a>toBuiltinData</a> and <a>unsafeFromBuiltinData</a> operations
--   (e.g., they are primitive types or types defined using
--   <tt>asData</tt>).
--   
--   A <a>Map</a> is considered well-defined if it has no duplicate keys.
--   Most operations preserve the definedness of the resulting <a>Map</a>
--   unless otherwise noted. It is important to observe that, in comparison
--   to standard map implementations, this implementation provides slow
--   lookup and update operations because it is based on a list
--   representation.
data Map k a

-- | Look up the value corresponding to the key. If the <a>Map</a> is not
--   well-defined, the result is the value associated with the left-most
--   occurrence of the key in the list. This operation is O(n).
lookup :: forall k a. (ToData k, UnsafeFromData a) => k -> Map k a -> Maybe a

-- | Check if the key is in the <a>Map</a>.
member :: forall k a. ToData k => k -> Map k a -> Bool

-- | Insert a key-value pair into the <a>Map</a>. If the key is already
--   present, the value is updated.
insert :: forall k a. (ToData k, ToData a) => k -> a -> Map k a -> Map k a

-- | Delete a key value pair from the <a>Map</a>. If the <a>Map</a> is not
--   well-defined, it deletes the pair associated with the left-most
--   occurrence of the key in the list.
delete :: forall k a. ToData k => k -> Map k a -> Map k a

-- | Create an <a>Map</a> with a single key-value pair.
singleton :: forall k a. (ToData k, ToData a) => k -> a -> Map k a

-- | An empty <a>Map</a>.
empty :: forall k a. Map k a

-- | Check if the <a>Map</a> is empty.
null :: forall k a. Map k a -> Bool

-- | Convert the <a>Map</a> to a list of key-value pairs. This operation is
--   O(n). See <a>toBuiltinList</a> for a more efficient alternative.
toList :: (UnsafeFromData k, UnsafeFromData a) => Map k a -> [(k, a)]

-- | Convert the <a>Map</a> to a <a>BuiltinList</a> of key-value pairs.
--   This operation is O(1).
toBuiltinList :: Map k a -> BuiltinList (BuiltinPair BuiltinData BuiltinData)

-- | Create an <a>Map</a> from a list of key-value pairs. In case of
--   duplicates, this function will keep only one entry (the one that
--   precedes). In other words, this function de-duplicates the input list.
safeFromList :: forall k a. (ToData k, ToData a) => [(k, a)] -> Map k a

-- | Unsafely create an <a>Map</a> from a list of pairs. This should _only_
--   be applied to lists which have been checked to not contain duplicate
--   keys, otherwise the resulting <a>Map</a> will contain conflicting
--   entries (two entries sharing the same key), and therefore be
--   ill-defined.
unsafeFromList :: (ToData k, ToData a) => [(k, a)] -> Map k a

-- | Unsafely create an <a>Map</a> from a <a>BuiltinList</a> of key-value
--   pairs. This function is unsafe because it assumes that the elements of
--   the list can be safely decoded from their <a>BuiltinData</a>
--   representation.
unsafeFromBuiltinList :: forall k a. BuiltinList (BuiltinPair BuiltinData BuiltinData) -> Map k a

-- | Check if the <a>Map</a> is well-defined. Warning: this operation is
--   O(n^2).
noDuplicateKeys :: forall k a. Map k a -> Bool
all :: forall k a. UnsafeFromData a => (a -> Bool) -> Map k a -> Bool

-- | Check if any value in the <a>Map</a> satisfies the predicate.
any :: forall k a. UnsafeFromData a => (a -> Bool) -> Map k a -> Bool

-- | Combine two <a>Map</a>s into one. It saves both values if the key is
--   present in both maps.
union :: forall k a b. (UnsafeFromData a, UnsafeFromData b, ToData a, ToData b) => Map k a -> Map k b -> Map k (These a b)

-- | Combine two <a>Map</a>s with the given combination function.
unionWith :: forall k a. (UnsafeFromData a, ToData a) => (a -> a -> a) -> Map k a -> Map k a -> Map k a
keys :: forall k a. Map k a -> BuiltinList BuiltinData
map :: forall k a b. (UnsafeFromData a, ToData b) => (a -> b) -> Map k a -> Map k b
mapThese :: forall v k a b. (ToData a, ToData b, UnsafeFromData v) => (v -> These a b) -> Map k v -> (Map k a, Map k b)
foldr :: forall a b k. UnsafeFromData a => (a -> b -> b) -> b -> Map k a -> b
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusTx.Data.AssocMap.Map
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (PlutusTx.Data.AssocMap.Map k a)
instance GHC.Show.Show (PlutusTx.Data.AssocMap.Map k a)
instance PlutusTx.IsData.Class.ToData (PlutusTx.Data.AssocMap.Map k a)
instance PlutusTx.IsData.Class.FromData (PlutusTx.Data.AssocMap.Map k a)
instance PlutusTx.IsData.Class.UnsafeFromData (PlutusTx.Data.AssocMap.Map k a)
instance (Prettyprinter.Internal.Pretty k, Prettyprinter.Internal.Pretty a, PlutusTx.IsData.Class.UnsafeFromData k, PlutusTx.IsData.Class.UnsafeFromData a) => Prettyprinter.Internal.Pretty (PlutusTx.Data.AssocMap.Map k a)


-- | A map represented as an "association list" of key-value pairs.
module PlutusTx.AssocMap

-- | A <a>Map</a> of key-value pairs. A <a>Map</a> is considered
--   well-defined if there are no key collisions, meaning that each value
--   is uniquely identified by a key.
--   
--   Use <a>safeFromList</a> to create well-defined <a>Map</a>s from
--   arbitrary lists of pairs.
--   
--   If cost minimisation is required, then you can use
--   <a>unsafeFromList</a> but you must be certain that the list you are
--   converting to a <a>Map</a> abides by the well-definedness condition.
--   
--   Most operations on <a>Map</a>s are definedness-preserving, meaning
--   that for the resulting <a>Map</a> to be well-defined then the input
--   <a>Map</a>(s) have to also be well-defined. This is not checked
--   explicitly unless mentioned in the documentation.
--   
--   Take care when using <a>fromBuiltinData</a> and
--   <a>unsafeFromBuiltinData</a>, as neither function performs
--   deduplication of the input collection and may create invalid
--   <a>Map</a>s!
data Map k v

-- | A singleton map.
singleton :: k -> v -> Map k v

-- | An empty <a>Map</a>.
empty :: Map k v

-- | Is the map empty?
null :: Map k v -> Bool

-- | Unsafely create a <a>Map</a> from a list of pairs. This should _only_
--   be applied to lists which have been checked to not contain duplicate
--   keys, otherwise the resulting <a>Map</a> will contain conflicting
--   entries (two entries sharing the same key). As usual, the "keys" are
--   considered to be the first element of the pair.
unsafeFromList :: [(k, v)] -> Map k v

-- | In case of duplicates, this function will keep only one entry (the one
--   that precedes). In other words, this function de-duplicates the input
--   list.
safeFromList :: Eq k => [(k, v)] -> Map k v
toList :: Map k v -> [(k, v)]

-- | The keys of a <a>Map</a>. Semantically, the resulting list is only a
--   set if the <a>Map</a> didn't contain duplicate keys.
keys :: Map k v -> [k]

-- | Return all elements of the map.
elems :: Map k v -> [v]

-- | Find an entry in a <a>Map</a>. If the <a>Map</a> is not well-formed
--   (it contains duplicate keys) then this will return the value of the
--   left-most pair in the underlying list of pairs.
lookup :: forall k v. Eq k => k -> Map k v -> Maybe v

-- | Is the key a member of the map?
member :: forall k v. Eq k => k -> Map k v -> Bool

-- | If a key already exists in the map, its entry will be replaced with
--   the new value.
insert :: forall k v. Eq k => k -> v -> Map k v -> Map k v

-- | Delete an entry from the <a>Map</a>. Assumes that the <a>Map</a> is
--   well-formed, i.e. if the underlying list of pairs contains pairs with
--   duplicate keys then only the left-most pair will be removed.
delete :: forall k v. Eq k => k -> Map k v -> Map k v

-- | Combine two <a>Map</a>s. Keeps both values on key collisions. Note
--   that well-formedness is only preserved if the two input maps are also
--   well-formed. Also, as an implementation detail, in the case that the
--   right map contains duplicate keys, and there exists a collision
--   between the two maps, then only the left-most value of the right map
--   will be kept.
union :: forall k v r. Eq k => Map k v -> Map k r -> Map k (These v r)

-- | Combine two <a>Map</a>s with the given combination function. Note that
--   well-formedness of the resulting map depends on the two input maps
--   being well-formed. Also, as an implementation detail, in the case that
--   the right map contains duplicate keys, and there exists a collision
--   between the two maps, then only the left-most value of the right map
--   will be kept.
unionWith :: forall k a. Eq k => (a -> a -> a) -> Map k a -> Map k a -> Map k a

-- | Filter all values that satisfy the predicate.
filter :: (v -> Bool) -> Map k v -> Map k v

-- | Map a function over all values in the map.
mapWithKey :: (k -> a -> b) -> Map k a -> Map k b

-- | Map keys/values and collect the <a>Just</a> results.
mapMaybe :: (a -> Maybe b) -> Map k a -> Map k b

-- | Map keys/values and collect the <a>Just</a> results.
mapMaybeWithKey :: (k -> a -> Maybe b) -> Map k a -> Map k b

-- | Determines whether all elements in the map satisfy the predicate.
all :: (a -> Bool) -> Map k a -> Bool

-- | A version of <a>mapEither</a> that works with <a>These</a>.
mapThese :: (v -> These a b) -> Map k v -> (Map k a, Map k b)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusTx.AssocMap.Map
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni [(k, v)] => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (PlutusTx.AssocMap.Map k v)
instance (Control.DeepSeq.NFData k, Control.DeepSeq.NFData v) => Control.DeepSeq.NFData (PlutusTx.AssocMap.Map k v)
instance (Language.Haskell.TH.Syntax.Lift k, Language.Haskell.TH.Syntax.Lift v) => Language.Haskell.TH.Syntax.Lift (PlutusTx.AssocMap.Map k v)
instance (Data.Data.Data k, Data.Data.Data v) => Data.Data.Data (PlutusTx.AssocMap.Map k v)
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (PlutusTx.AssocMap.Map k v)
instance GHC.Generics.Generic (PlutusTx.AssocMap.Map k v)
instance (GHC.Classes.Ord k, GHC.Classes.Eq v) => GHC.Classes.Eq (PlutusTx.AssocMap.Map k v)
instance (GHC.Classes.Ord k, GHC.Classes.Ord v) => GHC.Classes.Ord (PlutusTx.AssocMap.Map k v)
instance (PlutusTx.IsData.Class.ToData k, PlutusTx.IsData.Class.ToData v) => PlutusTx.IsData.Class.ToData (PlutusTx.AssocMap.Map k v)
instance (PlutusTx.IsData.Class.FromData k, PlutusTx.IsData.Class.FromData v) => PlutusTx.IsData.Class.FromData (PlutusTx.AssocMap.Map k v)
instance (PlutusTx.IsData.Class.UnsafeFromData k, PlutusTx.IsData.Class.UnsafeFromData v) => PlutusTx.IsData.Class.UnsafeFromData (PlutusTx.AssocMap.Map k v)
instance (PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition k, PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition v) => PlutusTx.Blueprint.Definition.Unroll.HasBlueprintDefinition (PlutusTx.AssocMap.Map k v)
instance (PlutusTx.Blueprint.Class.HasBlueprintSchema k referencedTypes, PlutusTx.Blueprint.Class.HasBlueprintSchema v referencedTypes) => PlutusTx.Blueprint.Class.HasBlueprintSchema (PlutusTx.AssocMap.Map k v) referencedTypes
instance PlutusTx.Functor.Functor (PlutusTx.AssocMap.Map k)
instance PlutusTx.Foldable.Foldable (PlutusTx.AssocMap.Map k)
instance PlutusTx.Traversable.Traversable (PlutusTx.AssocMap.Map k)
instance (PlutusTx.Eq.Eq k, PlutusTx.Semigroup.Semigroup v) => PlutusTx.Semigroup.Semigroup (PlutusTx.AssocMap.Map k v)
instance (PlutusTx.Eq.Eq k, PlutusTx.Semigroup.Semigroup v) => PlutusTx.Monoid.Monoid (PlutusTx.AssocMap.Map k v)
instance (Prettyprinter.Internal.Pretty k, Prettyprinter.Internal.Pretty v) => Prettyprinter.Internal.Pretty (PlutusTx.AssocMap.Map k v)

module PlutusTx.Utils
mustBeReplaced :: String -> a

module PlutusTx.Plugin.Utils

-- | Marks the given expression for compilation to PLC.
plc :: forall (loc :: Symbol) a. Proxy loc -> a -> CompiledCode a

module PlutusTx.TH

-- | Compile a quoted Haskell expression into a corresponding Plutus Core
--   program.
compile :: SpliceQ a -> SpliceQ (CompiledCode a)

-- | Compile a quoted Haskell expression into a corresponding Plutus Core
--   program.
compileUntyped :: Q Exp -> Q Exp

-- | Load a <a>CompiledCode</a> from a file. Drop-in replacement for
--   <a>compile</a>.
loadFromFile :: FilePath -> SpliceQ (CompiledCode a)

module PlutusTx

-- | <a>CompiledCodeIn</a> instantiated with default built-in types and
--   functions.
type CompiledCode = CompiledCodeIn DefaultUni DefaultFun

-- | A compiled Plutus Tx program. The last type parameter indicates the
--   type of the Haskell expression that was compiled, and hence the type
--   of the compiled code.
--   
--   Note: the compiled PLC program does *not* have normalized types, if
--   you want to put it on the chain you must normalize the types first.
data CompiledCodeIn uni fun a

-- | Get the actual Plutus Core program out of a <a>CompiledCodeIn</a>.
getPlc :: (Closed uni, uni `Everywhere` Flat, Flat fun) => CompiledCodeIn uni fun a -> Program NamedDeBruijn uni fun SrcSpans
getPlcNoAnn :: (Closed uni, uni `Everywhere` Flat, Flat fun) => CompiledCodeIn uni fun a -> Program NamedDeBruijn uni fun ()

-- | Get the Plutus IR program, if there is one, out of a
--   <a>CompiledCodeIn</a>.
getPir :: (Closed uni, uni `Everywhere` Flat, Flat fun) => CompiledCodeIn uni fun a -> Maybe (Program TyName Name uni fun SrcSpans)
getPirNoAnn :: (Closed uni, uni `Everywhere` Flat, Flat fun) => CompiledCodeIn uni fun a -> Maybe (Program TyName Name uni fun ())

-- | Apply a compiled function to a compiled argument. Will fail if the
--   versions don't match.
applyCode :: (Closed uni, uni `Everywhere` Flat, Flat fun, Pretty fun, Everywhere uni PrettyConst, PrettyBy RenderContext (SomeTypeIn uni)) => CompiledCodeIn uni fun (a -> b) -> CompiledCodeIn uni fun a -> Either String (CompiledCodeIn uni fun b)

-- | Apply a compiled function to a compiled argument. Will throw if the
--   versions don't match, should only be used in non-production code.
unsafeApplyCode :: (Closed uni, uni `Everywhere` Flat, Flat fun, Pretty fun, Everywhere uni PrettyConst, PrettyBy RenderContext (SomeTypeIn uni)) => CompiledCodeIn uni fun (a -> b) -> CompiledCodeIn uni fun a -> CompiledCodeIn uni fun b

-- | A type corresponding to the Plutus Core builtin equivalent of
--   <a>Data</a>.
--   
--   The point of this type is to be an opaque equivalent of <a>Data</a>,
--   so as to ensure that it is only used in ways that the compiler can
--   handle.
--   
--   As such, you should use this type in your on-chain code, and in any
--   data structures that you want to be representable on-chain.
--   
--   For off-chain usage, there are conversion functions
--   <a>builtinDataToData</a> and <a>dataToBuiltinData</a>, but note that
--   these will not work on-chain.
data BuiltinData
data () => Data
Constr :: Integer -> [Data] -> Data
Map :: [(Data, Data)] -> Data
List :: [Data] -> Data
I :: Integer -> Data
B :: ByteString -> Data

-- | A typeclass for types that can be converted to and from
--   <a>BuiltinData</a>.
class ToData (a :: Type)

-- | Convert a value to <a>BuiltinData</a>.
toBuiltinData :: ToData a => a -> BuiltinData
class FromData (a :: Type)

-- | Convert a value from <a>BuiltinData</a>, returning <a>Nothing</a> if
--   this fails.
fromBuiltinData :: FromData a => BuiltinData -> Maybe a
class UnsafeFromData (a :: Type)

-- | Convert a value from <a>BuiltinData</a>, calling <a>error</a> if this
--   fails. This is typically much faster than <a>fromBuiltinData</a>.
--   
--   When implementing this function, make sure to call
--   <a>unsafeFromBuiltinData</a> rather than <a>fromBuiltinData</a> when
--   converting substructures!
--   
--   This is a simple type without any validation, <b>use with caution</b>.
unsafeFromBuiltinData :: UnsafeFromData a => BuiltinData -> a

-- | Convert a value to <a>Data</a>.
toData :: ToData a => a -> Data

-- | Convert a value from <a>Data</a>, returning <a>Nothing</a> if this
--   fails.
fromData :: FromData a => Data -> Maybe a

-- | Convert a <a>BuiltinData</a> into a <a>Data</a>. Only works off-chain.
builtinDataToData :: BuiltinData -> Data

-- | Convert a <a>Data</a> into a <a>BuiltinData</a>. Only works off-chain.
dataToBuiltinData :: Data -> BuiltinData

-- | Generate a <a>FromData</a> and a <a>ToData</a> instance for a type.
--   This may not be stable in the face of constructor additions,
--   renamings, etc. Use <a>makeIsDataIndexed</a> if you need stability.
unstableMakeIsData :: Name -> Q [Dec]

-- | Generate a <a>ToData</a>, 'FromData and a <a>UnsafeFromData</a>
--   instances for a type, using an explicit mapping of constructor names
--   to indices. Use this for types where you need to keep the
--   representation stable.
makeIsDataIndexed :: Name -> [(Name, Int)] -> Q [Dec]

-- | Generate a <tt>ToData</tt>, <tt>FromData</tt>,
--   <tt>UnsafeFromData</tt>, <a>HasBlueprintSchema</a> instances for a
--   type, using an explicit mapping of constructor names to indices. Use
--   this for types where you need to keep the representation stable.
makeIsDataSchemaIndexed :: Name -> [(Name, Natural)] -> Q [InstanceDec]

-- | Class for types which can be lifted into Plutus IR. Instances should
--   be derived, do not write your own instance!
class Lift uni a

-- | Class for types which have a corresponding Plutus IR type. Instances
--   should always be derived, do not write your own instance!
class Typeable uni (a :: k)
makeLift :: Name -> Q [Dec]
safeLiftCode :: (Lift uni a, AsTypeError e (Term TyName Name uni fun ()) uni fun (Provenance ()), GEq uni, AsTypeErrorExt e uni (Provenance ()), AsFreeVariableError e, AsError e uni fun (Provenance ()), MonadError e m, MonadQuote m, Typecheckable uni fun, PrettyUni uni, Pretty fun, Default (CostingPart uni fun), Default (BuiltinsInfo uni fun), Default (RewriteRules uni fun), Hashable fun) => Version -> a -> m (CompiledCodeIn uni fun a)

-- | Get a Plutus Core program corresponding to the given value as a
--   <a>CompiledCodeIn</a>, throwing any errors that occur as exceptions
--   and ignoring fresh names.
liftCode :: (Lift uni a, GEq uni, ThrowableBuiltins uni fun, Typecheckable uni fun, Default (CostingPart uni fun), Default (BuiltinsInfo uni fun), Default (RewriteRules uni fun), Hashable fun) => Version -> a -> CompiledCodeIn uni fun a

-- | Get a Plutus Core program with the default version, corresponding to
--   the given value as a <a>CompiledCodeIn</a>, throwing any errors that
--   occur as exceptions and ignoring fresh names.
liftCodeDef :: (Lift uni a, GEq uni, ThrowableBuiltins uni fun, Typecheckable uni fun, Default (CostingPart uni fun), Default (BuiltinsInfo uni fun), Default (RewriteRules uni fun), Hashable fun) => a -> CompiledCodeIn uni fun a
