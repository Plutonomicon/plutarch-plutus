-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Language library for Plutus Core
--   
--   Pretty-printer, parser, and typechecker for Plutus Core.
@package plutus-core
@version 1.36.0.0

module Codec.Extras.FlatViaSerialise

-- | For deriving <a>Flat</a> instances via <tt>Serialize</tt>.
newtype FlatViaSerialise a
FlatViaSerialise :: a -> FlatViaSerialise a
[unFlatViaSerialise] :: FlatViaSerialise a -> a
instance Codec.Serialise.Class.Serialise a => Flat.Class.Flat (Codec.Extras.FlatViaSerialise.FlatViaSerialise a)

module Data.Aeson.THReader
readJSONFromFile :: (FromJSON a, Lift a) => String -> SpliceQ a

module Data.Either.Extras

-- | If argument is <a>Left</a> throw an exception, otherwise return the
--   value inside <a>Right</a>.
unsafeFromEither :: Exception e => Either e a -> a

-- | If argument is <a>Right</a> return its value, otherwise apply the
--   given action to the value of Left and return its result.
fromRightM :: Monad m => (a -> m b) -> Either a b -> m b

module Codec.Extras.SerialiseViaFlat

-- | Newtype to provide <a>Serialise</a> instances for types with a
--   <tt>Flat</tt> instance that just encodes the flat-serialized value as
--   a CBOR bytestring
newtype SerialiseViaFlat a
SerialiseViaFlat :: a -> SerialiseViaFlat a
[unSerialiseViaFlat] :: SerialiseViaFlat a -> a
decodeViaFlatWith :: Get a -> Decoder s a

-- | Similar to <a>DeserialiseFailure</a>, with the difference that plain
--   string reason messages are turned into the datatype:
--   <a>DeserialiseFailureReason</a>.
data DeserialiseFailureInfo
DeserialiseFailureInfo :: ByteOffset -> DeserialiseFailureReason -> DeserialiseFailureInfo
[dfOffset] :: DeserialiseFailureInfo -> ByteOffset
[dfReason] :: DeserialiseFailureInfo -> DeserialiseFailureReason

-- | The reason of the cbor failure as a datatype, not as a plain string.
data DeserialiseFailureReason

-- | Not enough input provided
EndOfInput :: DeserialiseFailureReason

-- | The bytes inside the input are malformed.
ExpectedBytes :: DeserialiseFailureReason

-- | This is either a cbor failure that we (plutus) are not aware of, or an
--   underlying flat failure. We use whatever message <tt>cborg</tt> or
--   flat returns.
OtherReason :: String -> DeserialiseFailureReason

-- | The errors returned by <tt>cborg</tt> are plain strings (untyped).
--   With this function we try to map onto datatypes, those cborg error
--   messages that we are interested in.
--   
--   Currently we are only interested in error messages returned by the
--   <a>decodeBytes</a> decoder; see <a>scriptCBORDecoder</a>.
readDeserialiseFailureInfo :: DeserialiseFailure -> DeserialiseFailureInfo
instance GHC.Show.Show Codec.Extras.SerialiseViaFlat.DeserialiseFailureReason
instance GHC.Classes.Eq Codec.Extras.SerialiseViaFlat.DeserialiseFailureReason
instance GHC.Show.Show Codec.Extras.SerialiseViaFlat.DeserialiseFailureInfo
instance GHC.Classes.Eq Codec.Extras.SerialiseViaFlat.DeserialiseFailureInfo
instance Prettyprinter.Internal.Pretty Codec.Extras.SerialiseViaFlat.DeserialiseFailureInfo
instance Prettyprinter.Internal.Pretty Codec.Extras.SerialiseViaFlat.DeserialiseFailureReason
instance Flat.Class.Flat a => Codec.Serialise.Class.Serialise (Codec.Extras.SerialiseViaFlat.SerialiseViaFlat a)

module Data.List.Extras

-- | A variant of <a>ix</a> that takes a <a>Word64</a> instead of an
--   <a>Int</a>.
wix :: Word64 -> Traversal' [a] a

module Data.MultiSet.Lens

-- | Create a <a>MultiSet</a> from a <a>Getter</a>, <a>Fold</a>, etc.
multiSetOf :: Getting (MultiSet a) s a -> s -> MultiSet a

module PlutusCore.Annotation

-- | An annotation type used during the compilation.
data Ann
Ann :: Inline -> SrcSpans -> Ann
[annInline] :: Ann -> Inline
[annSrcSpans] :: Ann -> SrcSpans

-- | The span between two source locations.
--   
--   This corresponds roughly to the <a>SrcSpan</a> used by GHC, but we
--   define our own version so we don't have to depend on <tt>ghc</tt> to
--   use it.
--   
--   The line and column numbers are 1-based, and the unit is Unicode code
--   point (or <a>Char</a>).
data SrcSpan
SrcSpan :: FilePath -> Int -> Int -> Int -> Int -> SrcSpan
[srcSpanFile] :: SrcSpan -> FilePath
[srcSpanSLine] :: SrcSpan -> Int
[srcSpanSCol] :: SrcSpan -> Int
[srcSpanELine] :: SrcSpan -> Int

-- | Same as GHC's <tt>SrcSpan</tt>, <tt>srcSpanECol</tt> is usually one
--   more than the column of the last character of the thing this
--   <tt>SrcSpan</tt> is for (unless the last character is the line break).
[srcSpanECol] :: SrcSpan -> Int
newtype SrcSpans
SrcSpans :: Set SrcSpan -> SrcSpans
[unSrcSpans] :: SrcSpans -> Set SrcSpan
newtype InlineHints name a
InlineHints :: (a -> name -> Bool) -> InlineHints name a
[shouldInline] :: InlineHints name a -> a -> name -> Bool
data Inline

-- | When calling <tt>PlutusIR.Compiler.Definitions.defineTerm</tt> to add
--   a new term definition, if we annotation the var on the LHS of the
--   definition with <a>AlwaysInline</a>, the inliner will always inline
--   that var.
--   
--   This is currently used to ensure builtin functions such as
--   <tt>trace</tt> (when the <tt>remove-trace</tt> flag is on and
--   <tt>trace</tt> is rewritten to <tt>const</tt>) are inlined, because
--   the inliner would otherwise not inline them. To achieve that, we
--   annotate the definition with <a>AlwaysInline</a> when defining
--   <tt>trace</tt>, i.e., <tt>trace <a>AlwaysInline</a> = _ a -&gt;
--   a</tt>.
AlwaysInline :: Inline
MayInline :: Inline

-- | Create an <a>Ann</a> with <a>AlwaysInline</a>.
annAlwaysInline :: Ann

-- | Create an <a>Ann</a> with <a>MayInline</a>.
annMayInline :: Ann
data () => SourcePos
SourcePos :: FilePath -> !Pos -> !Pos -> SourcePos
[sourceName] :: SourcePos -> FilePath
[sourceLine] :: SourcePos -> !Pos
[sourceColumn] :: SourcePos -> !Pos
data () => Pos

-- | Add an extra SrcSpan to existing <a>SrcSpans</a> of <a>Ann</a>
addSrcSpan :: SrcSpan -> Ann -> Ann

-- | Tells if a line (positive integer) falls inside a SrcSpan.
lineInSrcSpan :: Pos -> SrcSpan -> Bool
instance GHC.Base.Monoid (PlutusCore.Annotation.InlineHints name a)
instance GHC.Base.Semigroup (PlutusCore.Annotation.InlineHints name a)
instance Data.Hashable.Class.Hashable PlutusCore.Annotation.Inline
instance GHC.Show.Show PlutusCore.Annotation.Inline
instance GHC.Generics.Generic PlutusCore.Annotation.Inline
instance GHC.Classes.Ord PlutusCore.Annotation.Inline
instance GHC.Classes.Eq PlutusCore.Annotation.Inline
instance Control.DeepSeq.NFData PlutusCore.Annotation.SrcSpan
instance Data.Hashable.Class.Hashable PlutusCore.Annotation.SrcSpan
instance Flat.Class.Flat PlutusCore.Annotation.SrcSpan
instance GHC.Generics.Generic PlutusCore.Annotation.SrcSpan
instance GHC.Classes.Ord PlutusCore.Annotation.SrcSpan
instance GHC.Classes.Eq PlutusCore.Annotation.SrcSpan
instance Flat.Class.Flat PlutusCore.Annotation.SrcSpans
instance GHC.Generics.Generic PlutusCore.Annotation.SrcSpans
instance Control.DeepSeq.NFData PlutusCore.Annotation.SrcSpans
instance Data.MonoTraversable.MonoFoldable PlutusCore.Annotation.SrcSpans
instance GHC.Base.Monoid PlutusCore.Annotation.SrcSpans
instance GHC.Base.Semigroup PlutusCore.Annotation.SrcSpans
instance Data.Hashable.Class.Hashable PlutusCore.Annotation.SrcSpans
instance GHC.Classes.Ord PlutusCore.Annotation.SrcSpans
instance GHC.Classes.Eq PlutusCore.Annotation.SrcSpans
instance Data.Hashable.Class.Hashable PlutusCore.Annotation.Ann
instance GHC.Show.Show PlutusCore.Annotation.Ann
instance GHC.Generics.Generic PlutusCore.Annotation.Ann
instance GHC.Classes.Ord PlutusCore.Annotation.Ann
instance GHC.Classes.Eq PlutusCore.Annotation.Ann
instance Prettyprinter.Internal.Pretty PlutusCore.Annotation.Ann
instance GHC.Show.Show PlutusCore.Annotation.SrcSpans
instance Prettyprinter.Internal.Pretty PlutusCore.Annotation.SrcSpans
instance GHC.Show.Show PlutusCore.Annotation.SrcSpan
instance Prettyprinter.Internal.Pretty PlutusCore.Annotation.SrcSpan
instance GHC.Show.Show (PlutusCore.Annotation.InlineHints name a)

module PlutusCore.Crypto.BLS12_381.Error
data BLS12_381_Error
HashToCurveDstTooBig :: BLS12_381_Error
instance GHC.Show.Show PlutusCore.Crypto.BLS12_381.Error.BLS12_381_Error


-- | Hash functions for lazy [[Data.ByteString.ByteString]]s
module PlutusCore.Crypto.Hash

-- | Hash a <a>ByteString</a> using the SHA-256 hash function.
sha2_256 :: ByteString -> ByteString

-- | Hash a <a>ByteString</a> using the SHA3-256 hash function.
sha3_256 :: ByteString -> ByteString

-- | Hash a <a>ByteString</a> using the Blake2b-224 hash function.
blake2b_224 :: ByteString -> ByteString

-- | Hash a <a>ByteString</a> using the Blake2b-256 hash function.
blake2b_256 :: ByteString -> ByteString

-- | Hash a <a>ByteString</a> using the Keccak-256 hash function.
keccak_256 :: ByteString -> ByteString

-- | Hash a <a>ByteString</a> using the RIPEMD-160 hash function.
ripemd_160 :: ByteString -> ByteString

module PlutusCore.Data

-- | A generic "data" type.
--   
--   The main constructor <a>Constr</a> represents a datatype value in
--   sum-of-products form: <tt>Constr i args</tt> represents a use of the
--   <tt>i</tt>th constructor along with its arguments.
--   
--   The other constructors are various primitives.
data Data
Constr :: Integer -> [Data] -> Data
Map :: [(Data, Data)] -> Data
List :: [Data] -> Data
I :: Integer -> Data
B :: ByteString -> Data
instance NoThunks.Class.NoThunks PlutusCore.Data.Data
instance Control.DeepSeq.NFData PlutusCore.Data.Data
instance Data.Hashable.Class.Hashable PlutusCore.Data.Data
instance Data.Data.Data PlutusCore.Data.Data
instance GHC.Generics.Generic PlutusCore.Data.Data
instance GHC.Classes.Ord PlutusCore.Data.Data
instance GHC.Classes.Eq PlutusCore.Data.Data
instance GHC.Read.Read PlutusCore.Data.Data
instance GHC.Show.Show PlutusCore.Data.Data
instance Prettyprinter.Internal.Pretty PlutusCore.Data.Data
instance Codec.Serialise.Class.Serialise PlutusCore.Data.Data


-- | Various file paths used in plutus-core, currently all to do with the
--   cost model.
module PlutusCore.DataFilePaths
costModelDataDir :: FilePath
builtinCostModelFileA :: FilePath
builtinCostModelFileB :: FilePath
builtinCostModelFileC :: FilePath
latestBuiltinCostModelFile :: FilePath
cekMachineCostsFileA :: FilePath
cekMachineCostsFileB :: FilePath
cekMachineCostsFileC :: FilePath
latestMachineCostsFile :: FilePath

-- | The file containing the R models: only needed for cost-model-test.
rModelFile :: FilePath

-- | The file containing the benchmark results for the built-in functions:
--   only needed for cost-model-test.
benchingResultsFile :: FilePath


-- | A JSON representation of costing functions for Plutus Core builtins
--   which produces a simple cost model which can be used from Agda and
--   other executables
module PlutusCore.Evaluation.Machine.CostingFun.SimpleJSON
data LinearFunction
LinearFunction :: Integer -> Integer -> LinearFunction
[intercept_] :: LinearFunction -> Integer
[slope_] :: LinearFunction -> Integer
data TwoVariableLinearFunction
TwoVariableLinearFunction :: Integer -> Integer -> Integer -> TwoVariableLinearFunction
[intercept'_] :: TwoVariableLinearFunction -> Integer
[slope1_] :: TwoVariableLinearFunction -> Integer
[slope2_] :: TwoVariableLinearFunction -> Integer
data OneVariableQuadraticFunction
OneVariableQuadraticFunction :: Integer -> Integer -> Integer -> OneVariableQuadraticFunction
[coeff0_] :: OneVariableQuadraticFunction -> Integer
[coeff1_] :: OneVariableQuadraticFunction -> Integer
[coeff2_] :: OneVariableQuadraticFunction -> Integer
data TwoVariableQuadraticFunction
TwoVariableQuadraticFunction :: Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> TwoVariableQuadraticFunction
[minimum] :: TwoVariableQuadraticFunction -> Integer
[coeff00_] :: TwoVariableQuadraticFunction -> Integer
[coeff10_] :: TwoVariableQuadraticFunction -> Integer
[coeff01_] :: TwoVariableQuadraticFunction -> Integer
[coeff20_] :: TwoVariableQuadraticFunction -> Integer
[coeff11_] :: TwoVariableQuadraticFunction -> Integer
[coeff02_] :: TwoVariableQuadraticFunction -> Integer

-- | This type reflects what is actually in the JSON. The stuff in
--   CostingFun.Core and CostingFun.JSON is much more rigid, allowing
--   parsing only for the model types applicable to the various
--   ModelNArguments types; it also requires entries for everything in
--   DefaultFun. Using the type defined here allows us to be more flexible
--   and parse stuff that's not exactly what's expected in
--   builtinCostModel.json.
data Model
ConstantCost :: Integer -> Model
AddedSizes :: LinearFunction -> Model
MultipliedSizes :: LinearFunction -> Model
MinSize :: LinearFunction -> Model
MaxSize :: LinearFunction -> Model
LinearInX :: LinearFunction -> Model
LinearInY :: LinearFunction -> Model
LinearInZ :: LinearFunction -> Model
LiteralInYOrLinearInZ :: LinearFunction -> Model
LinearInMaxYZ :: LinearFunction -> Model
LinearInYAndZ :: TwoVariableLinearFunction -> Model
QuadraticInY :: OneVariableQuadraticFunction -> Model
QuadraticInZ :: OneVariableQuadraticFunction -> Model
QuadraticInXAndY :: TwoVariableQuadraticFunction -> Model

-- | Linear model in x-y plus minimum value for the case x-y &lt; 0.
SubtractedSizes :: LinearFunction -> Integer -> Model
ConstAboveDiagonal :: Integer -> Model -> Model
ConstBelowDiagonal :: Integer -> Model -> Model
ConstOffDiagonal :: Integer -> Model -> Model

-- | A CPU usage modelling function and a memory usage modelling function
--   bundled together
data CpuAndMemoryModel
CpuAndMemoryModel :: Model -> Model -> CpuAndMemoryModel
[cpuModel] :: CpuAndMemoryModel -> Model
[memoryModel] :: CpuAndMemoryModel -> Model
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.SimpleJSON.LinearFunction
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.SimpleJSON.LinearFunction
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.SimpleJSON.TwoVariableLinearFunction
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.SimpleJSON.TwoVariableLinearFunction
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.SimpleJSON.OneVariableQuadraticFunction
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.SimpleJSON.OneVariableQuadraticFunction
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.SimpleJSON.TwoVariableQuadraticFunction
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.SimpleJSON.TwoVariableQuadraticFunction
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.SimpleJSON.Model
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.SimpleJSON.Model
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.SimpleJSON.CpuAndMemoryModel
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.SimpleJSON.CpuAndMemoryModel
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.SimpleJSON.CpuAndMemoryModel
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.SimpleJSON.Model
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.SimpleJSON.TwoVariableQuadraticFunction
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.SimpleJSON.OneVariableQuadraticFunction
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.SimpleJSON.TwoVariableLinearFunction
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.SimpleJSON.LinearFunction

module PlutusCore.Evaluation.Machine.ExMemory
type CostingInteger = SatInt

-- | Counts size in machine words.
newtype ExMemory
ExMemory :: CostingInteger -> ExMemory

-- | Counts CPU units in picoseconds: maximum value for SatInt is 2^63 ps,
--   or appproximately 106 days.
newtype ExCPU
ExCPU :: CostingInteger -> ExCPU
instance NoThunks.Class.NoThunks PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance Codec.Serialise.Class.Serialise PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance GHC.Enum.Bounded PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance GHC.Read.Read PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance GHC.Num.Num PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance GHC.Show.Show PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance GHC.Classes.Ord PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance NoThunks.Class.NoThunks PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance Codec.Serialise.Class.Serialise PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance GHC.Enum.Bounded PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance GHC.Read.Read PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance GHC.Num.Num PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance GHC.Show.Show PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance GHC.Classes.Ord PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance Prettyprinter.Internal.Pretty PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance Text.PrettyBy.Internal.PrettyBy config PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance GHC.Base.Semigroup PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance GHC.Base.Monoid PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance Prettyprinter.Internal.Pretty PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance Text.PrettyBy.Internal.PrettyBy config PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance GHC.Base.Semigroup PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance GHC.Base.Monoid PlutusCore.Evaluation.Machine.ExMemory.ExMemory

module PlutusCore.Evaluation.Machine.CostStream

-- | A lazy stream of <a>CostingInteger</a>s. Basically <tt>NonEmpty
--   CostingInteger</tt>, except the elements are stored strictly.
--   
--   The semantics of a stream are those of the sum of its elements. I.e. a
--   stream that is a reordered version of another stream is considered
--   equal to that stream.
--   
--   All costs are assumed not to be negative and functions handling
--   <a>CostStream</a>s may rely on this assumption. Negative costs (a.k.a.
--   allowing the user to forge execution units at runtime) wouldn't make
--   sense.
data CostStream
CostLast :: {-# UNPACK #-} !CostingInteger -> CostStream
CostCons :: {-# UNPACK #-} !CostingInteger -> CostStream -> CostStream

-- | Uncons an element from a <a>CostStream</a> and return the rest of the
--   stream, if not empty.
unconsCost :: CostStream -> (CostingInteger, Maybe CostStream)

-- | Cons an element to a <a>CostStream</a>, if given any. Otherwise create
--   a new <a>CostStream</a> using <a>CostLast</a>.
reconsCost :: CostingInteger -> Maybe CostStream -> CostStream

-- | Add up all the costs in a <a>CostStream</a>.
sumCostStream :: CostStream -> CostingInteger

-- | Map a function over a <a>CostStream</a>.
mapCostStream :: (CostingInteger -> CostingInteger) -> CostStream -> CostStream

-- | Add two streams by interleaving their elements (as opposed to draining
--   out one of the streams before starting to take elements from the other
--   one). No particular reason to prefer interleaving over draining out
--   one of the streams first.
addCostStream :: CostStream -> CostStream -> CostStream

-- | Calculate the minimum of two <a>CostStream</a>s. May return a stream
--   that is longer than either of the two (but not more than twice).
minCostStream :: CostStream -> CostStream -> CostStream
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostStream.CostStream


-- | A program to parse a JSON representation of costing functions for
--   Plutus Core builtins and and produce a simple cost model which can be
--   used from Agda and other executables
module PlutusCore.Evaluation.Machine.SimpleBuiltinCostModel
type BuiltinCostMap = [(Text, CpuAndMemoryModel)]
type BuiltinCostKeyMap = KeyMap CpuAndMemoryModel
toSimpleBuiltinCostModel :: BuiltinCostKeyMap -> BuiltinCostMap
defaultSimpleBuiltinCostModel :: BuiltinCostMap

module PlutusPrelude

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: a -> (a -> b) -> b
infixl 1 &

-- | Fanout: send the input to both argument arrows and combine their
--   output.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
infixr 3 &&&

-- | Left-to-right composition
(>>>) :: forall {k} cat (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
infixr 1 >>>

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | List of elements of a structure, from left to right. If the entire
--   list is intended to be reduced via a fold, just fold the structure
--   directly bypassing the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; toList Nothing
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList (Just 42)
--   [42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList (Left "foo")
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList (Node (Leaf 5) 17 (Node Empty 12 (Leaf 8)))
--   [5,17,12,8]
--   </pre>
--   
--   For lists, <a>toList</a> is the identity:
--   
--   <pre>
--   &gt;&gt;&gt; toList [1, 2, 3]
--   [1,2,3]
--   </pre>
toList :: Foldable t => t a -> [a]

-- | Map covariantly over the first argument.
--   
--   <pre>
--   <a>first</a> f ≡ <a>bimap</a> f <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper ('j', 3)
--   ('J',3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper (Left 'j')
--   Left 'J'
--   </pre>
first :: Bifunctor p => (a -> b) -> p a c -> p b c

-- | Map covariantly over the second argument.
--   
--   <pre>
--   <a>second</a> ≡ <a>bimap</a> <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) ('j', 3)
--   ('j',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) (Right 3)
--   Right 4
--   </pre>
second :: Bifunctor p => (b -> c) -> p a b -> p a c

-- | <tt><a>on</a> b u x y</tt> runs the binary function <tt>b</tt>
--   <i>on</i> the results of applying unary function <tt>u</tt> to two
--   arguments <tt>x</tt> and <tt>y</tt>. From the opposite perspective, it
--   transforms two inputs and combines the outputs.
--   
--   <pre>
--   ((+) `<a>on</a>` f) x y = f x + f y
--   </pre>
--   
--   Typical usage: <tt><a>sortBy</a> (<a>compare</a> `on`
--   <a>fst</a>)</tt>.
--   
--   Algebraic properties:
--   
--   <ul>
--   <li><pre>(*) `on` <a>id</a> = (*) -- (if (*) ∉ {⊥, <a>const</a>
--   ⊥})</pre></li>
--   <li><pre>((*) `on` f) `on` g = (*) `on` (f . g)</pre></li>
--   <li><pre><a>flip</a> on f . <a>flip</a> on g = <a>flip</a> on (g .
--   f)</pre></li>
--   </ul>
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
infixl 0 `on`

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just ())
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just Nothing)
--   False
--   </pre>
isNothing :: Maybe a -> Bool

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: Maybe a -> Bool

-- | The <a>fromMaybe</a> function takes a default value and a <a>Maybe</a>
--   value. If the <a>Maybe</a> is <a>Nothing</a>, it returns the default
--   value; otherwise, it returns the value contained in the <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: a -> Maybe a -> a

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to Weak Head Normal
--   Form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite structure to a single strict result (e.g. <a>sum</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl' f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | <a>for_</a> is <a>traverse_</a> with its arguments flipped. For a
--   version that doesn't ignore the results see <a>for</a>. This is
--   <a>forM_</a> generalised to <a>Applicative</a> actions.
--   
--   <a>for_</a> is just like <a>forM_</a>, but generalised to
--   <a>Applicative</a> actions.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; for_ [1..4] print
--   1
--   2
--   3
--   4
--   </pre>
for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()

-- | Map each element of a structure to an <a>Applicative</a> action,
--   evaluate these actions from left to right, and ignore the results. For
--   a version that doesn't ignore the results see <a>traverse</a>.
--   
--   <a>traverse_</a> is just like <a>mapM_</a>, but generalised to
--   <a>Applicative</a> actions.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; traverse_ print ["Hello", "world", "!"]
--   "Hello"
--   "world"
--   "!"
--   </pre>
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()

-- | Given a structure with elements whose type is a <a>Monoid</a>, combine
--   them via the monoid's <tt>(<a>&lt;&gt;</a>)</tt> operator. This fold
--   is right-associative and lazy in the accumulator. When you need a
--   strict left-associative fold, use <a>foldMap'</a> instead, with
--   <a>id</a> as the map.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fold [[1, 2, 3], [4, 5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fold $ Node (Leaf (Sum 1)) (Sum 3) (Leaf (Sum 5))
--   Sum {getSum = 9}
--   </pre>
--   
--   Folds of unbounded structures do not terminate when the monoid's
--   <tt>(<a>&lt;&gt;</a>)</tt> operator is strict:
--   
--   <pre>
--   &gt;&gt;&gt; fold (repeat Nothing)
--   * Hangs forever *
--   </pre>
--   
--   Lazy corecursive folds of unbounded structures are fine:
--   
--   <pre>
--   &gt;&gt;&gt; take 12 $ fold $ map (\i -&gt; [i..i+2]) [0..]
--   [0,1,2,1,2,3,2,3,4,3,4,5]
--   
--   &gt;&gt;&gt; sum $ take 4000000 $ fold $ map (\i -&gt; [i..i+2]) [0..]
--   2666668666666
--   </pre>
fold :: (Foldable t, Monoid m) => t m -> m

-- | <a>for</a> is <a>traverse</a> with its arguments flipped. For a
--   version that ignores the results see <a>for_</a>.
for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)

-- | Throw an exception. Exceptions may be thrown from purely functional
--   code, but may only be caught within the <a>IO</a> monad.
--   
--   WARNING: You may want to use <tt>throwIO</tt> instead so that your
--   pure code stays exception-free.
throw :: forall (r :: RuntimeRep) (a :: TYPE r) e. Exception e => e -> a

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
--   
--   '<tt><a>join</a> bss</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do bs &lt;- bss
--      bs
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>join</a> is to run an <a>IO</a> computation
--   returned from an <a>STM</a> transaction, since <a>STM</a> transactions
--   can't perform <a>IO</a> directly. Recall that
--   
--   <pre>
--   <a>atomically</a> :: STM a -&gt; IO a
--   </pre>
--   
--   is used to run <a>STM</a> transactions atomically. So, by specializing
--   the types of <a>atomically</a> and <a>join</a> to
--   
--   <pre>
--   <a>atomically</a> :: STM (IO b) -&gt; IO (IO b)
--   <a>join</a>       :: IO (IO b)  -&gt; IO b
--   </pre>
--   
--   we can compose them as
--   
--   <pre>
--   <a>join</a> . <a>atomically</a> :: STM (IO b) -&gt; IO b
--   </pre>
--   
--   to run an <a>STM</a> transaction and the <a>IO</a> action it returns.
join :: Monad m => m (m a) -> m a

-- | Right-to-left composition of Kleisli arrows.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Left-to-right composition of Kleisli arrows.
--   
--   '<tt>(bs <a>&gt;=&gt;</a> cs) a</tt>' can be understood as the
--   <tt>do</tt> expression
--   
--   <pre>
--   do b &lt;- bs a
--      cs b
--   </pre>
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with a
--   constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with a constant <a>String</a>, resulting in an
--   <tt><a>Either</a> <a>Int</a> <a>String</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | Return the contents of a <a>Right</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromRight 1 (Right 3)
--   3
--   
--   &gt;&gt;&gt; fromRight 1 (Left "foo")
--   1
--   </pre>
fromRight :: b -> Either a b -> b

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isRight (Left "foo")
--   False
--   
--   &gt;&gt;&gt; isRight (Right 3)
--   True
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isRight</a> to write a very simple reporting function that only
--   outputs "SUCCESS" when a computation has succeeded.
--   
--   This example shows how <a>isRight</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isRight e) $ putStrLn "SUCCESS"
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   
--   &gt;&gt;&gt; report (Right 1)
--   SUCCESS
--   </pre>
isRight :: Either a b -> Bool

-- | Return <a>True</a> if the given value is a <a>Left</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLeft (Left "foo")
--   True
--   
--   &gt;&gt;&gt; isLeft (Right 3)
--   False
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isLeft</a> to write a very simple error-reporting function that
--   does absolutely nothing in the case of success, and outputs "ERROR" if
--   any error occurred.
--   
--   This example shows how <a>isLeft</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isLeft e) $ putStrLn "ERROR"
--   
--   &gt;&gt;&gt; report (Right 1)
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   ERROR
--   </pre>
isLeft :: Either a b -> Bool

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with unit, resulting in an <tt><a>Either</a>
--   <a>Int</a> <tt>()</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | Makes an effectful function ignore its result value and return its
--   input value.
through :: Functor f => (a -> f b) -> a -> f a

-- | The function <a>coerce</a> allows you to safely convert between values
--   of types that have the same representation with no run-time overhead.
--   In the simplest case you can use it instead of a newtype constructor,
--   to go from the newtype's concrete type to the abstract type. But it
--   also works in more complicated settings, e.g. converting a list of
--   newtypes to a list of concrete types.
--   
--   When used in conversions involving a newtype wrapper, make sure the
--   newtype constructor is in scope.
--   
--   This function is representation-polymorphic, but the
--   <tt>RuntimeRep</tt> type argument is marked as <tt>Inferred</tt>,
--   meaning that it is not available for visible type application. This
--   means the typechecker will accept <tt><a>coerce</a> @<tt>Int</tt> @Age
--   42</tt>.
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; newtype TTL = TTL Int deriving (Eq, Ord, Show)
--   
--   &gt;&gt;&gt; newtype Age = Age Int deriving (Eq, Ord, Show)
--   
--   &gt;&gt;&gt; coerce (Age 42) :: TTL
--   TTL 42
--   
--   &gt;&gt;&gt; coerce (+ (1 :: Int)) (Age 42) :: TTL
--   TTL 43
--   
--   &gt;&gt;&gt; coerce (map (+ (1 :: Int))) [Age 42, Age 24] :: [TTL]
--   [TTL 43,TTL 25]
--   </pre>
coerce :: forall {k :: RuntimeRep} (a :: TYPE k) (b :: TYPE k). Coercible a b => a -> b

-- | Coerce the second argument to the result type of the first one. The
--   motivation for this function is that it's often more annoying to
--   explicitly specify a target type for <a>coerce</a> than to construct
--   an explicit coercion function, so this combinator can be used in cases
--   like that. Plus the code reads better, as it becomes clear what and
--   where gets wrapped/unwrapped.
coerceVia :: Coercible a b => (a -> b) -> a -> b

-- | Same as <tt>f -&gt; f . coerce</tt>, but does not create any closures
--   and so is completely free.
coerceArg :: Coercible a b => (a -> s) -> b -> s

-- | Same as <tt>f -&gt; coerce . f</tt>, but does not create any closures
--   and so is completely free.
coerceRes :: Coercible s t => (a -> s) -> a -> t

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class () => Generic a

-- | A class of types that can be fully evaluated.
class () => NFData a

-- | Natural number
--   
--   Invariant: numbers &lt;= 0xffffffffffffffff use the <a>NS</a>
--   constructor
data () => Natural

-- | Non-empty (and non-strict) list type.
data () => NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|

-- | 8-bit unsigned integer type
data () => Word8

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre><a>some</a> v = (:) <a>&lt;$&gt;</a> v <a>&lt;*&gt;</a>
--   <a>many</a> v</pre></li>
--   <li><pre><a>many</a> v = <a>some</a> v <a>&lt;|&gt;</a> <a>pure</a>
--   []</pre></li>
--   </ul>
class Applicative f => Alternative (f :: Type -> Type)

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => f a

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]
infixl 3 <|>

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
newtype PairT b f a
PairT :: f (b, a) -> PairT b f a
[unPairT] :: PairT b f a -> f (b, a)

-- | <tt>Coercible</tt> is a two-parameter class that has instances for
--   types <tt>a</tt> and <tt>b</tt> if the compiler can infer that they
--   have the same representation. This class does not have regular
--   instances; instead they are created on-the-fly during type-checking.
--   Trying to manually declare an instance of <tt>Coercible</tt> is an
--   error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance Coercible a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class a ~R# b => Coercible (a :: k) (b :: k)

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class () => Typeable (a :: k)
type Lens' s a = Lens s s a a
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b
(^.) :: s -> Getting a s a -> a
view :: MonadReader s m => Getting a s a -> m a
(.~) :: ASetter s t a b -> b -> s -> t
set :: ASetter s t a b -> b -> s -> t
(%~) :: ASetter s t a b -> (a -> b) -> s -> t
over :: ASetter s t a b -> (a -> b) -> s -> t

-- | Compose two folds to make them run in parallel. The results are
--   concatenated.
(<^>) :: Fold s a -> Fold s a -> Fold s a
infixr 6 <^>

-- | Like <a>traceShow</a> but returns the shown value instead of a third
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; traceShowId (1+2+3, "hello" ++ "world")
--   (6,"helloworld")
--   (6,"helloworld")
--   </pre>
traceShowId :: Show a => a -> a

-- | The <a>trace</a> function outputs the trace message given as its first
--   argument, before returning the second argument as its result.
--   
--   For example, this returns the value of <tt>f x</tt> and outputs the
--   message to stderr. Depending on your terminal (settings), they may or
--   may not be mixed.
--   
--   <pre>
--   &gt;&gt;&gt; let x = 123; f = show
--   
--   &gt;&gt;&gt; trace ("calling f with x = " ++ show x) (f x)
--   calling f with x = 123
--   "123"
--   </pre>
--   
--   The <a>trace</a> function should <i>only</i> be used for debugging, or
--   for monitoring execution. The function is not referentially
--   transparent: its type indicates that it is a pure function but it has
--   the side effect of outputting the trace message.
trace :: String -> a -> a
(.*) :: (c -> d) -> (a -> b -> c) -> a -> b -> d
(<<$>>) :: (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
infixl 4 <<$>>
(<<*>>) :: (Applicative f1, Applicative f2) => f1 (f2 (a -> b)) -> f1 (f2 a) -> f1 (f2 b)
infixl 4 <<*>>
mtraverse :: (Monad m, Traversable m, Applicative f) => (a -> f (m b)) -> m a -> f (m b)

-- | Fold a monadic function over a <a>Foldable</a>. The monadic version of
--   <a>foldMap</a>.
foldMapM :: (Foldable f, Monad m, Monoid b) => (a -> m b) -> f a -> m b

-- | This function generalizes <tt>eitherToMaybe</tt>,
--   <tt>eitherToList</tt>, <tt>listToMaybe</tt> and other such functions.
reoption :: (Foldable f, Alternative g) => f a -> g a
enumerate :: (Enum a, Bounded a) => [a]

-- | Basically a <tt>Data.Functor.Representable</tt> instance for
--   <a>Array</a>. We can't provide an actual instance because of the
--   <tt>Distributive</tt> superclass: <tt>Array i</tt> is not
--   <tt>Distributive</tt> unless we assume that indices in an array range
--   over the entirety of <tt>i</tt>.
tabulateArray :: (Bounded i, Enum i, Ix i) => (i -> a) -> Array i a

-- | <tt>b ? x</tt> is equal to <tt>pure x</tt> whenever <tt>b</tt> holds
--   and is <a>empty</a> otherwise.
(?) :: Alternative f => Bool -> a -> f a
infixr 2 ?

-- | <tt>ensure p x</tt> is equal to <tt>pure x</tt> whenever <tt>p x</tt>
--   holds and is <a>empty</a> otherwise.
ensure :: Alternative f => (a -> Bool) -> a -> f a

-- | A monadic version of <tt>asks</tt>.
asksM :: MonadReader r m => (r -> m a) -> m a

-- | function recursively applied N times
timesA :: Natural -> (a -> a) -> a -> a
data () => Doc ann

-- | A newtype wrapper around <tt>a</tt> whose point is to provide a
--   <a>Show</a> instance for anything that has a <a>Pretty</a> instance.
newtype ShowPretty a
ShowPretty :: a -> ShowPretty a
[unShowPretty] :: ShowPretty a -> a
class () => Pretty a
pretty :: Pretty a => a -> Doc ann
prettyList :: Pretty a => [a] -> Doc ann
class () => PrettyBy config a
prettyBy :: PrettyBy config a => config -> a -> Doc ann
prettyListBy :: PrettyBy config a => config -> [a] -> Doc ann
type family HasPrettyDefaults config :: Bool
type PrettyDefaultBy config = DispatchPrettyDefaultBy NonStuckHasPrettyDefaults config config
newtype () => PrettyAny a
PrettyAny :: a -> PrettyAny a
[unPrettyAny] :: PrettyAny a -> a
class () => Render str
render :: Render str => Doc ann -> str
display :: forall str a. (Pretty a, Render str) => a -> str

-- | A command suitable for use in GHCi as an interactive printer.
printPretty :: Pretty a => a -> IO ()
showText :: Show a => a -> Text
class () => Default a
def :: Default a => a

-- | Zips two lists of the same length together, returning <a>Nothing</a>
--   if they are not the same length.
zipExact :: [a] -> [b] -> Maybe [(a, b)]
allSame :: Eq a => [a] -> Bool
distinct :: Eq a => [a] -> Bool

-- | Similar to Maybe's <tt>fromJust</tt>. Returns the <a>Right</a> and
--   errors out with the show instance of the <a>Left</a>.
unsafeFromRight :: Show e => Either e a -> a

-- | A <a>MonadError</a> version of <tt>try</tt>.
--   
--   TODO: remove when we switch to mtl&gt;=2.3
tryError :: MonadError e m => m a -> m (Either e a)
modifyError :: MonadError e' m => (e -> e') -> ExceptT e m a -> m a
lowerInitialChar :: String -> String
instance GHC.Classes.Eq a => GHC.Classes.Eq (PlutusPrelude.ShowPretty a)
instance Text.PrettyBy.Internal.PrettyDefaultBy config (Data.Either.Either a b) => Text.PrettyBy.Internal.PrettyBy config (Data.Either.Either a b)
instance GHC.Base.Functor f => GHC.Base.Functor (PlutusPrelude.PairT b f)
instance Prettyprinter.Internal.Pretty a => GHC.Show.Show (PlutusPrelude.ShowPretty a)
instance (Prettyprinter.Internal.Pretty a, Prettyprinter.Internal.Pretty b) => Prettyprinter.Internal.Pretty (Data.Either.Either a b)
instance (Text.PrettyBy.Internal.PrettyBy config a, Text.PrettyBy.Internal.PrettyBy config b) => Text.PrettyBy.Internal.DefaultPrettyBy config (Data.Either.Either a b)

module PlutusCore.Version

-- | The version of Plutus Core used by this program.
--   
--   The intention is to convey different levels of backwards compatibility
--   for existing scripts: - Major version changes are
--   backwards-incompatible - Minor version changes are
--   backwards-compatible - Patch version changes should be entirely
--   invisible (and we will likely not use this level)
--   
--   The version used should be changed only when the <i>language
--   itself</i> changes. For example, adding a new kind of term to the
--   language would require a minor version bump; removing a kind of term
--   would require a major version bump.
--   
--   Similarly, changing the semantics of the language will require a
--   version bump, typically a major one. This is the main reason why the
--   version is actually tracked in the AST: we can have two language
--   versions with identical ASTs but different semantics, so we need to
--   track the version explicitly.
--   
--   Compatibility is about compatibility for specific scripts, not about
--   e.g. tools which consume scripts. Adding a new kind of term does not
--   change how existing scripts behave, but does change what tools would
--   need to do to process scripts.
data Version
Version :: Natural -> Natural -> Natural -> Version
[_versionMajor] :: Version -> Natural
[_versionMinor] :: Version -> Natural
[_versionPatch] :: Version -> Natural
versionMajor :: Lens' Version Natural
versionMinor :: Lens' Version Natural
versionPatch :: Lens' Version Natural

-- | Plutus Core version 1.0.0
plcVersion100 :: Version

-- | Plutus Core version 1.1.0
plcVersion110 :: Version

-- | The first version of Plutus Core supported by this library.
firstVersion :: Version

-- | The latest version of Plutus Core supported by this library.
latestVersion :: Version

-- | The set of versions that are "known", i.e. that have been released and
--   have actual differences associated with them.
knownVersions :: Set Version
instance GHC.Classes.Ord PlutusCore.Version.Version
instance Prettyprinter.Internal.Pretty PlutusCore.Version.Version
instance Data.Hashable.Class.Hashable PlutusCore.Version.Version
instance Control.DeepSeq.NFData PlutusCore.Version.Version
instance GHC.Generics.Generic PlutusCore.Version.Version
instance GHC.Show.Show PlutusCore.Version.Version
instance GHC.Classes.Eq PlutusCore.Version.Version


-- | A <a>Name</a> is a datatype used to identify a variable inside the
--   Plutus Core languages. Name comparisons are a fundamental part of the
--   domain logic, and comparing <a>Text</a> directly is inefficient. As a
--   solution to this problem, we provide the <a>Unique</a> type which is
--   an integer associated to the <a>Name</a>, unique to each instantiation
--   of the type. We can, therefore, compare the integers instead, which is
--   obviously much more cost-effective.
--   
--   We distinguish between the names of term variables and type variables
--   by defining the <a>TyName</a> wrapper over <a>Name</a>. Since the code
--   we usually write is polymorphic in the name type, we want to be able
--   to define a class of names which have an associated <a>Unique</a>.
--   This class is <a>HasUnique</a>, see the definition below.
module PlutusCore.Name.Unique

-- | A <a>Name</a> represents variables/names in Plutus Core.
data Name
Name :: Text -> Unique -> Name

-- | The identifier name, for use in error messages.
[_nameText] :: Name -> Text

-- | A <a>Unique</a> assigned to the name, allowing for cheap comparisons
--   in the compiler.
[_nameUnique] :: Name -> Unique

-- | Allowed characters in the starting position of a non-quoted
--   identifier.
isIdentifierStartingChar :: Char -> Bool

-- | Allowed characters in a non-starting position of a non-quoted
--   identifier.
isIdentifierChar :: Char -> Bool

-- | Allowed characters in a quoted identifier.
isQuotedIdentifierChar :: Char -> Bool
isValidUnquotedName :: Text -> Bool

-- | Quote the name with backticks if it is not a valid unquoted name. It
--   does not check whether the given name is a valid quoted name.
toPrintedName :: Text -> Text

-- | We use a <tt>newtype</tt> to enforce separation between names used for
--   types and those used for terms.
newtype TyName
TyName :: Name -> TyName
[unTyName] :: TyName -> Name
data Named a
Named :: Text -> a -> Named a
[_namedString] :: Named a -> Text
[_namedValue] :: Named a -> a

-- | A unique identifier
newtype Unique
Unique :: Int -> Unique
[unUnique] :: Unique -> Int

-- | The unique of a type-level name.
newtype TypeUnique
TypeUnique :: Unique -> TypeUnique
[unTypeUnique] :: TypeUnique -> Unique

-- | The unique of a term-level name.
newtype TermUnique
TermUnique :: Unique -> TermUnique
[unTermUnique] :: TermUnique -> Unique

-- | Types which have a textual name attached to them.
class HasText a
theText :: HasText a => Lens' a Text

-- | Types which have a <a>Unique</a> attached to them, mostly names.
class (Coercible unique Unique) => HasUnique a unique | a -> unique
unique :: HasUnique a unique => Lens' a unique
unique :: (HasUnique a unique, Wrapped a, HasUnique (Unwrapped a) unique', Coercible unique' unique) => Lens' a unique

-- | A lens focused on the <a>Unique</a> of a name.
theUnique :: HasUnique name unique => Lens' name Unique

-- | Apply a function to the string representation of a <a>Name</a>.
mapNameString :: (Text -> Text) -> Name -> Name

-- | Apply a function to the string representation of a <a>TyName</a>.
mapTyNameString :: (Text -> Text) -> TyName -> TyName
instance PlutusCore.Name.Unique.HasUnique PlutusCore.Name.Unique.Unique PlutusCore.Name.Unique.Unique
instance PlutusCore.Name.Unique.HasUnique PlutusCore.Name.Unique.Name PlutusCore.Name.Unique.TermUnique
instance PlutusCore.Name.Unique.HasUnique PlutusCore.Name.Unique.TyName PlutusCore.Name.Unique.TypeUnique
instance PlutusCore.Name.Unique.HasText PlutusCore.Name.Unique.Name
instance PlutusCore.Name.Unique.HasText PlutusCore.Name.Unique.TyName
instance Data.Traversable.Traversable PlutusCore.Name.Unique.Named
instance Data.Foldable.Foldable PlutusCore.Name.Unique.Named
instance GHC.Base.Functor PlutusCore.Name.Unique.Named
instance Data.Hashable.Class.Hashable PlutusCore.Name.Unique.Unique
instance Prettyprinter.Internal.Pretty PlutusCore.Name.Unique.Unique
instance Control.DeepSeq.NFData PlutusCore.Name.Unique.Unique
instance GHC.Enum.Enum PlutusCore.Name.Unique.Unique
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Name.Unique.Unique
instance GHC.Classes.Ord PlutusCore.Name.Unique.Unique
instance GHC.Show.Show PlutusCore.Name.Unique.Unique
instance GHC.Classes.Eq PlutusCore.Name.Unique.Unique
instance Control.DeepSeq.NFData PlutusCore.Name.Unique.Name
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Name.Unique.Name
instance GHC.Generics.Generic PlutusCore.Name.Unique.Name
instance GHC.Show.Show PlutusCore.Name.Unique.Name
instance PlutusCore.Pretty.ConfigName.HasPrettyConfigName config => Text.PrettyBy.Internal.PrettyBy config PlutusCore.Name.Unique.TyName
instance Data.Hashable.Class.Hashable PlutusCore.Name.Unique.TyName
instance Control.DeepSeq.NFData PlutusCore.Name.Unique.TyName
instance GHC.Classes.Ord PlutusCore.Name.Unique.TyName
instance GHC.Classes.Eq PlutusCore.Name.Unique.TyName
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Name.Unique.TyName
instance GHC.Generics.Generic PlutusCore.Name.Unique.TyName
instance GHC.Show.Show PlutusCore.Name.Unique.TyName
instance Data.Hashable.Class.Hashable PlutusCore.Name.Unique.TypeUnique
instance GHC.Classes.Ord PlutusCore.Name.Unique.TypeUnique
instance GHC.Classes.Eq PlutusCore.Name.Unique.TypeUnique
instance Data.Hashable.Class.Hashable PlutusCore.Name.Unique.TermUnique
instance GHC.Classes.Ord PlutusCore.Name.Unique.TermUnique
instance GHC.Classes.Eq PlutusCore.Name.Unique.TermUnique
instance Control.Lens.Wrapped.Wrapped PlutusCore.Name.Unique.TyName
instance PlutusCore.Pretty.ConfigName.HasPrettyConfigName config => Text.PrettyBy.Internal.PrettyBy config PlutusCore.Name.Unique.Name
instance GHC.Classes.Eq PlutusCore.Name.Unique.Name
instance GHC.Classes.Ord PlutusCore.Name.Unique.Name
instance Data.Hashable.Class.Hashable PlutusCore.Name.Unique.Name

module PlutusCore.Quote

-- | Run a quote from an empty identifier state. Note that the resulting
--   term cannot necessarily be safely combined with other terms - that
--   should happen inside <a>QuoteT</a>.
runQuoteT :: Monad m => QuoteT m a -> m a

-- | See <a>runQuoteT</a>.
runQuote :: Quote a -> a

-- | Get a fresh <a>Unique</a>.
freshUnique :: MonadQuote m => m Unique

-- | Get a fresh <a>Name</a>, given the annotation and the <a>Text</a>
--   name.
freshName :: MonadQuote m => Text -> m Name

-- | Get a fresh <a>TyName</a>, given the annotation and the <a>Text</a>
--   name.
freshTyName :: MonadQuote m => Text -> m TyName

-- | Make a copy of the given <a>Name</a> that is distinct from the old
--   one.
freshenName :: MonadQuote m => Name -> m Name

-- | Make a copy of the given <a>TyName</a> that is distinct from the old
--   one.
freshenTyName :: MonadQuote m => TyName -> m TyName

-- | The "quotation" monad transformer. Within this monad you can do safe
--   construction of PLC terms using quasiquotation, fresh-name generation,
--   and parsing.
newtype QuoteT m a
QuoteT :: StateT FreshState m a -> QuoteT m a
[unQuoteT] :: QuoteT m a -> StateT FreshState m a

-- | A non-transformer version of <a>QuoteT</a>.
type Quote = QuoteT Identity

-- | A monad that allows lifting of quoted expressions.
class Monad m => MonadQuote m

-- | The state contains the "next" <a>Unique</a> that should be used for a
--   name
type FreshState = Unique
liftQuote :: MonadQuote m => Quote a -> m a

-- | Mark all <a>Unique</a>s less than the given <a>Unique</a> as used, so
--   they will not be generated in future.
markNonFreshBelow :: MonadQuote m => Unique -> m ()

-- | Mark a given <a>Unique</a> (and implicitly all <a>Unique</a>s less
--   than it) as used, so they will not be generated in future.
markNonFresh :: MonadQuote m => Unique -> m ()

-- | Mark the maximal <a>Unique</a> from a set of <a>Unique</a>s (and
--   implicitly all <a>Unique</a>s less than it) as used, so they will not
--   be generated in future.
markNonFreshMax :: MonadQuote m => Set Unique -> m ()
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (PlutusCore.Quote.QuoteT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (PlutusCore.Quote.QuoteT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (PlutusCore.Quote.QuoteT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (PlutusCore.Quote.QuoteT m)
instance Control.Monad.Morph.MFunctor PlutusCore.Quote.QuoteT
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (PlutusCore.Quote.QuoteT m)
instance Control.Monad.Trans.Class.MonadTrans PlutusCore.Quote.QuoteT
instance GHC.Base.Monad m => GHC.Base.Monad (PlutusCore.Quote.QuoteT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (PlutusCore.Quote.QuoteT m)
instance GHC.Base.Functor m => GHC.Base.Functor (PlutusCore.Quote.QuoteT m)
instance GHC.Base.Monad m => PlutusCore.Quote.MonadQuote (PlutusCore.Quote.QuoteT m)
instance PlutusCore.Quote.MonadQuote m => PlutusCore.Quote.MonadQuote (Control.Monad.Trans.State.Lazy.StateT s m)
instance PlutusCore.Quote.MonadQuote m => PlutusCore.Quote.MonadQuote (Control.Monad.Trans.Maybe.MaybeT m)
instance PlutusCore.Quote.MonadQuote m => PlutusCore.Quote.MonadQuote (Control.Monad.Trans.Except.ExceptT e m)
instance PlutusCore.Quote.MonadQuote m => PlutusCore.Quote.MonadQuote (Control.Monad.Trans.Reader.ReaderT r m)
instance PlutusCore.Quote.MonadQuote m => PlutusCore.Quote.MonadQuote (Hedgehog.Internal.Gen.GenT m)
instance PlutusCore.Quote.MonadQuote m => PlutusCore.Quote.MonadQuote (Hedgehog.Internal.Property.PropertyT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (PlutusCore.Quote.QuoteT m)


-- | A type for sets of things identified by <a>Unique</a>s, usually names.
--   This approach is preferred when it is more efficient to compare the
--   associated <a>Unique</a>s instead of the underlying type.
module PlutusCore.Name.UniqueSet

-- | A set containing <a>Unique</a>s. Since <a>Unique</a> is equivalent to
--   <a>Int</a> (see <a>PlutusCore.Name.Unique</a>), we can use an
--   <tt>IntSet</tt> representation for this type.
newtype UniqueSet unique
UniqueSet :: IntSet -> UniqueSet unique
[unUniqueSet] :: UniqueSet unique -> IntSet

-- | Insert a <tt>unique</tt>.
insertByUnique :: Coercible unique Unique => unique -> UniqueSet unique -> UniqueSet unique

-- | Insert the <tt>unique</tt> associated to the <tt>name</tt>.
insertByName :: HasUnique name unique => name -> UniqueSet unique -> UniqueSet unique

-- | Create the singleton set of the <tt>unique</tt> associated to the
--   <tt>name</tt>.
singletonName :: HasUnique name unique => name -> UniqueSet unique

-- | Convert a <a>Foldable</a> into a <a>UniqueSet</a> using the given
--   insertion function.
fromFoldable :: Foldable f => (i -> UniqueSet unique -> UniqueSet unique) -> f i -> UniqueSet unique

-- | Convert a <a>Foldable</a> with uniques into a <a>UniqueSet</a>.
fromUniques :: Foldable f => Coercible Unique unique => f unique -> UniqueSet unique

-- | Convert a <a>Foldable</a> with names into a <a>UniqueSet</a>.
fromNames :: Foldable f => HasUnique name unique => f name -> UniqueSet unique

-- | Is the <tt>unique</tt> a member of the set?
memberByUnique :: Coercible unique Unique => unique -> UniqueSet unique -> Bool

-- | Is the <tt>name</tt> associated to the <tt>unique</tt> a member of the
--   set?
memberByName :: HasUnique name unique => name -> UniqueSet unique -> Bool

-- | The negation of <a>memberByName</a>, useful for converting to operator
--   form, e.g. <tt>name <a>notMemberByName</a> set</tt>.
notMemberByName :: HasUnique name unique => name -> UniqueSet unique -> Bool

-- | The difference of two <a>UniqueSet</a>s.
(\\) :: UniqueSet unique -> UniqueSet unique -> UniqueSet unique

-- | The union of two <a>UniqueSet</a>s.
union :: UniqueSet unique -> UniqueSet unique -> UniqueSet unique

-- | Build a set of <tt>unique</tt>s from the <a>Getting</a>.
setOfByUnique :: Coercible unique Unique => Getting (UniqueSet unique) s unique -> s -> UniqueSet unique

-- | Build a set of <tt>unique</tt>s associated to the names in the
--   <a>Getting</a>.
setOfByName :: HasUnique name unique => Getting (UniqueSet unique) s name -> s -> UniqueSet unique
instance GHC.Base.Monoid (PlutusCore.Name.UniqueSet.UniqueSet unique)
instance GHC.Base.Semigroup (PlutusCore.Name.UniqueSet.UniqueSet unique)
instance GHC.Classes.Eq (PlutusCore.Name.UniqueSet.UniqueSet unique)
instance GHC.Show.Show (PlutusCore.Name.UniqueSet.UniqueSet unique)


-- | A type for maps (key-value associations), where the key type can be
--   identified by <a>Unique</a>s. In practice, these types are usually
--   names. This approach is preferred when it is more efficient to compare
--   the associated <a>Unique</a>s instead of the underlying type.
module PlutusCore.Name.UniqueMap

-- | A mapping from <a>Unique</a>s to arbitrary values of type <tt>a</tt>.
--   Since <a>Unique</a> is equivalent to <a>Int</a> (see
--   <a>PlutusCore.Name.Unique</a>), we can use an <tt>IntMap</tt>
--   representation for this type.
newtype UniqueMap unique a
UniqueMap :: IntMap a -> UniqueMap unique a
[unUniqueMap] :: UniqueMap unique a -> IntMap a

-- | Insert a value <tt>a</tt> by a <tt>unique</tt>.
insertByUnique :: Coercible unique Unique => unique -> a -> UniqueMap unique a -> UniqueMap unique a

-- | Insert a value <tt>a</tt> by the <tt>unique</tt> of a <tt>name</tt>.
insertByName :: HasUnique name unique => name -> a -> UniqueMap unique a -> UniqueMap unique a

-- | Create the singleton map of the <tt>unique</tt> of a <tt>name</tt> and
--   a value <tt>a</tt>.
singletonByName :: HasUnique name unique => name -> a -> UniqueMap unique a

-- | Insert a named value <tt>a</tt> by the index of the <tt>unique</tt> of
--   the <tt>name</tt>.
insertNamed :: (HasText name, HasUnique name unique) => name -> a -> UniqueMap unique (Named a) -> UniqueMap unique (Named a)

-- | Insert a value by the index of the unique of a name. Unlike
--   <a>insertByUnique</a> and <a>insertByName</a>, this function does not
--   provide any static guarantees, so you can for example insert by a
--   type-level name in a map from term-level uniques.
insertByNameIndex :: (HasUnique name unique1, Coercible unique2 Unique) => name -> a -> UniqueMap unique2 a -> UniqueMap unique2 a

-- | Convert a <a>Foldable</a> into a <a>UniqueMap</a> using the given
--   insertion function.
fromFoldable :: Foldable f => (i -> a -> UniqueMap unique a -> UniqueMap unique a) -> f (i, a) -> UniqueMap unique a

-- | Convert a <a>Foldable</a> with uniques into a <a>UniqueMap</a>.
fromUniques :: Foldable f => Coercible Unique unique => f (unique, a) -> UniqueMap unique a

-- | Convert a <a>Foldable</a> with names into a <a>UniqueMap</a>.
fromNames :: Foldable f => HasUnique name unique => f (name, a) -> UniqueMap unique a

-- | Look up a value by a unique.
lookupUnique :: Coercible unique Unique => unique -> UniqueMap unique a -> Maybe a

-- | Look up a value by the unique of a name.
lookupName :: HasUnique name unique => name -> UniqueMap unique a -> Maybe a
restrictKeys :: UniqueMap unique v -> UniqueSet unique -> UniqueMap unique v

-- | Look up a value by the index of the unique of a name. Unlike
--   <a>lookupUnique</a> and <a>lookupName</a>, this function does not
--   provide any static guarantees, so you can for example look up a
--   type-level name in a map from term-level uniques.
lookupNameIndex :: (HasUnique name unique1, Coercible unique2 Unique) => name -> UniqueMap unique2 a -> Maybe a
instance Data.Foldable.Foldable (PlutusCore.Name.UniqueMap.UniqueMap unique)
instance GHC.Base.Functor (PlutusCore.Name.UniqueMap.UniqueMap unique)
instance GHC.Base.Monoid (PlutusCore.Name.UniqueMap.UniqueMap unique a)
instance GHC.Base.Semigroup (PlutusCore.Name.UniqueMap.UniqueMap unique a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (PlutusCore.Name.UniqueMap.UniqueMap unique a)
instance GHC.Show.Show a => GHC.Show.Show (PlutusCore.Name.UniqueMap.UniqueMap unique a)


-- | The monad that the renamer runs in and related infrastructure.
module PlutusCore.Rename.Monad

-- | The monad the renamer runs in.
newtype RenameT ren m a
RenameT :: ReaderT ren m a -> RenameT ren m a
[unRenameT] :: RenameT ren m a -> ReaderT ren m a
type ScopedRenameT = RenameT ScopedRenaming

-- | A renaming is a mapping from old uniques to new ones.
newtype Renaming unique
Renaming :: UniqueMap unique unique -> Renaming unique
[unRenaming] :: Renaming unique -> UniqueMap unique unique

-- | A type-level renaming. Needed for instantiating functions running over
--   types in generic <tt>RenameT ren m</tt> to a particular type of
--   renaming.
type TypeRenaming = Renaming TypeUnique

-- | Scoping-aware mapping from locally unique uniques to globally unique
--   uniques.
data ScopedRenaming
ScopedRenaming :: Renaming TypeUnique -> Renaming TermUnique -> ScopedRenaming
[_scopedRenamingTypes] :: ScopedRenaming -> Renaming TypeUnique
[_scopedRenamingTerms] :: ScopedRenaming -> Renaming TermUnique

-- | A class that specifies which <a>Renaming</a> a <tt>ren</tt> has
--   inside. A <tt>ren</tt> can contain several <a>Renaming</a>s (like
--   <tt>Scoped</tt>, for example).
class Coercible unique Unique => HasRenaming ren unique
renaming :: HasRenaming ren unique => Lens' ren (Renaming unique)
scopedRenamingTypes :: Lens' ScopedRenaming (Renaming TypeUnique)
scopedRenamingTerms :: Lens' ScopedRenaming (Renaming TermUnique)

-- | Run a <a>RenameT</a> computation with an empty renaming.
runRenameT :: Monoid ren => RenameT ren m a -> m a

-- | Look up the new unique a name got mapped to.
lookupNameM :: (HasUnique name unique, HasRenaming ren unique, MonadReader ren m) => name -> m (Maybe unique)

-- | Rename a name that has a unique inside.
renameNameM :: (HasRenaming ren unique, HasUnique name unique, MonadReader ren m) => name -> m name

-- | Replace the unique in a name by a new unique, save the mapping from
--   the old unique to the new one and supply the updated value to a
--   continuation.
withFreshenedName :: (HasRenaming ren unique, HasUnique name unique, MonadQuote m, MonadReader ren m) => name -> (name -> m c) -> m c

-- | Run a <a>RenameT</a> computation in the environment extended by the
--   mapping from an old name to a new one.
withRenamedName :: (HasRenaming ren unique, HasUnique name unique, MonadReader ren m) => name -> name -> m c -> m c
instance GHC.Base.Semigroup PlutusCore.Rename.Monad.ScopedRenaming
instance GHC.Base.Monoid PlutusCore.Rename.Monad.ScopedRenaming
instance (GHC.Types.Coercible unique1 PlutusCore.Name.Unique.Unique, unique1 GHC.Types.~ unique2) => PlutusCore.Rename.Monad.HasRenaming (PlutusCore.Rename.Monad.Renaming unique1) unique2
instance PlutusCore.Rename.Monad.HasRenaming PlutusCore.Rename.Monad.ScopedRenaming PlutusCore.Name.Unique.TypeUnique
instance PlutusCore.Rename.Monad.HasRenaming PlutusCore.Rename.Monad.ScopedRenaming PlutusCore.Name.Unique.TermUnique
instance PlutusCore.Quote.MonadQuote m => PlutusCore.Quote.MonadQuote (PlutusCore.Rename.Monad.RenameT ren m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader ren (PlutusCore.Rename.Monad.RenameT ren m)
instance GHC.Base.Monad m => GHC.Base.Monad (PlutusCore.Rename.Monad.RenameT ren m)
instance GHC.Base.Alternative m => GHC.Base.Alternative (PlutusCore.Rename.Monad.RenameT ren m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (PlutusCore.Rename.Monad.RenameT ren m)
instance GHC.Base.Functor m => GHC.Base.Functor (PlutusCore.Rename.Monad.RenameT ren m)
instance GHC.Base.Monoid (PlutusCore.Rename.Monad.Renaming unique)
instance GHC.Base.Semigroup (PlutusCore.Rename.Monad.Renaming unique)

module PlutusCore.Check.Scoping
data ScopedName
TypeName :: TyName -> ScopedName
TermName :: Name -> ScopedName
isSameScope :: ScopedName -> ScopedName -> Bool

-- | Staying names.
data Stays

-- | An out-of-scope variable does not get renamed and hence stays.
StaysOutOfScopeVariable :: Stays

-- | A free variable does not get renamed and hence stays.
StaysFreeVariable :: Stays

-- | Changing names.
data Disappears

-- | A binding gets renamed and hence the name that it binds disappears.
DisappearsBinding :: Disappears

-- | A bound variable gets renamed and hence its name disappears.
DisappearsVariable :: Disappears

-- | A name either stays or disappears.
data NameAction
Stays :: Stays -> NameAction
Disappears :: Disappears -> NameAction
data NameAnn
NameAction :: NameAction -> ScopedName -> NameAnn
NotAName :: NameAnn
class ToScopedName name
toScopedName :: ToScopedName name => name -> ScopedName

-- | Annotation for a binding saying "supposed to disappear".
introduceBound :: ToScopedName name => name -> NameAnn

-- | Annotation for a bound variable saying "supposed to disappear".
registerBound :: ToScopedName name => name -> NameAnn

-- | Annotation for an out-of-scope variable saying "supposed to stay out
--   of scope".
registerOutOfScope :: ToScopedName name => name -> NameAnn

-- | Annotation for a free variable saying "supposed to stay free".
registerFree :: ToScopedName name => name -> NameAnn
class Reference n t

-- | Take a registering function, apply it to the provided name, create a
--   type/term variable out of the resulting annotation and the original
--   name and reference that variable in the provided type/term by
--   prepending a constructor to it mentioning the variable.
referenceVia :: Reference n t => (forall name. ToScopedName name => name -> NameAnn) -> n -> t NameAnn -> t NameAnn

-- | Reference the provided variable in the provided type/term as an
--   in-scope one.
referenceBound :: Reference n t => n -> t NameAnn -> t NameAnn

-- | Reference the provided variable in the provided type/term as an
--   out-of-scope one.
referenceOutOfScope :: Reference n t => n -> t NameAnn -> t NameAnn

-- | Each kind of old and new names.
data ScopeEntry
DisappearedBindings :: ScopeEntry
DisappearedVariables :: ScopeEntry
AppearedBindings :: ScopeEntry
AppearedVariables :: ScopeEntry
StayedOutOfScopeVariables :: ScopeEntry
StayedFreeVariables :: ScopeEntry

-- | A <a>ScopeInfo</a> is a set of <a>ScopedName</a>s for each of the
--   <a>ScopeEntry</a>. If a <a>ScopeEntry</a> is not present in the map,
--   the corresponding set of <tt>ScopeName</tt>s is considered to be
--   empty.
newtype ScopeInfo
ScopeInfo :: Map ScopeEntry (Set ScopedName) -> ScopeInfo
unScopeInfo :: ScopeInfo -> Map ScopeEntry (Set ScopedName)

-- | Extract the set stored in the provided <a>ScopeInfo</a> at the
--   provided <a>ScopeEntry</a>.
to :: ScopeEntry -> ScopeInfo -> Set ScopedName
emptyScopeInfo :: ScopeInfo

-- | Check if a set is empty and report an error with the set embedded in
--   it otherwise.
checkEmptyOn :: (Set ScopedName -> Set ScopedName -> Set ScopedName) -> (Set ScopedName -> Set ScopedName -> ScopeError) -> Set ScopedName -> Set ScopedName -> Either ScopeError ()

-- | Merge two <a>ScopeInfo</a>s checking that binders in them do not
--   intersect along the way.
mergeScopeInfo :: ScopeInfo -> ScopeInfo -> Either ScopeError ScopeInfo
newtype ScopeErrorOrInfo
ScopeErrorOrInfo :: Either ScopeError ScopeInfo -> ScopeErrorOrInfo
unScopeErrorOrInfo :: ScopeErrorOrInfo -> Either ScopeError ScopeInfo

-- | Whether it's OK if the pass removes bindings. A renamer isn't supposed
--   to do that, but for example an inliner may do it, since it's basically
--   the entire point of an inliner.
data BindingRemoval
BindingRemovalOk :: BindingRemoval
BindingRemovalNotOk :: BindingRemoval
class EstablishScoping t

-- | Traverse a <tt>t</tt> freshening every name (both at the binding and
--   the use sites) and annotating the freshened names with either
--   <a>DisappearsBinding</a> or <a>StaysFreeVariable</a> depending on
--   whether the name occurs at the binding or the use site.
--   
--   In addition to that every binder should be decorated with one
--   out-of-scope variable (annotated with <a>StaysOutOfScopeVariable</a>)
--   and one in-scope one (annotated with <a>DisappearsVariable</a>).
--   
--   Note that no original name occurring in <tt>t</tt> should survive this
--   procedure (and hence we don't care if any of the freshened names
--   clashes with an original one as all original ones are supposed to be
--   gone).
--   
--   How to provide an implementation:
--   
--   <ol>
--   <li>handle bindings with 'freshen*Name' +
--   <a>establishScopingBinder</a> (or similar)</li>
--   <li>handle variables with 'freshen*Name' + <a>registerFree</a></li>
--   <li>everything else is direct recursion + <a>Applicative</a>
--   stuff</li>
--   </ol>
establishScoping :: EstablishScoping t => t ann -> Quote (t NameAnn)
class CollectScopeInfo t

-- | Collect scoping information after scoping was established and renaming
--   was performed.
--   
--   How to provide an implementation:
--   
--   <ol>
--   <li>handle names (both bindings and variables) with
--   <a>handleSname</a></li>
--   <li>everything else is direct recursion + <a>Monoid</a> stuff</li>
--   </ol>
collectScopeInfo :: CollectScopeInfo t => t NameAnn -> ScopeErrorOrInfo
type Scoping t = (EstablishScoping t, CollectScopeInfo t)

-- | Take a constructor for a binder, a name bound by it, a sort
--   (kind/type), a value of that sort (type/term) and call
--   <a>establishScoping</a> on both the sort and its value and reassemble
--   the original binder with the annotated sort and its value, but also
--   decorate the reassembled binder with one out-of-scope variable and one
--   in-scope one.
establishScopingBinder :: (Reference name value, ToScopedName name, Scoping sort, Scoping value) => (NameAnn -> name -> sort NameAnn -> value NameAnn -> value NameAnn) -> name -> sort ann -> value ann -> Quote (value NameAnn)

-- | Every kind of error thrown by the scope checking machinery at
--   different stages.
data ScopeError
UnannotatedName :: !ScopedName -> ScopeError
NameChangedItsScope :: !ScopedName -> !ScopedName -> ScopeError
[_oldName] :: ScopeError -> !ScopedName
[_newName] :: ScopeError -> !ScopedName
NameUnexpectedlyDisappeared :: !ScopedName -> !ScopedName -> ScopeError
[_oldName] :: ScopeError -> !ScopedName
[_newName] :: ScopeError -> !ScopedName
NameUnexpectedlyStayed :: !ScopedName -> ScopeError
DuplicateBindersInTheInput :: !Set ScopedName -> !Set ScopedName -> ScopeError
[_duplicateBindersLeft] :: ScopeError -> !Set ScopedName
[_duplicateBindersRight] :: ScopeError -> !Set ScopedName
DuplicateBindersInTheOutput :: !Set ScopedName -> !Set ScopedName -> ScopeError
DisappearedBindingsDiscordWithBoundVariables :: !Set ScopedName -> !Set ScopedName -> ScopeError
[_disappearedBindings] :: ScopeError -> !Set ScopedName
[_boundVariables] :: ScopeError -> !Set ScopedName
DisappearedBindingsDiscordWithOutOfScopeVariables :: !Set ScopedName -> !Set ScopedName -> ScopeError
[_disappearedBindings] :: ScopeError -> !Set ScopedName
[_outOfScopeVariables] :: ScopeError -> !Set ScopedName
AppearedBindingsDiscordWithBoundVariables :: !Set ScopedName -> !Set ScopedName -> ScopeError
[_appearedBindings] :: ScopeError -> !Set ScopedName
[_boundVariables] :: ScopeError -> !Set ScopedName
DisappearedBindingsClashWithFreeVariables :: !Set ScopedName -> !Set ScopedName -> ScopeError
[_disappearedBindings] :: ScopeError -> !Set ScopedName
[_freeVariables] :: ScopeError -> !Set ScopedName
DisappearedBindingsClashWithAppearedBindings :: !Set ScopedName -> !Set ScopedName -> ScopeError
[_disppearedBindings] :: ScopeError -> !Set ScopedName
[_appearedBindings] :: ScopeError -> !Set ScopedName
AppearedBindingsClashWithFreeVariabes :: !Set ScopedName -> !Set ScopedName -> ScopeError
[_appearedBindings] :: ScopeError -> !Set ScopedName
[_freeVariables] :: ScopeError -> !Set ScopedName

-- | Override the set at the provided <a>ScopeEntry</a> to contain only the
--   provided <a>ScopedName</a>.
overrideSname :: ScopeEntry -> ScopedName -> ScopeInfo -> ScopeInfo

-- | Use a <a>Stays</a> to handle an unchanged old name.
applyStays :: Stays -> ScopedName -> ScopeInfo

-- | Use a <a>Disappears</a> to handle differing old and new names.
applyDisappears :: Disappears -> ScopedName -> ScopedName -> ScopeInfo

-- | Use a <a>NameAction</a> to handle an old and a new name.
applyNameAction :: NameAction -> ScopedName -> ScopedName -> Either ScopeError ScopeInfo

-- | Use a <a>NameAnn</a> to handle a new name.
handleSname :: ToScopedName name => NameAnn -> name -> ScopeErrorOrInfo
symmetricDifference :: Ord a => Set a -> Set a -> Set a

-- | Check that each kind of <a>Set</a> from <a>ScopeInfo</a> relates to
--   all other ones in a certain way. We start with these three relations
--   that are based on the assumption that for each binder we add at least
--   one out-of-scope variable and at least one in-scope one:
--   
--   <ol>
--   <li>disappeared bindings should be the same as stayed out of scope
--   variables (ensures that old bindings disappear via renaming and not
--   via removal)</li>
--   <li>disappeared bindings should be the same as disappeared variables
--   (ensures that old names consistently disappear at the binding and use
--   sites)</li>
--   <li>appeared bindings should be the same as appeared variables
--   (ensures that new names consistently appear at the binding and use
--   sites)</li>
--   </ol>
--   
--   Once we've ensured all of that, we're left with only three sets and
--   3C2 equals 3, so we only need to consider three more relations:
--   
--   <ol>
--   <li>disappeared bindings should not intersect with free variables (an
--   internal sanity check)</li>
--   <li>appeared bindings should not intersect with disappeared
--   bindings</li>
--   <li>appeared bindings should not intersect with free variables</li>
--   </ol>
--   
--   The last two ensure that no new name has an old name's unique.
checkScopeInfo :: BindingRemoval -> ScopeInfo -> Either ScopeError ()

-- | The type of errors that the scope checking machinery returns.
data ScopeCheckError t
ScopeCheckError :: !t NameAnn -> !t NameAnn -> !ScopeError -> ScopeCheckError t

-- | What got fed to the scoping check pass.
[_input] :: ScopeCheckError t -> !t NameAnn

-- | What got out of it.
[_output] :: ScopeCheckError t -> !t NameAnn

-- | The error returned by the scoping check pass.
[_error] :: ScopeCheckError t -> !ScopeError

-- | Check if a pass respects scoping.
--   
--   Returns the thing that the scoping tests run on, the result of the
--   pass and the scope checking outcome, respectively.
checkRespectsScoping :: Scoping t => BindingRemoval -> (t NameAnn -> t NameAnn) -> (t NameAnn -> t NameAnn) -> t ann -> Either (ScopeCheckError t) ()
instance GHC.Classes.Ord PlutusCore.Check.Scoping.ScopedName
instance GHC.Classes.Eq PlutusCore.Check.Scoping.ScopedName
instance GHC.Show.Show PlutusCore.Check.Scoping.ScopedName
instance GHC.Show.Show PlutusCore.Check.Scoping.Stays
instance GHC.Show.Show PlutusCore.Check.Scoping.Disappears
instance GHC.Show.Show PlutusCore.Check.Scoping.NameAction
instance GHC.Show.Show PlutusCore.Check.Scoping.NameAnn
instance GHC.Classes.Ord PlutusCore.Check.Scoping.ScopeEntry
instance GHC.Classes.Eq PlutusCore.Check.Scoping.ScopeEntry
instance GHC.Show.Show PlutusCore.Check.Scoping.ScopeEntry
instance GHC.Show.Show PlutusCore.Check.Scoping.ScopeInfo
instance GHC.Classes.Eq PlutusCore.Check.Scoping.BindingRemoval
instance GHC.Show.Show PlutusCore.Check.Scoping.BindingRemoval
instance GHC.Show.Show PlutusCore.Check.Scoping.ScopeError
instance GHC.Show.Show (t PlutusCore.Check.Scoping.NameAnn) => GHC.Show.Show (PlutusCore.Check.Scoping.ScopeCheckError t)
instance Text.PrettyBy.Internal.PrettyBy config (t PlutusCore.Check.Scoping.NameAnn) => Text.PrettyBy.Internal.PrettyBy config (PlutusCore.Check.Scoping.ScopeCheckError t)
instance GHC.Base.Semigroup PlutusCore.Check.Scoping.ScopeErrorOrInfo
instance GHC.Base.Monoid PlutusCore.Check.Scoping.ScopeErrorOrInfo
instance Prettyprinter.Internal.Pretty PlutusCore.Check.Scoping.ScopeError
instance PlutusCore.Check.Scoping.Reference n t => PlutusCore.Check.Scoping.Reference [n] t
instance PlutusCore.Check.Scoping.Reference n t => PlutusCore.Check.Scoping.Reference (GHC.Base.NonEmpty n) t
instance PlutusCore.Check.Scoping.ToScopedName PlutusCore.Name.Unique.TyName
instance PlutusCore.Check.Scoping.ToScopedName PlutusCore.Name.Unique.Name
instance Prettyprinter.Internal.Pretty PlutusCore.Check.Scoping.NameAnn

module PlutusCore.Evaluation.Machine.ExBudget
data ExBudget
ExBudget :: ExCPU -> ExMemory -> ExBudget
[exBudgetCPU] :: ExBudget -> ExCPU
[exBudgetMemory] :: ExBudget -> ExMemory

-- | Subract one <a>ExBudget</a> from another. Does not guarantee that the
--   result is positive.
minusExBudget :: ExBudget -> ExBudget -> ExBudget

-- | A class for injecting a <tt>Builtin</tt> into an <tt>exBudgetCat</tt>.
--   We need it, because the constant application machinery calls
--   <tt>spendBudget</tt> before reducing a constant application and we
--   want to be general over <tt>exBudgetCat</tt> there, but still track
--   the built-in functions category, hence the ad hoc polymorphism.
class ExBudgetBuiltin fun exBudgetCat
exBudgetBuiltin :: ExBudgetBuiltin fun exBudgetCat => fun -> exBudgetCat
newtype ExRestrictingBudget
ExRestrictingBudget :: ExBudget -> ExRestrictingBudget
[unExRestrictingBudget] :: ExRestrictingBudget -> ExBudget

-- | This is used elsewhere to convert cost models into JSON objects where
--   the names of the fields are exactly the same as the names of the
--   builtins.
data LowerInitialCharacter

-- | When we want to just evaluate the program we use the
--   <tt>Restricting</tt> mode with an enormous budget, so that evaluation
--   costs of on-chain budgeting are reflected accurately in benchmarks.
enormousBudget :: ExRestrictingBudget
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance Codec.Serialise.Class.Serialise PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance NoThunks.Class.NoThunks PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance Text.PrettyBy.Internal.PrettyBy config PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance GHC.Show.Show PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.ExBudget.ExRestrictingBudget
instance Text.PrettyBy.Internal.PrettyBy config PlutusCore.Evaluation.Machine.ExBudget.ExRestrictingBudget
instance Prettyprinter.Internal.Pretty PlutusCore.Evaluation.Machine.ExBudget.ExRestrictingBudget
instance GHC.Base.Monoid PlutusCore.Evaluation.Machine.ExBudget.ExRestrictingBudget
instance GHC.Base.Semigroup PlutusCore.Evaluation.Machine.ExBudget.ExRestrictingBudget
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.ExBudget.ExRestrictingBudget
instance GHC.Show.Show PlutusCore.Evaluation.Machine.ExBudget.ExRestrictingBudget
instance GHC.Base.Semigroup PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance GHC.Base.Monoid PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance Prettyprinter.Internal.Pretty PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance PlutusCore.Evaluation.Machine.ExBudget.ExBudgetBuiltin fun ()
instance Deriving.Aeson.StringModifier PlutusCore.Evaluation.Machine.ExBudget.LowerInitialCharacter

module PlutusCore.Evaluation.Machine.ExBudgetStream

-- | A lazy stream of <a>ExBudget</a>s. Basically <tt>NonEmpty
--   ExBudget</tt>, except the elements are stored strictly.
--   
--   The semantics of a stream are those of the <tt>fold</tt> of its
--   elements. I.e. a stream that is a reordered version of another stream
--   is considered equal to that stream.
--   
--   An <a>ExBudgetStream</a> is what one gets by zipping two
--   <a>CostStream</a>s (one for CPU, one for memory), which is why the two
--   data types are so similar. The only reason why we don't express both
--   the concepts in terms of a single data type is efficiency, in
--   particular unboxing is crucial for <a>CostStream</a> and we don't care
--   about it in <a>ExBudgetStream</a>, because we can't get the spender in
--   the CEK machine to get inlined and so unboxing <a>ExBudget</a> here
--   would only result in boxing it back once it's about to be spent.
data ExBudgetStream
ExBudgetLast :: !ExBudget -> ExBudgetStream
ExBudgetCons :: !ExBudget -> ExBudgetStream -> ExBudgetStream

-- | Add up all the budgets in a <a>ExBudgetStream</a>.
sumExBudgetStream :: ExBudgetStream -> ExBudget

-- | Zip two <a>CostStream</a> together (one with CPU costs and the other
--   one with memory costs, respectively) to get an <a>ExBudgetStream</a>.
--   If one is longer than the other, then it's assumed to contain the
--   required amount of zeros for two streams to have the same length (all
--   those zeros "appear" in the tail of the stream).
zipCostStream :: CostStream -> CostStream -> ExBudgetStream
instance GHC.Show.Show PlutusCore.Evaluation.Machine.ExBudgetStream.ExBudgetStream

module Prettyprinter.Custom

-- | This prints a document enclosed by brackets, possibly indenting the
--   output on a new line if it does not fit.
brackets' :: Doc a -> Doc a

-- | This prints a document enclosed by braces, possibly indenting the
--   output on a new line if it does not fit.
braces' :: Doc a -> Doc a

-- | This prints a document enclosed by parentheses, aligning the opening
--   and closing parentheses.
parens' :: Doc a -> Doc a

-- | Print a "sexp", i.e. something like "(keyword arg1 ... argN)".
sexp :: Doc a -> [Doc a] -> Doc a

-- | Separate two documents <tt>p</tt> and <tt>q</tt> and increase
--   indentation if <tt>q</tt> has to be put on a new line. Useful to e.g.
--   pretty-print function application like `fun <a>?</a> sep arguments`.
(<?>) :: Doc ann -> Doc ann -> Doc ann
infixr 6 <?>

-- | Lay out a sequence of documents vertically with forced lines between
--   documents. Useful for prettyprinting layout-sensitive things like
--   let-bindings.
vcatHard :: [Doc ann] -> Doc ann

module Universe

-- | "Escapes" a type of an arbitrary kind to fit into <a>Type</a>.
data Esc a
data () => Some (tag :: k -> Type)
pattern Some :: forall {k} tag (a :: k). () => tag a -> Some tag

-- | A particular type from a universe.
data SomeTypeIn uni
SomeTypeIn :: !uni (Esc a) -> SomeTypeIn uni
data Kinded uni ta
[Kinded] :: Typeable k => !uni (Esc a) -> Kinded uni (Esc (a :: k))

-- | A value of a particular type from a universe.
data ValueOf uni a
ValueOf :: !uni (Esc a) -> !a -> ValueOf uni a

-- | A class for enumerating types and fully instantiated type formers that
--   <tt>uni</tt> contains. For example, a particular <tt>ExampleUni</tt>
--   may have monomorphic types in it:
--   
--   instance ExampleUni <a>Contains</a> Integer where <a>...</a> instance
--   ExampleUni <a>Contains</a> Bool where <a>...</a>
--   
--   as well as polymorphic ones:
--   
--   instance ExampleUni <a>Contains</a> [] where <a>...</a> instance
--   ExampleUni <a>Contains</a> (,) where <a>...</a>
--   
--   as well as their instantiations:
--   
--   instance ExampleUni <a>Contains</a> a =&gt; ExampleUni <a>Contains</a>
--   [a] where <a>...</a> instance (ExampleUni <a>Contains</a> a,
--   ExampleUni <a>Contains</a> b) =&gt; ExampleUni <a>Contains</a> (a, b)
--   where <a>...</a>
--   
--   (a universe can have any subset of the mentioned sorts of types, for
--   example it's fine to have instantiated polymorphic types and not have
--   uninstantiated ones and vice versa)
--   
--   Note that when used as a constraint of a function <a>Contains</a> does
--   not allow you to directly express things like "<tt>uni</tt> has the
--   <tt>Integer</tt>, <tt>Bool</tt> and <tt>[]</tt> types and type
--   formers", because <tt>[]</tt> is not fully instantiated. So you can
--   only say "<tt>uni</tt> has <tt>Integer</tt>, <tt>Bool</tt>,
--   <tt>[Integer]</tt>, <tt>[Bool]</tt>, <tt>[[Integer]]</tt>,
--   <tt>[[Bool]]</tt> etc" and such manual enumeration is annoying, so
--   we'd really like to be able to say that <tt>uni</tt> has lists of
--   arbitrary built-in types (including lists of lists etc).
--   <a>Contains</a> does not allow that, but <a>Includes</a> does. For
--   example, in the body of the following definition:
--   
--   foo :: (uni <a>Includes</a> Integer, uni <a>Includes</a> Bool, uni
--   <a>Includes</a> []) =&gt; <a>...</a> foo = <a>...</a>
--   
--   you can make use of the fact that <tt>uni</tt> has lists of arbitrary
--   included types (integers, booleans and lists).
--   
--   Hence most of the time opt for using the more flexible
--   <a>Includes</a>.
--   
--   <a>Includes</a> is defined in terms of <a>Contains</a>, so you only
--   need to provide a <a>Contains</a> instance per type from the universe
--   and you'll get <a>Includes</a> for free.
class uni `Contains` a
knownUni :: Contains uni a => uni (Esc a)

-- | <tt>uni <a>Includes</a> a</tt> reads as "<tt>a</tt> is in the
--   <tt>uni</tt>". <tt>a</tt> can be of a higher-kind, see the docs of
--   <a>Contains</a> on why you might want that.
type Includes uni = Permits (Contains uni)

-- | Same as <a>knownUni</a>, but receives a <tt>proxy</tt>.
knownUniOf :: uni `Contains` a => proxy a -> uni (Esc a)

-- | Wrap a type into <tt>SomeTypeIn</tt>, provided it's in the universe.
someType :: forall k (a :: k) uni. uni `Contains` a => SomeTypeIn uni

-- | Wrap a value into <tt>Some (ValueOf uni)</tt>, given its explicit type
--   tag.
someValueOf :: forall a uni. uni (Esc a) -> a -> Some (ValueOf uni)

-- | Wrap a value into <tt>Some (ValueOf uni)</tt>, provided its type is in
--   the universe.
someValue :: forall a uni. uni `Contains` a => a -> Some (ValueOf uni)
someValueType :: Some (ValueOf uni) -> SomeTypeIn uni

-- | A monad to decode types from a universe in. We use a monad for
--   decoding, because parsing arguments of polymorphic built-in types can
--   peel off an arbitrary amount of type tags from the input list of tags
--   and so we have state, which is convenient to handle with, well,
--   <a>StateT</a>.
newtype DecodeUniM a
DecodeUniM :: StateT [Int] Maybe a -> DecodeUniM a
[unDecodeUniM] :: DecodeUniM a -> StateT [Int] Maybe a

-- | A universe is <a>Closed</a>, if it's known how to constrain every type
--   from the universe and every type can be encoded to / decoded from a
--   sequence of integer tags. The universe doesn't have to be finite and
--   providing support for infinite universes is the reason why we encode a
--   type as a sequence of integer tags as opposed to a single integer tag.
--   For example, given
--   
--   <pre>
--   data U a where
--       UList :: !(U a) -&gt; U [a]
--       UInt  :: U Int
--   </pre>
--   
--   <tt>UList (UList UInt)</tt> can be encoded to <tt>[0,0,1]</tt> where
--   <tt>0</tt> and <tt>1</tt> are the integer tags of the <tt>UList</tt>
--   and <tt>UInt</tt> constructors, respectively.
class Closed uni where {
    
    -- | A constrant for "<tt>constr a</tt> holds for any <tt>a</tt> from
    --   <tt>uni</tt>".
    type Everywhere uni (constr :: Type -> Constraint) :: Constraint;
}

-- | Encode a type as a sequence of <a>Int</a> tags. The opposite of
--   <tt>decodeUni</tt>.
encodeUni :: Closed uni => uni a -> [Int]

-- | Decode a type and feed it to the continuation.
withDecodedUni :: Closed uni => (forall k (a :: k). Typeable k => uni (Esc a) -> DecodeUniM r) -> DecodeUniM r

-- | Bring a <tt>constr a</tt> instance in scope, provided <tt>a</tt> is a
--   type from the universe and <tt>constr</tt> holds for any type from the
--   universe.
bring :: (Closed uni, uni `Everywhere` constr) => proxy constr -> uni (Esc a) -> (constr a => r) -> r

-- | Decode a type from a sequence of <a>Int</a> tags. The opposite of
--   <a>encodeUni</a> (modulo invalid input).
decodeKindedUni :: Closed uni => [Int] -> Maybe (SomeTypeIn (Kinded uni))

-- | Peel off a tag from the input list of type tags.
peelUniTag :: DecodeUniM Int

-- | <tt>constr <a>Permits</a> f</tt> elaborates to one of - constr f
--   forall a. constr a =&gt; constr (f a) forall a b. (constr a, constr b)
--   =&gt; constr (f a b) forall a b c. (constr a, constr b, constr c)
--   =&gt; constr (f a b c)
--   
--   depending on the kind of <tt>f</tt>. This allows us to say things like
--   
--   ( constr <a>Permits</a> Integer , constr <a>Permits</a> [] , constr
--   <a>Permits</a> (,) )
--   
--   and thus constraint every type from the universe (including
--   polymorphic ones) to satisfy <tt>constr</tt>, which is how we provide
--   an implementation of <a>Everywhere</a> for universes with polymorphic
--   types.
--   
--   <a>Permits</a> is an open type family, so you can provide type
--   instances for <tt>f</tt>s expecting more type arguments than 3 if you
--   need that.
--   
--   Note that, say, <tt>constr <a>Permits</a> []</tt> elaborates to
--   
--   forall a. constr a =&gt; constr [a]
--   
--   and for certain type classes that does not make sense (e.g. the
--   <tt>Generic</tt> instance of <tt>[]</tt> does not require the type of
--   elements to be <tt>Generic</tt>), however it's not a problem because
--   we use <tt>Permit</tt> to constrain the whole universe and so we know
--   that arguments of polymorphic built-in types are builtins themselves
--   are hence do satisfy the constraint and the fact that these
--   constraints on arguments do not get used in the polymorphic case only
--   means that they get ignored.
type family Permits constr
type family uni `EverywhereAll` constrs

-- | A constraint for "<tt>uni1</tt> is a subuniverse of <tt>uni2</tt>".
type uni1 <: uni2 = uni1 `Everywhere` Includes uni2

-- | A class for "<tt>uni</tt> has general type application".
class HasUniApply (uni :: Type -> Type)

-- | Apply a type constructor to an argument.
uniApply :: forall k l (f :: k -> l) a. HasUniApply uni => uni (Esc f) -> uni (Esc a) -> uni (Esc (f a))

-- | Deconstruct a type application into the function and the argument and
--   feed them to the continuation. If the type is not an application, then
--   return the default value.
matchUniApply :: HasUniApply uni => uni tb -> r -> (forall k l (f :: k -> l) a. tb ~ Esc (f a) => uni (Esc f) -> uni (Esc a) -> r) -> r

-- | Check if the kind of the given type from the universe is <a>Type</a>.
checkStar :: forall uni a (x :: a). Typeable a => uni (Esc x) -> Maybe (a :~: Type)

-- | Check if one type from the universe can be applied to another (i.e.
--   check that the expected kind of the argument matches the actual one)
--   and call the continuation in the refined context. Fail with
--   <a>mzero</a> otherwise.
withApplicable :: forall (a :: Type) (ab :: Type) f x uni m r. (Typeable ab, Typeable a, MonadPlus m) => uni (Esc (f :: ab)) -> uni (Esc (x :: a)) -> (forall (b :: Type). (Typeable b, ab ~ (a -> b)) => m r) -> m r

-- | Apply a type constructor to an argument, provided kinds match.
tryUniApply :: (MonadPlus m, HasUniApply uni) => SomeTypeIn (Kinded uni) -> SomeTypeIn (Kinded uni) -> m (SomeTypeIn (Kinded uni))
class () => GShow (t :: k -> Type)
gshowsPrec :: forall (a :: k). GShow t => Int -> t a -> ShowS
gshow :: forall {k} t (a :: k). GShow t => t a -> String
class () => GEq (f :: k -> Type)
geq :: forall (a :: k) (b :: k). GEq f => f a -> f b -> Maybe (a :~: b)
defaultEq :: forall {k} f (a :: k) (b :: k). GEq f => f a -> f b -> Bool

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data () => (a :: k) :~: (b :: k)
[Refl] :: forall {k} (a :: k). a :~: a
infix 4 :~:
data () => DSum (tag :: k -> Type) (f :: k -> Type)
(:=>) :: !tag a -> f a -> DSum (tag :: k -> Type) (f :: k -> Type)

module PlutusCore.Pretty
data () => Doc ann
class () => Pretty a
pretty :: Pretty a => a -> Doc ann
prettyList :: Pretty a => [a] -> Doc ann
class () => PrettyBy config a
prettyBy :: PrettyBy config a => config -> a -> Doc ann
prettyListBy :: PrettyBy config a => config -> [a] -> Doc ann
newtype () => IgnorePrettyConfig a
IgnorePrettyConfig :: a -> IgnorePrettyConfig a
[unIgnorePrettyConfig] :: IgnorePrettyConfig a -> a
data () => AttachPrettyConfig config a
AttachPrettyConfig :: !config -> !a -> AttachPrettyConfig config a
class () => Render str
render :: Render str => Doc ann -> str

-- | For pretty-printing a value with a minimum amount of parens.
type PrettyParens = PrettyBy RenderContext
display :: forall str a. (Pretty a, Render str) => a -> str
displayBy :: forall str a config. (PrettyBy config a, Render str) => config -> a -> str

-- | An initial <a>RenderContextOver</a>. An expression printed in this
--   context gets enclosed in parens unless its outermost operator (if any)
--   binds even stronger than function application.
juxtRenderContext :: RenderContext

-- | Pretty-print a value in the default mode using the classic view.
prettyPlc :: PrettyPlc a => a -> Doc ann

-- | Render a value to <a>String</a> in the default mode using the classic
--   view.
displayPlc :: (PrettyPlc a, Render str) => a -> str

-- | Pretty-print a value in the debug mode using the classic view.
prettyPlcSimple :: PrettyPlc a => a -> Doc ann

-- | Render a value to <a>String</a> in the debug mode using the classic
--   view.
displayPlcSimple :: (PrettyPlc a, Render str) => a -> str

-- | Whether to pretty-print PLC errors in full or with some information
--   omitted.
data CondensedErrors
CondensedErrorsYes :: CondensedErrors
CondensedErrorsNo :: CondensedErrors

-- | A constraint that allows to derive <tt>PrettyBy PrettyConfigPlc</tt>
--   instances, see below.
type DefaultPrettyPlcStrategy a = (PrettyClassic a, PrettyReadable a)

-- | Options for pretty-printing PLC entities.
newtype PrettyConfigPlcOptions
PrettyConfigPlcOptions :: CondensedErrors -> PrettyConfigPlcOptions
[_pcpoCondensedErrors] :: PrettyConfigPlcOptions -> CondensedErrors

-- | Strategy for pretty-printing PLC entities.
data PrettyConfigPlcStrategy
PrettyConfigPlcClassic :: PrettyConfigClassic PrettyConfigName -> PrettyConfigPlcStrategy
PrettyConfigPlcReadable :: PrettyConfigReadable PrettyConfigName -> PrettyConfigPlcStrategy

-- | Global configuration used for pretty-printing PLC entities.
data PrettyConfigPlc
PrettyConfigPlc :: PrettyConfigPlcOptions -> PrettyConfigPlcStrategy -> PrettyConfigPlc
[_pcpOptions] :: PrettyConfigPlc -> PrettyConfigPlcOptions
[_pcpStrategy] :: PrettyConfigPlc -> PrettyConfigPlcStrategy

-- | The "pretty-printable PLC entity" constraint.
type PrettyPlc = PrettyBy PrettyConfigPlc

-- | The <a>PrettyConfigPlcOptions</a> used by default: print errors in
--   full.
prettyConfigPlcOptions :: PrettyConfigPlcOptions

-- | The <a>PrettyConfigPlc</a> used by default: use the classic view and
--   print neither <tt>Unique</tt>s, nor name attachments.
prettyConfigPlcClassic :: PrettyConfigPlcOptions -> PrettyConfigPlc

-- | The <a>PrettyConfigPlc</a> used for debugging: use the classic view
--   and print <tt>Unique</tt>s, but not name attachments.
prettyConfigPlcClassicSimple :: PrettyConfigPlcOptions -> PrettyConfigPlc

-- | The <a>PrettyConfigPlc</a> used by default and for readability: use
--   the refined view and print <tt>Unique</tt>s but not name attachments.
prettyConfigPlcReadable :: PrettyConfigPlcOptions -> PrettyConfigPlc

-- | The <a>PrettyConfigPlc</a> used for debugging and readability: use the
--   refined view and print neither <tt>Unique</tt>s nor name attachments.
prettyConfigPlcReadableSimple :: PrettyConfigPlcOptions -> PrettyConfigPlc

-- | Pretty-print a PLC value in the default mode using the classic view.
prettyPlcClassic :: PrettyPlc a => a -> Doc ann

-- | Pretty-print a PLC value without unique indices using the classic
--   view.
prettyPlcClassicSimple :: PrettyPlc a => a -> Doc ann

-- | Pretty-print a PLC value in the default mode using the readable view.
prettyPlcReadable :: PrettyPlc a => a -> Doc ann

-- | Pretty-print a PLC value without unique indices using the readable
--   view.
prettyPlcReadableSimple :: PrettyPlc a => a -> Doc ann

-- | Pretty-print a PLC value using the condensed way (see
--   <a>CondensedErrors</a>) of pretty-printing PLC errors (in case there
--   are any).
prettyPlcCondensedErrorBy :: PrettyPlc a => (PrettyConfigPlcOptions -> PrettyConfigPlc) -> a -> Doc ann

-- | Render an error to <a>String</a> in the condensed manner using the
--   classic view.
displayPlcCondensedErrorClassic :: (PrettyPlc a, Render str) => a -> str

-- | A config that determines how to pretty-print a PLC name.
newtype PrettyConfigName
PrettyConfigName :: Bool -> PrettyConfigName

-- | Whether to show the <tt>Unique</tt> of a name or not.
[_pcnShowsUnique] :: PrettyConfigName -> Bool

-- | A class of configs from which a <a>PrettyConfigName</a> can be
--   extracted.
class HasPrettyConfigName config
toPrettyConfigName :: HasPrettyConfigName config => config -> PrettyConfigName

-- | The <a>PrettyConfigName</a> used by default: print <tt>Unique</tt>
--   indexes after nams.
prettyConfigName :: PrettyConfigName

-- | The <a>PrettyConfigName</a> to be used when <tt>Unique</tt> indices
--   don't matter. Easier to read.
prettyConfigNameSimple :: PrettyConfigName

-- | Configuration for the classic pretty-printing.
data PrettyConfigClassic configName
PrettyConfigClassic :: configName -> Bool -> PrettyConfigClassic configName

-- | How to pretty-print names.
[_pccConfigName] :: PrettyConfigClassic configName -> configName

-- | Whether to display annotations.
[_pccDisplayAnn] :: PrettyConfigClassic configName -> Bool

-- | The "classically pretty-printable" constraint.
type PrettyClassicBy configName = PrettyBy (PrettyConfigClassic configName)
type PrettyClassic = PrettyClassicBy PrettyConfigName

-- | Add a pretty-printed annotation to a list of <a>Doc</a>s if the given
--   config enables pretty-printing of annotations.
consAnnIf :: Pretty ann => PrettyConfigClassic configName -> ann -> [Doc dann] -> [Doc dann]

-- | Pretty-print a value in the default mode using the classic view.
prettyClassic :: PrettyClassic a => a -> Doc ann

-- | Pretty-print a value in the simple mode using the classic view.
prettyClassicSimple :: PrettyClassic a => a -> Doc ann
data ShowKinds
ShowKindsYes :: ShowKinds
ShowKindsNonType :: ShowKinds
ShowKindsNo :: ShowKinds

-- | Configuration for the readable pretty-printing.
data PrettyConfigReadable configName
PrettyConfigReadable :: configName -> RenderContext -> ShowKinds -> PrettyConfigReadable configName
[_pcrConfigName] :: PrettyConfigReadable configName -> configName
[_pcrRenderContext] :: PrettyConfigReadable configName -> RenderContext
[_pcrShowKinds] :: PrettyConfigReadable configName -> ShowKinds

-- | Pretty-print something with the <tt>PrettyConfigReadable</tt> config.
prettyReadable :: PrettyReadable a => a -> Doc ann

-- | Pretty-print something with the <tt>PrettyConfigReadableSimple</tt>
--   config.
prettyReadableSimple :: PrettyReadable a => a -> Doc ann
pcrConfigName :: forall configName_a1jAQ configName_a1jFq. Lens (PrettyConfigReadable configName_a1jAQ) (PrettyConfigReadable configName_a1jFq) configName_a1jAQ configName_a1jFq
pcrRenderContext :: forall configName_a1jAQ. Lens' (PrettyConfigReadable configName_a1jAQ) RenderContext
pcrShowKinds :: forall configName_a1jAQ. Lens' (PrettyConfigReadable configName_a1jAQ) ShowKinds

-- | The "readably pretty-printable" constraint.
type PrettyReadableBy configName = PrettyBy (PrettyConfigReadable configName)
type PrettyReadable = PrettyReadableBy PrettyConfigName

-- | For rendering things in a readable manner regardless of the
--   pretty-printing function chosen. I.e. all of <a>show</a>,
--   <a>pretty</a>, <tt>prettyClassic</tt> will use <a>PrettyReadable</a>
--   instead of doing what they normally do. <tt>prettyBy config
--   (AsReadable x)</tt> requires <tt>config</tt> to have a
--   <a>PrettyConfigName</a> and respects it.
--   
--   This wrapper can be particularly useful if you want to apply a
--   function having a <a>Show</a> or <a>Pretty</a> or
--   <tt>PrettyClassic</tt> or <tt>PrettyPlc</tt> or whatever constraint,
--   but want to get the argument rendered in a readable manner instead.
newtype AsReadable a
AsReadable :: a -> AsReadable a
[unAsReadable] :: AsReadable a -> a

-- | A value of type <tt>a</tt> to render in parens using the readable
--   pretty-printer.
data Parened a
Parened :: String -> String -> a -> Parened a
[parenOpening] :: Parened a -> String
[parenClosing] :: Parened a -> String
[parenedValue] :: Parened a -> a

-- | Enclose the given value, so that it's rendered inside of braces with
--   no additional parens regardless of the <a>RenderContextOver</a>.
inBraces :: a -> Parened a

-- | A <a>PrettyConfigReadable</a> with the fixity specified to
--   <a>topFixity</a>.
topPrettyConfigReadable :: configName -> ShowKinds -> PrettyConfigReadable configName

-- | A <a>PrettyConfigReadable</a> with the fixity specified to
--   <a>botFixity</a>.
botPrettyConfigReadable :: configName -> ShowKinds -> PrettyConfigReadable configName

-- | The fixity of a binder.
binderFixity :: Fixity

-- | The fixity of <tt>(-&gt;)</tt>.
arrowFixity :: Fixity

-- | Lay out an iterated <tt>TyForall</tt> via <a>iterBinderPrettyM</a>.
iterTyForallPrettyM :: (MonadPrettyReadable configName env m, PrettyReadableBy configName arg, PrettyReadableBy configName body) => [arg] -> body -> m (Doc ann)

-- | Lay out an iterated <tt>LamAbs</tt> via <a>iterBinderPrettyM</a>.
iterLamAbsPrettyM :: (MonadPrettyReadable configName env m, PrettyReadableBy configName arg, PrettyReadableBy configName body) => [arg] -> body -> m (Doc ann)

-- | Lay out an iterated <tt>TyAbs</tt> via <a>iterBinderPrettyM</a>.
iterTyAbsPrettyM :: (MonadPrettyReadable configName env m, PrettyReadableBy configName arg, PrettyReadableBy configName body) => [arg] -> body -> m (Doc ann)

-- | Lay out an iterated <tt>-&gt;</tt>.
iterArrowPrettyM :: (MonadPrettyReadable configName env m, PrettyReadableBy configName a) => [a] -> a -> m (Doc ann)

-- | Lay out an iteration application, providing to the caller a function
--   to render the head of the application and a function to render each of
--   the arguments.
iterAppDocM :: MonadPrettyContext config env m => (AnyToDoc config ann -> AnyToDoc config ann -> NonEmpty (Doc ann)) -> m (Doc ann)

-- | Lay out interleaved function applications either as
--   
--   <pre>
--   foo {a} x {b} y z
--   </pre>
--   
--   or as
--   
--   <pre>
--   foo
--     {a}
--     x
--     {b}
--     y
--     z
--   </pre>
--   
--   <a>Left</a>s are laid out in braces, <a>Right</a>s are laid out
--   without braces.
iterInterAppPrettyM :: (MonadPrettyReadable configName env m, PrettyReadableBy configName fun, PrettyReadableBy configName ty, PrettyReadableBy configName term) => fun -> [Either ty term] -> m (Doc ann)

-- | Lay out iterated function applications either as
--   
--   <pre>
--   foo x y z
--   </pre>
--   
--   or as
--   
--   <pre>
--   foo
--     x
--     y
--     z
--   </pre>
iterAppPrettyM :: (MonadPrettyContext config env m, PrettyBy config fun, PrettyBy config term) => fun -> [term] -> m (Doc ann)
prettyBytes :: ByteString -> Doc ann

-- | The type of configs used for pretty-printing constants. Has a
--   <a>RenderContextOver</a> inside, so that we don't add redundant parens
--   to the output.
newtype ConstConfig
ConstConfig :: RenderContext -> ConstConfig
[unConstConfig] :: ConstConfig -> RenderContext
type PrettyConst = PrettyBy ConstConfig

-- | The set of constraints we need to be able to print built-in types and
--   their values.
type PrettyUni uni = (PrettyParens (SomeTypeIn uni), Closed uni, uni `Everywhere` PrettyConst)

-- | The set of constraints we need to be able to throw exceptions with
--   things with built-in types and functions in them.
type ThrowableBuiltins uni fun = (PrettyUni uni, Pretty fun, Typeable uni, Typeable fun)
prettyConst :: PrettyConst a => RenderContext -> a -> Doc ann


-- | This module defines a common type various evaluation machine use to
--   return their results.
module PlutusCore.Evaluation.Result

-- | A class for viewing errors as evaluation failures (in the sense of
--   Plutus).
class AsEvaluationFailure err
_EvaluationFailure :: AsEvaluationFailure err => Prism' err ()
evaluationFailure :: AsEvaluationFailure err => err

-- | Construct a prism focusing on the <tt>*EvaluationFailure</tt> part of
--   <tt>err</tt> by taking that <tt>*EvaluationFailure</tt> and
--   
--   <ol>
--   <li>returning it for the setter part of the prism</li>
--   <li>checking the error for equality with <tt>*EvaluationFailure</tt>
--   for the opposite direction.</li>
--   </ol>
_EvaluationFailureVia :: Eq err => err -> Prism' err ()

-- | The parameterized type of results various evaluation engines return.
--   On the PLC side this becomes (via <tt>makeKnown</tt>) either a call to
--   <tt>Error</tt> or a value of the PLC counterpart of type <tt>a</tt>.
data EvaluationResult a
EvaluationSuccess :: !a -> EvaluationResult a
EvaluationFailure :: EvaluationResult a

-- | Check whether an <a>EvaluationResult</a> is an
--   <a>EvaluationSuccess</a>.
isEvaluationSuccess :: EvaluationResult a -> Bool

-- | Check whether an <a>EvaluationResult</a> is an
--   <a>EvaluationFailure</a>.
isEvaluationFailure :: EvaluationResult a -> Bool
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (PlutusCore.Evaluation.Result.EvaluationResult a)
instance Data.Traversable.Traversable PlutusCore.Evaluation.Result.EvaluationResult
instance Data.Foldable.Foldable PlutusCore.Evaluation.Result.EvaluationResult
instance GHC.Base.Functor PlutusCore.Evaluation.Result.EvaluationResult
instance GHC.Generics.Generic (PlutusCore.Evaluation.Result.EvaluationResult a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (PlutusCore.Evaluation.Result.EvaluationResult a)
instance GHC.Show.Show a => GHC.Show.Show (PlutusCore.Evaluation.Result.EvaluationResult a)
instance PlutusCore.Evaluation.Result.AsEvaluationFailure (PlutusCore.Evaluation.Result.EvaluationResult a)
instance Control.Monad.Error.Class.MonadError () PlutusCore.Evaluation.Result.EvaluationResult
instance GHC.Base.Applicative PlutusCore.Evaluation.Result.EvaluationResult
instance GHC.Base.Monad PlutusCore.Evaluation.Result.EvaluationResult
instance GHC.Base.Alternative PlutusCore.Evaluation.Result.EvaluationResult
instance Control.Monad.Fail.MonadFail PlutusCore.Evaluation.Result.EvaluationResult
instance Text.PrettyBy.Internal.PrettyBy config a => Text.PrettyBy.Internal.PrettyBy config (PlutusCore.Evaluation.Result.EvaluationResult a)
instance PlutusCore.Pretty.Classic.PrettyClassic a => Prettyprinter.Internal.Pretty (PlutusCore.Evaluation.Result.EvaluationResult a)
instance PlutusCore.Evaluation.Result.AsEvaluationFailure ()


-- | The exceptions that an abstract machine can throw.
module PlutusCore.Evaluation.Error

-- | The type of errors that can occur during evaluation. There are two
--   kinds of errors:
--   
--   <ol>
--   <li>Structural ones -- these are errors that are indicative of the
--   _structure_ of the program being wrong. For example, a free variable
--   was encountered during evaluation, a non-function was applied to an
--   argument or <tt>tailList</tt> was applied to a non-list.</li>
--   <li>Operational ones -- these are errors that are indicative of the
--   _logic_ of the program being wrong. For example, <a>error</a> was
--   executed, <tt>tailList</tt> was applied to an empty list or evaluation
--   ran out of gas.</li>
--   </ol>
--   
--   On the chain both of these are just regular failures and we don't
--   distinguish between them there: if a script fails, it fails, it
--   doesn't matter what the reason was. However in the tests it does
--   matter why the failure occurred: a structural error may indicate that
--   the test was written incorrectly while an operational error may be
--   entirely expected.
--   
--   In other words, structural errors are "runtime type errors" and
--   operational errors are regular runtime errors. Which means that
--   evaluating an (erased) well-typed program should never produce a
--   structural error, only an operational one. This creates a sort of
--   "runtime type system" for UPLC and it would be great to stick to it
--   and enforce in tests etc, but we currently don't.
data EvaluationError structural operational
StructuralEvaluationError :: !structural -> EvaluationError structural operational
OperationalEvaluationError :: !operational -> EvaluationError structural operational
class AsEvaluationError r_a1wHB structural_a1wxv operational_a1wxw | r_a1wHB -> structural_a1wxv operational_a1wxw
_EvaluationError :: AsEvaluationError r_a1wHB structural_a1wxv operational_a1wxw => Prism' r_a1wHB (EvaluationError structural_a1wxv operational_a1wxw)
_StructuralEvaluationError :: AsEvaluationError r_a1wHB structural_a1wxv operational_a1wxw => Prism' r_a1wHB structural_a1wxv
_OperationalEvaluationError :: AsEvaluationError r_a1wHB structural_a1wxv operational_a1wxw => Prism' r_a1wHB operational_a1wxw
instance PlutusCore.Evaluation.Error.AsEvaluationError (PlutusCore.Evaluation.Error.EvaluationError structural operational) structural operational
instance PlutusCore.Evaluation.Result.AsEvaluationFailure operational => PlutusCore.Evaluation.Result.AsEvaluationFailure (PlutusCore.Evaluation.Error.EvaluationError structural operational)
instance Data.Bifunctor.Bifunctor PlutusCore.Evaluation.Error.EvaluationError
instance Data.Bifoldable.Bifoldable PlutusCore.Evaluation.Error.EvaluationError
instance Data.Bitraversable.Bitraversable PlutusCore.Evaluation.Error.EvaluationError
instance (Text.PrettyBy.Internal.HasPrettyDefaults config GHC.Types.~ 'GHC.Types.True, Text.PrettyBy.Internal.PrettyBy config structural, Prettyprinter.Internal.Pretty operational) => Text.PrettyBy.Internal.PrettyBy config (PlutusCore.Evaluation.Error.EvaluationError structural operational)
instance (Prettyprinter.Internal.Pretty structural, Prettyprinter.Internal.Pretty operational) => Prettyprinter.Internal.Pretty (PlutusCore.Evaluation.Error.EvaluationError structural operational)
instance (Control.DeepSeq.NFData structural, Control.DeepSeq.NFData operational) => Control.DeepSeq.NFData (PlutusCore.Evaluation.Error.EvaluationError structural operational)
instance GHC.Generics.Generic (PlutusCore.Evaluation.Error.EvaluationError structural operational)
instance GHC.Base.Functor (PlutusCore.Evaluation.Error.EvaluationError structural)
instance (GHC.Classes.Eq structural, GHC.Classes.Eq operational) => GHC.Classes.Eq (PlutusCore.Evaluation.Error.EvaluationError structural operational)
instance (GHC.Show.Show structural, GHC.Show.Show operational) => GHC.Show.Show (PlutusCore.Evaluation.Error.EvaluationError structural operational)

module PlutusCore.Crypto.Secp256k1

-- | Verify an ECDSA signature made using the SECP256k1 curve.
--   
--   <h1>Note</h1>
--   
--   There are additional well-formation requirements for the arguments
--   beyond their length:
--   
--   <ul>
--   <li>The first byte of the public key must correspond to the sign of
--   the <i>y</i> coordinate: this is <tt>0x02</tt> if <i>y</i> is even,
--   and <tt>0x03</tt> otherwise.</li>
--   <li>The remaining bytes of the public key must correspond to the
--   <i>x</i> coordinate, as a big-endian integer.</li>
--   <li>The first 32 bytes of the signature must correspond to the
--   big-endian integer representation of _r_.</li>
--   <li>The last 32 bytes of the signature must correspond to the
--   big-endian integer representation of _s_.</li>
--   </ul>
--   
--   While this primitive <i>accepts</i> a hash, any caller should only
--   pass it hashes that they computed themselves: specifically, they
--   should receive the <i>message</i> from a sender and hash it, rather
--   than receiving the <i>hash</i> from said sender. Failure to do so can
--   be <a>dangerous</a>. Other than length, we make no requirements of
--   what hash gets used.
verifyEcdsaSecp256k1Signature :: ByteString -> ByteString -> ByteString -> BuiltinResult Bool

-- | Verify a Schnorr signature made using the SECP256k1 curve.
--   
--   <h1>Note</h1>
--   
--   There are additional well-formation requirements for the arguments
--   beyond their length. Throughout, we refer to co-ordinates of the point
--   <tt>R</tt>.
--   
--   <ul>
--   <li>The bytes of the public key must correspond to the <i>x</i>
--   coordinate, as a big-endian integer, as specified in BIP-340.</li>
--   <li>The first 32 bytes of the signature must correspond to the
--   <i>x</i> coordinate, as a big-endian integer, as specified in
--   BIP-340.</li>
--   <li>The last 32 bytes of the signature must correspond to the bytes of
--   <i>s</i>, as a big-endian integer, as specified in BIP-340.</li>
--   </ul>
--   
--   <h1>See also</h1>
--   
--   <ul>
--   <li><a>BIP-340</a></li>
--   </ul>
verifySchnorrSecp256k1Signature :: ByteString -> ByteString -> ByteString -> BuiltinResult Bool

module PlutusCore.Evaluation.ErrorWithCause

-- | An error and (optionally) what caused it.
data ErrorWithCause err cause
ErrorWithCause :: !err -> !Maybe cause -> ErrorWithCause err cause
[_ewcError] :: ErrorWithCause err cause -> !err
[_ewcCause] :: ErrorWithCause err cause -> !Maybe cause

-- | <a>Prismatically</a> throw an error and its (optional) cause.
throwingWithCause :: forall exc e t term m x. (exc ~ ErrorWithCause e term, MonadError exc m) => AReview e t -> t -> Maybe term -> m x

-- | <a>Prismatically</a> throw a contentless error and its (optional)
--   cause. <a>throwingWithCause_</a> is to <a>throwingWithCause</a> as
--   <a>throwing_</a> is to <a>throwing</a>.
throwingWithCause_ :: forall exc e term m x. (exc ~ ErrorWithCause e term, MonadError exc m) => AReview e () -> Maybe term -> m x

-- | Attach a <tt>cause</tt> to a <a>BuiltinError</a> and throw that. Note
--   that an evaluator might require the cause to be computed lazily for
--   best performance on the happy path, hence this function must not force
--   its first argument. TODO: wrap <tt>cause</tt> in <a>Lazy</a> once we
--   have it.
throwBuiltinErrorWithCause :: (MonadError (ErrorWithCause err cause) m, AsUnliftingEvaluationError err, AsEvaluationFailure err) => cause -> BuiltinError -> m void
instance (Control.DeepSeq.NFData err, Control.DeepSeq.NFData cause) => Control.DeepSeq.NFData (PlutusCore.Evaluation.ErrorWithCause.ErrorWithCause err cause)
instance GHC.Generics.Generic (PlutusCore.Evaluation.ErrorWithCause.ErrorWithCause err cause)
instance Data.Traversable.Traversable (PlutusCore.Evaluation.ErrorWithCause.ErrorWithCause err)
instance Data.Foldable.Foldable (PlutusCore.Evaluation.ErrorWithCause.ErrorWithCause err)
instance GHC.Base.Functor (PlutusCore.Evaluation.ErrorWithCause.ErrorWithCause err)
instance (GHC.Classes.Eq err, GHC.Classes.Eq cause) => GHC.Classes.Eq (PlutusCore.Evaluation.ErrorWithCause.ErrorWithCause err cause)
instance (PlutusCore.Pretty.Plc.PrettyPlc cause, PlutusCore.Pretty.Plc.PrettyPlc err, Data.Typeable.Internal.Typeable cause, Data.Typeable.Internal.Typeable err) => GHC.Exception.Type.Exception (PlutusCore.Evaluation.ErrorWithCause.ErrorWithCause err cause)
instance Data.Bifunctor.Bifunctor PlutusCore.Evaluation.ErrorWithCause.ErrorWithCause
instance PlutusCore.Evaluation.Result.AsEvaluationFailure err => PlutusCore.Evaluation.Result.AsEvaluationFailure (PlutusCore.Evaluation.ErrorWithCause.ErrorWithCause err cause)
instance (Prettyprinter.Internal.Pretty err, Prettyprinter.Internal.Pretty cause) => Prettyprinter.Internal.Pretty (PlutusCore.Evaluation.ErrorWithCause.ErrorWithCause err cause)
instance (Text.PrettyBy.Internal.PrettyBy config cause, Text.PrettyBy.Internal.PrettyBy config err) => Text.PrettyBy.Internal.PrettyBy config (PlutusCore.Evaluation.ErrorWithCause.ErrorWithCause err cause)
instance (PlutusCore.Pretty.Plc.PrettyPlc cause, PlutusCore.Pretty.Plc.PrettyPlc err) => GHC.Show.Show (PlutusCore.Evaluation.ErrorWithCause.ErrorWithCause err cause)


-- | The exceptions that an abstract machine can throw.
module PlutusCore.Evaluation.Machine.Exception

-- | The error message part of an <a>UnliftingEvaluationError</a>.
newtype UnliftingError
MkUnliftingError :: Text -> UnliftingError
[unUnliftingError] :: UnliftingError -> Text
class AsUnliftingError r_a1ymj
_UnliftingError :: AsUnliftingError r_a1ymj => Prism' r_a1ymj UnliftingError
_MkUnliftingError :: AsUnliftingError r_a1ymj => Prism' r_a1ymj Text

-- | The type of errors that <tt>readKnown</tt> and <tt>makeKnown</tt> can
--   return.
data BuiltinError
BuiltinUnliftingEvaluationError :: UnliftingEvaluationError -> BuiltinError
BuiltinEvaluationFailure :: BuiltinError

-- | Errors which can occur during a run of an abstract machine.
data MachineError fun

-- | An attempt to reduce a not immediately reducible type instantiation.
NonPolymorphicInstantiationMachineError :: MachineError fun

-- | An attempt to unwrap a not wrapped term.
NonWrapUnwrappedMachineError :: MachineError fun

-- | An attempt to reduce a not immediately reducible application.
NonFunctionalApplicationMachineError :: MachineError fun

-- | An attempt to evaluate an open term.
OpenTermEvaluatedMachineError :: MachineError fun

-- | An attempt to compute a constant application resulted in
--   <a>UnliftingError</a>.
UnliftingMachineError :: UnliftingError -> MachineError fun

-- | A builtin expected a term argument, but something else was received.
BuiltinTermArgumentExpectedMachineError :: MachineError fun

-- | A builtin received a term argument when something else was expected
UnexpectedBuiltinTermArgumentMachineError :: MachineError fun
NonConstrScrutinized :: MachineError fun
MissingCaseBranch :: Word64 -> MachineError fun
class AsMachineError r_a1Gkd fun_a1G3E | r_a1Gkd -> fun_a1G3E
_MachineError :: AsMachineError r_a1Gkd fun_a1G3E => Prism' r_a1Gkd (MachineError fun_a1G3E)
_NonPolymorphicInstantiationMachineError :: AsMachineError r_a1Gkd fun_a1G3E => Prism' r_a1Gkd ()
_NonWrapUnwrappedMachineError :: AsMachineError r_a1Gkd fun_a1G3E => Prism' r_a1Gkd ()
_NonFunctionalApplicationMachineError :: AsMachineError r_a1Gkd fun_a1G3E => Prism' r_a1Gkd ()
_OpenTermEvaluatedMachineError :: AsMachineError r_a1Gkd fun_a1G3E => Prism' r_a1Gkd ()
_UnliftingMachineError :: AsMachineError r_a1Gkd fun_a1G3E => Prism' r_a1Gkd UnliftingError
_BuiltinTermArgumentExpectedMachineError :: AsMachineError r_a1Gkd fun_a1G3E => Prism' r_a1Gkd ()
_UnexpectedBuiltinTermArgumentMachineError :: AsMachineError r_a1Gkd fun_a1G3E => Prism' r_a1Gkd ()
_NonConstrScrutinized :: AsMachineError r_a1Gkd fun_a1G3E => Prism' r_a1Gkd ()
_MissingCaseBranch :: AsMachineError r_a1Gkd fun_a1G3E => Prism' r_a1Gkd Word64

-- | The type of errors that can occur during evaluation. There are two
--   kinds of errors:
--   
--   <ol>
--   <li>Structural ones -- these are errors that are indicative of the
--   _structure_ of the program being wrong. For example, a free variable
--   was encountered during evaluation, a non-function was applied to an
--   argument or <tt>tailList</tt> was applied to a non-list.</li>
--   <li>Operational ones -- these are errors that are indicative of the
--   _logic_ of the program being wrong. For example, <a>error</a> was
--   executed, <tt>tailList</tt> was applied to an empty list or evaluation
--   ran out of gas.</li>
--   </ol>
--   
--   On the chain both of these are just regular failures and we don't
--   distinguish between them there: if a script fails, it fails, it
--   doesn't matter what the reason was. However in the tests it does
--   matter why the failure occurred: a structural error may indicate that
--   the test was written incorrectly while an operational error may be
--   entirely expected.
--   
--   In other words, structural errors are "runtime type errors" and
--   operational errors are regular runtime errors. Which means that
--   evaluating an (erased) well-typed program should never produce a
--   structural error, only an operational one. This creates a sort of
--   "runtime type system" for UPLC and it would be great to stick to it
--   and enforce in tests etc, but we currently don't.
data EvaluationError structural operational
StructuralEvaluationError :: !structural -> EvaluationError structural operational
OperationalEvaluationError :: !operational -> EvaluationError structural operational
class AsEvaluationError r_a1wHB structural_a1wxv operational_a1wxw | r_a1wHB -> structural_a1wxv operational_a1wxw
_EvaluationError :: AsEvaluationError r_a1wHB structural_a1wxv operational_a1wxw => Prism' r_a1wHB (EvaluationError structural_a1wxv operational_a1wxw)
_StructuralEvaluationError :: AsEvaluationError r_a1wHB structural_a1wxv operational_a1wxw => Prism' r_a1wHB structural_a1wxv
_OperationalEvaluationError :: AsEvaluationError r_a1wHB structural_a1wxv operational_a1wxw => Prism' r_a1wHB operational_a1wxw

-- | An error and (optionally) what caused it.
data ErrorWithCause err cause
ErrorWithCause :: !err -> !Maybe cause -> ErrorWithCause err cause
[_ewcError] :: ErrorWithCause err cause -> !err
[_ewcCause] :: ErrorWithCause err cause -> !Maybe cause
type EvaluationException structural operational = ErrorWithCause (EvaluationError structural operational)
throwNotAConstant :: MonadError BuiltinError m => m void
throwing :: MonadError e m => AReview e t -> t -> m x
throwing_ :: MonadError e m => AReview e () -> m x

-- | <a>Prismatically</a> throw an error and its (optional) cause.
throwingWithCause :: forall exc e t term m x. (exc ~ ErrorWithCause e term, MonadError exc m) => AReview e t -> t -> Maybe term -> m x

-- | Preserve the contents of an <a>StructuralEvaluationError</a> as a
--   <a>Left</a> and turn an <a>OperationalEvaluationError</a> into a
--   <tt>Right EvaluationFailure</tt> (thus erasing the content of the
--   error in the latter case).
splitStructuralOperational :: Either (EvaluationException structural operational term) a -> Either (ErrorWithCause structural term) (EvaluationResult a)

-- | Throw on a <a>StructuralEvaluationError</a> and turn an
--   <a>OperationalEvaluationError</a> into an <a>EvaluationFailure</a>
--   (thus erasing the content of the error in the latter case).
unsafeSplitStructuralOperational :: (PrettyPlc structural, PrettyPlc term, Typeable structural, Typeable term) => Either (EvaluationException structural operational term) a -> EvaluationResult a
instance PlutusCore.Evaluation.Machine.Exception.AsMachineError (PlutusCore.Evaluation.Machine.Exception.MachineError fun) fun
instance (structural GHC.Types.~ PlutusCore.Evaluation.Machine.Exception.MachineError fun) => PlutusCore.Evaluation.Machine.Exception.AsMachineError (PlutusCore.Evaluation.Error.EvaluationError structural operational) fun
instance PlutusCore.Builtin.Result.AsUnliftingError (PlutusCore.Evaluation.Machine.Exception.MachineError fun)
instance (Text.PrettyBy.Internal.HasPrettyDefaults config GHC.Types.~ 'GHC.Types.True, Prettyprinter.Internal.Pretty fun) => Text.PrettyBy.Internal.PrettyBy config (PlutusCore.Evaluation.Machine.Exception.MachineError fun)
instance Control.DeepSeq.NFData (PlutusCore.Evaluation.Machine.Exception.MachineError fun)
instance GHC.Generics.Generic (PlutusCore.Evaluation.Machine.Exception.MachineError fun)
instance GHC.Base.Functor PlutusCore.Evaluation.Machine.Exception.MachineError
instance GHC.Classes.Eq (PlutusCore.Evaluation.Machine.Exception.MachineError fun)
instance GHC.Show.Show (PlutusCore.Evaluation.Machine.Exception.MachineError fun)


-- | Support for using de Bruijn indices for term and type names.
module PlutusCore.DeBruijn.Internal

-- | A relative index used for de Bruijn identifiers.
--   
--   FIXME: downside of using newtype+Num instead of type-synonym is that
--   `-Woverflowed-literals` does not work, e.g.: `DeBruijn (-1)` has no
--   warning. To trigger the warning you have to bypass the Num and write
--   `DeBruijn (Index -1)`. This can be revisited when we implement
--   PLT-1053.
newtype Index
Index :: Word64 -> Index
class HasIndex a
index :: HasIndex a => Lens' a Index

-- | A term name as a de Bruijn index, without the name string.
newtype DeBruijn
DeBruijn :: Index -> DeBruijn
[dbnIndex] :: DeBruijn -> Index

-- | A term name as a de Bruijn index.
data NamedDeBruijn
NamedDeBruijn :: !Text -> !Index -> NamedDeBruijn
[ndbnString] :: NamedDeBruijn -> !Text
[ndbnIndex] :: NamedDeBruijn -> !Index

-- | A wrapper around <a>NamedDeBruijn</a> that *must* hold the invariant
--   of name=<a>fakeName</a>.
--   
--   We do not export the <a>FakeNamedDeBruijn</a> constructor: the
--   projection `FND-&gt;ND` is safe but injection `ND-&gt;FND` is unsafe,
--   thus they are not isomorphic.
--   
--   See Note [Why newtype FakeNamedDeBruijn]
newtype FakeNamedDeBruijn
FakeNamedDeBruijn :: NamedDeBruijn -> FakeNamedDeBruijn
[unFakeNamedDeBruijn] :: FakeNamedDeBruijn -> NamedDeBruijn

-- | A type name as a de Bruijn index, without the name string.
newtype TyDeBruijn
TyDeBruijn :: DeBruijn -> TyDeBruijn

-- | A type name as a de Bruijn index.
newtype NamedTyDeBruijn
NamedTyDeBruijn :: NamedDeBruijn -> NamedTyDeBruijn

-- | We cannot do a correct translation to or from de Bruijn indices if the
--   program is not well-scoped. So we throw an error in such a case.
data FreeVariableError
FreeUnique :: !Unique -> FreeVariableError
FreeIndex :: !Index -> FreeVariableError
class AsFreeVariableError r_a1KDI
_FreeVariableError :: AsFreeVariableError r_a1KDI => Prism' r_a1KDI FreeVariableError
_FreeUnique :: AsFreeVariableError r_a1KDI => Prism' r_a1KDI Unique
_FreeIndex :: AsFreeVariableError r_a1KDI => Prism' r_a1KDI Index

-- | An absolute level in the program.
newtype Level
Level :: Integer -> Level

-- | During visiting the AST we hold a reader "state" of current level and
--   a current scoping (levelMapping). Invariant-A: the current level is
--   positive and greater than all levels in the levelMapping. Invariant-B:
--   only positive levels are stored in the levelMapping.
data LevelInfo
LevelInfo :: Level -> Bimap Unique Level -> LevelInfo
[currentLevel] :: LevelInfo -> Level
[levelMapping] :: LevelInfo -> Bimap Unique Level

-- | Declare a name with a unique, recording the mapping to a <a>Level</a>.
declareUnique :: (MonadReader LevelInfo m, HasUnique name unique) => name -> m a -> m a

-- | Declares a new binder by assigning a fresh unique to the *current
--   level*. Maintains invariant-B of <a>LevelInfo</a> (that only positive
--   levels are stored), since current level is always positive
--   (invariant-A). See Note [DeBruijn indices of Binders]
declareBinder :: (MonadReader LevelInfo m, MonadQuote m) => m a -> m a

-- | Enter a scope, incrementing the current <a>Level</a> by one Maintains
--   invariant-A (that the current level is positive).
withScope :: MonadReader LevelInfo m => m a -> m a

-- | Get the <a>Index</a> corresponding to a given <a>Unique</a>. Uses
--   supplied handler for free names (uniques).
getIndex :: MonadReader LevelInfo m => Unique -> (Unique -> m Index) -> m Index

-- | Get the <a>Unique</a> corresponding to a given <a>Index</a>. Uses
--   supplied handler for free debruijn indices.
getUnique :: MonadReader LevelInfo m => Index -> (Index -> m Unique) -> m Unique
unNameDeBruijn :: NamedDeBruijn -> DeBruijn
unNameTyDeBruijn :: NamedTyDeBruijn -> TyDeBruijn
fakeNameDeBruijn :: DeBruijn -> NamedDeBruijn
fakeTyNameDeBruijn :: TyDeBruijn -> NamedTyDeBruijn
nameToDeBruijn :: MonadReader LevelInfo m => (Unique -> m Index) -> Name -> m NamedDeBruijn
tyNameToDeBruijn :: MonadReader LevelInfo m => (Unique -> m Index) -> TyName -> m NamedTyDeBruijn
deBruijnToName :: MonadReader LevelInfo m => (Index -> m Unique) -> NamedDeBruijn -> m Name
deBruijnToTyName :: MonadReader LevelInfo m => (Index -> m Unique) -> NamedTyDeBruijn -> m TyName

-- | The default handler of throwing an error upon encountering a free
--   debruijn index.
freeIndexThrow :: (AsFreeVariableError e, MonadError e m) => Index -> m Unique

-- | A different implementation of a handler, where "free" debruijn indices
--   do not throw an error but are instead gracefully converted to fresh
--   uniques. These generated uniques remain free; i.e. if the original
--   term was open, it will remain open after applying this handler. These
--   generated free uniques are consistent across the open term (by using a
--   state cache).
freeIndexAsConsistentLevel :: (MonadReader LevelInfo m, MonadState (Map Level Unique) m, MonadQuote m) => Index -> m Unique

-- | The default handler of throwing an error upon encountering a free name
--   (unique).
freeUniqueThrow :: (AsFreeVariableError e, MonadError e m) => Unique -> m Index
runDeBruijnT :: ReaderT LevelInfo m a -> m a

-- | The LamAbs index (for debruijn indices) and the starting level of
--   DeBruijn monad
deBruijnInitIndex :: Index
toFake :: DeBruijn -> FakeNamedDeBruijn
fromFake :: FakeNamedDeBruijn -> DeBruijn
instance PlutusCore.DeBruijn.Internal.AsFreeVariableError PlutusCore.DeBruijn.Internal.FreeVariableError
instance GHC.Read.Read PlutusCore.DeBruijn.Internal.Index
instance Control.DeepSeq.NFData PlutusCore.DeBruijn.Internal.Index
instance Prettyprinter.Internal.Pretty PlutusCore.DeBruijn.Internal.Index
instance Data.Hashable.Class.Hashable PlutusCore.DeBruijn.Internal.Index
instance GHC.Classes.Ord PlutusCore.DeBruijn.Internal.Index
instance GHC.Classes.Eq PlutusCore.DeBruijn.Internal.Index
instance GHC.Real.Integral PlutusCore.DeBruijn.Internal.Index
instance GHC.Real.Real PlutusCore.DeBruijn.Internal.Index
instance GHC.Enum.Enum PlutusCore.DeBruijn.Internal.Index
instance GHC.Num.Num PlutusCore.DeBruijn.Internal.Index
instance GHC.Show.Show PlutusCore.DeBruijn.Internal.Index
instance GHC.Generics.Generic PlutusCore.DeBruijn.Internal.Index
instance Control.DeepSeq.NFData PlutusCore.DeBruijn.Internal.NamedDeBruijn
instance Data.Hashable.Class.Hashable PlutusCore.DeBruijn.Internal.NamedDeBruijn
instance GHC.Read.Read PlutusCore.DeBruijn.Internal.NamedDeBruijn
instance GHC.Generics.Generic PlutusCore.DeBruijn.Internal.NamedDeBruijn
instance GHC.Show.Show PlutusCore.DeBruijn.Internal.NamedDeBruijn
instance PlutusCore.Pretty.ConfigName.HasPrettyConfigName config => Text.PrettyBy.Internal.PrettyBy config PlutusCore.DeBruijn.Internal.FakeNamedDeBruijn
instance Control.DeepSeq.NFData PlutusCore.DeBruijn.Internal.FakeNamedDeBruijn
instance Data.Hashable.Class.Hashable PlutusCore.DeBruijn.Internal.FakeNamedDeBruijn
instance GHC.Classes.Eq PlutusCore.DeBruijn.Internal.FakeNamedDeBruijn
instance GHC.Show.Show PlutusCore.DeBruijn.Internal.FakeNamedDeBruijn
instance Control.DeepSeq.NFData PlutusCore.DeBruijn.Internal.DeBruijn
instance Data.Hashable.Class.Hashable PlutusCore.DeBruijn.Internal.DeBruijn
instance GHC.Classes.Eq PlutusCore.DeBruijn.Internal.DeBruijn
instance GHC.Generics.Generic PlutusCore.DeBruijn.Internal.DeBruijn
instance GHC.Show.Show PlutusCore.DeBruijn.Internal.DeBruijn
instance GHC.Classes.Eq PlutusCore.DeBruijn.Internal.NamedTyDeBruijn
instance Control.DeepSeq.NFData PlutusCore.DeBruijn.Internal.NamedTyDeBruijn
instance PlutusCore.Pretty.ConfigName.HasPrettyConfigName config => Text.PrettyBy.Internal.PrettyBy config PlutusCore.DeBruijn.Internal.NamedTyDeBruijn
instance GHC.Generics.Generic PlutusCore.DeBruijn.Internal.NamedTyDeBruijn
instance GHC.Show.Show PlutusCore.DeBruijn.Internal.NamedTyDeBruijn
instance GHC.Classes.Eq PlutusCore.DeBruijn.Internal.TyDeBruijn
instance PlutusCore.Pretty.ConfigName.HasPrettyConfigName config => Text.PrettyBy.Internal.PrettyBy config PlutusCore.DeBruijn.Internal.TyDeBruijn
instance Control.DeepSeq.NFData PlutusCore.DeBruijn.Internal.TyDeBruijn
instance GHC.Generics.Generic PlutusCore.DeBruijn.Internal.TyDeBruijn
instance GHC.Show.Show PlutusCore.DeBruijn.Internal.TyDeBruijn
instance GHC.Real.Integral PlutusCore.DeBruijn.Internal.Level
instance GHC.Enum.Enum PlutusCore.DeBruijn.Internal.Level
instance GHC.Real.Real PlutusCore.DeBruijn.Internal.Level
instance GHC.Num.Num PlutusCore.DeBruijn.Internal.Level
instance GHC.Classes.Ord PlutusCore.DeBruijn.Internal.Level
instance GHC.Classes.Eq PlutusCore.DeBruijn.Internal.Level
instance Control.DeepSeq.NFData PlutusCore.DeBruijn.Internal.FreeVariableError
instance GHC.Exception.Type.Exception PlutusCore.DeBruijn.Internal.FreeVariableError
instance GHC.Generics.Generic PlutusCore.DeBruijn.Internal.FreeVariableError
instance GHC.Classes.Ord PlutusCore.DeBruijn.Internal.FreeVariableError
instance GHC.Classes.Eq PlutusCore.DeBruijn.Internal.FreeVariableError
instance GHC.Show.Show PlutusCore.DeBruijn.Internal.FreeVariableError
instance Prettyprinter.Internal.Pretty PlutusCore.DeBruijn.Internal.FreeVariableError
instance PlutusCore.DeBruijn.Internal.HasIndex PlutusCore.DeBruijn.Internal.NamedDeBruijn
instance PlutusCore.DeBruijn.Internal.HasIndex PlutusCore.DeBruijn.Internal.DeBruijn
instance PlutusCore.DeBruijn.Internal.HasIndex PlutusCore.DeBruijn.Internal.NamedTyDeBruijn
instance PlutusCore.DeBruijn.Internal.HasIndex PlutusCore.DeBruijn.Internal.TyDeBruijn
instance Control.Lens.Wrapped.Wrapped PlutusCore.DeBruijn.Internal.TyDeBruijn
instance Control.Lens.Wrapped.Wrapped PlutusCore.DeBruijn.Internal.NamedTyDeBruijn
instance PlutusCore.Pretty.ConfigName.HasPrettyConfigName config => Text.PrettyBy.Internal.PrettyBy config PlutusCore.DeBruijn.Internal.DeBruijn
instance GHC.Classes.Eq PlutusCore.DeBruijn.Internal.NamedDeBruijn
instance PlutusCore.Pretty.ConfigName.HasPrettyConfigName config => Text.PrettyBy.Internal.PrettyBy config PlutusCore.DeBruijn.Internal.NamedDeBruijn

module PlutusCore.Crypto.BLS12_381.G2

-- | See Note [Wrapping the BLS12-381 types in Plutus Core].
newtype Element
Element :: Point2 -> Element
[unElement] :: Element -> Point2

-- | Add two G2 group elements
add :: Element -> Element -> Element

-- | Negate a G2 group element
neg :: Element -> Element
scalarMul :: Integer -> Element -> Element
hashToGroup :: ByteString -> ByteString -> Either BLS12_381_Error Element

-- | Compress a G2 element to a bytestring. This serialises a curve point
--   to its x coordinate only, using an extra bit to determine which of two
--   possible y coordinates the point has. The compressed bytestring is 96
--   bytes long. See
--   <a>https://github.com/supranational/blst#serialization-format</a>
compress :: Element -> ByteString

-- | Uncompress a bytestring to get a G2 point. This will fail if any of
--   the following are true: * The bytestring is not exactly 96 bytes long
--   * The most significant three bits are used incorrectly * The
--   bytestring encodes a field element which is not the x coordinate of a
--   point on the E2 curve * The bytestring does represent a point on the
--   E2 curve, but the point is not in the G2 subgroup
uncompress :: ByteString -> Either BLSTError Element

-- | The zero element of G2. This cannot be flat-serialised and is provided
--   only for off-chain testing.
offchain_zero :: Element

-- | The zero element of G2 compressed into a bytestring. This is provided
--   for convenience in PlutusTx and is not exported as a builtin.
compressed_zero :: ByteString

-- | The standard generator of G2 compressed into a bytestring. This is
--   provided for convenience in PlutusTx and is not exported as a builtin.
compressed_generator :: ByteString

-- | Memory usage of a G2 point (288 bytes)
memSizeBytes :: Int

-- | Compressed size of a G2 point (96 bytes)
compressedSizeBytes :: Int
instance GHC.Classes.Eq PlutusCore.Crypto.BLS12_381.G2.Element
instance GHC.Show.Show PlutusCore.Crypto.BLS12_381.G2.Element
instance Prettyprinter.Internal.Pretty PlutusCore.Crypto.BLS12_381.G2.Element
instance Text.PrettyBy.Internal.PrettyBy PlutusCore.Pretty.PrettyConst.ConstConfig PlutusCore.Crypto.BLS12_381.G2.Element
instance Flat.Class.Flat PlutusCore.Crypto.BLS12_381.G2.Element
instance Control.DeepSeq.NFData PlutusCore.Crypto.BLS12_381.G2.Element
instance Data.Hashable.Class.Hashable PlutusCore.Crypto.BLS12_381.G2.Element

module PlutusCore.Crypto.BLS12_381.G1
newtype Element
Element :: Point1 -> Element
[unElement] :: Element -> Point1

-- | Add two G1 group elements
add :: Element -> Element -> Element

-- | Negate a G1 group element
neg :: Element -> Element

-- | Multiplication of group elements by scalars. In the blst library the
--   arguments are the other way round, but scalars acting on the left is
--   more consistent with standard mathematical practice.
scalarMul :: Integer -> Element -> Element

-- | Take an arbitrary bytestring and a Domain Separation Tag (DST) and
--   hash them to a get point in G1.
hashToGroup :: ByteString -> ByteString -> Either BLS12_381_Error Element

-- | Compress a G1 element to a bytestring. This serialises a curve point
--   to its x coordinate only. The compressed bytestring is 48 bytes long,
--   with three spare bits used to convey extra information about the
--   point, including determining which of two possible y coordinates the
--   point has and whether the point is the point at infinity. See
--   <a>https://github.com/supranational/blst#serialization-format</a>
compress :: Element -> ByteString

-- | Uncompress a bytestring to get a G1 point. This will fail if any of
--   the following are true. * The bytestring is not exactly 48 bytes long.
--   * The most significant three bits are used incorrectly. * The
--   bytestring encodes a field element which is not the x coordinate of a
--   point on the E1 curve. * The bytestring does represent a point on the
--   E1 curve, but the point is not in the G1 subgroup.
uncompress :: ByteString -> Either BLSTError Element

-- | The zero element of G1. This cannot be flat-serialised and is provided
--   only for off-chain testing.
offchain_zero :: Element

-- | The zero element of G1 compressed into a bytestring. This is provided
--   for convenience in PlutusTx and is not exported as a builtin.
compressed_zero :: ByteString

-- | The standard generator of G1 compressed into a bytestring. This is
--   provided for convenience in PlutusTx and is not exported as a builtin.
compressed_generator :: ByteString

-- | Memory usage of a G1 point (144 bytes)
memSizeBytes :: Int

-- | Compressed size of a G1 point (48 bytes)
compressedSizeBytes :: Int
instance GHC.Classes.Eq PlutusCore.Crypto.BLS12_381.G1.Element
instance GHC.Show.Show PlutusCore.Crypto.BLS12_381.G1.Element
instance Prettyprinter.Internal.Pretty PlutusCore.Crypto.BLS12_381.G1.Element
instance Text.PrettyBy.Internal.PrettyBy PlutusCore.Pretty.PrettyConst.ConstConfig PlutusCore.Crypto.BLS12_381.G1.Element
instance Flat.Class.Flat PlutusCore.Crypto.BLS12_381.G1.Element
instance Control.DeepSeq.NFData PlutusCore.Crypto.BLS12_381.G1.Element
instance Data.Hashable.Class.Hashable PlutusCore.Crypto.BLS12_381.G1.Element

module PlutusCore.Crypto.BLS12_381.Pairing

-- | This type represents the result of computing a pairing using the
--   Miller loop. Values of this type are ephemeral, only created during
--   script execution. We do not provide any means of serialising,
--   deserialising, printing, or parsing MlResult values.
newtype MlResult
MlResult :: PT -> MlResult
[unMlResult] :: MlResult -> PT
millerLoop :: Element -> Element -> MlResult
mulMlResult :: MlResult -> MlResult -> MlResult
finalVerify :: MlResult -> MlResult -> Bool

-- | Memory usage of an MlResult point (576 bytes)
mlResultMemSizeBytes :: Int

-- | For some of the tests we need a small element of the MlResult type. We
--   can get the identity element by pairing the zero elements of G1 and
--   G2.
identityMlResult :: MlResult
instance GHC.Classes.Eq PlutusCore.Crypto.BLS12_381.Pairing.MlResult
instance GHC.Show.Show PlutusCore.Crypto.BLS12_381.Pairing.MlResult
instance Prettyprinter.Internal.Pretty PlutusCore.Crypto.BLS12_381.Pairing.MlResult
instance Text.PrettyBy.Internal.PrettyBy PlutusCore.Pretty.PrettyConst.ConstConfig PlutusCore.Crypto.BLS12_381.Pairing.MlResult
instance Flat.Class.Flat PlutusCore.Crypto.BLS12_381.Pairing.MlResult
instance Control.DeepSeq.NFData PlutusCore.Crypto.BLS12_381.Pairing.MlResult
instance Data.Hashable.Class.Hashable PlutusCore.Crypto.BLS12_381.Pairing.MlResult

module PlutusCore.Evaluation.Machine.ExMemoryUsage

-- | A lazy tree of costs. Convenient for calculating the costs of values
--   of built-in types, because they may have arbitrary branching (in
--   particular a <a>Data</a> object can contain a list of <a>Data</a>
--   objects inside of it).
--   
--   <a>CostRose</a> gets collapsed to a lazy linear structure down the
--   pipeline, so that we can stream the costs to the outside where, say,
--   the CEK machine picks them up one by one and handles somehow (in
--   particular, subtracts from the remaining budget).
data CostRose
CostRose :: {-# UNPACK #-} !CostingInteger -> ![CostRose] -> CostRose

-- | Create a <a>CostRose</a> containing a single cost.
singletonRose :: CostingInteger -> CostRose
class ExMemoryUsage a
memoryUsage :: ExMemoryUsage a => a -> CostRose

-- | Collapse a <a>CostRose</a> to a lazy linear stream of costs.
--   Retrieving the next element takes O(1) time in the worst case
--   regardless of the recursion pattern of the given <a>CostRose</a>.
flattenCostRose :: CostRose -> CostStream

-- | When invoking a built-in function, a value of type
--   <a>NumBytesCostedAsNumWords</a> can be used transparently as a
--   built-in Integer but with a different size measure: see Note [Integral
--   types as Integer]. This is required by the
--   <tt>integerToByteString</tt> builtin, which takes an argument
--   <tt>w</tt> specifying the width (in bytes) of the output bytestring
--   (zero-padded to the desired size). The memory consumed by the function
--   is given by <tt>w</tt>, *not* the size of <tt>w</tt>. The
--   <a>NumBytesCostedAsNumWords</a> type wraps an Int <tt>w</tt> in a
--   newtype whose <a>ExMemoryUsage</a> is equal to the number of
--   eight-byte words required to contain <tt>w</tt> bytes, allowing its
--   costing function to work properly. We also use this for
--   <tt>replicateByte</tt>. If this is used to wrap an argument in the
--   denotation of a builtin then it *MUST* also be used to wrap the same
--   argument in the relevant budgeting benchmark.
newtype NumBytesCostedAsNumWords
NumBytesCostedAsNumWords :: Integer -> NumBytesCostedAsNumWords
[unNumBytesCostedAsNumWords] :: NumBytesCostedAsNumWords -> Integer

-- | A wrapper for <a>Integer</a>s whose "memory usage" for costing
--   purposes is the absolute value of the <a>Integer</a>. This is used for
--   costing built-in functions such as <tt>shiftByteString</tt> and
--   <tt>rotateByteString</tt>, where the cost may depend on the actual
--   value of the shift argument, not its size. If this is used to wrap an
--   argument in the denotation of a builtin then it *MUST* also be used to
--   wrap the same argument in the relevant budgeting benchmark.
newtype IntegerCostedLiterally
IntegerCostedLiterally :: Integer -> IntegerCostedLiterally
[unIntegerCostedLiterally] :: IntegerCostedLiterally -> Integer

-- | A wrappper for lists whose "memory usage" for costing purposes is just
--   the length of the list, ignoring the sizes of the elements. If this is
--   used to wrap an argument in the denotation of a builtin then it *MUST*
--   also be used to wrap the same argument in the relevant budgeting
--   benchmark.
newtype ListCostedByLength a
ListCostedByLength :: [a] -> ListCostedByLength a
[unListCostedByLength] :: ListCostedByLength a -> [a]
instance GHC.Show.Show PlutusCore.Evaluation.Machine.ExMemoryUsage.CostRose
instance PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage (PlutusCore.Evaluation.Machine.ExMemoryUsage.ListCostedByLength a)
instance PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage PlutusCore.Evaluation.Machine.ExMemoryUsage.IntegerCostedLiterally
instance PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage PlutusCore.Evaluation.Machine.ExMemoryUsage.NumBytesCostedAsNumWords
instance (PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage a, PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage b) => PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage (a, b)
instance (Universe.Core.Closed uni, Universe.Core.Everywhere uni PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage) => PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage (Data.Some.Newtype.Some (Universe.Core.ValueOf uni))
instance PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage ()
instance PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage GHC.Num.Integer.Integer
instance PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage GHC.Num.Natural.Natural
instance PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage GHC.Word.Word8
instance PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage Data.ByteString.Internal.Type.ByteString
instance PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage Data.Text.Internal.Text
instance PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage GHC.Types.Int
instance PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage GHC.Types.Char
instance PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage GHC.Types.Bool
instance PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage a => PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage [a]
instance PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage PlutusCore.Data.Data
instance PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage PlutusCore.Crypto.BLS12_381.G1.Element
instance PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage PlutusCore.Crypto.BLS12_381.G2.Element
instance PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage PlutusCore.Crypto.BLS12_381.Pairing.MlResult

module PlutusCore.Evaluation.Machine.CostingFun.Core

-- | A type of costing functions parametric over a model type. In practice
--   the we have one model type `Model<a>N</a>Arguments` for every N, where
--   N is the arity of the builtin whose costs we want to model. Each model
--   type has a number of constructors defining different "shapes" of
--   N-parameter functions which calculate a cost given the sizes of the
--   builtin's arguments.
data CostingFun model
CostingFun :: model -> model -> CostingFun model
[costingFunCpu] :: CostingFun model -> model
[costingFunMemory] :: CostingFun model -> model

-- | In the initial stages of implementing a new builtin it is necessary to
--   provide a temporary costing function which is used until the builtin
--   has been properly costed: `see CostModelGeneration.md`. Each
--   `Model<a>N</a>Arguments` type defines an instance of this class where
--   <a>unimplementedCostingFun</a> is a constant costing function which
--   returns a very high cost for all inputs. This prevents new functions
--   from being used in situations where costs are important until a
--   sensible costing function has been implemented.
class UnimplementedCostingFun a
unimplementedCostingFun :: UnimplementedCostingFun a => b -> CostingFun a

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as an
--   intercept.
newtype Intercept
Intercept :: CostingInteger -> Intercept
[unIntercept] :: Intercept -> CostingInteger

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as a
--   slope.
newtype Slope
Slope :: CostingInteger -> Slope
[unSlope] :: Slope -> CostingInteger

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as the
--   degree 0 coefficient of a polynomial.
newtype Coefficient0
Coefficient0 :: CostingInteger -> Coefficient0
[unCoefficient0] :: Coefficient0 -> CostingInteger

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as the
--   degree 1 coefficient of a polynomial.
newtype Coefficient1
Coefficient1 :: CostingInteger -> Coefficient1
[unCoefficient1] :: Coefficient1 -> CostingInteger

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as the
--   degree 2 coefficient of a polynomial.
newtype Coefficient2
Coefficient2 :: CostingInteger -> Coefficient2
[unCoefficient2] :: Coefficient2 -> CostingInteger

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as the
--   degree (0,0) coefficient of a two-variable polynomial.
newtype Coefficient00
Coefficient00 :: CostingInteger -> Coefficient00
[unCoefficient00] :: Coefficient00 -> CostingInteger

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as the
--   degree (1,0) coefficient of a two-variable polynomial.
newtype Coefficient10
Coefficient10 :: CostingInteger -> Coefficient10
[unCoefficient10] :: Coefficient10 -> CostingInteger

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as the
--   degree (0,1) coefficient of a two-variable polynomial.
newtype Coefficient01
Coefficient01 :: CostingInteger -> Coefficient01
[unCoefficient01] :: Coefficient01 -> CostingInteger

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as the
--   degree (2,0) coefficient of a two-variable polynomial.
newtype Coefficient20
Coefficient20 :: CostingInteger -> Coefficient20
[unCoefficient20] :: Coefficient20 -> CostingInteger

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as the
--   degree (1,1) coefficient of a two-variable polynomial.
newtype Coefficient11
Coefficient11 :: CostingInteger -> Coefficient11
[unCoefficient11] :: Coefficient11 -> CostingInteger

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as the
--   degree (0,2) coefficient of a two-variable polynomial.
newtype Coefficient02
Coefficient02 :: CostingInteger -> Coefficient02
[unCoefficient02] :: Coefficient02 -> CostingInteger

-- | s * x + I
data OneVariableLinearFunction
OneVariableLinearFunction :: Intercept -> Slope -> OneVariableLinearFunction
[oneVariableLinearFunctionIntercept] :: OneVariableLinearFunction -> Intercept
[oneVariableLinearFunctionSlope] :: OneVariableLinearFunction -> Slope

-- | c0 + c1*x + c2*x^2
data OneVariableQuadraticFunction
OneVariableQuadraticFunction :: Coefficient0 -> Coefficient1 -> Coefficient2 -> OneVariableQuadraticFunction
[oneVariableQuadraticFunctionC0] :: OneVariableQuadraticFunction -> Coefficient0
[oneVariableQuadraticFunctionC1] :: OneVariableQuadraticFunction -> Coefficient1
[oneVariableQuadraticFunctionC2] :: OneVariableQuadraticFunction -> Coefficient2

-- | s1 * x + s2 * y + I
data TwoVariableLinearFunction
TwoVariableLinearFunction :: Intercept -> Slope -> Slope -> TwoVariableLinearFunction
[twoVariableLinearFunctionIntercept] :: TwoVariableLinearFunction -> Intercept
[twoVariableLinearFunctionSlope1] :: TwoVariableLinearFunction -> Slope
[twoVariableLinearFunctionSlope2] :: TwoVariableLinearFunction -> Slope

-- | c00 + c10*x + c01*y + c20*x^2 + c11*c*y + c02*y^2
data TwoVariableQuadraticFunction
TwoVariableQuadraticFunction :: CostingInteger -> Coefficient00 -> Coefficient10 -> Coefficient01 -> Coefficient20 -> Coefficient11 -> Coefficient02 -> TwoVariableQuadraticFunction
[twoVariableQuadraticFunctionMinimum] :: TwoVariableQuadraticFunction -> CostingInteger
[twoVariableQuadraticFunctionC00] :: TwoVariableQuadraticFunction -> Coefficient00
[twoVariableQuadraticFunctionC10] :: TwoVariableQuadraticFunction -> Coefficient10
[twoVariableQuadraticFunctionC01] :: TwoVariableQuadraticFunction -> Coefficient01
[twoVariableQuadraticFunctionC20] :: TwoVariableQuadraticFunction -> Coefficient20
[twoVariableQuadraticFunctionC11] :: TwoVariableQuadraticFunction -> Coefficient11
[twoVariableQuadraticFunctionC02] :: TwoVariableQuadraticFunction -> Coefficient02

-- | s * (x - y) + I
data ModelSubtractedSizes
ModelSubtractedSizes :: Intercept -> Slope -> CostingInteger -> ModelSubtractedSizes
[modelSubtractedSizesIntercept] :: ModelSubtractedSizes -> Intercept
[modelSubtractedSizesSlope] :: ModelSubtractedSizes -> Slope
[modelSubtractedSizesMinimum] :: ModelSubtractedSizes -> CostingInteger

-- | NB: this is subsumed by ModelConstantOrOneArgument, but we have to
--   keep it for the time being. See Note [Backward compatibility for
--   costing functions]. | if p then s*x else c; p depends on usage
data ModelConstantOrLinear
ModelConstantOrLinear :: CostingInteger -> Intercept -> Slope -> ModelConstantOrLinear
[modelConstantOrLinearConstant] :: ModelConstantOrLinear -> CostingInteger
[modelConstantOrLinearIntercept] :: ModelConstantOrLinear -> Intercept
[modelConstantOrLinearSlope] :: ModelConstantOrLinear -> Slope

-- | if p then f(x) else c; p depends on usage
data ModelConstantOrOneArgument
ModelConstantOrOneArgument :: CostingInteger -> ModelOneArgument -> ModelConstantOrOneArgument
[modelConstantOrOneArgumentConstant] :: ModelConstantOrOneArgument -> CostingInteger
[modelConstantOrOneArgumentModel] :: ModelConstantOrOneArgument -> ModelOneArgument

-- | if p then f(x,y) else c; p depends on usage
data ModelConstantOrTwoArguments
ModelConstantOrTwoArguments :: CostingInteger -> ModelTwoArguments -> ModelConstantOrTwoArguments
[modelConstantOrTwoArgumentsConstant] :: ModelConstantOrTwoArguments -> CostingInteger
[modelConstantOrTwoArgumentsModel] :: ModelConstantOrTwoArguments -> ModelTwoArguments
data ModelOneArgument
ModelOneArgumentConstantCost :: CostingInteger -> ModelOneArgument
ModelOneArgumentLinearInX :: OneVariableLinearFunction -> ModelOneArgument
data ModelTwoArguments
ModelTwoArgumentsConstantCost :: CostingInteger -> ModelTwoArguments
ModelTwoArgumentsLinearInX :: OneVariableLinearFunction -> ModelTwoArguments
ModelTwoArgumentsLinearInY :: OneVariableLinearFunction -> ModelTwoArguments
ModelTwoArgumentsLinearInXAndY :: TwoVariableLinearFunction -> ModelTwoArguments
ModelTwoArgumentsAddedSizes :: OneVariableLinearFunction -> ModelTwoArguments
ModelTwoArgumentsSubtractedSizes :: ModelSubtractedSizes -> ModelTwoArguments
ModelTwoArgumentsMultipliedSizes :: OneVariableLinearFunction -> ModelTwoArguments
ModelTwoArgumentsMinSize :: OneVariableLinearFunction -> ModelTwoArguments
ModelTwoArgumentsMaxSize :: OneVariableLinearFunction -> ModelTwoArguments
ModelTwoArgumentsLinearOnDiagonal :: ModelConstantOrLinear -> ModelTwoArguments
ModelTwoArgumentsConstOffDiagonal :: ModelConstantOrOneArgument -> ModelTwoArguments
ModelTwoArgumentsConstAboveDiagonal :: ModelConstantOrTwoArguments -> ModelTwoArguments
ModelTwoArgumentsConstBelowDiagonal :: ModelConstantOrTwoArguments -> ModelTwoArguments
ModelTwoArgumentsQuadraticInY :: OneVariableQuadraticFunction -> ModelTwoArguments
ModelTwoArgumentsQuadraticInXAndY :: TwoVariableQuadraticFunction -> ModelTwoArguments
data ModelThreeArguments
ModelThreeArgumentsConstantCost :: CostingInteger -> ModelThreeArguments
ModelThreeArgumentsLinearInX :: OneVariableLinearFunction -> ModelThreeArguments
ModelThreeArgumentsLinearInY :: OneVariableLinearFunction -> ModelThreeArguments
ModelThreeArgumentsLinearInZ :: OneVariableLinearFunction -> ModelThreeArguments
ModelThreeArgumentsQuadraticInZ :: OneVariableQuadraticFunction -> ModelThreeArguments
ModelThreeArgumentsLiteralInYOrLinearInZ :: OneVariableLinearFunction -> ModelThreeArguments
ModelThreeArgumentsLinearInMaxYZ :: OneVariableLinearFunction -> ModelThreeArguments
ModelThreeArgumentsLinearInYAndZ :: TwoVariableLinearFunction -> ModelThreeArguments
data ModelFourArguments
ModelFourArgumentsConstantCost :: CostingInteger -> ModelFourArguments
data ModelFiveArguments
ModelFiveArgumentsConstantCost :: CostingInteger -> ModelFiveArguments
data ModelSixArguments
ModelSixArgumentsConstantCost :: CostingInteger -> ModelSixArguments
runCostingFunOneArgument :: ExMemoryUsage a1 => CostingFun ModelOneArgument -> a1 -> ExBudgetStream
runCostingFunTwoArguments :: (ExMemoryUsage a1, ExMemoryUsage a2) => CostingFun ModelTwoArguments -> a1 -> a2 -> ExBudgetStream
runCostingFunThreeArguments :: (ExMemoryUsage a1, ExMemoryUsage a2, ExMemoryUsage a3) => CostingFun ModelThreeArguments -> a1 -> a2 -> a3 -> ExBudgetStream
runCostingFunFourArguments :: (ExMemoryUsage a1, ExMemoryUsage a2, ExMemoryUsage a3, ExMemoryUsage a4) => CostingFun ModelFourArguments -> a1 -> a2 -> a3 -> a4 -> ExBudgetStream
runCostingFunFiveArguments :: (ExMemoryUsage a1, ExMemoryUsage a2, ExMemoryUsage a3, ExMemoryUsage a4, ExMemoryUsage a5) => CostingFun ModelFiveArguments -> a1 -> a2 -> a3 -> a4 -> a5 -> ExBudgetStream
runCostingFunSixArguments :: (ExMemoryUsage a1, ExMemoryUsage a2, ExMemoryUsage a3, ExMemoryUsage a4, ExMemoryUsage a5, ExMemoryUsage a6) => CostingFun ModelSixArguments -> a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> ExBudgetStream
class Eq a => Hashable a
instance Control.DeepSeq.NFData model => Control.DeepSeq.NFData (PlutusCore.Evaluation.Machine.CostingFun.Core.CostingFun model)
instance Data.Default.Class.Default model => Data.Default.Class.Default (PlutusCore.Evaluation.Machine.CostingFun.Core.CostingFun model)
instance Language.Haskell.TH.Syntax.Lift model => Language.Haskell.TH.Syntax.Lift (PlutusCore.Evaluation.Machine.CostingFun.Core.CostingFun model)
instance GHC.Generics.Generic (PlutusCore.Evaluation.Machine.CostingFun.Core.CostingFun model)
instance GHC.Classes.Eq model => GHC.Classes.Eq (PlutusCore.Evaluation.Machine.CostingFun.Core.CostingFun model)
instance GHC.Show.Show model => GHC.Show.Show (PlutusCore.Evaluation.Machine.CostingFun.Core.CostingFun model)
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.Intercept
instance GHC.Num.Num PlutusCore.Evaluation.Machine.CostingFun.Core.Intercept
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.Intercept
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.Intercept
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.Intercept
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.Intercept
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.Slope
instance GHC.Num.Num PlutusCore.Evaluation.Machine.CostingFun.Core.Slope
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.Slope
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.Slope
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.Slope
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.Slope
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient0
instance GHC.Num.Num PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient0
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient0
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient0
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient0
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient0
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient1
instance GHC.Num.Num PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient1
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient1
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient1
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient1
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient1
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient2
instance GHC.Num.Num PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient2
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient2
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient2
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient2
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient2
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient00
instance GHC.Num.Num PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient00
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient00
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient00
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient00
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient00
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient10
instance GHC.Num.Num PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient10
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient10
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient10
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient10
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient10
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient01
instance GHC.Num.Num PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient01
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient01
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient01
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient01
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient01
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient20
instance GHC.Num.Num PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient20
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient20
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient20
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient20
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient20
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient11
instance GHC.Num.Num PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient11
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient11
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient11
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient11
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient11
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient02
instance GHC.Num.Num PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient02
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient02
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient02
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient02
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient02
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.OneVariableLinearFunction
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.OneVariableLinearFunction
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.OneVariableLinearFunction
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.OneVariableLinearFunction
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.OneVariableLinearFunction
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.ModelOneArgument
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.ModelOneArgument
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.ModelOneArgument
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.ModelOneArgument
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.ModelOneArgument
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.TwoVariableLinearFunction
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.TwoVariableLinearFunction
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.TwoVariableLinearFunction
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.TwoVariableLinearFunction
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.TwoVariableLinearFunction
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.OneVariableQuadraticFunction
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.OneVariableQuadraticFunction
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.OneVariableQuadraticFunction
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.OneVariableQuadraticFunction
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.OneVariableQuadraticFunction
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.TwoVariableQuadraticFunction
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.TwoVariableQuadraticFunction
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.TwoVariableQuadraticFunction
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.TwoVariableQuadraticFunction
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.TwoVariableQuadraticFunction
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.ModelSubtractedSizes
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.ModelSubtractedSizes
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.ModelSubtractedSizes
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.ModelSubtractedSizes
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.ModelSubtractedSizes
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.ModelConstantOrLinear
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.ModelConstantOrLinear
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.ModelConstantOrLinear
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.ModelConstantOrLinear
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.ModelConstantOrLinear
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.ModelConstantOrOneArgument
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.ModelConstantOrOneArgument
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.ModelConstantOrOneArgument
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.ModelConstantOrOneArgument
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.ModelConstantOrOneArgument
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.ModelConstantOrTwoArguments
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.ModelConstantOrTwoArguments
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.ModelConstantOrTwoArguments
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.ModelConstantOrTwoArguments
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.ModelConstantOrTwoArguments
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.ModelTwoArguments
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.ModelTwoArguments
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.ModelTwoArguments
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.ModelTwoArguments
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.ModelTwoArguments
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.ModelThreeArguments
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.ModelThreeArguments
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.ModelThreeArguments
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.ModelThreeArguments
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.ModelThreeArguments
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.ModelFourArguments
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.ModelFourArguments
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.ModelFourArguments
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.ModelFourArguments
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.ModelFourArguments
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.ModelFiveArguments
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.ModelFiveArguments
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.ModelFiveArguments
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.ModelFiveArguments
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.ModelFiveArguments
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostingFun.Core.ModelSixArguments
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.CostingFun.Core.ModelSixArguments
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostingFun.Core.ModelSixArguments
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostingFun.Core.ModelSixArguments
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostingFun.Core.ModelSixArguments
instance Data.Default.Class.Default PlutusCore.Evaluation.Machine.CostingFun.Core.ModelSixArguments
instance PlutusCore.Evaluation.Machine.CostingFun.Core.UnimplementedCostingFun PlutusCore.Evaluation.Machine.CostingFun.Core.ModelSixArguments
instance Data.Default.Class.Default PlutusCore.Evaluation.Machine.CostingFun.Core.ModelFiveArguments
instance PlutusCore.Evaluation.Machine.CostingFun.Core.UnimplementedCostingFun PlutusCore.Evaluation.Machine.CostingFun.Core.ModelFiveArguments
instance Data.Default.Class.Default PlutusCore.Evaluation.Machine.CostingFun.Core.ModelFourArguments
instance PlutusCore.Evaluation.Machine.CostingFun.Core.UnimplementedCostingFun PlutusCore.Evaluation.Machine.CostingFun.Core.ModelFourArguments
instance Data.Default.Class.Default PlutusCore.Evaluation.Machine.CostingFun.Core.ModelThreeArguments
instance PlutusCore.Evaluation.Machine.CostingFun.Core.UnimplementedCostingFun PlutusCore.Evaluation.Machine.CostingFun.Core.ModelThreeArguments
instance Data.Default.Class.Default PlutusCore.Evaluation.Machine.CostingFun.Core.ModelTwoArguments
instance PlutusCore.Evaluation.Machine.CostingFun.Core.UnimplementedCostingFun PlutusCore.Evaluation.Machine.CostingFun.Core.ModelTwoArguments
instance Data.Default.Class.Default PlutusCore.Evaluation.Machine.CostingFun.Core.ModelOneArgument
instance PlutusCore.Evaluation.Machine.CostingFun.Core.UnimplementedCostingFun PlutusCore.Evaluation.Machine.CostingFun.Core.ModelOneArgument
instance (ab GHC.Types.~ (a -> b), PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage a, PlutusCore.Evaluation.Machine.CostingFun.Core.OnMemoryUsages c b) => PlutusCore.Evaluation.Machine.CostingFun.Core.OnMemoryUsages (PlutusCore.Evaluation.Machine.CostStream.CostStream -> c) ab
instance (ab GHC.Types.~ PlutusCore.Evaluation.Machine.ExBudgetStream.ExBudgetStream) => PlutusCore.Evaluation.Machine.CostingFun.Core.OnMemoryUsages PlutusCore.Evaluation.Machine.ExBudgetStream.ExBudgetStream ab


-- | A separate module for JSON instances, so that we can stick
--   <tt>-O0</tt> on it and avoid spending a lot of time optimizing loads
--   of Core whose performance doesn't matter.
module PlutusCore.Evaluation.Machine.CostingFun.JSON
instance Data.Aeson.Types.FromJSON.FromJSON model => Data.Aeson.Types.FromJSON.FromJSON (PlutusCore.Evaluation.Machine.CostingFun.Core.CostingFun model)
instance Data.Aeson.Types.ToJSON.ToJSON model => Data.Aeson.Types.ToJSON.ToJSON (PlutusCore.Evaluation.Machine.CostingFun.Core.CostingFun model)
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Intercept
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Intercept
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Slope
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Slope
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient0
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient0
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient1
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient1
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient2
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient2
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient00
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient00
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient10
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient10
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient01
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient01
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient20
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient20
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient11
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient11
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient02
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.Coefficient02
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.ModelOneArgument
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.ModelOneArgument
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.ModelTwoArguments
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.ModelTwoArguments
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.ModelThreeArguments
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.ModelThreeArguments
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.ModelFourArguments
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.ModelFourArguments
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.ModelFiveArguments
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.ModelFiveArguments
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.ModelSixArguments
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.ModelSixArguments
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.ModelSubtractedSizes
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.ModelSubtractedSizes
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.OneVariableLinearFunction
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.OneVariableLinearFunction
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.TwoVariableLinearFunction
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.TwoVariableLinearFunction
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.OneVariableQuadraticFunction
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.OneVariableQuadraticFunction
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.TwoVariableQuadraticFunction
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.TwoVariableQuadraticFunction
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.ModelConstantOrOneArgument
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.ModelConstantOrOneArgument
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.ModelConstantOrTwoArguments
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.ModelConstantOrTwoArguments
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.CostingFun.Core.ModelConstantOrLinear
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.CostingFun.Core.ModelConstantOrLinear

module PlutusCore.Evaluation.Machine.BuiltinCostModel
type BuiltinCostModel = BuiltinCostModelBase CostingFun

-- | The main model which contains all data required to predict the cost of
--   builtin functions. See <a>md</a> for how this is generated. Calibrated
--   for the CEK machine.
data BuiltinCostModelBase f
BuiltinCostModelBase :: f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelThreeArguments -> f ModelOneArgument -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelOneArgument -> f ModelOneArgument -> f ModelOneArgument -> f ModelThreeArguments -> f ModelThreeArguments -> f ModelThreeArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelOneArgument -> f ModelOneArgument -> f ModelThreeArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelOneArgument -> f ModelOneArgument -> f ModelThreeArguments -> f ModelTwoArguments -> f ModelOneArgument -> f ModelOneArgument -> f ModelOneArgument -> f ModelSixArguments -> f ModelTwoArguments -> f ModelOneArgument -> f ModelOneArgument -> f ModelOneArgument -> f ModelOneArgument -> f ModelOneArgument -> f ModelOneArgument -> f ModelOneArgument -> f ModelOneArgument -> f ModelOneArgument -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelOneArgument -> f ModelOneArgument -> f ModelOneArgument -> f ModelTwoArguments -> f ModelOneArgument -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelOneArgument -> f ModelOneArgument -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelOneArgument -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelOneArgument -> f ModelOneArgument -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelOneArgument -> f ModelOneArgument -> f ModelThreeArguments -> f ModelTwoArguments -> f ModelThreeArguments -> f ModelThreeArguments -> f ModelThreeArguments -> f ModelOneArgument -> f ModelTwoArguments -> f ModelThreeArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelOneArgument -> f ModelOneArgument -> f ModelOneArgument -> f ModelThreeArguments -> BuiltinCostModelBase f
[paramAddInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramSubtractInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramMultiplyInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramDivideInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramQuotientInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramRemainderInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramModInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramEqualsInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramLessThanInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramLessThanEqualsInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramAppendByteString] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramConsByteString] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramSliceByteString] :: BuiltinCostModelBase f -> f ModelThreeArguments
[paramLengthOfByteString] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramIndexByteString] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramEqualsByteString] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramLessThanByteString] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramLessThanEqualsByteString] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramSha2_256] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramSha3_256] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramBlake2b_256] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramVerifyEd25519Signature] :: BuiltinCostModelBase f -> f ModelThreeArguments
[paramVerifyEcdsaSecp256k1Signature] :: BuiltinCostModelBase f -> f ModelThreeArguments
[paramVerifySchnorrSecp256k1Signature] :: BuiltinCostModelBase f -> f ModelThreeArguments
[paramAppendString] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramEqualsString] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramEncodeUtf8] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramDecodeUtf8] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramIfThenElse] :: BuiltinCostModelBase f -> f ModelThreeArguments
[paramChooseUnit] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramTrace] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramFstPair] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramSndPair] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramChooseList] :: BuiltinCostModelBase f -> f ModelThreeArguments
[paramMkCons] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramHeadList] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramTailList] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramNullList] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramChooseData] :: BuiltinCostModelBase f -> f ModelSixArguments
[paramConstrData] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramMapData] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramListData] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramIData] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramBData] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramUnConstrData] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramUnMapData] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramUnListData] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramUnIData] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramUnBData] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramEqualsData] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramMkPairData] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramMkNilData] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramMkNilPairData] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramSerialiseData] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramBls12_381_G1_add] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramBls12_381_G1_neg] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramBls12_381_G1_scalarMul] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramBls12_381_G1_equal] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramBls12_381_G1_compress] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramBls12_381_G1_uncompress] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramBls12_381_G1_hashToGroup] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramBls12_381_G2_add] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramBls12_381_G2_neg] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramBls12_381_G2_scalarMul] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramBls12_381_G2_equal] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramBls12_381_G2_compress] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramBls12_381_G2_uncompress] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramBls12_381_G2_hashToGroup] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramBls12_381_millerLoop] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramBls12_381_mulMlResult] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramBls12_381_finalVerify] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramKeccak_256] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramBlake2b_224] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramIntegerToByteString] :: BuiltinCostModelBase f -> f ModelThreeArguments
[paramByteStringToInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramAndByteString] :: BuiltinCostModelBase f -> f ModelThreeArguments
[paramOrByteString] :: BuiltinCostModelBase f -> f ModelThreeArguments
[paramXorByteString] :: BuiltinCostModelBase f -> f ModelThreeArguments
[paramComplementByteString] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramReadBit] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramWriteBits] :: BuiltinCostModelBase f -> f ModelThreeArguments
[paramReplicateByte] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramShiftByteString] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramRotateByteString] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramCountSetBits] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramFindFirstSetBit] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramRipemd_160] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramExpModInteger] :: BuiltinCostModelBase f -> f ModelThreeArguments

-- | A type of costing functions parametric over a model type. In practice
--   the we have one model type `Model<a>N</a>Arguments` for every N, where
--   N is the arity of the builtin whose costs we want to model. Each model
--   type has a number of constructors defining different "shapes" of
--   N-parameter functions which calculate a cost given the sizes of the
--   builtin's arguments.
data CostingFun model
CostingFun :: model -> model -> CostingFun model
[costingFunCpu] :: CostingFun model -> model
[costingFunMemory] :: CostingFun model -> model

-- | In the initial stages of implementing a new builtin it is necessary to
--   provide a temporary costing function which is used until the builtin
--   has been properly costed: `see CostModelGeneration.md`. Each
--   `Model<a>N</a>Arguments` type defines an instance of this class where
--   <a>unimplementedCostingFun</a> is a constant costing function which
--   returns a very high cost for all inputs. This prevents new functions
--   from being used in situations where costs are important until a
--   sensible costing function has been implemented.
class UnimplementedCostingFun a
unimplementedCostingFun :: UnimplementedCostingFun a => b -> CostingFun a

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as an
--   intercept.
newtype Intercept
Intercept :: CostingInteger -> Intercept
[unIntercept] :: Intercept -> CostingInteger

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as a
--   slope.
newtype Slope
Slope :: CostingInteger -> Slope
[unSlope] :: Slope -> CostingInteger

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as the
--   degree 0 coefficient of a polynomial.
newtype Coefficient0
Coefficient0 :: CostingInteger -> Coefficient0
[unCoefficient0] :: Coefficient0 -> CostingInteger

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as the
--   degree 1 coefficient of a polynomial.
newtype Coefficient1
Coefficient1 :: CostingInteger -> Coefficient1
[unCoefficient1] :: Coefficient1 -> CostingInteger

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as the
--   degree 2 coefficient of a polynomial.
newtype Coefficient2
Coefficient2 :: CostingInteger -> Coefficient2
[unCoefficient2] :: Coefficient2 -> CostingInteger

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as the
--   degree (0,0) coefficient of a two-variable polynomial.
newtype Coefficient00
Coefficient00 :: CostingInteger -> Coefficient00
[unCoefficient00] :: Coefficient00 -> CostingInteger

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as the
--   degree (1,0) coefficient of a two-variable polynomial.
newtype Coefficient10
Coefficient10 :: CostingInteger -> Coefficient10
[unCoefficient10] :: Coefficient10 -> CostingInteger

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as the
--   degree (0,1) coefficient of a two-variable polynomial.
newtype Coefficient01
Coefficient01 :: CostingInteger -> Coefficient01
[unCoefficient01] :: Coefficient01 -> CostingInteger

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as the
--   degree (2,0) coefficient of a two-variable polynomial.
newtype Coefficient20
Coefficient20 :: CostingInteger -> Coefficient20
[unCoefficient20] :: Coefficient20 -> CostingInteger

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as the
--   degree (1,1) coefficient of a two-variable polynomial.
newtype Coefficient11
Coefficient11 :: CostingInteger -> Coefficient11
[unCoefficient11] :: Coefficient11 -> CostingInteger

-- | A wrapped <a>CostingInteger</a> that is supposed to be used as the
--   degree (0,2) coefficient of a two-variable polynomial.
newtype Coefficient02
Coefficient02 :: CostingInteger -> Coefficient02
[unCoefficient02] :: Coefficient02 -> CostingInteger

-- | s * x + I
data OneVariableLinearFunction
OneVariableLinearFunction :: Intercept -> Slope -> OneVariableLinearFunction
[oneVariableLinearFunctionIntercept] :: OneVariableLinearFunction -> Intercept
[oneVariableLinearFunctionSlope] :: OneVariableLinearFunction -> Slope

-- | c0 + c1*x + c2*x^2
data OneVariableQuadraticFunction
OneVariableQuadraticFunction :: Coefficient0 -> Coefficient1 -> Coefficient2 -> OneVariableQuadraticFunction
[oneVariableQuadraticFunctionC0] :: OneVariableQuadraticFunction -> Coefficient0
[oneVariableQuadraticFunctionC1] :: OneVariableQuadraticFunction -> Coefficient1
[oneVariableQuadraticFunctionC2] :: OneVariableQuadraticFunction -> Coefficient2

-- | s1 * x + s2 * y + I
data TwoVariableLinearFunction
TwoVariableLinearFunction :: Intercept -> Slope -> Slope -> TwoVariableLinearFunction
[twoVariableLinearFunctionIntercept] :: TwoVariableLinearFunction -> Intercept
[twoVariableLinearFunctionSlope1] :: TwoVariableLinearFunction -> Slope
[twoVariableLinearFunctionSlope2] :: TwoVariableLinearFunction -> Slope

-- | c00 + c10*x + c01*y + c20*x^2 + c11*c*y + c02*y^2
data TwoVariableQuadraticFunction
TwoVariableQuadraticFunction :: CostingInteger -> Coefficient00 -> Coefficient10 -> Coefficient01 -> Coefficient20 -> Coefficient11 -> Coefficient02 -> TwoVariableQuadraticFunction
[twoVariableQuadraticFunctionMinimum] :: TwoVariableQuadraticFunction -> CostingInteger
[twoVariableQuadraticFunctionC00] :: TwoVariableQuadraticFunction -> Coefficient00
[twoVariableQuadraticFunctionC10] :: TwoVariableQuadraticFunction -> Coefficient10
[twoVariableQuadraticFunctionC01] :: TwoVariableQuadraticFunction -> Coefficient01
[twoVariableQuadraticFunctionC20] :: TwoVariableQuadraticFunction -> Coefficient20
[twoVariableQuadraticFunctionC11] :: TwoVariableQuadraticFunction -> Coefficient11
[twoVariableQuadraticFunctionC02] :: TwoVariableQuadraticFunction -> Coefficient02

-- | s * (x - y) + I
data ModelSubtractedSizes
ModelSubtractedSizes :: Intercept -> Slope -> CostingInteger -> ModelSubtractedSizes
[modelSubtractedSizesIntercept] :: ModelSubtractedSizes -> Intercept
[modelSubtractedSizesSlope] :: ModelSubtractedSizes -> Slope
[modelSubtractedSizesMinimum] :: ModelSubtractedSizes -> CostingInteger

-- | if p then f(x) else c; p depends on usage
data ModelConstantOrOneArgument
ModelConstantOrOneArgument :: CostingInteger -> ModelOneArgument -> ModelConstantOrOneArgument
[modelConstantOrOneArgumentConstant] :: ModelConstantOrOneArgument -> CostingInteger
[modelConstantOrOneArgumentModel] :: ModelConstantOrOneArgument -> ModelOneArgument

-- | if p then f(x,y) else c; p depends on usage
data ModelConstantOrTwoArguments
ModelConstantOrTwoArguments :: CostingInteger -> ModelTwoArguments -> ModelConstantOrTwoArguments
[modelConstantOrTwoArgumentsConstant] :: ModelConstantOrTwoArguments -> CostingInteger
[modelConstantOrTwoArgumentsModel] :: ModelConstantOrTwoArguments -> ModelTwoArguments

-- | NB: this is subsumed by ModelConstantOrOneArgument, but we have to
--   keep it for the time being. See Note [Backward compatibility for
--   costing functions]. | if p then s*x else c; p depends on usage
data ModelConstantOrLinear
ModelConstantOrLinear :: CostingInteger -> Intercept -> Slope -> ModelConstantOrLinear
[modelConstantOrLinearConstant] :: ModelConstantOrLinear -> CostingInteger
[modelConstantOrLinearIntercept] :: ModelConstantOrLinear -> Intercept
[modelConstantOrLinearSlope] :: ModelConstantOrLinear -> Slope
data ModelOneArgument
ModelOneArgumentConstantCost :: CostingInteger -> ModelOneArgument
ModelOneArgumentLinearInX :: OneVariableLinearFunction -> ModelOneArgument
data ModelTwoArguments
ModelTwoArgumentsConstantCost :: CostingInteger -> ModelTwoArguments
ModelTwoArgumentsLinearInX :: OneVariableLinearFunction -> ModelTwoArguments
ModelTwoArgumentsLinearInY :: OneVariableLinearFunction -> ModelTwoArguments
ModelTwoArgumentsLinearInXAndY :: TwoVariableLinearFunction -> ModelTwoArguments
ModelTwoArgumentsAddedSizes :: OneVariableLinearFunction -> ModelTwoArguments
ModelTwoArgumentsSubtractedSizes :: ModelSubtractedSizes -> ModelTwoArguments
ModelTwoArgumentsMultipliedSizes :: OneVariableLinearFunction -> ModelTwoArguments
ModelTwoArgumentsMinSize :: OneVariableLinearFunction -> ModelTwoArguments
ModelTwoArgumentsMaxSize :: OneVariableLinearFunction -> ModelTwoArguments
ModelTwoArgumentsLinearOnDiagonal :: ModelConstantOrLinear -> ModelTwoArguments
ModelTwoArgumentsConstOffDiagonal :: ModelConstantOrOneArgument -> ModelTwoArguments
ModelTwoArgumentsConstAboveDiagonal :: ModelConstantOrTwoArguments -> ModelTwoArguments
ModelTwoArgumentsConstBelowDiagonal :: ModelConstantOrTwoArguments -> ModelTwoArguments
ModelTwoArgumentsQuadraticInY :: OneVariableQuadraticFunction -> ModelTwoArguments
ModelTwoArgumentsQuadraticInXAndY :: TwoVariableQuadraticFunction -> ModelTwoArguments
data ModelThreeArguments
ModelThreeArgumentsConstantCost :: CostingInteger -> ModelThreeArguments
ModelThreeArgumentsLinearInX :: OneVariableLinearFunction -> ModelThreeArguments
ModelThreeArgumentsLinearInY :: OneVariableLinearFunction -> ModelThreeArguments
ModelThreeArgumentsLinearInZ :: OneVariableLinearFunction -> ModelThreeArguments
ModelThreeArgumentsQuadraticInZ :: OneVariableQuadraticFunction -> ModelThreeArguments
ModelThreeArgumentsLiteralInYOrLinearInZ :: OneVariableLinearFunction -> ModelThreeArguments
ModelThreeArgumentsLinearInMaxYZ :: OneVariableLinearFunction -> ModelThreeArguments
ModelThreeArgumentsLinearInYAndZ :: TwoVariableLinearFunction -> ModelThreeArguments
data ModelFourArguments
ModelFourArgumentsConstantCost :: CostingInteger -> ModelFourArguments
data ModelFiveArguments
ModelFiveArgumentsConstantCost :: CostingInteger -> ModelFiveArguments
data ModelSixArguments
ModelSixArgumentsConstantCost :: CostingInteger -> ModelSixArguments
runCostingFunOneArgument :: ExMemoryUsage a1 => CostingFun ModelOneArgument -> a1 -> ExBudgetStream
runCostingFunTwoArguments :: (ExMemoryUsage a1, ExMemoryUsage a2) => CostingFun ModelTwoArguments -> a1 -> a2 -> ExBudgetStream
runCostingFunThreeArguments :: (ExMemoryUsage a1, ExMemoryUsage a2, ExMemoryUsage a3) => CostingFun ModelThreeArguments -> a1 -> a2 -> a3 -> ExBudgetStream
runCostingFunFourArguments :: (ExMemoryUsage a1, ExMemoryUsage a2, ExMemoryUsage a3, ExMemoryUsage a4) => CostingFun ModelFourArguments -> a1 -> a2 -> a3 -> a4 -> ExBudgetStream
runCostingFunFiveArguments :: (ExMemoryUsage a1, ExMemoryUsage a2, ExMemoryUsage a3, ExMemoryUsage a4, ExMemoryUsage a5) => CostingFun ModelFiveArguments -> a1 -> a2 -> a3 -> a4 -> a5 -> ExBudgetStream
runCostingFunSixArguments :: (ExMemoryUsage a1, ExMemoryUsage a2, ExMemoryUsage a3, ExMemoryUsage a4, ExMemoryUsage a5, ExMemoryUsage a6) => CostingFun ModelSixArguments -> a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> ExBudgetStream
class Eq a => Hashable a

-- | Same as <a>CostingFun</a> but maybe missing. We could use 'Compose
--   Maybe CostinFun' instead but we would then need an orphan ToJSON
--   instance.
newtype MCostingFun a
MCostingFun :: Maybe (CostingFun a) -> MCostingFun a
instance Barbies.Internal.ConstraintsB.ConstraintsB PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase
instance Barbies.Internal.TraversableB.TraversableB PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase
instance Barbies.Internal.FunctorB.FunctorB PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase
instance GHC.Generics.Generic (PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase f)
instance GHC.Base.Monoid (PlutusCore.Evaluation.Machine.BuiltinCostModel.MCostingFun a)
instance GHC.Base.Semigroup (PlutusCore.Evaluation.Machine.BuiltinCostModel.MCostingFun a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (PlutusCore.Evaluation.Machine.BuiltinCostModel.MCostingFun a)
instance Data.Aeson.Types.ToJSON.ToJSON (PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase PlutusCore.Evaluation.Machine.CostingFun.Core.CostingFun)
instance Data.Aeson.Types.FromJSON.FromJSON (PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase PlutusCore.Evaluation.Machine.CostingFun.Core.CostingFun)
instance Data.Aeson.Types.ToJSON.ToJSON (PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase PlutusCore.Evaluation.Machine.BuiltinCostModel.MCostingFun)
instance PlutusCore.Evaluation.Machine.BuiltinCostModel.AllArgumentModels Control.DeepSeq.NFData f => Control.DeepSeq.NFData (PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase f)
instance PlutusCore.Evaluation.Machine.BuiltinCostModel.AllArgumentModels Data.Default.Class.Default f => Data.Default.Class.Default (PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase f)
instance PlutusCore.Evaluation.Machine.BuiltinCostModel.AllArgumentModels Language.Haskell.TH.Syntax.Lift f => Language.Haskell.TH.Syntax.Lift (PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase f)
instance PlutusCore.Evaluation.Machine.BuiltinCostModel.AllArgumentModels GHC.Show.Show f => GHC.Show.Show (PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase f)
instance PlutusCore.Evaluation.Machine.BuiltinCostModel.AllArgumentModels GHC.Classes.Eq f => GHC.Classes.Eq (PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase f)


-- | Support for using de Bruijn indices for term and type names.
module PlutusCore.DeBruijn

-- | A relative index used for de Bruijn identifiers.
--   
--   FIXME: downside of using newtype+Num instead of type-synonym is that
--   `-Woverflowed-literals` does not work, e.g.: `DeBruijn (-1)` has no
--   warning. To trigger the warning you have to bypass the Num and write
--   `DeBruijn (Index -1)`. This can be revisited when we implement
--   PLT-1053.
newtype Index
Index :: Word64 -> Index

-- | An absolute level in the program.
newtype Level
Level :: Integer -> Level

-- | During visiting the AST we hold a reader "state" of current level and
--   a current scoping (levelMapping). Invariant-A: the current level is
--   positive and greater than all levels in the levelMapping. Invariant-B:
--   only positive levels are stored in the levelMapping.
data LevelInfo
LevelInfo :: Level -> Bimap Unique Level -> LevelInfo
[currentLevel] :: LevelInfo -> Level
[levelMapping] :: LevelInfo -> Bimap Unique Level
class HasIndex a
index :: HasIndex a => Lens' a Index

-- | A term name as a de Bruijn index, without the name string.
newtype DeBruijn
DeBruijn :: Index -> DeBruijn
[dbnIndex] :: DeBruijn -> Index

-- | A term name as a de Bruijn index.
data NamedDeBruijn
NamedDeBruijn :: !Text -> !Index -> NamedDeBruijn
[ndbnString] :: NamedDeBruijn -> !Text
[ndbnIndex] :: NamedDeBruijn -> !Index

-- | A wrapper around <a>NamedDeBruijn</a> that *must* hold the invariant
--   of name=<a>fakeName</a>.
--   
--   We do not export the <a>FakeNamedDeBruijn</a> constructor: the
--   projection `FND-&gt;ND` is safe but injection `ND-&gt;FND` is unsafe,
--   thus they are not isomorphic.
--   
--   See Note [Why newtype FakeNamedDeBruijn]
data FakeNamedDeBruijn

-- | A type name as a de Bruijn index, without the name string.
newtype TyDeBruijn
TyDeBruijn :: DeBruijn -> TyDeBruijn

-- | A type name as a de Bruijn index.
newtype NamedTyDeBruijn
NamedTyDeBruijn :: NamedDeBruijn -> NamedTyDeBruijn

-- | We cannot do a correct translation to or from de Bruijn indices if the
--   program is not well-scoped. So we throw an error in such a case.
data FreeVariableError
FreeUnique :: !Unique -> FreeVariableError
FreeIndex :: !Index -> FreeVariableError
class AsFreeVariableError r_a1KDI
_FreeVariableError :: AsFreeVariableError r_a1KDI => Prism' r_a1KDI FreeVariableError
_FreeUnique :: AsFreeVariableError r_a1KDI => Prism' r_a1KDI Unique
_FreeIndex :: AsFreeVariableError r_a1KDI => Prism' r_a1KDI Index
unNameDeBruijn :: NamedDeBruijn -> DeBruijn
unNameTyDeBruijn :: NamedTyDeBruijn -> TyDeBruijn
fakeNameDeBruijn :: DeBruijn -> NamedDeBruijn
fakeTyNameDeBruijn :: TyDeBruijn -> NamedTyDeBruijn

-- | Convert a <a>Kind</a> with <a>TyName</a>s into a <a>Kind</a> with
--   <a>NamedTyDeBruijn</a>s. Will throw an error if a free variable is
--   encountered.
deBruijnTy :: (AsFreeVariableError e, MonadError e m) => Type TyName uni ann -> m (Type NamedTyDeBruijn uni ann)

-- | Convert a <a>Term</a> with <a>TyName</a>s and <a>Name</a>s into a
--   <a>Term</a> with <a>NamedTyDeBruijn</a>s and <a>NamedDeBruijn</a>s.
--   Will throw an error if a free variable is encountered.
deBruijnTerm :: (AsFreeVariableError e, MonadError e m) => Term TyName Name uni fun ann -> m (Term NamedTyDeBruijn NamedDeBruijn uni fun ann)

-- | Convert a <a>Kind</a> with <a>NamedTyDeBruijn</a>s into a <a>Kind</a>
--   with <a>TyName</a>s. Will throw an error if a free variable is
--   encountered.
unDeBruijnTy :: (MonadQuote m, AsFreeVariableError e, MonadError e m) => Type NamedTyDeBruijn uni ann -> m (Type TyName uni ann)

-- | Convert a <a>Term</a> with <a>NamedTyDeBruijn</a>s and
--   <a>NamedDeBruijn</a>s into a <a>Term</a> with <a>TyName</a>s and
--   <a>Name</a>s. Will throw an error if a free variable is encountered.
unDeBruijnTerm :: (MonadQuote m, AsFreeVariableError e, MonadError e m) => Term NamedTyDeBruijn NamedDeBruijn uni fun ann -> m (Term TyName Name uni fun ann)
deBruijnTyWith :: Monad m => (Unique -> ReaderT LevelInfo m Index) -> Type TyName uni ann -> m (Type NamedTyDeBruijn uni ann)
deBruijnTermWith :: Monad m => (Unique -> ReaderT LevelInfo m Index) -> Term TyName Name uni fun ann -> m (Term NamedTyDeBruijn NamedDeBruijn uni fun ann)

-- | Takes a "handler" function to execute when encountering free
--   variables.
unDeBruijnTyWith :: MonadQuote m => (Index -> ReaderT LevelInfo m Unique) -> Type NamedTyDeBruijn uni ann -> m (Type TyName uni ann)

-- | Takes a "handler" function to execute when encountering free
--   variables.
unDeBruijnTermWith :: MonadQuote m => (Index -> ReaderT LevelInfo m Unique) -> Term NamedTyDeBruijn NamedDeBruijn uni fun ann -> m (Term TyName Name uni fun ann)

-- | A different implementation of a handler, where "free" debruijn indices
--   do not throw an error but are instead gracefully converted to fresh
--   uniques. These generated uniques remain free; i.e. if the original
--   term was open, it will remain open after applying this handler. These
--   generated free uniques are consistent across the open term (by using a
--   state cache).
freeIndexAsConsistentLevel :: (MonadReader LevelInfo m, MonadState (Map Level Unique) m, MonadQuote m) => Index -> m Unique

-- | The LamAbs index (for debruijn indices) and the starting level of
--   DeBruijn monad
deBruijnInitIndex :: Index
fromFake :: FakeNamedDeBruijn -> DeBruijn
toFake :: DeBruijn -> FakeNamedDeBruijn

module PlutusCore.Core.Plated
kindSubkinds :: Traversal' (Kind ann) (Kind ann)
kindSubkindsDeep :: Fold (Kind ann) (Kind ann)

-- | Get all the direct child <a>Kind</a>s of the given <a>TyVarDecl</a>.
tyVarDeclSubkinds :: Traversal' (TyVarDecl tyname a) (Kind a)

-- | Get all the direct child 'tyname a's of the given <a>Kind</a> from
--   binders.
typeTyBinds :: Traversal' (Type tyname uni ann) tyname

-- | Get all the direct child 'tyname a's of the given <a>Kind</a> from
--   <a>TyVar</a>s.
typeTyVars :: Traversal' (Type tyname uni ann) tyname

-- | Get all the direct child <a>Unique</a>s of the given <a>Kind</a> from
--   binders <a>TyVar</a>s.
typeUniques :: HasUniques (Type tyname uni ann) => Traversal' (Type tyname uni ann) Unique

-- | Get all the direct child <a>Kind</a>s of the given <a>Kind</a>.
typeSubkinds :: Traversal' (Type tyname uni ann) (Kind ann)

-- | Get all the direct child <a>Kind</a>s of the given <a>Kind</a>.
typeSubtypes :: Traversal' (Type tyname uni ann) (Type tyname uni ann)

-- | Get all the transitive child <a>Kind</a>s of the given <a>Kind</a>.
typeSubtypesDeep :: Fold (Type tyname uni ann) (Type tyname uni ann)

-- | Get all the direct child <a>Kind</a>s of the given <a>VarDecl</a>.
varDeclSubtypes :: Traversal' (VarDecl tyname name uni a) (Type tyname uni a)

-- | Get all the direct constants of the given <a>Term</a> from
--   <a>Constant</a>s.
termConstants :: Traversal' (Term tyname name uni fun ann) (Some (ValueOf uni))

-- | Get all the direct child 'tyname a's of the given <a>Term</a> from
--   <a>TyAbs</a>es.
termTyBinds :: Traversal' (Term tyname name uni fun ann) tyname

-- | Get all the direct child 'name a's of the given <a>Term</a> from
--   <a>LamAbs</a>es.
termBinds :: Traversal' (Term tyname name uni fun ann) name

-- | Get all the direct child 'name a's of the given <a>Term</a> from
--   <a>Var</a>s.
termVars :: Traversal' (Term tyname name uni fun ann) name

-- | Get all the direct child <a>Unique</a>s of the given <a>Term</a>
--   (including the type-level ones).
termUniques :: HasUniques (Term tyname name uni fun ann) => Traversal' (Term tyname name uni fun ann) Unique

-- | Get all the direct child <a>Kind</a>s of the given <a>Term</a>.
termSubkinds :: Traversal' (Term tyname name uni fun ann) (Kind ann)

-- | Get all the direct child <a>Kind</a>s of the given <a>Term</a>.
termSubtypes :: Traversal' (Term tyname name uni fun ann) (Type tyname uni ann)

-- | Get all the transitive child <a>Term</a>s of the given <a>Term</a>.
termSubtermsDeep :: Fold (Term tyname name uni fun ann) (Term tyname name uni fun ann)

-- | Get all the transitive child <a>Kind</a>s of the given <a>Term</a>.
termSubtypesDeep :: Fold (Term tyname name uni fun ann) (Type tyname uni ann)

-- | Get all the transitive child <a>Constant</a>s of the given
--   <a>Term</a>.
termConstantsDeep :: Fold (Term tyname name uni fun ann) (Some (ValueOf uni))

-- | Get all the direct child <a>Term</a>s of the given <a>Term</a>.
termSubterms :: Traversal' (Term tyname name uni fun ann) (Term tyname name uni fun ann)

-- | Get all the transitive child <a>Unique</a>s of the given <a>Kind</a>.
typeUniquesDeep :: HasUniques (Type tyname uni ann) => Fold (Type tyname uni ann) Unique

-- | Get all the transitive child <a>Unique</a>s of the given <a>Term</a>
--   (including the type-level ones).
termUniquesDeep :: HasUniques (Term tyname name uni fun ann) => Fold (Term tyname name uni fun ann) Unique

module PlutusCore.Core
data Kind ann
Type :: ann -> Kind ann
KindArrow :: ann -> Kind ann -> Kind ann -> Kind ann

-- | The kind of a pattern functor (the first <a>Kind</a> argument of
--   <a>TyIFix</a>) at a given kind (of the second <a>Kind</a> argument of
--   <a>TyIFix</a>):
--   
--   <pre>
--   toPatFuncKind k = (k -&gt; *) -&gt; k -&gt; *
--   </pre>
toPatFuncKind :: Kind () -> Kind ()
fromPatFuncKind :: Kind () -> Maybe (Kind ())

-- | Extract all <tt>a_i</tt> from <tt>a_0 -&gt; a_1 -&gt; ... -&gt;
--   r</tt>.
argsFunKind :: Kind ann -> [Kind ann]

-- | A <a>Kind</a> assigned to expressions.
data Type tyname uni ann

-- | Type variable
TyVar :: ann -> tyname -> Type tyname uni ann

-- | Function type
TyFun :: ann -> Type tyname uni ann -> Type tyname uni ann -> Type tyname uni ann

-- | Fix-point type, for constructing self-recursive types
TyIFix :: ann -> Type tyname uni ann -> Type tyname uni ann -> Type tyname uni ann

-- | Polymorphic type
TyForall :: ann -> tyname -> Kind ann -> Type tyname uni ann -> Type tyname uni ann

-- | Builtin type
TyBuiltin :: ann -> SomeTypeIn uni -> Type tyname uni ann

-- | Type lambda
TyLam :: ann -> tyname -> Kind ann -> Type tyname uni ann -> Type tyname uni ann

-- | Type application
TyApp :: ann -> Type tyname uni ann -> Type tyname uni ann -> Type tyname uni ann

-- | Sum-of-products type
TySOP :: ann -> [[Type tyname uni ann]] -> Type tyname uni ann

-- | Get recursively all the domains and codomains of a type.
--   <tt>splitFunTyParts (A-&gt;B-&gt;C) = [A, B, C]</tt>
--   <tt>splitFunTyParts (X) = [X]</tt>
splitFunTyParts :: Type tyname uni a -> NonEmpty (Type tyname uni a)

-- | Get the argument types of a function type. <tt>funTyArgs
--   (A-&gt;B-&gt;C) = [A, B]</tt>
funTyArgs :: Type tyname uni a -> [Type tyname uni a]

-- | Get the result type of a function. If not a function, then is the same
--   as <a>id</a> <tt>funResultType (A-&gt;B-&gt;C) = C</tt>
--   <tt>funResultType (X) = X</tt>
funTyResultType :: Type tyname uni a -> Type tyname uni a
data Term tyname name uni fun ann

-- | a named variable
Var :: ann -> name -> Term tyname name uni fun ann

-- | lambda abstraction
LamAbs :: ann -> name -> Type tyname uni ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann

-- | application
Apply :: ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann

-- | type abstraction
TyAbs :: ann -> tyname -> Kind ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann

-- | instantiation
TyInst :: ann -> Term tyname name uni fun ann -> Type tyname uni ann -> Term tyname name uni fun ann

-- | wrapping
IWrap :: ann -> Type tyname uni ann -> Type tyname uni ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann

-- | unwrapping See Note [Constr tag type]
Unwrap :: ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann

-- | constructor
Constr :: ann -> Type tyname uni ann -> Word64 -> [Term tyname name uni fun ann] -> Term tyname name uni fun ann

-- | case
Case :: ann -> Type tyname uni ann -> Term tyname name uni fun ann -> [Term tyname name uni fun ann] -> Term tyname name uni fun ann

-- | constants
Constant :: ann -> Some (ValueOf uni) -> Term tyname name uni fun ann

-- | builtin functions
Builtin :: ann -> fun -> Term tyname name uni fun ann

-- | fail with error
Error :: ann -> Type tyname uni ann -> Term tyname name uni fun ann

-- | A <a>Program</a> is simply a <a>Term</a> coupled with a <a>Version</a>
--   of the core language.
data Program tyname name uni fun ann
Program :: ann -> Version -> Term tyname name uni fun ann -> Program tyname name uni fun ann
[_progAnn] :: Program tyname name uni fun ann -> ann
[_progVer] :: Program tyname name uni fun ann -> Version
[_progTerm] :: Program tyname name uni fun ann -> Term tyname name uni fun ann

-- | Specifies that the given type is a built-in one and its values can be
--   embedded into a <a>Term</a>.
type HasTermLevel uni = Includes uni

-- | Extract the universe from a type.
type family UniOf a :: Type -> Type
newtype Normalized a
Normalized :: a -> Normalized a
[unNormalized] :: Normalized a -> a

-- | A "type variable declaration", i.e. a name and a kind for a type
--   variable.
data TyVarDecl tyname ann
TyVarDecl :: ann -> tyname -> Kind ann -> TyVarDecl tyname ann
[_tyVarDeclAnn] :: TyVarDecl tyname ann -> ann
[_tyVarDeclName] :: TyVarDecl tyname ann -> tyname
[_tyVarDeclKind] :: TyVarDecl tyname ann -> Kind ann

-- | A "variable declaration", i.e. a name and a type for a variable.
data VarDecl tyname name uni ann
VarDecl :: ann -> name -> Type tyname uni ann -> VarDecl tyname name uni ann
[_varDeclAnn] :: VarDecl tyname name uni ann -> ann
[_varDeclName] :: VarDecl tyname name uni ann -> name
[_varDeclType] :: VarDecl tyname name uni ann -> Type tyname uni ann

-- | A "type declaration", i.e. a kind for a type.
data TyDecl tyname uni ann
TyDecl :: ann -> Type tyname uni ann -> Kind ann -> TyDecl tyname uni ann
[_tyDeclAnn] :: TyDecl tyname uni ann -> ann
[_tyDeclType] :: TyDecl tyname uni ann -> Type tyname uni ann
[_tyDeclKind] :: TyDecl tyname uni ann -> Kind ann
tyDeclVar :: TyVarDecl tyname ann -> TyDecl tyname uni ann

-- | All kinds of uniques an entity contains.
type family HasUniques a :: Constraint

-- | This is a wrapper to mark the place where the binder is introduced
--   (i.e. LamAbs/TyAbs) and not where it is actually used (TyVar/Var..).
--   This marking allows us to skip the (de)serialization of binders at
--   LamAbs/TyAbs positions iff <tt>name</tt> is DeBruijn-encoded (level or
--   index). See for example the instance of <a>Flat</a>
newtype Binder name
Binder :: name -> Binder name
[unBinder] :: Binder name -> name
termAnn :: Term tyname name uni fun ann -> ann
typeAnn :: Type tyname uni ann -> ann

-- | Map a function over the set of built-in functions.
mapFun :: (fun -> fun') -> Term tyname name uni fun ann -> Term tyname name uni fun' ann
tyVarDeclAnn :: forall tyname_a7d1z ann_a7d1A. Lens' (TyVarDecl tyname_a7d1z ann_a7d1A) ann_a7d1A
tyVarDeclName :: forall tyname_a7d1z ann_a7d1A tyname_a7dfC. Lens (TyVarDecl tyname_a7d1z ann_a7d1A) (TyVarDecl tyname_a7dfC ann_a7d1A) tyname_a7d1z tyname_a7dfC
tyVarDeclKind :: forall tyname_a7d1z ann_a7d1A. Lens' (TyVarDecl tyname_a7d1z ann_a7d1A) (Kind ann_a7d1A)
varDeclAnn :: forall tyname_a7dg0 name_a7dg1 uni_a7dg2 ann_a7dg3. Lens' (VarDecl tyname_a7dg0 name_a7dg1 uni_a7dg2 ann_a7dg3) ann_a7dg3
varDeclName :: forall tyname_a7dg0 name_a7dg1 uni_a7dg2 ann_a7dg3 name_a7dq7. Lens (VarDecl tyname_a7dg0 name_a7dg1 uni_a7dg2 ann_a7dg3) (VarDecl tyname_a7dg0 name_a7dq7 uni_a7dg2 ann_a7dg3) name_a7dg1 name_a7dq7
varDeclType :: forall tyname_a7dg0 name_a7dg1 uni_a7dg2 ann_a7dg3 tyname_a7dq8 uni_a7dq9. Lens (VarDecl tyname_a7dg0 name_a7dg1 uni_a7dg2 ann_a7dg3) (VarDecl tyname_a7dq8 name_a7dg1 uni_a7dq9 ann_a7dg3) (Type tyname_a7dg0 uni_a7dg2 ann_a7dg3) (Type tyname_a7dq8 uni_a7dq9 ann_a7dg3)
tyDeclAnn :: forall tyname_a7dqx uni_a7dqy ann_a7dqz. Lens' (TyDecl tyname_a7dqx uni_a7dqy ann_a7dqz) ann_a7dqz
tyDeclType :: forall tyname_a7dqx uni_a7dqy ann_a7dqz tyname_a7dAY uni_a7dAZ. Lens (TyDecl tyname_a7dqx uni_a7dqy ann_a7dqz) (TyDecl tyname_a7dAY uni_a7dAZ ann_a7dqz) (Type tyname_a7dqx uni_a7dqy ann_a7dqz) (Type tyname_a7dAY uni_a7dAZ ann_a7dqz)
tyDeclKind :: forall tyname_a7dqx uni_a7dqy ann_a7dqz. Lens' (TyDecl tyname_a7dqx uni_a7dqy ann_a7dqz) (Kind ann_a7dqz)
progAnn :: forall tyname_a7aWk name_a7aWl uni_a7aWm fun_a7aWn ann_a7aWo. Lens' (Program tyname_a7aWk name_a7aWl uni_a7aWm fun_a7aWn ann_a7aWo) ann_a7aWo
progVer :: forall tyname_a7aWk name_a7aWl uni_a7aWm fun_a7aWn ann_a7aWo. Lens' (Program tyname_a7aWk name_a7aWl uni_a7aWm fun_a7aWn ann_a7aWo) Version
progTerm :: forall tyname_a7aWk name_a7aWl uni_a7aWm fun_a7aWn ann_a7aWo tyname_a7d16 name_a7d17 uni_a7d18 fun_a7d19. Lens (Program tyname_a7aWk name_a7aWl uni_a7aWm fun_a7aWn ann_a7aWo) (Program tyname_a7d16 name_a7d17 uni_a7d18 fun_a7d19 ann_a7aWo) (Term tyname_a7aWk name_a7aWl uni_a7aWm fun_a7aWn ann_a7aWo) (Term tyname_a7d16 name_a7d17 uni_a7d18 fun_a7d19 ann_a7aWo)

module PlutusCore.Subst

-- | Applicatively replace a type variable using the given function.
substTyVarA :: Applicative f => (tyname -> f (Maybe (Type tyname uni ann))) -> Type tyname uni ann -> f (Type tyname uni ann)

-- | Applicatively replace a variable using the given function.
substVarA :: Applicative f => (name -> f (Maybe (Term tyname name uni fun ann))) -> Term tyname name uni fun ann -> f (Term tyname name uni fun ann)

-- | Replace a type variable using the given function.
substTyVar :: (tyname -> Maybe (Type tyname uni ann)) -> Type tyname uni ann -> Type tyname uni ann

-- | Replace a variable using the given function.
substVar :: (name -> Maybe (Term tyname name uni fun ann)) -> Term tyname name uni fun ann -> Term tyname name uni fun ann

-- | Naively monadically substitute names using the given function (i.e. do
--   not substitute binders).
termSubstNamesM :: Monad m => (name -> m (Maybe (Term tyname name uni fun ann))) -> Term tyname name uni fun ann -> m (Term tyname name uni fun ann)

-- | Naively monadically substitute type names using the given function
--   (i.e. do not substitute binders).
termSubstTyNamesM :: Monad m => (tyname -> m (Maybe (Type tyname uni ann))) -> Term tyname name uni fun ann -> m (Term tyname name uni fun ann)

-- | Naively monadically substitute type names (i.e. do not substitute
--   binders). INLINE is important here because the function is too
--   polymorphic (determined from profiling)
typeSubstTyNamesM :: Monad m => (tyname -> m (Maybe (Type tyname uni ann))) -> Type tyname uni ann -> m (Type tyname uni ann)

-- | Naively substitute names using the given function (i.e. do not
--   substitute binders).
termSubstNames :: (name -> Maybe (Term tyname name uni fun ann)) -> Term tyname name uni fun ann -> Term tyname name uni fun ann

-- | Naively substitute type names using the given function (i.e. do not
--   substitute binders).
termSubstTyNames :: (tyname -> Maybe (Type tyname uni ann)) -> Term tyname name uni fun ann -> Term tyname name uni fun ann

-- | Naively substitute type names (i.e. do not substitute binders).
typeSubstTyNames :: (tyname -> Maybe (Type tyname uni ann)) -> Type tyname uni ann -> Type tyname uni ann

-- | Substitute the given closed <a>Kind</a> for the given type variable in
--   the given <a>Kind</a>. Does not descend under binders that bind the
--   same variable as the one we're substituting for (since from there that
--   variable is no longer free). The resulting <a>Term</a> may and likely
--   will not satisfy global uniqueness.
typeSubstClosedType :: Eq tyname => tyname -> Type tyname uni a -> Type tyname uni a -> Type tyname uni a

-- | Substitute the given closed <a>Kind</a> for the given type variable in
--   the given <a>Term</a>. Does not descend under binders that bind the
--   same variable as the one we're substituting for (since from there that
--   variable is no longer free). The resulting <a>Term</a> may and likely
--   will not satisfy global uniqueness.
termSubstClosedType :: Eq tyname => tyname -> Type tyname uni a -> Term tyname name uni fun a -> Term tyname name uni fun a

-- | Substitute the given closed <a>Term</a> for the given term variable in
--   the given <a>Term</a>. Does not descend under binders that bind the
--   same variable as the one we're substituting for (since from there that
--   variable is no longer free). The resulting <a>Term</a> may and likely
--   will not satisfy global uniqueness.
termSubstClosedTerm :: Eq name => name -> Term tyname name uni fun a -> Term tyname name uni fun a -> Term tyname name uni fun a
typeMapNames :: forall tyname tyname' uni ann. (tyname -> tyname') -> Type tyname uni ann -> Type tyname' uni ann
termMapNames :: forall tyname tyname' name name' uni fun ann. (tyname -> tyname') -> (name -> name') -> Term tyname name uni fun ann -> Term tyname' name' uni fun ann
programMapNames :: forall tyname tyname' name name' uni fun ann. (tyname -> tyname') -> (name -> name') -> Program tyname name uni fun ann -> Program tyname' name' uni fun ann

-- | Get all the free term variables in a term.
fvTerm :: HasUnique name unique => Traversal' (Term tyname name uni fun ann) name

-- | Get all the free type variables in a term.
ftvTerm :: HasUnique tyname unique => Traversal' (Term tyname name uni fun ann) tyname

-- | Get all the free type variables in a type.
ftvTy :: HasUnique tyname unique => Traversal' (Type tyname uni ann) tyname
ftvTyCtx :: HasUnique tyname unique => UniqueSet unique -> Traversal' (Type tyname uni ann) tyname

-- | Get all the term variables in a term.
vTerm :: Fold (Term tyname name uni fun ann) name

-- | Get all the type variables in a term.
tvTerm :: Fold (Term tyname name uni fun ann) tyname

-- | Get all the type variables in a type.
tvTy :: Fold (Type tyname uni ann) tyname
purely :: ((a -> Identity b) -> c -> Identity d) -> (a -> b) -> c -> d

module PlutusCore.Size
newtype Size
Size :: Integer -> Size
[unSize] :: Size -> Integer

-- | Count the number of AST nodes in a kind.
--   
--   <pre>
--   &gt;&gt;&gt; kindSize $ Type ()
--   Size {unSize = 1}
--   
--   &gt;&gt;&gt; kindSize $ KindArrow () (KindArrow () (Type ()) (Type ())) (Type ())
--   Size {unSize = 5}
--   </pre>
kindSize :: Kind a -> Size

-- | Count the number of AST nodes in a type.
typeSize :: Type tyname uni ann -> Size
tyVarDeclSize :: TyVarDecl tyname ann -> Size

-- | Count the number of AST nodes in a term.
termSize :: Term tyname name uni fun ann -> Size
varDeclSize :: VarDecl tyname name uni ann -> Size

-- | Count the number of AST nodes in a program.
programSize :: Program tyname name uni fun ann -> Size

-- | Compute the size of the serializabled form of a value.
serialisedSize :: Flat a => a -> Integer
instance GHC.Base.Monoid PlutusCore.Size.Size
instance GHC.Base.Semigroup PlutusCore.Size.Size
instance GHC.Num.Num PlutusCore.Size.Size
instance GHC.Classes.Ord PlutusCore.Size.Size
instance GHC.Classes.Eq PlutusCore.Size.Size
instance Prettyprinter.Internal.Pretty PlutusCore.Size.Size
instance GHC.Show.Show PlutusCore.Size.Size


-- | The internal module of the renamer that defines the actual algorithms,
--   but not the user-facing API.
module PlutusCore.Rename.Internal

-- | A wrapper for signifying that the value inside of it satisfies global
--   uniqueness.
--   
--   It's safe to call <a>unRenamed</a>, it's not safe to call
--   <a>Renamed</a>, hence the latter is only exported from this internal
--   module and should not be exported from the main API.
--   
--   Don't provide any instances allowing the user to create a
--   <a>Renamed</a> (even out of an existing one like with <a>Functor</a>).
newtype Renamed a
Renamed :: a -> Renamed a
[unRenamed] :: Renamed a -> a

-- | <tt>Dupable a</tt> is isomorphic to <tt>a</tt>, but the only way to
--   extract the <tt>a</tt> is via <tt>liftDupable</tt> (defined in the
--   main API module because of a constraint requirement) which renames the
--   stored value along the way. This type is used whenever
--   
--   <ol>
--   <li>preserving global uniqueness is required</li>
--   <li>some value may be used multiple times</li>
--   </ol>
--   
--   so we annotate such a value with <a>Dupable</a> and call
--   <tt>liftDupable</tt> at each usage, which ensures global uniqueness is
--   preserved.
--   
--   <a>unDupable</a> is not supposed to be exported. Don't provide any
--   instances allowing the user to access the underlying value.
newtype Dupable a
Dupable :: a -> Dupable a
[unDupable] :: Dupable a -> a

-- | Replace the unique in the name stored in a <a>TyVarDecl</a> by a new
--   unique, save the mapping from the old unique to the new one and supply
--   the updated <a>TyVarDecl</a> to a continuation.
withFreshenedTyVarDecl :: (HasRenaming ren TypeUnique, HasUniques (Type tyname uni ann), MonadQuote m, MonadReader ren m) => TyVarDecl tyname ann -> (TyVarDecl tyname ann -> m c) -> m c

-- | Replace the unique in the name stored in a <a>VarDecl</a> by a new
--   unique, save the mapping from the old unique to the new one and supply
--   to a continuation the computation that renames the type stored in the
--   updated <a>VarDecl</a>. The reason the continuation receives a
--   computation rather than a pure term is that we may want to bring
--   several term and type variables in scope before renaming the types of
--   term variables. This situation arises when we want to rename a bunch
--   of mutually recursive bindings.
withFreshenedVarDecl :: (HasUniques (Term tyname name uni fun ann), MonadQuote m, MonadReader ScopedRenaming m) => VarDecl tyname name uni ann -> (m (VarDecl tyname name uni ann) -> m c) -> m c

-- | Rename a <a>Kind</a> in the <tt>RenameM</tt> monad.
renameTypeM :: (HasRenaming ren TypeUnique, HasUniques (Type tyname uni ann), MonadQuote m, MonadReader ren m) => Type tyname uni ann -> m (Type tyname uni ann)

-- | Rename a <a>Term</a> in the <tt>RenameM</tt> monad.
renameTermM :: (HasUniques (Term tyname name uni fun ann), MonadQuote m, MonadReader ScopedRenaming m) => Term tyname name uni fun ann -> m (Term tyname name uni fun ann)

-- | Rename a <a>Program</a> in the <tt>RenameM</tt> monad.
renameProgramM :: (HasUniques (Program tyname name uni fun ann), MonadQuote m, MonadReader ScopedRenaming m) => Program tyname name uni fun ann -> m (Program tyname name uni fun ann)
instance GHC.Classes.Eq a => GHC.Classes.Eq (PlutusCore.Rename.Internal.Renamed a)
instance GHC.Show.Show a => GHC.Show.Show (PlutusCore.Rename.Internal.Renamed a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (PlutusCore.Rename.Internal.Dupable a)
instance GHC.Show.Show a => GHC.Show.Show (PlutusCore.Rename.Internal.Dupable a)

module PlutusCore.Mark

-- | Marks all the <a>Unique</a>s in a term as used, so they will not be
--   generated in future. Useful if you have a term which was not generated
--   in <a>Quote</a>.
markNonFreshTerm :: (HasUniques (Term tyname name uni fun ann), MonadQuote m) => Term tyname name uni fun ann -> m ()

-- | Marks all the <a>Unique</a>s in a type as used, so they will not be
--   generated in future. Useful if you have a type which was not generated
--   in <a>Quote</a>.
markNonFreshType :: (HasUniques (Type tyname uni ann), MonadQuote m) => Type tyname uni ann -> m ()

-- | Marks all the <a>Unique</a>s in a program as used, so they will not be
--   generated in future. Useful if you have a program which was not
--   generated in <a>Quote</a>.
markNonFreshProgram :: (HasUnique tyname TypeUnique, HasUnique name TermUnique, MonadQuote m) => Program tyname name uni fun ann -> m ()


-- | The user-facing API of the renamer.
module PlutusCore.Rename

-- | A wrapper for signifying that the value inside of it satisfies global
--   uniqueness.
--   
--   It's safe to call <a>unRenamed</a>, it's not safe to call
--   <a>Renamed</a>, hence the latter is only exported from this internal
--   module and should not be exported from the main API.
--   
--   Don't provide any instances allowing the user to create a
--   <a>Renamed</a> (even out of an existing one like with <a>Functor</a>).
data Renamed a

-- | The class of things that can be renamed. I.e. things that are capable
--   of satisfying the global uniqueness condition.
class Rename a

-- | Rename <a>Unique</a>s so that they're globally unique. In case there
--   are any free variables, they must be left untouched and bound
--   variables must not get renamed to free ones. Must always assign new
--   names to bound variables, so that <tt>rename</tt> can be used for
--   alpha-renaming as well.
rename :: (Rename a, MonadQuote m) => a -> m a

-- | <a>rename</a> a value and wrap the result in <a>Renamed</a>, so that
--   it can be passed around and it's visible in the types that the thing
--   inside satisfies global uniqueness.
getRenamed :: (Rename a, MonadQuote m) => a -> m (Renamed a)

-- | <tt>Dupable a</tt> is isomorphic to <tt>a</tt>, but the only way to
--   extract the <tt>a</tt> is via <tt>liftDupable</tt> (defined in the
--   main API module because of a constraint requirement) which renames the
--   stored value along the way. This type is used whenever
--   
--   <ol>
--   <li>preserving global uniqueness is required</li>
--   <li>some value may be used multiple times</li>
--   </ol>
--   
--   so we annotate such a value with <a>Dupable</a> and call
--   <tt>liftDupable</tt> at each usage, which ensures global uniqueness is
--   preserved.
--   
--   <a>unDupable</a> is not supposed to be exported. Don't provide any
--   instances allowing the user to access the underlying value.
data Dupable a

-- | Wrap a value in <a>Dupable</a>.
dupable :: a -> Dupable a

-- | Extract the value stored in a <tt>Dupable a</tt> and rename it.
liftDupable :: (MonadQuote m, Rename a) => Dupable a -> m a
instance PlutusCore.Core.Type.HasUniques (PlutusCore.Core.Type.Type tyname uni ann) => PlutusCore.Rename.Rename (PlutusCore.Core.Type.Type tyname uni ann)
instance PlutusCore.Core.Type.HasUniques (PlutusCore.Core.Type.Term tyname name uni fun ann) => PlutusCore.Rename.Rename (PlutusCore.Core.Type.Term tyname name uni fun ann)
instance PlutusCore.Core.Type.HasUniques (PlutusCore.Core.Type.Program tyname name uni fun ann) => PlutusCore.Rename.Rename (PlutusCore.Core.Type.Program tyname name uni fun ann)
instance PlutusCore.Rename.Rename a => PlutusCore.Rename.Rename (PlutusCore.Core.Type.Normalized a)


-- | Machinery defined in this module allows to export mulptiple Plutus
--   Core definitions (types and terms) as a single value which enables
--   convenient testing of various procedures (pretty-printing, type
--   checking, etc): each time a function / data type is added to that
--   value, none of the tests is required to be adapted, instead all the
--   tests see the new definition automatically.
module PlutusCore.FsTree

-- | An <a>FsTree</a> is either a file or a folder with a list of
--   <a>FsTree</a>s inside.
data FsTree a
FsFolder :: String -> FolderContents a -> FsTree a
FsFile :: String -> a -> FsTree a

-- | The contents of a folder. A wrapper around <tt>[FsTree a]</tt>. Exists
--   because of its <a>Semigroup</a> instance which allows to concatenate
--   two <a>FolderContents</a>s without placing them into the same folder
--   immediately, so we can have various PLC "modules" (<tt>stdlib</tt>,
--   <tt>examples</tt>, etc), define compound modules (e.g. <tt>stdlib
--   &lt;&gt; examples</tt>) and run various tests (pretty-printing, type
--   synthesis, etc) against simple and compound modules uniformly.
newtype FolderContents a
FolderContents :: [FsTree a] -> FolderContents a
[unFolderContents] :: FolderContents a -> [FsTree a]

-- | A <a>PlcEntity</a> is either a <a>Kind</a> or a <a>Term</a>.
data PlcEntity uni fun
PlcType :: Type TyName uni () -> PlcEntity uni fun
PlcTerm :: Term TyName Name uni fun () -> PlcEntity uni fun
type PlcFsTree uni fun = FsTree (PlcEntity uni fun)
type PlcFolderContents uni fun = FolderContents (PlcEntity uni fun)

-- | Construct an <a>FsTree</a> out of the name of a folder and a list of
--   <a>FsTree</a>s.
treeFolderContents :: String -> [FsTree a] -> FsTree a

-- | Construct a single-file <a>PlcFsTree</a> out of a type.
plcTypeFile :: String -> Type TyName uni () -> PlcFsTree uni fun

-- | Construct a single-file <a>PlcFsTree</a> out of a term.
plcTermFile :: String -> Term TyName Name uni fun () -> PlcFsTree uni fun

-- | Fold a <a>FsTree</a>.
foldFsTree :: (String -> [b] -> b) -> (String -> a -> b) -> FsTree a -> b

-- | Fold a <a>PlcFsTree</a>.
foldPlcFsTree :: (String -> [b] -> b) -> (String -> Type TyName uni () -> b) -> (String -> Term TyName Name uni fun () -> b) -> PlcFsTree uni fun -> b

-- | Fold the contents of a PLC folder.
foldPlcFolderContents :: (String -> [b] -> b) -> (String -> Type TyName uni () -> b) -> (String -> Term TyName Name uni fun () -> b) -> PlcFolderContents uni fun -> [b]
instance GHC.Base.Monoid (PlutusCore.FsTree.FolderContents a)
instance GHC.Base.Semigroup (PlutusCore.FsTree.FolderContents a)


-- | Flat instances for Plutus Core types. Make sure to read Note [Stable
--   encoding of TPLC] and Note [Stable encoding of UPLC] before touching
--   anything in this file.
module PlutusCore.Flat
safeEncodeBits :: NumBits -> Word8 -> Encoding
instance Flat.Class.Flat PlutusCore.Data.Data
instance Flat.Class.Flat PlutusCore.Name.Unique.Unique
instance Flat.Class.Flat PlutusCore.Name.Unique.TyName
instance Flat.Class.Flat a => Flat.Class.Flat (PlutusCore.Core.Type.Normalized a)
instance Flat.Class.Flat PlutusCore.DeBruijn.Internal.Index
instance Flat.Class.Flat PlutusCore.DeBruijn.Internal.DeBruijn
instance Flat.Class.Flat PlutusCore.DeBruijn.Internal.TyDeBruijn
instance Flat.Class.Flat PlutusCore.DeBruijn.Internal.NamedTyDeBruijn
instance Flat.Class.Flat (PlutusCore.Core.Type.Binder PlutusCore.Name.Unique.Name)
instance Flat.Class.Flat (PlutusCore.Core.Type.Binder PlutusCore.Name.Unique.TyName)
instance Flat.Class.Flat (PlutusCore.Core.Type.Binder PlutusCore.DeBruijn.Internal.NamedDeBruijn)
instance Flat.Class.Flat (PlutusCore.Core.Type.Binder PlutusCore.DeBruijn.Internal.NamedTyDeBruijn)
instance Universe.Core.Closed uni => Flat.Class.Flat (Universe.Core.SomeTypeIn uni)
instance (Universe.Core.Closed uni, Universe.Core.Everywhere uni Flat.Class.Flat) => Flat.Class.Flat (Data.Some.Newtype.Some (Universe.Core.ValueOf uni))
instance Flat.Class.Flat PlutusCore.Name.Unique.Name
instance Flat.Class.Flat PlutusCore.Version.Version
instance Flat.Class.Flat ann => Flat.Class.Flat (PlutusCore.Core.Type.Kind ann)
instance (Universe.Core.Closed uni, Flat.Class.Flat ann, Flat.Class.Flat tyname) => Flat.Class.Flat (PlutusCore.Core.Type.Type tyname uni ann)
instance (Universe.Core.Closed uni, Universe.Core.Everywhere uni Flat.Class.Flat, Flat.Class.Flat fun, Flat.Class.Flat ann, Flat.Class.Flat tyname, Flat.Class.Flat name) => Flat.Class.Flat (PlutusCore.Core.Type.Term tyname name uni fun ann)
instance (Universe.Core.Closed uni, Flat.Class.Flat ann, Flat.Class.Flat tyname, Flat.Class.Flat name) => Flat.Class.Flat (PlutusCore.Core.Type.VarDecl tyname name uni ann)
instance (Flat.Class.Flat ann, Flat.Class.Flat tyname) => Flat.Class.Flat (PlutusCore.Core.Type.TyVarDecl tyname ann)
instance (Flat.Class.Flat ann, Flat.Class.Flat (PlutusCore.Core.Type.Term tyname name uni fun ann)) => Flat.Class.Flat (PlutusCore.Core.Type.Program tyname name uni fun ann)
instance Flat.Class.Flat PlutusCore.DeBruijn.Internal.NamedDeBruijn
instance Flat.Class.Flat (PlutusCore.Core.Type.Binder PlutusCore.DeBruijn.Internal.DeBruijn)
instance Flat.Class.Flat PlutusCore.DeBruijn.Internal.FakeNamedDeBruijn
instance Flat.Class.Flat (PlutusCore.Core.Type.Binder PlutusCore.DeBruijn.Internal.FakeNamedDeBruijn)

module PlutusCore.Error

-- | An error encountered during parsing.
data ParserError
BuiltinTypeNotAStar :: !Text -> !SourcePos -> ParserError
UnknownBuiltinFunction :: !Text -> !SourcePos -> ![Text] -> ParserError
InvalidBuiltinConstant :: !Text -> !Text -> !SourcePos -> ParserError
class AsParserErrorBundle r_a7Uyo
_ParserErrorBundle :: AsParserErrorBundle r_a7Uyo => Prism' r_a7Uyo ParserErrorBundle
_ParseErrorB :: AsParserErrorBundle r_a7Uyo => Prism' r_a7Uyo (ParseErrorBundle Text ParserError)
data ParserErrorBundle
ParseErrorB :: !ParseErrorBundle Text ParserError -> ParserErrorBundle
data NormCheckError tyname name uni fun ann
BadType :: !ann -> !Type tyname uni ann -> !Text -> NormCheckError tyname name uni fun ann
BadTerm :: !ann -> !Term tyname name uni fun ann -> !Text -> NormCheckError tyname name uni fun ann
class AsNormCheckError r_a7UGI tyname_a7ScT name_a7ScU uni_a7ScV fun_a7ScW ann_a7ScX | r_a7UGI -> tyname_a7ScT name_a7ScU uni_a7ScV fun_a7ScW ann_a7ScX
_NormCheckError :: AsNormCheckError r_a7UGI tyname_a7ScT name_a7ScU uni_a7ScV fun_a7ScW ann_a7ScX => Prism' r_a7UGI (NormCheckError tyname_a7ScT name_a7ScU uni_a7ScV fun_a7ScW ann_a7ScX)
_BadType :: AsNormCheckError r_a7UGI tyname_a7ScT name_a7ScU uni_a7ScV fun_a7ScW ann_a7ScX => Prism' r_a7UGI (ann_a7ScX, Type tyname_a7ScT uni_a7ScV ann_a7ScX, Text)
_BadTerm :: AsNormCheckError r_a7UGI tyname_a7ScT name_a7ScU uni_a7ScV fun_a7ScW ann_a7ScX => Prism' r_a7UGI (ann_a7ScX, Term tyname_a7ScT name_a7ScU uni_a7ScV fun_a7ScW ann_a7ScX, Text)
data UniqueError ann
MultiplyDefined :: !Unique -> !ann -> !ann -> UniqueError ann
IncoherentUsage :: !Unique -> !ann -> !ann -> UniqueError ann
FreeVariable :: !Unique -> !ann -> UniqueError ann
class AsUniqueError r_a7UAM ann_a7ScY | r_a7UAM -> ann_a7ScY
_UniqueError :: AsUniqueError r_a7UAM ann_a7ScY => Prism' r_a7UAM (UniqueError ann_a7ScY)
_MultiplyDefined :: AsUniqueError r_a7UAM ann_a7ScY => Prism' r_a7UAM (Unique, ann_a7ScY, ann_a7ScY)
_IncoherentUsage :: AsUniqueError r_a7UAM ann_a7ScY => Prism' r_a7UAM (Unique, ann_a7ScY, ann_a7ScY)
_FreeVariable :: AsUniqueError r_a7UAM ann_a7ScY => Prism' r_a7UAM (Unique, ann_a7ScY)

-- | This is needed for nice kind/type checking error messages. In some
--   cases the type checker knows the exact type that an expression has to
--   have for type checking to succeed (see any of <tt>checkTypeM</tt>
--   functions and its usages), which is what <a>ExpectedExact</a> is
--   suitable for. In other cases the type checker only cares about the
--   shape of the inferred type, e.g. the type checker knows that the type
--   of a function has to be <tt>dom -&gt; cod</tt> for type checking to
--   succeed, but it doesn't yet care what <tt>dom</tt> and <tt>cod</tt>
--   exactly are. Which is what <a>ExpectedShape</a> is useful for as it
--   allows one to specify the shape of an expected type with some
--   existential variables in it when it's impossible to provide an exact
--   type.
data ExpectedShapeOr a
ExpectedShape :: !Text -> ![Text] -> ExpectedShapeOr a
ExpectedExact :: !a -> ExpectedShapeOr a
data TypeError term uni fun ann
KindMismatch :: !ann -> !Type TyName uni () -> !ExpectedShapeOr (Kind ()) -> !Kind () -> TypeError term uni fun ann
TypeMismatch :: !ann -> !term -> !ExpectedShapeOr (Type TyName uni ()) -> !Normalized (Type TyName uni ()) -> TypeError term uni fun ann
TyNameMismatch :: !ann -> !TyName -> !TyName -> TypeError term uni fun ann
NameMismatch :: !ann -> !Name -> !Name -> TypeError term uni fun ann
FreeTypeVariableE :: !ann -> !TyName -> TypeError term uni fun ann
FreeVariableE :: !ann -> !Name -> TypeError term uni fun ann
UnknownBuiltinFunctionE :: !ann -> !fun -> TypeError term uni fun ann
class AsTypeError r_a7UN6 term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR | r_a7UN6 -> term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR
_TypeError :: AsTypeError r_a7UN6 term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR => Prism' r_a7UN6 (TypeError term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR)
_KindMismatch :: AsTypeError r_a7UN6 term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR => Prism' r_a7UN6 (ann_a7ScR, Type TyName uni_a7ScP (), ExpectedShapeOr (Kind ()), Kind ())
_TypeMismatch :: AsTypeError r_a7UN6 term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR => Prism' r_a7UN6 (ann_a7ScR, term_a7ScO, ExpectedShapeOr (Type TyName uni_a7ScP ()), Normalized (Type TyName uni_a7ScP ()))
_TyNameMismatch :: AsTypeError r_a7UN6 term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR => Prism' r_a7UN6 (ann_a7ScR, TyName, TyName)
_NameMismatch :: AsTypeError r_a7UN6 term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR => Prism' r_a7UN6 (ann_a7ScR, Name, Name)
_FreeTypeVariableE :: AsTypeError r_a7UN6 term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR => Prism' r_a7UN6 (ann_a7ScR, TyName)
_FreeVariableE :: AsTypeError r_a7UN6 term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR => Prism' r_a7UN6 (ann_a7ScR, Name)
_UnknownBuiltinFunctionE :: AsTypeError r_a7UN6 term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR => Prism' r_a7UN6 (ann_a7ScR, fun_a7ScQ)

-- | We cannot do a correct translation to or from de Bruijn indices if the
--   program is not well-scoped. So we throw an error in such a case.
data FreeVariableError
FreeUnique :: !Unique -> FreeVariableError
FreeIndex :: !Index -> FreeVariableError
class AsFreeVariableError r_a1KDI
_FreeVariableError :: AsFreeVariableError r_a1KDI => Prism' r_a1KDI FreeVariableError
_FreeUnique :: AsFreeVariableError r_a1KDI => Prism' r_a1KDI Unique
_FreeIndex :: AsFreeVariableError r_a1KDI => Prism' r_a1KDI Index
data Error uni fun ann
ParseErrorE :: !ParserErrorBundle -> Error uni fun ann
UniqueCoherencyErrorE :: !UniqueError ann -> Error uni fun ann
TypeErrorE :: !TypeError (Term TyName Name uni fun ()) uni fun ann -> Error uni fun ann
NormCheckErrorE :: !NormCheckError TyName Name uni fun ann -> Error uni fun ann
FreeVariableErrorE :: !FreeVariableError -> Error uni fun ann
class AsError r_a7V3b uni_a7ScL fun_a7ScM ann_a7ScN | r_a7V3b -> uni_a7ScL fun_a7ScM ann_a7ScN
_Error :: AsError r_a7V3b uni_a7ScL fun_a7ScM ann_a7ScN => Prism' r_a7V3b (Error uni_a7ScL fun_a7ScM ann_a7ScN)
_ParseErrorE :: AsError r_a7V3b uni_a7ScL fun_a7ScM ann_a7ScN => Prism' r_a7V3b ParserErrorBundle
_UniqueCoherencyErrorE :: AsError r_a7V3b uni_a7ScL fun_a7ScM ann_a7ScN => Prism' r_a7V3b (UniqueError ann_a7ScN)
_TypeErrorE :: AsError r_a7V3b uni_a7ScL fun_a7ScM ann_a7ScN => Prism' r_a7V3b (TypeError (Term TyName Name uni_a7ScL fun_a7ScM ()) uni_a7ScL fun_a7ScM ann_a7ScN)
_NormCheckErrorE :: AsError r_a7V3b uni_a7ScL fun_a7ScM ann_a7ScN => Prism' r_a7V3b (NormCheckError TyName Name uni_a7ScL fun_a7ScM ann_a7ScN)
_FreeVariableErrorE :: AsError r_a7V3b uni_a7ScL fun_a7ScM ann_a7ScN => Prism' r_a7V3b FreeVariableError

-- | Lifts an <a>Either</a> into an error context where we can embed the
--   <a>Left</a> value into the error.
throwingEither :: MonadError e m => AReview e t -> Either t a -> m a
class Ord a => ShowErrorComponent a
showErrorComponent :: ShowErrorComponent a => a -> String
errorComponentLen :: ShowErrorComponent a => a -> Int

-- | Errors from <tt>applyProgram</tt> for PIR, PLC, UPLC.
data ApplyProgramError
MkApplyProgramError :: Version -> Version -> ApplyProgramError
instance GHC.Show.Show PlutusCore.Error.ApplyProgramError
instance GHC.Exception.Type.Exception PlutusCore.Error.ApplyProgramError
instance PlutusCore.Error.AsError (PlutusCore.Error.Error uni fun ann) uni fun ann
instance PlutusCore.Error.AsParserErrorBundle (PlutusCore.Error.Error uni fun ann)
instance PlutusCore.Error.AsUniqueError (PlutusCore.Error.Error uni fun ann) ann
instance PlutusCore.Error.AsTypeError (PlutusCore.Error.Error uni fun ann) (PlutusCore.Core.Type.Term PlutusCore.Name.Unique.TyName PlutusCore.Name.Unique.Name uni fun ()) uni fun ann
instance (tyname GHC.Types.~ PlutusCore.Name.Unique.TyName, name GHC.Types.~ PlutusCore.Name.Unique.Name) => PlutusCore.Error.AsNormCheckError (PlutusCore.Error.Error uni fun ann) tyname name uni fun ann
instance PlutusCore.DeBruijn.Internal.AsFreeVariableError (PlutusCore.Error.Error uni fun ann)
instance PlutusCore.Error.AsTypeError (PlutusCore.Error.TypeError term uni fun ann) term uni fun ann
instance PlutusCore.Error.AsNormCheckError (PlutusCore.Error.NormCheckError tyname name uni fun ann) tyname name uni fun ann
instance PlutusCore.Error.AsUniqueError (PlutusCore.Error.UniqueError ann) ann
instance PlutusCore.Error.AsParserErrorBundle PlutusCore.Error.ParserErrorBundle
instance PlutusCore.Error.AsParseError (Text.Megaparsec.Error.ParseError s e) s e
instance Control.DeepSeq.NFData PlutusCore.Error.ParserError
instance GHC.Generics.Generic PlutusCore.Error.ParserError
instance GHC.Classes.Ord PlutusCore.Error.ParserError
instance GHC.Classes.Eq PlutusCore.Error.ParserError
instance Control.DeepSeq.NFData ann => Control.DeepSeq.NFData (PlutusCore.Error.UniqueError ann)
instance GHC.Base.Functor PlutusCore.Error.UniqueError
instance GHC.Generics.Generic (PlutusCore.Error.UniqueError ann)
instance GHC.Classes.Eq ann => GHC.Classes.Eq (PlutusCore.Error.UniqueError ann)
instance GHC.Show.Show ann => GHC.Show.Show (PlutusCore.Error.UniqueError ann)
instance GHC.Generics.Generic (PlutusCore.Error.NormCheckError tyname name uni fun ann)
instance GHC.Base.Functor (PlutusCore.Error.NormCheckError tyname name uni fun)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (PlutusCore.Error.ExpectedShapeOr a)
instance GHC.Base.Functor PlutusCore.Error.ExpectedShapeOr
instance GHC.Generics.Generic (PlutusCore.Error.ExpectedShapeOr a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (PlutusCore.Error.ExpectedShapeOr a)
instance GHC.Show.Show a => GHC.Show.Show (PlutusCore.Error.ExpectedShapeOr a)
instance (Universe.Core.Closed uni, Control.DeepSeq.NFData ann, Control.DeepSeq.NFData term, Control.DeepSeq.NFData fun) => Control.DeepSeq.NFData (PlutusCore.Error.TypeError term uni fun ann)
instance GHC.Base.Functor (PlutusCore.Error.TypeError term uni fun)
instance GHC.Generics.Generic (PlutusCore.Error.TypeError term uni fun ann)
instance (Data.GADT.Internal.GEq uni, GHC.Classes.Eq term, GHC.Classes.Eq ann, GHC.Classes.Eq fun) => GHC.Classes.Eq (PlutusCore.Error.TypeError term uni fun ann)
instance (Data.GADT.Internal.GShow uni, GHC.Show.Show term, GHC.Show.Show ann, GHC.Show.Show fun) => GHC.Show.Show (PlutusCore.Error.TypeError term uni fun ann)
instance Control.DeepSeq.NFData PlutusCore.Error.ParserErrorBundle
instance GHC.Generics.Generic PlutusCore.Error.ParserErrorBundle
instance GHC.Classes.Eq PlutusCore.Error.ParserErrorBundle
instance GHC.Base.Functor (PlutusCore.Error.Error uni fun)
instance GHC.Generics.Generic (PlutusCore.Error.Error uni fun ann)
instance (Control.DeepSeq.NFData tyname, Control.DeepSeq.NFData name, Universe.Core.Closed uni, Universe.Core.Everywhere uni Control.DeepSeq.NFData, Control.DeepSeq.NFData fun, Control.DeepSeq.NFData ann) => Control.DeepSeq.NFData (PlutusCore.Error.NormCheckError tyname name uni fun ann)
instance (GHC.Show.Show tyname, GHC.Show.Show name, Universe.Core.Closed uni, Universe.Core.Everywhere uni GHC.Show.Show, GHC.Show.Show fun, GHC.Show.Show ann, Data.GADT.Internal.GShow uni) => GHC.Show.Show (PlutusCore.Error.NormCheckError tyname name uni fun ann)
instance (GHC.Classes.Eq (PlutusCore.Core.Type.Term tyname name uni fun ann), GHC.Classes.Eq (PlutusCore.Core.Type.Type tyname uni ann), Data.GADT.Internal.GEq uni, Universe.Core.Closed uni, Universe.Core.Everywhere uni GHC.Classes.Eq, GHC.Classes.Eq fun, GHC.Classes.Eq ann) => GHC.Classes.Eq (PlutusCore.Error.NormCheckError tyname name uni fun ann)
instance (GHC.Classes.Eq fun, GHC.Classes.Eq ann, Universe.Core.Closed uni, Universe.Core.Everywhere uni GHC.Classes.Eq, Data.GADT.Internal.GEq uni, GHC.Classes.Eq PlutusCore.Error.ParserError) => GHC.Classes.Eq (PlutusCore.Error.Error uni fun ann)
instance (Control.DeepSeq.NFData fun, Control.DeepSeq.NFData ann, Universe.Core.Closed uni, Universe.Core.Everywhere uni Control.DeepSeq.NFData, Control.DeepSeq.NFData PlutusCore.Error.ParserError) => Control.DeepSeq.NFData (PlutusCore.Error.Error uni fun ann)
instance (GHC.Show.Show fun, GHC.Show.Show ann, Universe.Core.Closed uni, Universe.Core.Everywhere uni GHC.Show.Show, Data.GADT.Internal.GShow uni, GHC.Show.Show PlutusCore.Error.ParserError) => GHC.Show.Show (PlutusCore.Error.Error uni fun ann)
instance (PlutusCore.Pretty.PrettyConst.PrettyUni uni, Prettyprinter.Internal.Pretty fun, Prettyprinter.Internal.Pretty ann) => Text.PrettyBy.Internal.PrettyBy PlutusCore.Pretty.Plc.PrettyConfigPlc (PlutusCore.Error.Error uni fun ann)
instance Prettyprinter.Internal.Pretty PlutusCore.Error.ParserErrorBundle
instance GHC.Show.Show PlutusCore.Error.ParserErrorBundle
instance (Prettyprinter.Internal.Pretty term, PlutusCore.Pretty.PrettyConst.PrettyUni uni, Prettyprinter.Internal.Pretty fun, Prettyprinter.Internal.Pretty ann) => Text.PrettyBy.Internal.PrettyBy PlutusCore.Pretty.Plc.PrettyConfigPlc (PlutusCore.Error.TypeError term uni fun ann)
instance Text.PrettyBy.Internal.PrettyBy PlutusCore.Pretty.Plc.PrettyConfigPlc a => Text.PrettyBy.Internal.PrettyBy PlutusCore.Pretty.Plc.PrettyConfigPlc (PlutusCore.Error.ExpectedShapeOr a)
instance (Prettyprinter.Internal.Pretty ann, Text.PrettyBy.Internal.PrettyBy config (PlutusCore.Core.Type.Type tyname uni ann), Text.PrettyBy.Internal.PrettyBy config (PlutusCore.Core.Type.Term tyname name uni fun ann)) => Text.PrettyBy.Internal.PrettyBy config (PlutusCore.Error.NormCheckError tyname name uni fun ann)
instance GHC.Exception.Type.Exception (PlutusCore.Error.UniqueError PlutusCore.Annotation.SrcSpan)
instance Prettyprinter.Internal.Pretty ann => Prettyprinter.Internal.Pretty (PlutusCore.Error.UniqueError ann)
instance GHC.Show.Show PlutusCore.Error.ParserError
instance Prettyprinter.Internal.Pretty PlutusCore.Error.ParserError
instance Text.Megaparsec.Error.ShowErrorComponent PlutusCore.Error.ParserError
instance Prettyprinter.Internal.Pretty Text.Megaparsec.Pos.SourcePos


-- | Definition analysis for Plutus Core.
module PlutusCore.Analysis.Definitions
type UniqueInfos ann = UniqueMap Unique (UniqueInfo ann)

-- | Tag for distinguishing between whether we are talking about the term
--   scope for variables or the type scope for variables.
data ScopeType
TermScope :: ScopeType
TypeScope :: ScopeType

-- | Given a PLC term, add all of its term and type definitions and usages,
--   including its subterms and subtypes, to a global map.
termDefs :: (Ord ann, HasUnique name TermUnique, HasUnique tyname TypeUnique, MonadState (UniqueInfos ann) m, MonadWriter [UniqueError ann] m) => Term tyname name uni fun ann -> m ()

-- | Given a type, add its type definition/usage, including its subtypes,
--   to a global map.
handleType :: (Ord ann, HasUnique tyname TypeUnique, MonadState (UniqueInfos ann) m, MonadWriter [UniqueError ann] m) => Type tyname uni ann -> m ()
runTermDefs :: (Ord ann, HasUnique name TermUnique, HasUnique tyname TypeUnique, Monad m) => Term tyname name uni fun ann -> m (UniqueInfos ann, [UniqueError ann])
addDef :: (Ord ann, HasUnique n unique, MonadState (UniqueInfos ann) m, MonadWriter [UniqueError ann] m) => n -> ann -> ScopeType -> m ()
addUsage :: (Ord ann, HasUnique n unique, MonadState (UniqueInfos ann) m, MonadWriter [UniqueError ann] m) => n -> ann -> ScopeType -> m ()
instance GHC.Classes.Ord PlutusCore.Analysis.Definitions.ScopeType
instance GHC.Classes.Eq PlutusCore.Analysis.Definitions.ScopeType
instance GHC.Classes.Ord ann => GHC.Classes.Ord (PlutusCore.Analysis.Definitions.ScopedLoc ann)
instance GHC.Classes.Eq ann => GHC.Classes.Eq (PlutusCore.Analysis.Definitions.ScopedLoc ann)

module PlutusCore.Check.Value
isTermValue :: Term tyname name uni fun ann -> Bool

module PlutusCore.Check.Uniques
checkProgram :: (Ord ann, HasUnique name TermUnique, HasUnique tyname TypeUnique, AsUniqueError e ann, MonadError e m) => (UniqueError ann -> Bool) -> Program tyname name uni fun ann -> m ()
checkTerm :: (Ord ann, HasUnique name TermUnique, HasUnique tyname TypeUnique, AsUniqueError e ann, MonadError e m) => (UniqueError ann -> Bool) -> Term tyname name uni fun ann -> m ()
data UniqueError ann
MultiplyDefined :: !Unique -> !ann -> !ann -> UniqueError ann
IncoherentUsage :: !Unique -> !ann -> !ann -> UniqueError ann
FreeVariable :: !Unique -> !ann -> UniqueError ann
class AsUniqueError r_a7UAM ann_a7ScY | r_a7UAM -> ann_a7ScY
_UniqueError :: AsUniqueError r_a7UAM ann_a7ScY => Prism' r_a7UAM (UniqueError ann_a7ScY)
_MultiplyDefined :: AsUniqueError r_a7UAM ann_a7ScY => Prism' r_a7UAM (Unique, ann_a7ScY, ann_a7ScY)
_IncoherentUsage :: AsUniqueError r_a7UAM ann_a7ScY => Prism' r_a7UAM (Unique, ann_a7ScY, ann_a7ScY)
_FreeVariable :: AsUniqueError r_a7UAM ann_a7ScY => Prism' r_a7UAM (Unique, ann_a7ScY)

module PlutusCore.Builtin.Elaborate

-- | Specialize each Haskell type variable in <tt>a</tt> as a type
--   representing a PLC type variable. <tt>i</tt> is a fresh id and
--   <tt>j</tt> is a final one as in <a>TrySpecializeAsVar</a>, but since
--   <a>HandleHole</a> can specialize multiple variables, <tt>j</tt> can be
--   equal to <tt>i + n</tt> for any <tt>n</tt> (including <tt>0</tt>).
type ElaborateFromTo uni i j val a = HandleHole uni i j val (TypeHole a)
instance forall a (i :: GHC.TypeNats.Nat) (j :: GHC.TypeNats.Nat) (x :: a) (uni :: * -> *) (k :: GHC.TypeNats.Nat) val. (PlutusCore.Builtin.Elaborate.TrySpecializeAsUnappliedVar i j PlutusCore.Builtin.KnownTypeAst.RepHole 'GHC.Maybe.Nothing x, PlutusCore.Builtin.Elaborate.HandleHoles uni j k val x) => PlutusCore.Builtin.Elaborate.HandleHole uni i k val (PlutusCore.Builtin.KnownTypeAst.RepHole x)
instance (PlutusCore.Builtin.Elaborate.TrySpecializeAsUnappliedVar i j PlutusCore.Builtin.KnownTypeAst.TypeHole ('GHC.Maybe.Just (PlutusCore.Builtin.Polymorphism.Opaque val)) a, PlutusCore.Builtin.Elaborate.HandleHoles uni j k val a) => PlutusCore.Builtin.Elaborate.HandleHole uni i k val (PlutusCore.Builtin.KnownTypeAst.TypeHole a)
instance (i GHC.Types.~ j) => PlutusCore.Builtin.Elaborate.HandleHolesGo uni i j val '[]
instance (PlutusCore.Builtin.Elaborate.HandleHole uni i j val hole, PlutusCore.Builtin.Elaborate.HandleHolesGo uni j k val holes) => PlutusCore.Builtin.Elaborate.HandleHolesGo uni i k val (hole : holes)
instance forall a k1 (i :: GHC.TypeNats.Nat) (j :: GHC.TypeNats.Nat) (hole :: * -> *) (f :: a -> k1) (k2 :: GHC.TypeNats.Nat) (mw :: GHC.Maybe.Maybe (k1 -> k1)) (x :: a). (PlutusCore.Builtin.Elaborate.TrySpecializeHeadAsVar i j hole f, PlutusCore.Builtin.Elaborate.TrySpecializeAsVar j k2 mw (f x)) => PlutusCore.Builtin.Elaborate.TrySpecializeAsUnappliedVar i k2 hole mw (f x)
instance forall k (i :: GHC.TypeNats.Nat) (j :: GHC.TypeNats.Nat) (mw :: GHC.Maybe.Maybe (k -> k)) (a :: k) (hole :: * -> *). PlutusCore.Builtin.Elaborate.TrySpecializeAsVar i j mw a => PlutusCore.Builtin.Elaborate.TrySpecializeAsUnappliedVar i j hole mw a
instance forall a1 a2 b (i :: GHC.TypeNats.Nat) (j :: GHC.TypeNats.Nat) (hole :: * -> *) (f :: a1 -> a2 -> b) (x :: a1). PlutusCore.Builtin.Elaborate.TrySpecializeHeadAsVar i j hole f => PlutusCore.Builtin.Elaborate.TrySpecializeHeadAsVar i j hole (f x)
instance forall a b (hole :: * -> *) (i :: GHC.TypeNats.Nat) (j :: GHC.TypeNats.Nat) (name :: PlutusCore.Builtin.Polymorphism.TyNameRep (a -> b)). (PlutusCore.Builtin.Elaborate.ThrowNoAppliedVars hole, i GHC.Types.~ j) => PlutusCore.Builtin.Elaborate.TrySpecializeHeadAsVar i j hole (PlutusCore.Builtin.Polymorphism.TyVarRep name)
instance forall a b (i :: GHC.TypeNats.Nat) (j :: GHC.TypeNats.Nat) (f :: a -> b) (hole :: * -> *). (PlutusCore.Builtin.Elaborate.TrySpecializeAsVar i j 'GHC.Maybe.Nothing f, PlutusCore.Builtin.Elaborate.CheckNotAppliedVar hole f) => PlutusCore.Builtin.Elaborate.TrySpecializeHeadAsVar i j hole f
instance forall k (var :: k) (mw :: GHC.Maybe.Maybe (k -> k)) (i :: GHC.TypeNats.Nat) (a :: k) (j :: GHC.Num.Natural.Natural). (var GHC.Types.~ PlutusCore.Builtin.Elaborate.MaybeApply mw (PlutusCore.Builtin.Polymorphism.TyVarRep ('PlutusCore.Builtin.Polymorphism.TyNameRep (PlutusCore.Builtin.Elaborate.GetName k i) i)), a PlutusCore.Builtin.Elaborate.~?~ var, j GHC.Types.~ Data.Type.Bool.If (a PlutusCore.Builtin.Elaborate.=== var) (i GHC.TypeNats.+ 1) i) => PlutusCore.Builtin.Elaborate.TrySpecializeAsVar i j mw a
instance forall a b (x :: a) (y :: b). ((x PlutusCore.Builtin.Elaborate.=== y) GHC.Types.~ 'GHC.Types.False) => PlutusCore.Builtin.Elaborate.TryUnify 'GHC.Types.False x y
instance forall a b (x :: a) (y :: b) (same :: GHC.Types.Bool). (x GHC.Types.~~ y, same GHC.Types.~ 'GHC.Types.True) => PlutusCore.Builtin.Elaborate.TryUnify same x y

module PlutusCore.Crypto.Ed25519

-- | Ed25519 signature verification This will fail if the key or the
--   signature are not of the expected length. This version uses the
--   cardano-crypto implementation of the verification function.
verifyEd25519Signature_V1 :: ByteString -> ByteString -> ByteString -> BuiltinResult Bool

-- | Ed25519 signature verification This will fail if the key or the
--   signature are not of the expected length. This version uses the
--   cardano-crypto-class implementation of the verification function
--   (using libsodium).
verifyEd25519Signature_V2 :: ByteString -> ByteString -> ByteString -> BuiltinResult Bool


-- | Reexports from modules from the <tt>Builtin</tt> folder.
module PlutusCore.Builtin

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class () => Typeable (a :: k)

-- | The type of type schemes of built-in functions. <tt>args</tt> is a
--   list of types of arguments, <tt>res</tt> is the resulting type. E.g.
--   <tt>Text -&gt; Bool -&gt; Integer</tt> is encoded as <tt>TypeScheme
--   val [Text, Bool] Integer</tt>.
data TypeScheme val (args :: [Type]) res
[TypeSchemeResult] :: (Typeable res, KnownTypeAst TyName (UniOf val) res, MakeKnown val res) => TypeScheme val '[] res
[TypeSchemeArrow] :: (Typeable arg, KnownTypeAst TyName (UniOf val) arg, MakeKnown val arg, ReadKnown val arg) => TypeScheme val args res -> TypeScheme val (arg ': args) res
[TypeSchemeAll] :: (KnownSymbol text, KnownNat uniq, KnownKind kind) => Proxy '(text, uniq, kind) -> TypeScheme val args res -> TypeScheme val args res
infixr 9 `TypeSchemeArrow`
argProxy :: TypeScheme val (arg ': args) res -> Proxy arg

-- | Convert a <a>TypeScheme</a> to the corresponding <a>Kind</a>.
typeSchemeToType :: TypeScheme val args res -> Type TyName (UniOf val) ()

-- | An instance of this class not having any constraints ensures that
--   every type (according to <a>Everywhere</a>) from the universe has
--   'KnownTypeAst, <a>ReadKnownIn</a> and <a>MakeKnownIn</a> instances.
class (uni `Everywhere` ImplementedKnownTypeAst uni, uni `Everywhere` ImplementedReadKnownIn uni, uni `Everywhere` ImplementedMakeKnownIn uni) => TestTypesFromTheUniverseAreAllKnown uni

-- | A <a>BuiltinRuntime</a> represents a possibly partial builtin
--   application, including an empty builtin application (i.e. just the
--   builtin with no arguments).
--   
--   Applying or type-instantiating a builtin peels off the corresponding
--   constructor from its <a>BuiltinRuntime</a>.
--   
--   <a>BuiltinCostedResult</a> contains the cost (an <tt>ExBudget</tt>)
--   and the result (a <tt>BuiltinResult val</tt>) of the builtin
--   application. The cost is stored strictly, since the evaluator is going
--   to look at it and the result is stored lazily, since it's not supposed
--   to be forced before accounting for the cost of the application. If the
--   cost exceeds the available budget, the evaluator discards the result
--   of the builtin application without ever forcing it and terminates with
--   evaluation failure. Allowing the user to compute something that they
--   don't have the budget for would be a major bug.
--   
--   Evaluators that ignore the entire concept of costing (e.g. the CK
--   machine) may of course force the result of the builtin application
--   unconditionally.
data BuiltinRuntime val
BuiltinCostedResult :: ExBudgetStream -> ~BuiltinResult val -> BuiltinRuntime val
BuiltinExpectArgument :: (val -> BuiltinRuntime val) -> BuiltinRuntime val
BuiltinExpectForce :: BuiltinRuntime val -> BuiltinRuntime val

-- | A <tt>data</tt> wrapper around a function returning the
--   <a>BuiltinRuntime</a> of a built-in function. We use <tt>data</tt>
--   rather than <tt>newtype</tt>, because GHC is able to see through
--   <tt>newtype</tt>s and may break carefully set up optimizations, see
--   <a>https://github.com/IntersectMBO/plutus/pull/4914#issuecomment-1396306606</a>
--   
--   Using <tt>data</tt> may make things more expensive, however it was
--   verified at the time of writing that the wrapper is removed before the
--   CEK machine starts, leaving the stored function to be used directly.
--   
--   In order for lookups to be efficient the <a>BuiltinRuntime</a>s need
--   to be cached, i.e. pulled out of the function statically. See
--   <tt>makeBuiltinMeaning</tt> for how we achieve that.
data BuiltinsRuntime fun val
BuiltinsRuntime :: (fun -> BuiltinRuntime val) -> BuiltinsRuntime fun val
[unBuiltinsRuntime] :: BuiltinsRuntime fun val -> fun -> BuiltinRuntime val
builtinRuntimeFailure :: BuiltinError -> BuiltinRuntime val

-- | Look up the runtime info of a built-in function during evaluation.
lookupBuiltin :: fun -> BuiltinsRuntime fun val -> BuiltinRuntime val

-- | The type of errors that can occur during evaluation. There are two
--   kinds of errors:
--   
--   <ol>
--   <li>Structural ones -- these are errors that are indicative of the
--   _structure_ of the program being wrong. For example, a free variable
--   was encountered during evaluation, a non-function was applied to an
--   argument or <tt>tailList</tt> was applied to a non-list.</li>
--   <li>Operational ones -- these are errors that are indicative of the
--   _logic_ of the program being wrong. For example, <a>error</a> was
--   executed, <tt>tailList</tt> was applied to an empty list or evaluation
--   ran out of gas.</li>
--   </ol>
--   
--   On the chain both of these are just regular failures and we don't
--   distinguish between them there: if a script fails, it fails, it
--   doesn't matter what the reason was. However in the tests it does
--   matter why the failure occurred: a structural error may indicate that
--   the test was written incorrectly while an operational error may be
--   entirely expected.
--   
--   In other words, structural errors are "runtime type errors" and
--   operational errors are regular runtime errors. Which means that
--   evaluating an (erased) well-typed program should never produce a
--   structural error, only an operational one. This creates a sort of
--   "runtime type system" for UPLC and it would be great to stick to it
--   and enforce in tests etc, but we currently don't.
data EvaluationError structural operational
StructuralEvaluationError :: !structural -> EvaluationError structural operational
OperationalEvaluationError :: !operational -> EvaluationError structural operational
class AsEvaluationError r_a1wHB structural_a1wxv operational_a1wxw | r_a1wHB -> structural_a1wxv operational_a1wxw
_EvaluationError :: AsEvaluationError r_a1wHB structural_a1wxv operational_a1wxw => Prism' r_a1wHB (EvaluationError structural_a1wxv operational_a1wxw)
_StructuralEvaluationError :: AsEvaluationError r_a1wHB structural_a1wxv operational_a1wxw => Prism' r_a1wHB structural_a1wxv
_OperationalEvaluationError :: AsEvaluationError r_a1wHB structural_a1wxv operational_a1wxw => Prism' r_a1wHB operational_a1wxw

-- | The error message part of an <a>UnliftingEvaluationError</a>.
newtype UnliftingError
MkUnliftingError :: Text -> UnliftingError
[unUnliftingError] :: UnliftingError -> Text

-- | When unlifting of a PLC term into a Haskell value fails, this error is
--   thrown.
newtype UnliftingEvaluationError
MkUnliftingEvaluationError :: EvaluationError UnliftingError UnliftingError -> UnliftingEvaluationError
[unUnliftingEvaluationError] :: UnliftingEvaluationError -> EvaluationError UnliftingError UnliftingError

-- | The type of errors that <tt>readKnown</tt> and <tt>makeKnown</tt> can
--   return.
data BuiltinError
BuiltinUnliftingEvaluationError :: UnliftingEvaluationError -> BuiltinError
BuiltinEvaluationFailure :: BuiltinError

-- | The monad that <tt>makeKnown</tt> runs in. Equivalent to <tt>ExceptT
--   BuiltinError (Writer (DList Text))</tt>, except optimized in two ways:
--   
--   <ol>
--   <li>everything is strict</li>
--   <li>has the <a>BuiltinSuccess</a> constructor that is used for
--   returning a value with no logs attached, which is the most common case
--   for us, so it helps a lot not to construct and deconstruct a redundant
--   tuple</li>
--   </ol>
--   
--   Moving from <tt>ExceptT BuiltinError (Writer (DList Text))</tt> to
--   this data type gave us a speedup of 8% of total evaluation time.
--   
--   Logs are represented as a <a>DList</a>, because we don't particularly
--   care about the efficiency of logging, since there's no logging on the
--   chain and builtins don't emit much anyway. Otherwise we'd have to use
--   <tt>text-builder</tt> or <tt>text-builder-linear</tt> or something of
--   this sort.
data BuiltinResult a
BuiltinSuccess :: a -> BuiltinResult a
BuiltinSuccessWithLogs :: DList Text -> a -> BuiltinResult a
BuiltinFailure :: DList Text -> BuiltinError -> BuiltinResult a
class AsUnliftingEvaluationError r_a1ymn
_UnliftingEvaluationError :: AsUnliftingEvaluationError r_a1ymn => Prism' r_a1ymn UnliftingEvaluationError
_MkUnliftingEvaluationError :: AsUnliftingEvaluationError r_a1ymn => Prism' r_a1ymn (EvaluationError UnliftingError UnliftingError)
class AsUnliftingError r_a1ymj
_UnliftingError :: AsUnliftingError r_a1ymj => Prism' r_a1ymj UnliftingError
_MkUnliftingError :: AsUnliftingError r_a1ymj => Prism' r_a1ymj Text
class AsBuiltinError r_a1ymr
_BuiltinError :: AsBuiltinError r_a1ymr => Prism' r_a1ymr BuiltinError
_BuiltinUnliftingEvaluationError :: AsBuiltinError r_a1ymr => Prism' r_a1ymr UnliftingEvaluationError
_BuiltinEvaluationFailure :: AsBuiltinError r_a1ymr => Prism' r_a1ymr ()
class AsBuiltinResult r_a1ymz a_a1y32 | r_a1ymz -> a_a1y32
_BuiltinResult :: AsBuiltinResult r_a1ymz a_a1y32 => Prism' r_a1ymz (BuiltinResult a_a1y32)
_BuiltinSuccess :: AsBuiltinResult r_a1ymz a_a1y32 => Prism' r_a1ymz a_a1y32
_BuiltinSuccessWithLogs :: AsBuiltinResult r_a1ymz a_a1y32 => Prism' r_a1ymz (DList Text, a_a1y32)
_BuiltinFailure :: AsBuiltinResult r_a1ymz a_a1y32 => Prism' r_a1ymz (DList Text, BuiltinError)

-- | Construct a prism focusing on the <tt>*EvaluationFailure</tt> part of
--   <tt>err</tt> by taking that <tt>*EvaluationFailure</tt> and
--   
--   <ol>
--   <li>pretty-printing and embedding it into an <a>UnliftingError</a> for
--   the setter part of the prism</li>
--   <li>returning it directly for the opposite direction (there's no other
--   way to convert an <a>UnliftingError</a> to an evaluation failure,
--   since the latter doesn't carry any content)</li>
--   </ol>
--   
--   This is useful for providing <a>AsUnliftingError</a> instances for
--   types such as <tt>CkUserError</tt> and <tt>CekUserError</tt>.
_UnliftingErrorVia :: Pretty err => err -> Prism' err UnliftingError
_StructuralUnliftingError :: AsBuiltinError err => Prism' err UnliftingError
_OperationalUnliftingError :: AsBuiltinError err => Prism' err UnliftingError
throwNotAConstant :: MonadError BuiltinError m => m void
throwUnderTypeError :: MonadError BuiltinError m => m void

-- | Add a log line to the logs.
emit :: Text -> BuiltinResult ()

-- | Prepend logs to a <a>BuiltinResult</a> computation.
withLogs :: DList Text -> BuiltinResult a -> BuiltinResult a
throwing :: MonadError e m => AReview e t -> t -> m x
throwing_ :: MonadError e m => AReview e () -> m x

-- | The AST of a value with a Plutus type attached to it. The type is for
--   the Plutus type checker to look at. <a>Opaque</a> can appear in the
--   type of the denotation of a builtin.
newtype Opaque val (rep :: Type)
Opaque :: val -> Opaque val (rep :: Type)
[unOpaque] :: Opaque val (rep :: Type) -> val

-- | For unlifting from the <a>Constant</a> constructor when the stored
--   value is of a monomorphic built-in type
--   
--   The <tt>rep</tt> parameter specifies how the type looks on the PLC
--   side (i.e. just like with <tt>Opaque val rep</tt>).
newtype SomeConstant uni (rep :: Type)
SomeConstant :: Some (ValueOf uni) -> SomeConstant uni (rep :: Type)
[unSomeConstant] :: SomeConstant uni (rep :: Type) -> Some (ValueOf uni)

-- | Representation of a type variable: its name and unique and an implicit
--   kind.
data TyNameRep (kind :: Type)
TyNameRep :: Symbol -> Nat -> TyNameRep (kind :: Type)

-- | Representation of an intrinsically-kinded type variable: a name.
data family TyVarRep (name :: TyNameRep kind) :: kind

-- | Representation of an intrinsically-kinded type application: a function
--   and an argument.
data family TyAppRep (fun :: dom -> cod) (arg :: dom) :: cod

-- | Representation of of an intrinsically-kinded universal quantifier: a
--   bound name and a body.
data family TyForallRep (name :: TyNameRep kind) (a :: Type) :: Type

-- | For annotating an uninstantiated built-in type, so that it gets
--   handled by the right instance or type family.
data family BuiltinHead x

-- | Take an iterated application of a built-in type and elaborate every
--   function application inside of it to <a>TyAppRep</a> and annotate the
--   head with <a>BuiltinHead</a>.
--   
--   The idea is that we don't need to process built-in types manually if
--   we simply add some annotations for instance resolution to look for.
--   Think what we'd have to do manually for, say, <tt>ToHoles</tt>:
--   traverse the spine of the application and collect all the holes into a
--   list, which is troubling, because type applications are left-nested
--   and lists are right-nested, so we'd have to use accumulators or an
--   explicit <tt>Reverse</tt> type family. And then we also have
--   <tt>KnownTypeAst</tt> and <tt>ToBinds</tt>, so handling built-in types
--   in a special way for each of those would be a hassle, especially given
--   the fact that type-level Haskell is not exactly good at computing
--   things. With the <a>ElaborateBuiltin</a> approach we get
--   <tt>KnownTypeAst</tt>, <tt>ToHoles</tt> and <tt>ToBinds</tt> for free.
--   
--   We make this an open type family, so that elaboration is customizable
--   for each universe.
type family ElaborateBuiltin uni x

-- | Take a constraint and use it to constrain every argument of a possibly
--   0-ary elaborated application of a built-in type.
type family AllElaboratedArgs constr x

-- | Take a constraint and use it to constrain every argument of a possibly
--   0-ary application of a built-in type.
class AllElaboratedArgs constr (ElaborateBuiltin uni x) => AllBuiltinArgs uni constr x

-- | Turn a list of Haskell types <tt>args</tt> into a functional type
--   ending in <tt>res</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; :kind! FoldArgs [(), Bool] Integer
--   FoldArgs [(), Bool] Integer :: *
--   = () -&gt; Bool -&gt; Integer
--   </pre>
type family FoldArgs args res

-- | The meaning of a built-in function consists of its type represented as
--   a <a>TypeScheme</a>, its Haskell denotation and its uninstantiated
--   runtime denotation.
--   
--   The <a>TypeScheme</a> of a built-in function is used for example for
--   
--   <ol>
--   <li>computing the PLC type of the function to be used during type
--   checking</li>
--   <li>getting arity information</li>
--   <li>generating arbitrary values to apply the function to in tests</li>
--   </ol>
--   
--   The denotation is lazy, so that we don't need to worry about a builtin
--   being bottom (happens in tests). The production path is not affected
--   by that, since only runtime denotations are used for evaluation.
data BuiltinMeaning val cost
BuiltinMeaning :: TypeScheme val args res -> ~FoldArgs args res -> (cost -> BuiltinRuntime val) -> BuiltinMeaning val cost

-- | Constraints available when defining a built-in function.
type HasMeaningIn uni val = (Typeable val, ExMemoryUsage val, HasConstantIn uni val)

-- | A type class for "each function from a set of built-in functions has a
--   <a>BuiltinMeaning</a>".
class (Typeable uni, Typeable fun, Bounded fun, Enum fun, Ix fun, Default (BuiltinSemanticsVariant fun)) => ToBuiltinMeaning uni fun where {
    
    -- | The <tt>cost</tt> part of <a>BuiltinMeaning</a>.
    type CostingPart uni fun;
    
    -- | See Note [Builtin semantics variants]
    data BuiltinSemanticsVariant fun;
}

-- | Get the <a>BuiltinMeaning</a> of a built-in function.
toBuiltinMeaning :: (ToBuiltinMeaning uni fun, HasMeaningIn uni val) => BuiltinSemanticsVariant fun -> fun -> BuiltinMeaning val (CostingPart uni fun)

-- | Feed the <a>TypeScheme</a> of the given built-in function to the
--   continuation.
withTypeSchemeOfBuiltinFunction :: forall val fun r. (ToBuiltinMeaning (UniOf val) fun, ExMemoryUsage val, Typeable val, HasConstant val) => BuiltinSemanticsVariant fun -> fun -> (forall args res. TypeScheme val args res -> r) -> r

-- | Get the type of a built-in function.
typeOfBuiltinFunction :: forall uni fun. ToBuiltinMeaning uni fun => BuiltinSemanticsVariant fun -> fun -> Type TyName uni ()

-- | Chop a function type to get a list of its argument types.
type family GetArgs a

-- | A class that allows us to derive a monotype for a builtin. We could've
--   computed the runtime denotation from the <a>TypeScheme</a> and the
--   denotation of the builtin, but not statically (due to unfolding not
--   working for recursive functions and <a>TypeScheme</a> being recursive,
--   i.e. requiring the conversion function to be recursive), and so it
--   would cause us to retain a lot of evaluation-irrelevant stuff in the
--   constructors of <a>BuiltinRuntime</a>, which has to make evaluation
--   slower (we didn't check) and certainly makes the generated Core much
--   harder to read. Technically speaking, we could get a
--   <tt>RuntimeScheme</tt> from the <a>TypeScheme</a> and the denotation
--   statically if we changed the definition of <a>TypeScheme</a> and made
--   it a singleton, but then the conversion function would have to become
--   a class anyway and we'd just replicate what we have here, except in a
--   much more complicated way.
class KnownMonotype val args res
knownMonotype :: KnownMonotype val args res => TypeScheme val args res

-- | Convert the denotation of a builtin to its runtime counterpart . The
--   argument is in <a>ReadKnownM</a>, because that's what deferred
--   unlifting amounts to: passing the action returning the builtin
--   application around until full saturation, which is when the action
--   actually gets run.
toMonoF :: KnownMonotype val args res => ReadKnownM (FoldArgs args res, FoldArgs args ExBudgetStream) -> BuiltinRuntime val

-- | A class that allows us to derive a polytype for a builtin.
class KnownMonotype val args res => KnownPolytype (binds :: [Some TyNameRep]) val args res
knownPolytype :: KnownPolytype binds val args res => TypeScheme val args res

-- | Convert the denotation of a builtin to its runtime counterpart. The
--   argument is in <a>ReadKnownM</a>, because that's what we need to do:
--   passing the action returning the builtin application around until full
--   saturation, which is when the action actually gets run.
toPolyF :: KnownPolytype binds val args res => ReadKnownM (FoldArgs args res, FoldArgs args ExBudgetStream) -> BuiltinRuntime val

-- | Ensure a built-in function is not nullary and throw a nice error
--   otherwise.
type family ThrowOnBothEmpty binds args isBuiltin a

-- | A function turned into a type class with exactly one fully general
--   instance. We can't package up the constraints of
--   <a>makeBuiltinMeaning</a> (see the instance) into a type or class
--   synonym, because they contain a bunch of variables defined by
--   <tt>~</tt> or determined via functional dependencies and neither class
--   nor type definitions can handle that (see
--   <a>https://gitlab.haskell.org/ghc/ghc/-/issues/7100)</a>. Inlining
--   three lines of constraints whenever we need to call
--   <a>makeBuiltinMeaning</a> over a non-concrete type is a bad option and
--   this abstraction is free anyway, hence its existence.
--   
--   The <tt>a</tt> type variable goes first, because
--   <tt>makeBuiltinMeaning @A</tt> is a common pattern.
class MakeBuiltinMeaning a val

-- | Construct the meaning for a built-in function by automatically
--   deriving its <a>TypeScheme</a>, given
--   
--   <ol>
--   <li>the denotation of the builtin</li>
--   <li>an uninstantiated costing function</li>
--   </ol>
makeBuiltinMeaning :: MakeBuiltinMeaning a val => a -> (cost -> FoldArgs (GetArgs a) ExBudgetStream) -> BuiltinMeaning val cost

-- | Convert a <a>BuiltinMeaning</a> to a <a>BuiltinRuntime</a> given a
--   cost model.
toBuiltinRuntime :: cost -> BuiltinMeaning val cost -> BuiltinRuntime val

-- | Calculate runtime info for all built-in functions given meanings of
--   builtins (as a constraint), the semantics variant of the set of
--   builtins and a cost model.
toBuiltinsRuntime :: (cost ~ CostingPart uni fun, ToBuiltinMeaning uni fun, HasMeaningIn uni val) => BuiltinSemanticsVariant fun -> cost -> BuiltinsRuntime fun val

-- | Representation of a type variable: its name and unique and an implicit
--   kind.
data TyNameRep (kind :: Type)
TyNameRep :: Symbol -> Nat -> TyNameRep (kind :: Type)

-- | Representation of an intrinsically-kinded type variable: a name.
data family TyVarRep (name :: TyNameRep kind) :: kind

-- | Representation of an intrinsically-kinded type application: a function
--   and an argument.
data family TyAppRep (fun :: dom -> cod) (arg :: dom) :: cod

-- | Representation of of an intrinsically-kinded universal quantifier: a
--   bound name and a body.
data family TyForallRep (name :: TyNameRep kind) (a :: Type) :: Type

-- | The kind of holes.
data Hole

-- | A hole in the Rep context.
data family RepHole x

-- | Specifies that the given type is a built-in one and its values can be
--   embedded into a <a>Term</a>.
type HasTermLevel uni = Includes uni

-- | Specifies that the given type is a built-in one and can be embedded
--   into a <a>Kind</a>.
type HasTypeLevel uni x = KnownTypeAst Void uni (ElaborateBuiltin uni x)

-- | The product of <a>HasTypeLevel</a> and <a>HasTermLevel</a>.
type HasTypeAndTermLevel uni x = (uni `HasTypeLevel` x, uni `HasTermLevel` x)

-- | Convert a Haskell representation of a possibly 0-ary application of a
--   built-in type to arbitrary types implementing <a>KnownTypeAst</a>.
mkTyBuiltin :: forall a (x :: a) uni ann tyname. uni `HasTypeLevel` x => ann -> Type tyname uni ann

-- | A hole in the Type context.
data family TypeHole a

-- | A constraint for "<tt>a</tt> is a <a>KnownTypeAst</a> by means of
--   being included in <tt>uni</tt>".
type KnownBuiltinTypeAst tyname uni x = AllBuiltinArgs uni (KnownTypeAst tyname uni) x

-- | This class allows one to convert the type-level Haskell representation
--   of a Plutus type into the corresponding Plutus type. Associated type
--   families are needed to help elaboration.
--   
--   Depending on the universe converting a Haskell type to a Plutus team
--   can give different results (e.g. <a>Int</a> can be a built-in type
--   instead of being encoded via built-in <a>Integer</a>), hence this
--   class takes a <tt>uni</tt> argument. Plus, elaboration is
--   universe-specific too.
class KnownTypeAst tyname uni x where {
    
    -- | Whether <tt>x</tt> is a built-in type.
    type IsBuiltin uni x :: Bool;
    
    -- | Return every part of the type that can be a to-be-instantiated type
    --   variable. For example, in <tt>Integer</tt> there's no such types and
    --   in <tt>(a, b)</tt> it's the two arguments (<tt>a</tt> and <tt>b</tt>)
    --   and the same applies to <tt>a -&gt; b</tt> (to mention a type that is
    --   not built-in).
    type ToHoles uni x :: [Hole];
    
    -- | Collect all unique variables (a variable consists of a textual name, a
    --   unique and a kind) in an accumulator and return the accumulator once a
    --   leaf is reached.
    type ToBinds uni (acc :: [Some TyNameRep]) x :: [Some TyNameRep];
    type IsBuiltin uni x = IsBuiltin uni (ElaborateBuiltin uni x);
    type ToHoles uni x = ToHoles uni (ElaborateBuiltin uni x);
    type ToBinds uni acc x = ToBinds uni acc (ElaborateBuiltin uni x);
}

-- | The Plutus counterpart of the <tt>x</tt> type.
typeAst :: KnownTypeAst tyname uni x => Type tyname uni ()

-- | The Plutus counterpart of the <tt>x</tt> type.
typeAst :: (KnownTypeAst tyname uni x, KnownTypeAst tyname uni (ElaborateBuiltin uni x)) => Type tyname uni ()

-- | Return the Plutus counterpart of the <tt>x</tt> type.
toTypeAst :: forall a tyname uni (x :: a) proxy. KnownTypeAst tyname uni x => proxy x -> Type tyname uni ()

-- | Insert <tt>x</tt> into <tt>xs</tt> unless it's already there.
type family Insert x xs

-- | Delete the first <tt>x</tt> from a list. Which is okay since we only
--   ever put things in once.
type family Delete x xs

-- | The type of errors that <tt>readKnown</tt> and <tt>makeKnown</tt> can
--   return.
data BuiltinError

-- | Attach a <tt>cause</tt> to a <a>BuiltinError</a> and throw that. Note
--   that an evaluator might require the cause to be computed lazily for
--   best performance on the happy path, hence this function must not force
--   its first argument. TODO: wrap <tt>cause</tt> in <a>Lazy</a> once we
--   have it.
throwBuiltinErrorWithCause :: (MonadError (ErrorWithCause err cause) m, AsUnliftingEvaluationError err, AsEvaluationFailure err) => cause -> BuiltinError -> m void

-- | A constraint for "<tt>a</tt> is a <a>ReadKnownIn</a> and
--   <a>MakeKnownIn</a> by means of being included in <tt>uni</tt>".
type KnownBuiltinTypeIn uni val a = (HasConstantIn uni val, PrettyParens (SomeTypeIn uni), GEq uni, uni `HasTermLevel` a)

-- | A constraint for "<tt>a</tt> is a <a>ReadKnownIn</a> and
--   <a>MakeKnownIn</a> by means of being included in <tt>UniOf term</tt>".
type KnownBuiltinType val a = KnownBuiltinTypeIn (UniOf val) val a

-- | The monad that <tt>makeKnown</tt> runs in. Equivalent to <tt>ExceptT
--   BuiltinError (Writer (DList Text))</tt>, except optimized in two ways:
--   
--   <ol>
--   <li>everything is strict</li>
--   <li>has the <a>BuiltinSuccess</a> constructor that is used for
--   returning a value with no logs attached, which is the most common case
--   for us, so it helps a lot not to construct and deconstruct a redundant
--   tuple</li>
--   </ol>
--   
--   Moving from <tt>ExceptT BuiltinError (Writer (DList Text))</tt> to
--   this data type gave us a speedup of 8% of total evaluation time.
--   
--   Logs are represented as a <a>DList</a>, because we don't particularly
--   care about the efficiency of logging, since there's no logging on the
--   chain and builtins don't emit much anyway. Otherwise we'd have to use
--   <tt>text-builder</tt> or <tt>text-builder-linear</tt> or something of
--   this sort.
data BuiltinResult a
BuiltinSuccess :: a -> BuiltinResult a
BuiltinSuccessWithLogs :: DList Text -> a -> BuiltinResult a
BuiltinFailure :: DList Text -> BuiltinError -> BuiltinResult a

-- | The monad that <a>readKnown</a> runs in.
type ReadKnownM = Either BuiltinError
class uni ~ UniOf val => MakeKnownIn uni val a

-- | Convert a Haskell value to the corresponding PLC value. The inverse of
--   <a>readKnown</a>.
makeKnown :: MakeKnownIn uni val a => a -> BuiltinResult val

-- | Convert a Haskell value to the corresponding PLC value. The inverse of
--   <a>readKnown</a>.
makeKnown :: (MakeKnownIn uni val a, KnownBuiltinType val a) => a -> BuiltinResult val

-- | Convert a constant embedded into a PLC term to the corresponding
--   Haskell value.
readKnownConstant :: forall val a. KnownBuiltinType val a => val -> ReadKnownM a
type MakeKnown val = MakeKnownIn (UniOf val) val
class uni ~ UniOf val => ReadKnownIn uni val a

-- | Convert a PLC value to the corresponding Haskell value. The inverse of
--   <a>makeKnown</a>.
readKnown :: ReadKnownIn uni val a => val -> ReadKnownM a

-- | Convert a PLC value to the corresponding Haskell value. The inverse of
--   <a>makeKnown</a>.
readKnown :: (ReadKnownIn uni val a, KnownBuiltinType val a) => val -> ReadKnownM a
type ReadKnown val = ReadKnownIn (UniOf val) val

-- | Same as <a>makeKnown</a>, but allows for neither emitting nor storing
--   the cause of a failure.
makeKnownOrFail :: MakeKnownIn uni val a => a -> EvaluationResult val

-- | Same as <a>readKnown</a>, but the cause of a potential failure is the
--   provided term itself.
readKnownSelf :: (ReadKnown val a, AsUnliftingEvaluationError err, AsEvaluationFailure err) => val -> Either (ErrorWithCause err val) a

-- | The type of singletonized Haskell kinds representing Plutus kinds.
--   Indexing by a Haskell kind allows us to avoid an <a>error</a> call in
--   the <a>ToKind</a> instance of <tt>DefaultUni</tt> and not worry about
--   proxies in the type of <a>knownKind</a>.
data SingKind k
[SingType] :: SingKind Type
[SingKindArrow] :: SingKind k -> SingKind l -> SingKind (k -> l)
infixr 5 `SingKindArrow`

-- | Feed the <a>SingKind</a> version of the given <a>Kind</a> to the given
--   continuation.
withSingKind :: Kind ann -> (forall k. SingKind k -> r) -> r

-- | For reifying Haskell kinds representing Plutus kinds at the term
--   level.
class KnownKind k
knownKind :: KnownKind k => SingKind k

-- | Satisfy the <a>KnownKind</a> constraint of a continuation using the
--   given <a>SingKind</a>.
bringKnownKind :: SingKind k -> (KnownKind k => r) -> r
withKnownKind :: Kind ann -> (forall k. KnownKind k => Proxy k -> r) -> r

-- | For computing the Plutus kind of a built-in type. See
--   <a>kindOfBuiltinType</a>.
class ToKind (uni :: Type -> Type)

-- | Reify the kind of a type from the universe at the term level.
toSingKind :: ToKind uni => uni (Esc (a :: k)) -> SingKind k

-- | Convert a reified Haskell kind to a Plutus kind.
demoteKind :: SingKind k -> Kind ()

-- | Compute the kind of a type from a universe.
kindOfBuiltinType :: ToKind uni => uni (Esc a) -> Kind ()

-- | The type of errors that <tt>readKnown</tt> and <tt>makeKnown</tt> can
--   return.
data BuiltinError
BuiltinUnliftingEvaluationError :: UnliftingEvaluationError -> BuiltinError
BuiltinEvaluationFailure :: BuiltinError
throwNotAConstant :: MonadError BuiltinError m => m void

-- | Ensures that <tt>term</tt> has a <a>Constant</a>-like constructor to
--   lift values to and unlift values from.
class HasConstant term

-- | Unwrap from a <a>Constant</a>-like constructor throwing an
--   <a>UnliftingError</a> if the provided <tt>term</tt> is not a wrapped
--   Haskell value.
asConstant :: HasConstant term => term -> Either BuiltinError (Some (ValueOf (UniOf term)))

-- | Wrap a Haskell value as a <tt>term</tt>.
fromConstant :: HasConstant term => Some (ValueOf (UniOf term)) -> term

-- | Ensures that <tt>term</tt> has a <a>Constant</a>-like constructor to
--   lift values to and unlift values from and connects <tt>term</tt> and
--   its <tt>uni</tt>.
type HasConstantIn uni term = (UniOf term ~ uni, HasConstant term)

-- | Wrap a Haskell value (given its explicit type tag) as a <tt>term</tt>.
fromValueOf :: forall a term. HasConstant term => UniOf term (Esc a) -> a -> term

-- | Wrap a Haskell value (provided its type is in the universe) as a
--   <tt>term</tt>.
fromValue :: forall a term. (HasConstant term, UniOf term `HasTermLevel` a) => a -> term

module PlutusCore.MkPlc

-- | A final encoding for Term, to allow PLC terms to be used transparently
--   as PIR terms.
class TermLike term tyname name uni fun | term -> tyname name uni fun
var :: TermLike term tyname name uni fun => ann -> name -> term ann
tyAbs :: TermLike term tyname name uni fun => ann -> tyname -> Kind ann -> term ann -> term ann
lamAbs :: TermLike term tyname name uni fun => ann -> name -> Type tyname uni ann -> term ann -> term ann
apply :: TermLike term tyname name uni fun => ann -> term ann -> term ann -> term ann
constant :: TermLike term tyname name uni fun => ann -> Some (ValueOf uni) -> term ann
builtin :: TermLike term tyname name uni fun => ann -> fun -> term ann
tyInst :: TermLike term tyname name uni fun => ann -> term ann -> Type tyname uni ann -> term ann
unwrap :: TermLike term tyname name uni fun => ann -> term ann -> term ann
iWrap :: TermLike term tyname name uni fun => ann -> Type tyname uni ann -> Type tyname uni ann -> term ann -> term ann
error :: TermLike term tyname name uni fun => ann -> Type tyname uni ann -> term ann
constr :: TermLike term tyname name uni fun => ann -> Type tyname uni ann -> Word64 -> [term ann] -> term ann
kase :: TermLike term tyname name uni fun => ann -> Type tyname uni ann -> term ann -> [term ann] -> term ann
termLet :: TermLike term tyname name uni fun => ann -> TermDef term tyname name uni ann -> term ann -> term ann
typeLet :: TermLike term tyname name uni fun => ann -> TypeDef tyname uni ann -> term ann -> term ann

-- | Extract the universe from a type.
type family UniOf a :: Type -> Type

-- | Specifies that the given type is a built-in one and can be embedded
--   into a <a>Kind</a>.
type HasTypeLevel uni x = KnownTypeAst Void uni (ElaborateBuiltin uni x)

-- | Specifies that the given type is a built-in one and its values can be
--   embedded into a <a>Term</a>.
type HasTermLevel uni = Includes uni

-- | The product of <a>HasTypeLevel</a> and <a>HasTermLevel</a>.
type HasTypeAndTermLevel uni x = (uni `HasTypeLevel` x, uni `HasTermLevel` x)

-- | Embed a type (given its explicit type tag) into a PLC type.
mkTyBuiltinOf :: forall k (a :: k) uni tyname ann. ann -> uni (Esc a) -> Type tyname uni ann

-- | Convert a Haskell representation of a possibly 0-ary application of a
--   built-in type to arbitrary types implementing <a>KnownTypeAst</a>.
mkTyBuiltin :: forall a (x :: a) uni ann tyname. uni `HasTypeLevel` x => ann -> Type tyname uni ann

-- | Embed a Haskell value (given its explicit type tag) into a PLC term.
mkConstantOf :: forall a uni fun term tyname name ann. TermLike term tyname name uni fun => ann -> uni (Esc a) -> a -> term ann

-- | Embed a Haskell value (provided its type is in the universe) into a
--   PLC term.
mkConstant :: forall a uni fun term tyname name ann. (TermLike term tyname name uni fun, uni `HasTermLevel` a) => ann -> a -> term ann

-- | A "variable declaration", i.e. a name and a type for a variable.
data VarDecl tyname name uni ann
VarDecl :: ann -> name -> Type tyname uni ann -> VarDecl tyname name uni ann
[_varDeclAnn] :: VarDecl tyname name uni ann -> ann
[_varDeclName] :: VarDecl tyname name uni ann -> name
[_varDeclType] :: VarDecl tyname name uni ann -> Type tyname uni ann

-- | A "type variable declaration", i.e. a name and a kind for a type
--   variable.
data TyVarDecl tyname ann
TyVarDecl :: ann -> tyname -> Kind ann -> TyVarDecl tyname ann
[_tyVarDeclAnn] :: TyVarDecl tyname ann -> ann
[_tyVarDeclName] :: TyVarDecl tyname ann -> tyname
[_tyVarDeclKind] :: TyVarDecl tyname ann -> Kind ann

-- | A "type declaration", i.e. a kind for a type.
data TyDecl tyname uni ann
TyDecl :: ann -> Type tyname uni ann -> Kind ann -> TyDecl tyname uni ann
[_tyDeclAnn] :: TyDecl tyname uni ann -> ann
[_tyDeclType] :: TyDecl tyname uni ann -> Type tyname uni ann
[_tyDeclKind] :: TyDecl tyname uni ann -> Kind ann

-- | Make a <a>Var</a> referencing the given <a>VarDecl</a>.
mkVar :: TermLike term tyname name uni fun => ann -> VarDecl tyname name uni ann -> term ann

-- | Make a <a>TyVar</a> referencing the given <a>TyVarDecl</a>.
mkTyVar :: ann -> TyVarDecl tyname ann -> Type tyname uni ann
tyDeclVar :: TyVarDecl tyname ann -> TyDecl tyname uni ann

-- | A definition. Pretty much just a pair with more descriptive names.
data Def var val
Def :: var -> val -> Def var val
[defVar] :: Def var val -> var
[defVal] :: Def var val -> val
embedTerm :: TermLike term tyname name uni fun => Term tyname name uni fun ann -> term ann

-- | A term definition as a variable.
type TermDef term tyname name uni ann = Def (VarDecl tyname name uni ann) (term ann)

-- | A type definition as a type variable.
type TypeDef tyname uni ann = Def (TyVarDecl tyname ann) (Type tyname uni ann)

-- | The type of a PLC function.
data FunctionType tyname uni ann
FunctionType :: ann -> Type tyname uni ann -> Type tyname uni ann -> FunctionType tyname uni ann

-- | An annotation.
[_functionTypeAnn] :: FunctionType tyname uni ann -> ann

-- | The domain of a function.
[_functionTypeDom] :: FunctionType tyname uni ann -> Type tyname uni ann

-- | The codomain of the function.
[_functionTypeCod] :: FunctionType tyname uni ann -> Type tyname uni ann

-- | A PLC function.
data FunctionDef term tyname name uni fun ann
FunctionDef :: ann -> name -> FunctionType tyname uni ann -> term ann -> FunctionDef term tyname name uni fun ann

-- | An annotation.
[_functionDefAnn] :: FunctionDef term tyname name uni fun ann -> ann

-- | The name of a function.
[_functionDefName] :: FunctionDef term tyname name uni fun ann -> name

-- | The type of the function.
[_functionDefType] :: FunctionDef term tyname name uni fun ann -> FunctionType tyname uni ann

-- | The definition of the function.
[_functionDefTerm] :: FunctionDef term tyname name uni fun ann -> term ann

-- | Convert a <a>FunctionType</a> to the corresponding <a>Kind</a>.
functionTypeToType :: FunctionType tyname uni ann -> Type tyname uni ann

-- | Get the type of a <a>FunctionDef</a>.
functionDefToType :: FunctionDef term tyname name uni fun ann -> Type tyname uni ann

-- | Convert a <a>FunctionDef</a> to a <a>VarDecl</a>. I.e. ignore the
--   actual term.
functionDefVarDecl :: FunctionDef term tyname name uni fun ann -> VarDecl tyname name uni ann

-- | Make a <a>FunctionDef</a>. Return <a>Nothing</a> if the provided type
--   is not functional.
mkFunctionDef :: ann -> name -> Type tyname uni ann -> term ann -> Maybe (FunctionDef term tyname name uni fun ann)

-- | Make a "let-binding" for a term as an immediately applied lambda
--   abstraction.
mkImmediateLamAbs :: TermLike term tyname name uni fun => ann -> TermDef term tyname name uni ann -> term ann -> term ann

-- | Make a "let-binding" for a type as an immediately instantiated type
--   abstraction. Note: the body must be a value.
mkImmediateTyAbs :: TermLike term tyname name uni fun => ann -> TypeDef tyname uni ann -> term ann -> term ann

-- | Universally quantify a list of names.
mkIterTyForall :: [TyVarDecl tyname ann] -> Type tyname uni ann -> Type tyname uni ann

-- | Lambda abstract a list of names.
mkIterTyLam :: [TyVarDecl tyname ann] -> Type tyname uni ann -> Type tyname uni ann

-- | Make an iterated application. Each <a>apply</a> node uses the
--   annotation associated with the corresponding argument.
mkIterApp :: TermLike term tyname name uni fun => term ann -> [(ann, term ann)] -> term ann

-- | Make an iterated application with no annotation.
mkIterAppNoAnn :: TermLike term tyname name uni fun => term () -> [term ()] -> term ()

-- | An infix synonym for <a>mkIterAppNoAnn</a>
(@@) :: TermLike term tyname name uni fun => term () -> [term ()] -> term ()

-- | Make an iterated function type.
mkIterTyFun :: ann -> [Type tyname uni ann] -> Type tyname uni ann -> Type tyname uni ann

-- | Lambda abstract a list of names.
mkIterLamAbs :: TermLike term tyname name uni fun => [VarDecl tyname name uni ann] -> term ann -> term ann

-- | Make an iterated instantiation. Each <a>tyInst</a> node uses the
--   annotation associated with the corresponding argument.
mkIterInst :: TermLike term tyname name uni fun => term ann -> [(ann, Type tyname uni ann)] -> term ann

-- | Make an iterated instantiation with no annotation.
mkIterInstNoAnn :: TermLike term tyname name uni fun => term () -> [Type tyname uni ()] -> term ()

-- | Type abstract a list of names.
mkIterTyAbs :: TermLike term tyname name uni fun => [TyVarDecl tyname ann] -> term ann -> term ann

-- | Make an iterated type application. Each <a>TyApp</a> node uses the
--   annotation associated with the corresponding argument.
mkIterTyApp :: Type tyname uni ann -> [(ann, Type tyname uni ann)] -> Type tyname uni ann

-- | Make an iterated type application with no annotation.
mkIterTyAppNoAnn :: Type tyname uni () -> [Type tyname uni ()] -> Type tyname uni ()

-- | Make an iterated function kind.
mkIterKindArrow :: ann -> [Kind ann] -> Kind ann -> Kind ann

-- | A helper to create a single, fresh strict binding; It returns the
--   fresh bound <a>Var</a>iable and a function `Term -&gt; Term`,
--   expecting an "in-Term" to form a let-expression.
mkFreshTermLet :: (MonadQuote m, TermLike t tyname Name uni fun, Monoid a) => Type tyname uni a -> t a -> m (t a, t a -> t a)
instance GHC.Generics.Generic (PlutusCore.MkPlc.Def var val)
instance (GHC.Classes.Ord var, GHC.Classes.Ord val) => GHC.Classes.Ord (PlutusCore.MkPlc.Def var val)
instance (GHC.Classes.Eq var, GHC.Classes.Eq val) => GHC.Classes.Eq (PlutusCore.MkPlc.Def var val)
instance (GHC.Show.Show var, GHC.Show.Show val) => GHC.Show.Show (PlutusCore.MkPlc.Def var val)
instance PlutusCore.MkPlc.TermLike (PlutusCore.Core.Type.Term tyname name uni fun) tyname name uni fun


-- | This module defines Haskell data types that simplify construction of
--   PLC types and terms.
module PlutusCore.StdLib.Type

-- | A recursive type packaged along with a specified <tt>Wrap</tt> that
--   allows to construct elements of this type.
data RecursiveType uni fun ann
RecursiveType :: Type TyName uni ann -> (forall term. TermLike term TyName Name uni fun => [Type TyName uni ann] -> term ann -> term ann) -> RecursiveType uni fun ann
[_recursiveType] :: RecursiveType uni fun ann -> Type TyName uni ann
[_recursiveWrap] :: RecursiveType uni fun ann -> forall term. TermLike term TyName Name uni fun => [Type TyName uni ann] -> term ann -> term ann

-- | Construct a <a>RecursiveType</a> out of its name, variables bound in
--   its pattern functor and the body of the pattern functor. The 0- and
--   1-ary pattern functors are special-cased, while in the general case
--   the pattern functor and type arguments get encoded into a 1-ary form
--   first.
makeRecursiveType :: FromDataPieces uni ann (RecursiveType uni fun ann)
instance GHC.Exception.Type.Exception PlutusCore.StdLib.Type.IndicesLengthsMismatchException
instance GHC.Show.Show PlutusCore.StdLib.Type.IndicesLengthsMismatchException


-- | <tt>tuple</tt>s of various sizes and related functions.
module PlutusCore.StdLib.Meta.Data.Tuple

-- | A Plutus Core (Scott-encoded) tuple.
data Tuple term uni ann
Tuple :: [Type TyName uni ann] -> term ann -> Tuple term uni ann

-- | The types of elements of a tuple.
[_tupleElementTypes] :: Tuple term uni ann -> [Type TyName uni ann]

-- | A term representation of the tuple.
[_tupleTerm] :: Tuple term uni ann -> term ann

-- | Get the type of a <a>Tuple</a>.
--   
--   <pre>
--   getTupleType _ (Tuple [a1, ... , an] _) = all r. (a1 -&gt; ... -&gt; an -&gt; r) -&gt; r
--   </pre>
getTupleType :: MonadQuote m => ann -> Tuple term uni ann -> m (Type TyName uni ann)

-- | Get the type of the ith element of a <a>Tuple</a> along with the
--   element itself.
--   
--   <pre>
--   tupleTypeTermAt _ i (Tuple [a0, ... , an] term) =
--       (ai, term {ai} (\(x0 : a0) ... (xn : an) -&gt; xi))
--   </pre>
tupleTypeTermAt :: (TermLike term TyName Name uni fun, MonadQuote m) => ann -> Int -> Tuple term uni ann -> m (Type TyName uni ann, term ann)

-- | Get the ith element of a <a>Tuple</a>.
tupleTermAt :: (TermLike term TyName Name uni fun, MonadQuote m) => ann -> Int -> Tuple term uni ann -> m (term ann)

-- | Get the ith element of a <a>Tuple</a> as a <a>TermDef</a>.
tupleDefAt :: (TermLike term TyName Name uni fun, MonadQuote m) => ann -> Int -> Name -> Tuple term uni ann -> m (TermDef term TyName Name uni ann)

-- | Bind all elements of a <a>Tuple</a> inside a <a>Term</a>.
--   
--   <pre>
--   bindTuple _ [x_1, ... , x_n] (Tuple [a1, ... , an] term) body =
--       (\(tup : all r. (a_1 -&gt; ... -&gt; a_n -&gt; r) -&gt; r) -&gt;
--         let x_1 = _1 tup
--             ...
--             x_n = _n tup
--           in body
--       ) term
--   </pre>
bindTuple :: (TermLike term TyName Name uni fun, MonadQuote m) => ann -> [Name] -> Tuple term uni ann -> term ann -> m (term ann)

-- | Given an arity <tt>n</tt>, create the n-ary product type.
--   
--   <pre>
--   (T_1 :: *) .. (T_n :: *) . all (R :: *) . (T_1 -&gt; .. -&gt; T_n -&gt; R) -&gt; R
--   </pre>
prodN :: Int -> Type TyName uni ()

-- | Given an arity <tt>n</tt>, create the constructor for n-ary products.
--   
--   <pre>
--   /(T_1 :: *) .. (T_n :: *) .
--       (arg_1 : T_1) .. (arg_n : T_n) .
--           /(R :: *).
--               (case : T_1 -&gt; .. -&gt; T_n -&gt; R) -&gt; case arg_1 .. arg_n
--   </pre>
prodNConstructor :: TermLike term TyName Name uni fun => Int -> term ()

-- | Given an arity <tt>n</tt> and an index <tt>i</tt>, create a function
--   for accessing the i'th component of a n-tuple.
--   
--   <pre>
--   /(T_1 :: *) .. (T_n :: *) .
--       (tuple : all (R :: *) . (T_1 -&gt; .. -&gt; T_n -&gt; R) -&gt; R)) .
--           tuple {T_i} ((arg_1 : T_1) .. (arg_n : T_n) . arg_i)
--   </pre>
prodNAccessor :: TermLike term TyName Name uni fun => Int -> Int -> term ()

-- | Convert a Haskell spine of <a>Term</a>s to a PLC <a>Tuple</a>.
--   
--   <pre>
--   getSpineToTuple _ [(a1, x1), ... , (an, xn)] =
--       Tuple [a1, ... , an] (/\(r :: *) -&gt; \(f :: a1 -&gt; ... -&gt; an -&gt; r) -&gt; f x1 ... xn)
--   </pre>
getSpineToTuple :: (TermLike term TyName Name uni fun, MonadQuote m) => ann -> [(Type TyName uni ann, term ann)] -> m (Tuple term uni ann)


-- | Meta-functions relating to functions.
module PlutusCore.StdLib.Meta.Data.Function

-- | <a>const</a> as a PLC term.
--   
--   <pre>
--   constPartial t = /\(A :: *) -&gt; \(x : A) -&gt; t
--   </pre>
constPartial :: TermLike term TyName Name uni fun => term () -> term ()

-- | Eta-expand a function at a given type. Note that this has to be a
--   "meta" function for it not force the function it receives and instead
--   directly hide it under a lambda.
--   
--   <pre>
--   etaExpand ty fun = \(x : ty) -&gt; fun x
--   </pre>
etaExpand :: TermLike term tyname Name uni fun => Type tyname uni () -> term () -> term ()


-- | <tt>unit</tt> and related functions.
module PlutusCore.StdLib.Data.Unit

-- | <tt>()</tt> as a PLC type.
unit :: uni `HasTypeLevel` () => Type tyname uni ()

-- | <tt>()</tt> as a PLC term.
unitval :: (TermLike term tyname name uni fun, uni `HasTermLevel` ()) => term ()

-- | <a>seq</a> specified to <tt>()</tt> as a PLC term.
sequ :: (TermLike term tyname Name uni fun, uni `HasTypeAndTermLevel` ()) => term ()


-- | <tt>sum</tt> and related functions.
module PlutusCore.StdLib.Data.Sum

-- | <a>Either</a> as a PLC type.
--   
--   <pre>
--   \(a b :: *) -&gt; all (r :: *). (a -&gt; r) -&gt; (b -&gt; r) -&gt; r
--   </pre>
sum :: Type TyName uni ()

-- | <a>Left</a> as a PLC term.
--   
--   <pre>
--   /\(a b :: *) -&gt; \(x : a) -&gt; /\(r :: *) -&gt; \(f : a -&gt; r) -&gt; (g : b -&gt; r) -&gt; f x
--   </pre>
left :: TermLike term TyName Name uni fun => term ()

-- | <a>Right</a> as a PLC term.
--   
--   <pre>
--   /\(a b :: *) -&gt; \(y : b) -&gt; /\(r :: *) -&gt; \(f : a -&gt; r) -&gt; (g : b -&gt; r) -&gt; g y
--   </pre>
right :: TermLike term TyName Name uni fun => term ()


-- | Scott-encoded <tt>unit</tt> and related functions.
module PlutusCore.StdLib.Data.ScottUnit

-- | <tt>()</tt> as a PLC type.
--   
--   <pre>
--   all (A :: *). A -&gt; A
--   </pre>
unit :: Type TyName uni ()

-- | <tt>()</tt> as a PLC term.
--   
--   <pre>
--   /\(A :: *) -&gt; \(x : A) -&gt; x
--   </pre>
unitval :: TermLike term TyName Name uni fun => term ()


-- | Combinators.
module PlutusCore.StdLib.Data.Function

-- | <a>const</a> as a PLC term.
--   
--   <pre>
--   /\(A B :: *) -&gt; \(x : A) (y : B) -&gt; x
--   </pre>
const :: TermLike term TyName Name uni fun => term ()

-- | <a>id</a> as a PLC term.
--   
--   <pre>
--   /\(A :: *) -&gt; \(x : A) -&gt; x
--   </pre>
idFun :: TermLike term TyName Name uni fun => term ()

-- | <a>($)</a> as a PLC term.
--   
--   <pre>
--   /\(A B :: *) -&gt; \(f : A -&gt; B) (x : A) -&gt; f x
--   </pre>
applyFun :: TermLike term TyName Name uni fun => term ()

-- | <tt>Self</tt> as a PLC type.
--   
--   <pre>
--   fix \(self :: * -&gt; *) (a :: *) -&gt; self a -&gt; a
--   </pre>
selfData :: RecursiveType uni fun ()

-- | <tt>unroll</tt> as a PLC term.
--   
--   <pre>
--   /\(a :: *) -&gt; \(s : self a) -&gt; unwrap s s
--   </pre>
unroll :: TermLike term TyName Name uni fun => term ()

-- | <a>fix</a> as a PLC term.
--   
--   <pre>
--   /\(a b :: *) -&gt; \(f : (a -&gt; b) -&gt; a -&gt; b) -&gt;
--       unroll {a -&gt; b} (iwrap selfF (a -&gt; b) \(s : self (a -&gt; b)) -&gt;
--           f (\(x : a) -&gt; unroll {a -&gt; b} s x))
--   </pre>
--   
--   See <tt>plutus<i>runQuote $
--   docs</i>fomega/z-combinator-benchmarks</tt> for details.
fix :: TermLike term TyName Name uni fun => term ()
fixAndType :: TermLike term TyName Name uni fun => (term (), Type TyName uni ())

-- | The <a>fixBy</a> combinator.
--   
--   <pre>
--   fixBy :
--       forall (F :: * -&gt; *) .
--       ((F ~&gt; Id) -&gt; (F ~&gt; Id)) -&gt;
--       ((F ~&gt; F) -&gt; (F ~&gt; Id))
--   </pre>
fixBy :: TermLike term TyName Name uni fun => term ()
fixByAndType :: TermLike term TyName Name uni fun => (term (), Type TyName uni ())

-- | Make a <tt>n</tt>-ary fixpoint combinator.
--   
--   <pre>
--   FixN n :
--       forall A1 B1 ... An Bn :: * .
--       (forall Q :: * .
--           ((A1 -&gt; B1) -&gt; ... -&gt; (An -&gt; Bn) -&gt; Q) -&gt;
--           (A1 -&gt; B1) -&gt;
--           ... -&gt;
--           (An -&gt; Bn) -&gt;
--           Q) -&gt;
--       (forall R :: * . ((A1 -&gt; B1) -&gt; ... (An -&gt; Bn) -&gt; R) -&gt; R)
--   </pre>
fixN :: TermLike term TyName Name uni fun => Integer -> term () -> term ()
fixNAndType :: TermLike term TyName Name uni fun => Integer -> term () -> (term (), Type TyName uni ())

-- | A PLC function.
data FunctionDef term tyname name uni fun ann
FunctionDef :: ann -> name -> FunctionType tyname uni ann -> term ann -> FunctionDef term tyname name uni fun ann

-- | An annotation.
[_functionDefAnn] :: FunctionDef term tyname name uni fun ann -> ann

-- | The name of a function.
[_functionDefName] :: FunctionDef term tyname name uni fun ann -> name

-- | The type of the function.
[_functionDefType] :: FunctionDef term tyname name uni fun ann -> FunctionType tyname uni ann

-- | The definition of the function.
[_functionDefTerm] :: FunctionDef term tyname name uni fun ann -> term ann

-- | Get the fixed-point of a list of mutually recursive functions.
--   
--   <pre>
--   MutualFixOf _ fixN [ FunctionDef _ fN1 (FunctionType _ a1 b1) f1
--                      , ...
--                      , FunctionDef _ fNn (FunctionType _ an bn) fn
--                      ] =
--       Tuple [(a1 -&gt; b1) ... (an -&gt; bn)] $
--           fixN {a1} {b1} ... {an} {bn}
--               /\(q :: *) -&gt; \(choose : (a1 -&gt; b1) -&gt; ... -&gt; (an -&gt; bn) -&gt; q) -&gt;
--                   \(fN1 : a1 -&gt; b1) ... (fNn : an -&gt; bn) -&gt; choose f1 ... fn
--   </pre>
getMutualFixOf :: TermLike term TyName Name uni fun => ann -> term ann -> [FunctionDef term TyName Name uni fun ann] -> Quote (Tuple term uni ann)

-- | Get the fixed-point of a single recursive function.
getSingleFixOf :: TermLike term TyName Name uni fun => ann -> term ann -> FunctionDef term TyName Name uni fun ann -> term ann


-- | Church-encoded <tt>nat</tt> and related functions.
module PlutusCore.StdLib.Data.ChurchNat

-- | Church-encoded <tt>Nat</tt> as a PLC type.
--   
--   <pre>
--   all (r :: *). r -&gt; (r -&gt; r) -&gt; r
--   </pre>
churchNat :: Type TyName uni ()

-- | Church-encoded '0' as a PLC term.
--   
--   <pre>
--   /\(r :: *) -&gt; \(z : r) (f : r -&gt; r) -&gt; z
--   </pre>
churchZero :: TermLike term TyName Name uni fun => term ()

-- | Church-encoded <a>succ</a> as a PLC term.
--   
--   <pre>
--   \(n : nat) -&gt; /\(r :: *) -&gt; \(z : r) (f : r -&gt; r) -&gt; f (n {r} z f)
--   </pre>
churchSucc :: TermLike term TyName Name uni fun => term ()

module PlutusCore.Examples.Data.Shad

-- | <pre>
--   \(a :: *) -&gt; ifix (getShadF a) a
--   </pre>
shad :: uni `HasTypeLevel` Integer => Type TyName uni ()

-- | Test that shadowing does not result in variable capture. The
--   definition is as follows:
--   
--   <pre>
--   /\(a :: *) -&gt; wrap (getShadF a) a (\(x : a) -&gt; /\(f :: * -&gt; *) -&gt; \(y : f i) -&gt; 0)
--   </pre>
--   
--   Type checking this term we eventually reach
--   
--   <pre>
--   NORM (vPat (\(a :: k) -&gt; ifix vPat a) arg)
--   </pre>
--   
--   (where in our case <tt>vPat</tt> is <tt>shadF</tt> and <tt>arg</tt> is
--   <tt>a</tt>), which, if we were naive, would unfold into
--   
--   <pre>
--   a -&gt; all (a :: * -&gt; *). a a -&gt; integer
--   </pre>
--   
--   i.e. we substituted the outer <tt>a</tt> for <tt>i</tt>, but due to
--   variable capture via <tt>all</tt> that outer <tt>a</tt> now became an
--   inner one, which would be a bug.
--   
--   But that problem is already solved before type checking starts as we
--   rename the program and that makes all binders uniques, so no variable
--   capture is possible due to the outer and inner bindings being
--   distinct.
mkShad :: uni `HasTypeAndTermLevel` Integer => Term TyName Name uni fun ()

-- | <pre>
--   ifix recUnitF ()
--   </pre>
recUnit :: uni `HasTypeLevel` () => Type TyName uni ()

-- | Test that a binder in a pattern functor does not get duplicated. The
--   definition is as follows:
--   
--   <pre>
--   /\(a :: *) -&gt; \(ru : recUnit) -&gt; unwrap ru {a} ru
--   </pre>
--   
--   Type checking this term we eventually reach
--   
--   <pre>
--   NORM (vPat (\(a :: k) -&gt; ifix vPat a) arg)
--   </pre>
--   
--   (where in our case <tt>vPat</tt> is <tt>recUnitF</tt> and <tt>arg</tt>
--   is <tt>()</tt>), which, if we were naive, would unfold into
--   
--   <pre>
--   all (r :: *). ifix (\(rec :: * -&gt; *) (i :: *) -&gt; all (r :: *). rec i -&gt; r -&gt; r) () -&gt; r -&gt; r
--   </pre>
--   
--   and break global uniqueness as the <tt>all (r :: *)</tt> binder
--   appears twice.
--   
--   But this doesn't happen in the actual code, since when a variable gets
--   looked up during type normalization, its value gets renamed, which
--   means that a fresh variable will be generated for the inner binder and
--   there will be no shadowing.
runRecUnit :: uni `HasTypeAndTermLevel` () => Term TyName Name uni fun ()

module PlutusCore.Examples.Data.InterList

-- | <tt>InterList</tt> as a PLC type.
--   
--   <pre>
--   fix \(interlist :: * -&gt; * -&gt; *) (a :: *) (b :: *) -&gt;
--       all (r :: *). r -&gt; (a -&gt; b -&gt; interlist b a -&gt; r) -&gt; r
--   </pre>
interListData :: RecursiveType uni fun ()
interNil :: Term TyName Name uni fun ()
interCons :: Term TyName Name uni fun ()
foldrInterList :: uni `HasTypeAndTermLevel` () => Term TyName Name uni fun ()

module PlutusCore.Examples.Data.Function
unsafeCoerce :: Term TyName Name uni fun ()

module PlutusCore.Evaluation.Machine.MachineParameters

-- | We need to account for the costs of evaluator steps and also built-in
--   function evaluation. The models for these have different structures
--   and are used in different parts of the code, so inside the valuator we
--   pass separate objects about most of the time . It's convenient for
--   clients of the evaluator to only have to worry about a single object,
--   so the CostModel type bundles the two together. We could conceivably
--   have different evaluators with different internal costs, so we keep
--   the machine costs abstract. The model for Cek machine steps is in
--   UntypedPlutusCore.Evaluation.Machine.Cek.CekMachineCosts.
data CostModel machinecosts builtincosts
CostModel :: machinecosts -> builtincosts -> CostModel machinecosts builtincosts
[_machineCostModel] :: CostModel machinecosts builtincosts -> machinecosts
[_builtinCostModel] :: CostModel machinecosts builtincosts -> builtincosts
machineCostModel :: forall machinecosts_a8ppT builtincosts_a8ppU machinecosts_a8psW. Lens (CostModel machinecosts_a8ppT builtincosts_a8ppU) (CostModel machinecosts_a8psW builtincosts_a8ppU) machinecosts_a8ppT machinecosts_a8psW
builtinCostModel :: forall machinecosts_a8ppT builtincosts_a8ppU builtincosts_a8psV. Lens (CostModel machinecosts_a8ppT builtincosts_a8ppU) (CostModel machinecosts_a8ppT builtincosts_a8psV) builtincosts_a8ppU builtincosts_a8psV

-- | At execution time we need a <a>BuiltinsRuntime</a> object which
--   includes both the cost model for builtins and their denotations. This
--   bundles one of those together with the cost model for evaluator steps.
--   The <tt>term</tt> type will be CekValue when we're using this with the
--   CEK machine.
data MachineParameters machinecosts fun val
MachineParameters :: machinecosts -> BuiltinsRuntime fun val -> MachineParameters machinecosts fun val
[machineCosts] :: MachineParameters machinecosts fun val -> machinecosts
[builtinsRuntime] :: MachineParameters machinecosts fun val -> BuiltinsRuntime fun val

-- | This just uses <a>toBuiltinsRuntime</a> function to convert a
--   BuiltinCostModel to a BuiltinsRuntime.
mkMachineParameters :: (CostingPart uni fun ~ builtincosts, HasMeaningIn uni val, ToBuiltinMeaning uni fun) => BuiltinSemanticsVariant fun -> CostModel machinecosts builtincosts -> MachineParameters machinecosts fun val
instance (Control.DeepSeq.NFData machinecosts, GHC.Enum.Bounded fun, GHC.Enum.Enum fun) => Control.DeepSeq.NFData (PlutusCore.Evaluation.Machine.MachineParameters.MachineParameters machinecosts fun val)
instance GHC.Generics.Generic (PlutusCore.Evaluation.Machine.MachineParameters.MachineParameters machinecosts fun val)
instance (NoThunks.Class.NoThunks machinecosts, GHC.Enum.Bounded fun, GHC.Enum.Enum fun) => NoThunks.Class.NoThunks (PlutusCore.Evaluation.Machine.MachineParameters.MachineParameters machinecosts fun val)
instance (GHC.Show.Show machinecosts, GHC.Show.Show builtincosts) => GHC.Show.Show (PlutusCore.Evaluation.Machine.MachineParameters.CostModel machinecosts builtincosts)
instance (GHC.Classes.Eq machinecosts, GHC.Classes.Eq builtincosts) => GHC.Classes.Eq (PlutusCore.Evaluation.Machine.MachineParameters.CostModel machinecosts builtincosts)


-- | The CK machine.
module PlutusCore.Evaluation.Machine.Ck

-- | The parameterized type of results various evaluation engines return.
--   On the PLC side this becomes (via <tt>makeKnown</tt>) either a call to
--   <tt>Error</tt> or a value of the PLC counterpart of type <tt>a</tt>.
data EvaluationResult a
EvaluationSuccess :: !a -> EvaluationResult a
EvaluationFailure :: EvaluationResult a

-- | The CK machine-specific <a>EvaluationException</a>.
type CkEvaluationException uni fun = EvaluationException (MachineError fun) CkUserError (Term TyName Name uni fun ())
type CkM uni fun s = ReaderT (CkEnv uni fun s) (ExceptT (CkEvaluationException uni fun) (ST s))
data CkValue uni fun
runCk :: BuiltinsRuntime fun (CkValue uni fun) -> Bool -> Term TyName Name uni fun () -> (Either (CkEvaluationException uni fun) (Term TyName Name uni fun ()), [Text])

-- | Preserve the contents of an <a>StructuralEvaluationError</a> as a
--   <a>Left</a> and turn an <a>OperationalEvaluationError</a> into a
--   <tt>Right EvaluationFailure</tt> (thus erasing the content of the
--   error in the latter case).
splitStructuralOperational :: Either (EvaluationException structural operational term) a -> Either (ErrorWithCause structural term) (EvaluationResult a)

-- | Throw on a <a>StructuralEvaluationError</a> and turn an
--   <a>OperationalEvaluationError</a> into an <a>EvaluationFailure</a>
--   (thus erasing the content of the error in the latter case).
unsafeSplitStructuralOperational :: (PrettyPlc structural, PrettyPlc term, Typeable structural, Typeable term) => Either (EvaluationException structural operational term) a -> EvaluationResult a

-- | Evaluate a term using the CK machine with logging enabled.
evaluateCk :: BuiltinsRuntime fun (CkValue uni fun) -> Term TyName Name uni fun () -> (Either (CkEvaluationException uni fun) (Term TyName Name uni fun ()), [Text])

-- | Evaluate a term using the CK machine with logging disabled.
evaluateCkNoEmit :: BuiltinsRuntime fun (CkValue uni fun) -> Term TyName Name uni fun () -> Either (CkEvaluationException uni fun) (Term TyName Name uni fun ())

-- | Unlift a value using the CK machine.
readKnownCk :: ReadKnown (Term TyName Name uni fun ()) a => BuiltinsRuntime fun (CkValue uni fun) -> Term TyName Name uni fun () -> Either (CkEvaluationException uni fun) a
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.Ck.CkUserError
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.Ck.CkUserError
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.Ck.CkUserError
instance GHC.Show.Show PlutusCore.Evaluation.Machine.Ck.CkUserError
instance (Data.GADT.Internal.GShow uni, Universe.Core.Everywhere uni GHC.Show.Show, GHC.Show.Show fun, Universe.Core.Closed uni) => GHC.Show.Show (PlutusCore.Evaluation.Machine.Ck.CkValue uni fun)
instance PlutusCore.Evaluation.Result.AsEvaluationFailure PlutusCore.Evaluation.Machine.Ck.CkUserError
instance PlutusCore.Builtin.Result.AsUnliftingError PlutusCore.Evaluation.Machine.Ck.CkUserError
instance Prettyprinter.Internal.Pretty PlutusCore.Evaluation.Machine.Ck.CkUserError
instance GHC.Show.Show (PlutusCore.Builtin.Runtime.BuiltinRuntime (PlutusCore.Evaluation.Machine.Ck.CkValue uni fun))
instance (PlutusCore.Pretty.PrettyConst.PrettyUni uni, Prettyprinter.Internal.Pretty fun) => Text.PrettyBy.Internal.PrettyBy PlutusCore.Pretty.Plc.PrettyConfigPlc (PlutusCore.Evaluation.Machine.Ck.CkValue uni fun)
instance PlutusCore.Builtin.HasConstant.HasConstant (PlutusCore.Evaluation.Machine.Ck.CkValue uni fun)
instance PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage (PlutusCore.Evaluation.Machine.Ck.CkValue uni fun)

module PlutusCore.Crypto.ExpMod
expMod :: Integer -> Integer -> Natural -> BuiltinResult Natural


-- | Implementations for CIP-121, CIP-122 and CIP-123. Grouped because they
--   all operate on <a>ByteString</a>s, and require similar functionality.
module PlutusCore.Bitwise

-- | Wrapper for <a>unsafeIntegerToByteString</a> to make it more
--   convenient to define as a builtin.
integerToByteString :: Bool -> Integer -> Integer -> BuiltinResult ByteString

-- | Conversion from <a>ByteString</a> to <a>Integer</a>, as per
--   <a>CIP-121</a>.
--   
--   Wrapper for <a>unsafeByteStringToInteger</a> to make it more
--   convenient to define as a builtin.
byteStringToInteger :: Bool -> ByteString -> Integer

-- | Bitwise logical AND, as per <a>CIP-122</a>.
andByteString :: Bool -> ByteString -> ByteString -> ByteString

-- | Bitwise logical OR, as per <a>CIP-122</a>.
orByteString :: Bool -> ByteString -> ByteString -> ByteString

-- | Bitwise logical XOR, as per <a>CIP-122</a>.
xorByteString :: Bool -> ByteString -> ByteString -> ByteString

-- | Bitwise logical complement, as per <a>CIP-122</a>.
complementByteString :: ByteString -> ByteString

-- | Wrapper for calling <tt>unsafesShiftByteString</tt> safely.
--   Specifically, we avoid various edge cases:
--   
--   <ul>
--   <li>Empty <a>ByteString</a>s and zero moves don't do anything</li>
--   <li>Bit moves whose absolute value is larger than the bit length
--   produce all-zeroes</li>
--   </ul>
--   
--   This also ensures we don't accidentally hit integer overflow issues.
shiftByteString :: ByteString -> Integer -> ByteString

-- | Wrapper for calling <a>unsafeRotateByteString</a> safely.
--   Specifically, we avoid various edge cases:
--   
--   <ul>
--   <li>Empty <a>ByteString</a>s and zero moves don't do anything</li>
--   <li>Bit moves whose absolute value is larger than the bit length are
--   reduced modulo the length</li>
--   </ul>
--   
--   Furthermore, we can convert all rotations into positive rotations, by
--   noting that a rotation by <tt>b</tt> is the same as a rotation by
--   <tt>b <a>mod</a> bitLen</tt>, where <tt>bitLen</tt> is the length of
--   the <a>ByteString</a> argument in bits. This value is always
--   non-negative, and if we get 0, we have nothing to do. This reduction
--   also helps us avoid integer overflow issues.
rotateByteString :: ByteString -> Integer -> ByteString

-- | Bit read at index, as per <a>CIP-122</a>
readBit :: ByteString -> Int -> BuiltinResult Bool

-- | Bulk bit write, as per <a>CIP-122</a>
writeBits :: ByteString -> [Integer] -> Bool -> BuiltinResult ByteString

-- | Byte replication, as per <a>CIP-122</a> We want to cautious about the
--   allocation of huge amounts of memory so we impose the same length
--   limit that's used in integerToByteString.
replicateByte :: Integer -> Word8 -> BuiltinResult ByteString

-- | Counting the number of set bits, as per <a>CIP-123</a>.
countSetBits :: ByteString -> Int

-- | Finding the first set bit's index, as per <a>CIP-123</a>.
findFirstSetBit :: ByteString -> Int

-- | Conversion from <a>Integer</a> to <a>ByteString</a>, as per
--   <a>CIP-121</a>.
--   
--   Structured type to help indicate conversion errors.
data IntegerToByteStringError
NegativeInput :: IntegerToByteStringError
NotEnoughDigits :: IntegerToByteStringError
maximumOutputLength :: Integer
instance GHC.Show.Show PlutusCore.Bitwise.IntegerToByteStringError
instance GHC.Classes.Eq PlutusCore.Bitwise.IntegerToByteStringError
instance GHC.Show.Show PlutusCore.Bitwise.WriteBitsException
instance GHC.Classes.Eq PlutusCore.Bitwise.WriteBitsException
instance GHC.Exception.Type.Exception PlutusCore.Bitwise.WriteBitsException

module PlutusCore.Default.Builtins

-- | Default built-in functions.
--   
--   When updating these, make sure to add them to the protocol version
--   listing! See Note [New builtins/language versions and protocol
--   versions]
data DefaultFun
AddInteger :: DefaultFun
SubtractInteger :: DefaultFun
MultiplyInteger :: DefaultFun
DivideInteger :: DefaultFun
QuotientInteger :: DefaultFun
RemainderInteger :: DefaultFun
ModInteger :: DefaultFun
EqualsInteger :: DefaultFun
LessThanInteger :: DefaultFun
LessThanEqualsInteger :: DefaultFun
AppendByteString :: DefaultFun
ConsByteString :: DefaultFun
SliceByteString :: DefaultFun
LengthOfByteString :: DefaultFun
IndexByteString :: DefaultFun
EqualsByteString :: DefaultFun
LessThanByteString :: DefaultFun
LessThanEqualsByteString :: DefaultFun
Sha2_256 :: DefaultFun
Sha3_256 :: DefaultFun
Blake2b_256 :: DefaultFun
VerifyEd25519Signature :: DefaultFun
VerifyEcdsaSecp256k1Signature :: DefaultFun
VerifySchnorrSecp256k1Signature :: DefaultFun
AppendString :: DefaultFun
EqualsString :: DefaultFun
EncodeUtf8 :: DefaultFun
DecodeUtf8 :: DefaultFun
IfThenElse :: DefaultFun
ChooseUnit :: DefaultFun
Trace :: DefaultFun
FstPair :: DefaultFun
SndPair :: DefaultFun
ChooseList :: DefaultFun
MkCons :: DefaultFun
HeadList :: DefaultFun
TailList :: DefaultFun
NullList :: DefaultFun
ChooseData :: DefaultFun
ConstrData :: DefaultFun
MapData :: DefaultFun
ListData :: DefaultFun
IData :: DefaultFun
BData :: DefaultFun
UnConstrData :: DefaultFun
UnMapData :: DefaultFun
UnListData :: DefaultFun
UnIData :: DefaultFun
UnBData :: DefaultFun
EqualsData :: DefaultFun
SerialiseData :: DefaultFun
MkPairData :: DefaultFun
MkNilData :: DefaultFun
MkNilPairData :: DefaultFun
Bls12_381_G1_add :: DefaultFun
Bls12_381_G1_neg :: DefaultFun
Bls12_381_G1_scalarMul :: DefaultFun
Bls12_381_G1_equal :: DefaultFun
Bls12_381_G1_hashToGroup :: DefaultFun
Bls12_381_G1_compress :: DefaultFun
Bls12_381_G1_uncompress :: DefaultFun
Bls12_381_G2_add :: DefaultFun
Bls12_381_G2_neg :: DefaultFun
Bls12_381_G2_scalarMul :: DefaultFun
Bls12_381_G2_equal :: DefaultFun
Bls12_381_G2_hashToGroup :: DefaultFun
Bls12_381_G2_compress :: DefaultFun
Bls12_381_G2_uncompress :: DefaultFun
Bls12_381_millerLoop :: DefaultFun
Bls12_381_mulMlResult :: DefaultFun
Bls12_381_finalVerify :: DefaultFun
Keccak_256 :: DefaultFun
Blake2b_224 :: DefaultFun
IntegerToByteString :: DefaultFun
ByteStringToInteger :: DefaultFun
AndByteString :: DefaultFun
OrByteString :: DefaultFun
XorByteString :: DefaultFun
ComplementByteString :: DefaultFun
ReadBit :: DefaultFun
WriteBits :: DefaultFun
ReplicateByte :: DefaultFun
ShiftByteString :: DefaultFun
RotateByteString :: DefaultFun
CountSetBits :: DefaultFun
FindFirstSetBit :: DefaultFun
Ripemd_160 :: DefaultFun
ExpModInteger :: DefaultFun

-- | Turn a function into another function that <a>fail</a>s when its
--   second argument is <tt>0</tt> or calls the original function otherwise
--   and wraps the result in <a>pure</a>. Useful for correctly handling
--   <a>div</a>, <a>mod</a>, etc.
nonZeroSecondArg :: (Integer -> Integer -> Integer) -> Integer -> Integer -> BuiltinResult Integer

-- | Turn a function returning <a>Either</a> into another function that
--   <a>fail</a>s in the <a>Left</a> case and wraps the result in
--   <a>pure</a> in the <a>Right</a> case.
eitherToBuiltinResult :: Show e => Either e r -> BuiltinResult r

-- | Using 7 bits to encode builtin tags.
builtinTagWidth :: NumBits
encodeBuiltin :: Word8 -> Encoding
decodeBuiltin :: Get Word8
instance Text.PrettyBy.Internal.PrettyBy PlutusCore.Pretty.Plc.PrettyConfigPlc PlutusCore.Default.Builtins.DefaultFun
instance Data.Hashable.Class.Hashable PlutusCore.Default.Builtins.DefaultFun
instance Control.DeepSeq.NFData PlutusCore.Default.Builtins.DefaultFun
instance GHC.Ix.Ix PlutusCore.Default.Builtins.DefaultFun
instance GHC.Generics.Generic PlutusCore.Default.Builtins.DefaultFun
instance GHC.Enum.Bounded PlutusCore.Default.Builtins.DefaultFun
instance GHC.Enum.Enum PlutusCore.Default.Builtins.DefaultFun
instance GHC.Classes.Ord PlutusCore.Default.Builtins.DefaultFun
instance GHC.Classes.Eq PlutusCore.Default.Builtins.DefaultFun
instance GHC.Show.Show PlutusCore.Default.Builtins.DefaultFun
instance NoThunks.Class.NoThunks (PlutusCore.Builtin.Meaning.BuiltinSemanticsVariant PlutusCore.Default.Builtins.DefaultFun)
instance Control.DeepSeq.NFData (PlutusCore.Builtin.Meaning.BuiltinSemanticsVariant PlutusCore.Default.Builtins.DefaultFun)
instance GHC.Generics.Generic (PlutusCore.Builtin.Meaning.BuiltinSemanticsVariant PlutusCore.Default.Builtins.DefaultFun)
instance GHC.Show.Show (PlutusCore.Builtin.Meaning.BuiltinSemanticsVariant PlutusCore.Default.Builtins.DefaultFun)
instance GHC.Enum.Bounded (PlutusCore.Builtin.Meaning.BuiltinSemanticsVariant PlutusCore.Default.Builtins.DefaultFun)
instance GHC.Enum.Enum (PlutusCore.Builtin.Meaning.BuiltinSemanticsVariant PlutusCore.Default.Builtins.DefaultFun)
instance GHC.Classes.Ord (PlutusCore.Builtin.Meaning.BuiltinSemanticsVariant PlutusCore.Default.Builtins.DefaultFun)
instance GHC.Classes.Eq (PlutusCore.Builtin.Meaning.BuiltinSemanticsVariant PlutusCore.Default.Builtins.DefaultFun)
instance Prettyprinter.Internal.Pretty PlutusCore.Default.Builtins.DefaultFun
instance PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage PlutusCore.Default.Builtins.DefaultFun
instance (uni GHC.Types.~ PlutusCore.Default.Universe.DefaultUni) => PlutusCore.Builtin.Meaning.ToBuiltinMeaning uni PlutusCore.Default.Builtins.DefaultFun
instance Data.Default.Class.Default (PlutusCore.Builtin.Meaning.BuiltinSemanticsVariant PlutusCore.Default.Builtins.DefaultFun)
instance Prettyprinter.Internal.Pretty (PlutusCore.Builtin.Meaning.BuiltinSemanticsVariant PlutusCore.Default.Builtins.DefaultFun)
instance Flat.Class.Flat PlutusCore.Default.Builtins.DefaultFun


-- | <tt>nat</tt> and related functions.
module PlutusCore.StdLib.Data.Nat

-- | <tt>Nat</tt> as a PLC type.
--   
--   <pre>
--   fix \(nat :: *) -&gt; all r. r -&gt; (nat -&gt; r) -&gt; r
--   </pre>
natData :: RecursiveType uni fun ()
natTy :: Type TyName uni ()

-- | '0' as a PLC term.
--   
--   <pre>
--   wrapNat [] /\(r :: *) -&gt; \(z : r) (f : nat -&gt; r) -&gt; z
--   </pre>
zero :: TermLike term TyName Name uni fun => term ()

-- | <a>succ</a> as a PLC term.
--   
--   <pre>
--   \(n : nat) -&gt; wrapNat [] /\(r :: *) -&gt; \(z : r) (f : nat -&gt; r) -&gt; f n
--   </pre>
succ :: TermLike term TyName Name uni fun => term ()

-- | <tt>foldrNat</tt> as a PLC term.
--   
--   <pre>
--   /\(r :: *) -&gt; \(f : r -&gt; r) (z : r) -&gt;
--       fix {nat} {r} \(rec : nat -&gt; r) (n : nat) -&gt;
--           unwrap n {r} z \(n' : nat) -&gt; f (rec n')
--   </pre>
foldrNat :: TermLike term TyName Name uni fun => term ()

-- | <tt>foldNat</tt> as a PLC term.
--   
--   <pre>
--   /\(r :: *) -&gt; \(f : r -&gt; r) -&gt;
--       fix {r} {nat -&gt; r} \(rec : r -&gt; nat -&gt; r) (z : r) (n : nat) -&gt;
--           unwrap n {r} z (\(n' : nat) -&gt; rec (f z) n')
--   </pre>
foldNat :: TermLike term TyName Name uni fun => term ()

-- | Convert a <tt>nat</tt> to an <tt>integer</tt>.
--   
--   <pre>
--   foldNat {integer} (addInteger 1) 1
--   </pre>
natToInteger :: (TermLike term TyName Name uni DefaultFun, uni `HasTypeAndTermLevel` Integer) => term ()


-- | Functions related to <tt>integer</tt>.
module PlutusCore.StdLib.Data.Integer
integer :: uni `HasTypeLevel` Integer => Type tyname uni ()

-- | <tt>succ :: Integer -&gt; Integer</tt> as a PLC term.
--   
--   <pre>
--   \(i : integer) -&gt; addInteger i 1
--   </pre>
succInteger :: (TermLike term tyname Name uni DefaultFun, uni `HasTypeAndTermLevel` Integer) => term ()


-- | <tt>boolean</tt> and related functions.
module PlutusCore.StdLib.Data.Bool

-- | <a>Bool</a> as a PLC type.
bool :: uni `HasTypeLevel` Bool => Type tyname uni ()

-- | <a>True</a> as a PLC term.
true :: (TermLike term tyname name uni fun, uni `HasTermLevel` Bool) => term ()

-- | <a>False</a> as a PLC term.
false :: (TermLike term tyname name uni fun, uni `HasTermLevel` Bool) => term ()

-- | <tt>if_then_else_</tt> as a PLC term.
--   
--   <pre>
--   /\(A :: *) -&gt; \(b : Bool) (x y : () -&gt; A) -&gt; IfThenElse {() -&gt; A} b x y ()
--   </pre>
ifThenElse :: forall term uni. (TermLike term TyName Name uni DefaultFun, uni `HasTypeAndTermLevel` Bool, uni `HasTypeAndTermLevel` ()) => term ()


-- | <tt>list</tt> and related functions.
module PlutusCore.StdLib.Data.ScottList

-- | <tt>List</tt> as a PLC type.
--   
--   <pre>
--   fix \(list :: * -&gt; *) (a :: *) -&gt; all (r :: *). r -&gt; (a -&gt; list a -&gt; r) -&gt; r
--   </pre>
listData :: RecursiveType uni fun ()
listTy :: Type TyName uni ()

-- | '[]' as a PLC term.
--   
--   <pre>
--   /\(a :: *) -&gt; wrapList [a] /\(r :: *) -&gt; \(z : r) (f : a -&gt; list a -&gt; r) -&gt; z)
--   </pre>
nil :: TermLike term TyName Name uni fun => term ()

-- | <tt>(:)</tt> as a PLC term.
--   
--   <pre>
--   /\(a :: *) -&gt; \(x : a) (xs : list a) -&gt;
--       wrapList [a] /\(r :: *) -&gt; \(z : r) (f : a -&gt; list a -&gt; r) -&gt; f x xs
--   </pre>
cons :: TermLike term TyName Name uni fun => term ()

-- | <tt>foldrList</tt> as a PLC term.
--   
--   <pre>
--   /\(a :: *) (r :: *) -&gt; \(f : a -&gt; r -&gt; r) (z : r) -&gt;
--       fix {list a} {r} \(rec : list a -&gt; r) (xs : list a) -&gt;
--           unwrap xs {r} z \(x : a) (xs' : list a) -&gt; f x (rec xs')
--   </pre>
foldrList :: TermLike term TyName Name uni fun => term ()

-- | 'foldl'' as a PLC term.
--   
--   <pre>
--   /\(a :: *) (r :: *) -&gt; \(f : r -&gt; a -&gt; r) -&gt;
--       fix {r} {list a -&gt; r} \(rec : r -&gt; list a -&gt; r) (z : r) (xs : list a) -&gt;
--           unwrap xs {r} z \(x : a) (xs' : list a) -&gt; rec (f z x) xs'
--   </pre>
foldList :: TermLike term TyName Name uni fun => term ()

-- | <tt>map</tt> as a PLC term.
--   
--   <pre>
--   /\(a :: *) (b :: *) -&gt; \(f : a -&gt; b) -&gt;
--       foldrList {a} {list b} (\(x : a) -&gt; cons {b} (f x)) (nil {b})
--   </pre>
map :: TermLike term TyName Name uni fun => term ()

-- | <a>reverse</a> as a PLC term.
--   
--   <pre>
--   /\(a :: *) -&gt; \(xs : list a) -&gt;
--       foldList {a} {list a} (\(r : list a) (x : a) -&gt; cons {a} x r) (nil {a})
--   </pre>
reverse :: TermLike term TyName Name uni fun => term ()

-- | <a>enumFromTo</a> as a PLC term
--   
--   <pre>
--   \(n m : integer) -&gt;
--       fix {integer} {list (integer)}
--           (\(rec : integer -&gt; list (integer)) (n' : integer) -&gt;
--               ifThenElse {list (integer)}
--                   (lessThanEqualsInteger n' m)
--                   (cons {integer} n' (rec (succInteger n')))
--                   (nil {integer}))
--           n
--   </pre>
enumFromTo :: (TermLike term TyName Name uni DefaultFun, uni `HasTypeAndTermLevel` Integer, uni `HasTypeAndTermLevel` (), uni `HasTypeAndTermLevel` Bool) => term ()

-- | <a>sum</a> as a PLC term.
--   
--   <pre>
--   foldList {integer} {integer} addInteger 0
--   </pre>
sum :: (TermLike term TyName Name uni DefaultFun, uni `HasTypeAndTermLevel` Integer) => term ()
sumr :: (TermLike term TyName Name uni DefaultFun, uni `HasTypeAndTermLevel` Integer) => term ()

-- | <a>product</a> as a PLC term.
--   
--   <pre>
--   foldList {integer} {integer} multiplyInteger 1
--   </pre>
product :: (TermLike term TyName Name uni DefaultFun, uni `HasTypeAndTermLevel` Integer) => term ()


-- | Functions that generate Plutus Core terms from Haskell values and vice
--   versa.
module PlutusCore.StdLib.Meta

-- | Convert an <a>Integer</a> to a <tt>nat</tt>. TODO: convert PLC's
--   <tt>integer</tt> to <tt>nat</tt> instead.
metaIntegerToNat :: TermLike term TyName Name uni fun => Integer -> term ()

-- | Convert a Haskell <a>Either</a> to a PLC <tt>sum</tt>.
metaEitherToSum :: TermLike term TyName Name uni fun => Type TyName uni () -> Type TyName uni () -> Either (term ()) (term ()) -> term ()

-- | Convert a Haskell list of <a>Term</a>s to a PLC <tt>list</tt>.
metaListToScottList :: TermLike term TyName Name uni fun => Type TyName uni () -> [term ()] -> term ()


-- | In this module we define Church-encoded type-level natural numbers,
--   Church-encoded vectors and Scott-encoded vectors.
--   
--   See <tt><i>docs</i>fomega<i>gadts</i>ScottVec.agda</tt> for how
--   Scott-encoded vectors work.
module PlutusCore.Examples.Data.Vec

-- | <pre>
--   natK = (* -&gt; *) -&gt; * -&gt; *
--   </pre>
natK :: Kind ()

-- | <pre>
--   getEta n = \(f :: * -&gt; *) (z :: *) -&gt; n f z
--   </pre>
getEta :: Type TyName uni () -> Quote (Type TyName uni ())

-- | <pre>
--   zeroT = \(f :: * -&gt; *) (z :: *) -&gt; z
--   </pre>
zeroT :: Type TyName uni ()

-- | <pre>
--   succT = \(n : natK) (f :: * -&gt; *) (z :: *) -&gt; f (n f z)
--   </pre>
succT :: Type TyName uni ()

-- | <pre>
--   plusT = \(n : natK) (m : natK) (f :: * -&gt; *) (z :: *) -&gt; n f (m f z)
--   </pre>
plusT :: Type TyName uni ()

-- | <pre>
--   stepFun a r1 r2 = all (p :: natK). a -&gt; r1 p -&gt; r2 (succT p)
--   </pre>
getStepFun :: TyName -> Type TyName uni () -> TyName -> Quote (Type TyName uni ())

-- | <pre>
--   churchVec =
--       \(a :: *) (n :: natK) -&gt;
--           all (r :: natK -&gt; *). (all (p :: natK). a -&gt; r p -&gt; r (succT p)) -&gt; r zeroT -&gt; r n
--   </pre>
churchVec :: Type TyName uni ()

-- | <pre>
--   churchNil =
--       /\(a :: *) -&gt;
--           /\(r :: natK -&gt; *) -&gt; \(f : all (p :: natK). a -&gt; r p -&gt; r (succT p)) (z : r zeroT) -&gt;
--               z
--   </pre>
churchNil :: Term TyName Name uni fun ()

-- | <pre>
--   churchCons =
--       /\(a :: *) (n :: natK) -&gt; \(x : a) (xs : churchVec a n) -&gt;
--           /\(r :: natK -&gt; *) -&gt; \(f : all (p :: natK). a -&gt; r p -&gt; r (succT p)) (z : r zeroT) -&gt;
--               f {n} x (xs {r} f z)
--   </pre>
churchCons :: Term TyName Name uni fun ()

-- | <pre>
--   churchConcat =
--       /\(a :: *) (n :: natK) (m :: natK) -&gt; \(xs : churchVec a n) (ys : churchVec a m) -&gt;
--           /\(r :: natK -&gt; *) -&gt; \(f : all (p :: natK). a -&gt; r p -&gt; r (succT p)) (z : r zeroT) -&gt;
--               xs
--                   {\(p :: natK) -&gt; r (plusT p m)}
--                   (/\(p :: natK) -&gt; f {plusT p m})
--                   (ys {r} f z)
--   </pre>
churchConcat :: Term TyName Name uni fun ()

-- | <pre>
--   scottVecF =
--       \(a :: *) (rec :: natK -&gt; *) (n :: natK) -&gt;
--           all (r :: natK -&gt; *). (all (p :: natK). a -&gt; rec p -&gt; r (succT p)) -&gt; r zeroT -&gt; r n
--   </pre>
scottVecF :: Type TyName uni ()

-- | <pre>
--   scottVec = \(a :: *) (n :: natK) -&gt; ifix (scottVecF a) n
--   </pre>
scottVec :: Type TyName uni ()

-- | <pre>
--   scottNil =
--       /\(a :: *) -&gt;
--           iwrap (scottVecF a) zeroT
--               (/\(r :: natK -&gt; *) -&gt;
--                   \(f : all (p :: natK). a -&gt; scottVec a p -&gt; r (succT p)) (z : r zeroT) -&gt;
--                       z)
--   </pre>
scottNil :: Term TyName Name uni fun ()

-- | <pre>
--   scottCons =
--       /\(a :: *) (n :: natK) -&gt; \(x : a) (xs : scottVec a n) -&gt;
--           iwrap (scottVecF a) (succT n)
--               (/\(r :: natK -&gt; *) -&gt;
--                   \(f : all (p :: natK). a -&gt; scottVec a p -&gt; r (succT p)) (z : r zeroT) -&gt;
--                       f {n} x xs)
--   </pre>
scottCons :: Term TyName Name uni fun ()

-- | <pre>
--   scottHead =
--       /\(a :: *) (n :: natK) -&gt; (xs : scottVec a (suc n)) -&gt;
--           unwrap
--               xs
--               {\(p :: natK) -&gt; p (\(z :: *) -&gt; a) unit}
--               (/\(p :: natK) (x : a) (xs' : scottVec a p) -&gt; x)
--               unitval
--   </pre>
scottHead :: uni `HasTypeAndTermLevel` () => Term TyName Name uni fun ()

-- | <pre>
--   scottSumHeadsOr0 =
--       /\(n :: natK) -&gt; (xs ys : scottVec integer n) -&gt;
--           unwrap
--               xs
--               {\(p :: natK) -&gt; (scottVec Integer n -&gt; scottVec integer p) -&gt; integer}
--               (/\(p :: natK) (x : integer) (xs' : scottVec integer p)
--                   \(coe : scottVec Integer n -&gt; scottVec integer (suc p)) -&gt;
--                       x + scottHead {integer} {p} (coe ys))
--               (\(coe : scottVec Integer n -&gt; scottVec integer zero) -&gt; 0)
--               (/\(xs' :: scottVec Integer n) -&gt; xs')
--   </pre>
scottSumHeadsOr0 :: (uni `HasTypeAndTermLevel` Integer, uni `HasTypeAndTermLevel` ()) => Term TyName Name uni DefaultFun ()

module PlutusCore.Default

-- | The universe used by default.
data DefaultUni a
[DefaultUniInteger] :: DefaultUni (Esc Integer)
[DefaultUniByteString] :: DefaultUni (Esc ByteString)
[DefaultUniString] :: DefaultUni (Esc Text)
[DefaultUniUnit] :: DefaultUni (Esc ())
[DefaultUniBool] :: DefaultUni (Esc Bool)
[DefaultUniProtoList] :: DefaultUni (Esc [])
[DefaultUniProtoPair] :: DefaultUni (Esc (,))
[DefaultUniApply] :: !DefaultUni (Esc f) -> !DefaultUni (Esc a) -> DefaultUni (Esc (f a))
[DefaultUniData] :: DefaultUni (Esc Data)
[DefaultUniBLS12_381_G1_Element] :: DefaultUni (Esc Element)
[DefaultUniBLS12_381_G2_Element] :: DefaultUni (Esc Element)
[DefaultUniBLS12_381_MlResult] :: DefaultUni (Esc MlResult)
pattern DefaultUniList :: forall {a} {k1} {k2} {f :: k1 -> k2} {a1 :: k1}. () => (a ~ Esc (f a1), Esc f ~ Esc []) => DefaultUni (Esc a1) -> DefaultUni a
pattern DefaultUniPair :: forall {a} {k1} {k2} {f1 :: k1 -> k2} {a1 :: k1} {k3} {k4} {f2 :: k3 -> k4} {a2 :: k3}. () => (a ~ Esc (f1 a1), Esc f1 ~ Esc (f2 a2), Esc f2 ~ Esc (,)) => DefaultUni (Esc a2) -> DefaultUni (Esc a1) -> DefaultUni a

-- | For pleasing the coverage checker.
noMoreTypeFunctions :: DefaultUni (Esc (f :: a -> b -> c -> d)) -> any


-- | Built-in <tt>pair</tt> and related functions.
module PlutusCore.StdLib.Data.Pair

-- | <tt>(,)</tt> as a built-in PLC type.
pair :: uni `HasTypeLevel` (,) => Type tyname uni ()

-- | <tt>fst</tt> as a PLC term.
--   
--   <pre>
--   /\(a :: *) (b :: *) -&gt; \(p : pair a b) -&gt; fst {a} {b} p
--   </pre>
fstPair :: TermLike term tyname name DefaultUni DefaultFun => term ()

-- | <tt>snd</tt> as a PLC term.
--   
--   <pre>
--   /\(a :: *) (b :: *) -&gt; \(p : pair a b) -&gt; snd {a} {b} p
--   </pre>
sndPair :: TermLike term tyname name DefaultUni DefaultFun => term ()

-- | <tt>uncurry</tt> as a PLC term.
--   
--   <pre>
--   /\(a :: *) (b :: *) (c :: *) -&gt; \(f : a -&gt; b -&gt; c) (p : pair a b) -&gt;
--       f (fst {a} {b} p) (snd {a} {b} p)
--   </pre>
uncurry :: TermLike term TyName Name DefaultUni DefaultFun => term ()


-- | Built-in <tt>list</tt> and related functions.
module PlutusCore.StdLib.Data.List

-- | <tt>[]</tt> as a built-in PLC type.
list :: uni `HasTypeLevel` [] => Type tyname uni ()

-- | Pattern matching on built-in lists. <tt>caseList {a} xs</tt> on
--   built-in lists is equivalent to <tt>unwrap xs</tt> on lists defined in
--   PLC itself (hence why we bind <tt>r</tt> after <tt>xs</tt>).
--   
--   <pre>
--   /\(a :: *) -&gt; \(xs : list a) -&gt; /\(r :: *) -&gt; (z : r) (f : a -&gt; list a -&gt; r) -&gt;
--       chooseList
--           {a}
--           {() -&gt; r}
--           xs
--           (\(u : ()) -&gt; z)
--           (\(u : ()) -&gt; f (head {a} xs) (tail {a} xs))
--           ()
--   </pre>
caseList :: TermLike term TyName Name DefaultUni DefaultFun => term ()

-- | <tt>foldr</tt> over built-in lists.
--   
--   <pre>
--   /\(a :: *) (r :: *) -&gt; \(f : a -&gt; r -&gt; r) (z : r) -&gt;
--       fix {list a} {r} \(rec : list a -&gt; r) (xs : list a) -&gt;
--           caseList {a} xs {r} z \(x : a) (xs' : list a) -&gt; f x (rec xs')
--   </pre>
foldrList :: TermLike term TyName Name DefaultUni DefaultFun => term ()

-- | 'foldl'' as a PLC term.
--   
--   <pre>
--   /\(a :: *) (r :: *) -&gt; \(f : r -&gt; a -&gt; r) -&gt;
--       fix {r} {list a -&gt; r} \(rec : r -&gt; list a -&gt; r) (z : r) (xs : list a) -&gt;
--           caseList {a} xs {r} z \(x : a) (xs' : list a) -&gt; rec (f z x) xs'
--   </pre>
foldList :: TermLike term TyName Name DefaultUni DefaultFun => term ()
sum :: TermLike term TyName Name DefaultUni DefaultFun => term ()
sumr :: TermLike term TyName Name DefaultUni DefaultFun => term ()

-- | <a>product</a> as a PLC term.
--   
--   <pre>
--   foldList {integer} {integer} multiplyInteger 1
--   </pre>
product :: TermLike term TyName Name DefaultUni DefaultFun => term ()


-- | Built-in <tt>pair</tt> and related functions.
module PlutusCore.StdLib.Data.Data

-- | <tt>Data</tt> as a built-in PLC type.
dataTy :: uni `HasTypeLevel` Data => Type tyname uni ()

-- | Pattern matching over <a>Data</a> inside PLC.
--   
--   <pre>
--   \(d : data) -&gt;
--       /\(r :: *) -&gt;
--        \(fConstr : integer -&gt; list data -&gt; r)
--         (fMap : list (pair data data) -&gt; r)
--         (fList : list data -&gt; r)
--         (fI : integer -&gt; r)
--         (fB : bytestring -&gt; r) -&gt;
--             chooseData
--                 d
--                 {unit -&gt; r}
--                 (\(u : unit) -&gt; uncurry {integer} {list data} {r} fConstr (unConstrB d))
--                 (\(u : unit) -&gt; fMap (unMapB d))
--                 (\(u : unit) -&gt; fList (unListB d))
--                 (\(u : unit) -&gt; fI (unIB d))
--                 (\(u : unit) -&gt; fB (unBB d))
--                 unitval
--   </pre>
caseData :: TermLike term TyName Name DefaultUni DefaultFun => term ()


-- | This module exports everything from the stdlib via a data type which
--   allows to test various procedures (pretty-printing, type checking,
--   etc) over the entire stdlib in a convenient way: each time a function
--   / data type is added to the stdlib, none of the tests is required to
--   be adapted, instead you just add the new definition to <a>stdLib</a>
--   defined below and all the tests see it automatically.
module PlutusCore.StdLib.Everything

-- | The entire stdlib exported as a single value.
stdLib :: PlcFolderContents DefaultUni DefaultFun


-- | Parsers for PLC terms in DefaultUni.
module PlutusCore.Parser

-- | A PLC <tt>Type</tt> to be parsed. ATM the parser only works for types
--   in the <tt>DefaultUni</tt> with <tt>DefaultFun</tt>.
type PType = Type TyName DefaultUni SrcSpan
varType :: Parser PType
funType :: Parser PType
allType :: Parser PType
lamType :: Parser PType
ifixType :: Parser PType
builtinType :: Parser PType
sopType :: Parser PType
appType :: Parser PType
kind :: Parser (Kind SrcSpan)

-- | Parser for <tt>PType</tt>.
pType :: Parser PType

-- | Parser for built-in type applications. The textual names here should
--   match the ones in the PrettyBy instance for DefaultUni in
--   PlutusCore.Default.Universe.
defaultUniApplication :: Parser (SomeTypeIn (Kinded DefaultUni))

-- | Parser for built-in types (the ones from <a>DefaultUni</a>
--   specifically).
--   
--   <a>Kinded</a> is needed for checking that a type function can be
--   applied to its argument. I.e. we do Plutus kind checking of builtin
--   type applications during parsing, which is unfortunate, but there's no
--   way we could construct a <a>DefaultUni</a> otherwise.
--   
--   In case of kind error no sensible message is shown, only an overly
--   general one:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; import PlutusCore.Error
--   
--   &gt;&gt;&gt; import PlutusCore.Quote
--   
--   &gt;&gt;&gt; let runP = putStrLn . either display display . runQuoteT . parseGen @ParserErrorBundle defaultUni
--   
--   &gt;&gt;&gt; runP "(list integer)"
--   (list integer)
--   
--   &gt;&gt;&gt; runP "(bool integer)"
--   test:1:14:
--     |
--   1 | (bool integer)
--     |              ^
--   expecting "bool", "bytestring", "data", "integer", "list", "pair", "string", "unit", or '('
--   </pre>
--   
--   This is to be fixed.
--   
--   One thing we could do to avoid doing kind checking during parsing is
--   to parse into
--   
--   data TextualUni a where TextualUni :: TextualUni (Esc (Tree Text))
--   
--   i.e. parse into <tt>Tree Text</tt> and do the kind checking
--   afterwards, but given that we'll still need to do the kind checking of
--   builtins regardless (even for UPLC), we don't win much by deferring
--   doing it.
defaultUni :: Parser (SomeTypeIn (Kinded DefaultUni))
tyName :: Parser TyName
newtype ParserState
ParserState :: Map Text Unique -> ParserState
[identifiers] :: ParserState -> Map Text Unique
type Parser = ParsecT ParserError Text (StateT ParserState (ReaderT (Maybe Version) Quote))
initial :: ParserState

-- | Get the version of the program being parsed, if we know it.
getVersion :: Parser (Maybe Version)

-- | Set the version of the program being parsed.
withVersion :: Version -> Parser a -> Parser a

-- | Run an action conditionally based on a predicate on the version. If we
--   don't know the version then the predicate is assumed to be false, i.e.
--   we act if we _know_ the predicate is satisfied.
whenVersion :: (Version -> Bool) -> Parser () -> Parser ()
parse :: (AsParserErrorBundle e, MonadError e m, MonadQuote m) => Parser a -> String -> Text -> m a
toErrorB :: Either (ParseErrorBundle Text ParserError) a -> Either ParserErrorBundle a

-- | Generic parser function in which the file path is just "test".
parseGen :: (AsParserErrorBundle e, MonadError e m, MonadQuote m) => Parser a -> Text -> m a

-- | Space consumer.
whitespace :: Parser ()
leadingWhitespace :: Parser a -> Parser a
trailingWhitespace :: Parser a -> Parser a

-- | Returns a parser for <tt>a</tt> by calling the supplied function on
--   the starting and ending positions of <tt>a</tt>.
--   
--   The supplied function should usually return a parser that does
--   <i>not</i> consume trailing whitespaces. Otherwise, the end position
--   will be the first character after the trailing whitespaces.
withSpan' :: (SrcSpan -> Parser a) -> Parser a

-- | Like <a>withSpan'</a>, but the result parser consumes whitespaces.
--   
--   @withSpan = (&lt;* whitespace) . withSpan'
withSpan :: (SrcSpan -> Parser a) -> Parser a
lexeme :: Parser a -> Parser a
symbol :: Text -> Parser Text
inParens :: Parser a -> Parser a
inBrackets :: Parser a -> Parser a
inBraces :: Parser a -> Parser a
toSrcSpan :: SourcePos -> SourcePos -> SrcSpan
version :: Parser Version

-- | Parses a <a>Name</a>. Does not consume leading or trailing
--   whitespaces.
name :: Parser Name
cachedBuiltin :: Map Text DefaultFun

-- | Parser for builtin functions. Atm the parser can only parse
--   <a>DefaultFun</a>.
builtinFunction :: Parser DefaultFun

-- | Parser for integer constants.
conInteger :: Parser Integer

-- | Parser for a pair of hex digits to a Word8.
hexByte :: Parser Word8

-- | Parser for bytestring constants. They start with "#".
conBS :: Parser ByteString

-- | Parser for string constants (wrapped in double quotes). Note that
--   Data.Text.pack "performs replacement on invalid scalar values", which
--   means that Unicode surrogate code points (corresponding to integers in
--   the range 0xD800-0xDFFF) are converted to the Unicode replacement
--   character U+FFFD (decimal 65533). Thus `(con string "XxD800Z")` parses
--   to a <tt>Text</tt> object whose second character is U+FFFD.
conText :: Parser Text

-- | Parser for unit.
conUnit :: Parser ()

-- | Parser for bool.
conBool :: Parser Bool

-- | Parser for lists.
conList :: DefaultUni (Esc a) -> Parser [a]

-- | Parser for pairs.
conPair :: DefaultUni (Esc a) -> DefaultUni (Esc b) -> Parser (a, b)
conDataNoParens :: Parser Data
conData :: ExpectParens -> Parser Data
con0xBS :: Parser ByteString
conBLS12_381_G1_Element :: Parser Element
conBLS12_381_G2_Element :: Parser Element

-- | Parser for constants of the given type.
constantOf :: ExpectParens -> DefaultUni (Esc a) -> Parser a

-- | Parser of constants whose type is in <a>DefaultUni</a>.
constant :: Parser (Some (ValueOf DefaultUni))
data ExpectParens
ExpectParensYes :: ExpectParens
ExpectParensNo :: ExpectParens

-- | Parser for PLC programs.
program :: Parser (Program TyName Name DefaultUni DefaultFun SrcSpan)

-- | Parse a PLC program. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors. This
--   passes "test" to the parser as the name of the input stream; to supply
--   a name explicity, use `parse program <a>name</a> <a>input</a>`.
parseProgram :: (AsParserErrorBundle e, MonadError e m, MonadQuote m) => Text -> m (Program TyName Name DefaultUni DefaultFun SrcSpan)

-- | Parse a PLC term. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors.
parseTerm :: (AsParserErrorBundle e, MonadError e m, MonadQuote m) => Text -> m (Term TyName Name DefaultUni DefaultFun SrcSpan)

-- | Parse a PLC type. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors.
parseType :: (AsParserErrorBundle e, MonadError e m, MonadQuote m) => Text -> m (Type TyName DefaultUni SrcSpan)
data () => SourcePos

-- | An error encountered during parsing.
data ParserError
BuiltinTypeNotAStar :: !Text -> !SourcePos -> ParserError
UnknownBuiltinFunction :: !Text -> !SourcePos -> ![Text] -> ParserError
InvalidBuiltinConstant :: !Text -> !Text -> !SourcePos -> ParserError


-- | This module helps to visualize and debug the <a>BuiltinMeaning</a>
--   inference machinery from the <tt>Elaborate</tt> and <tt>Meaning</tt>
--   modules.
module PlutusCore.Builtin.Debug

-- | Instantiate type variables in the type of a value using
--   <a>ElaborateFromTo</a>. Example usages:
--   
--   <pre>
--   &gt;&gt;&gt; :t elaborateDebug False
--   elaborateDebug False :: Bool
--   
--   &gt;&gt;&gt; :t elaborateDebug fst
--   elaborateDebug fst
--     :: (TyVarRep ('TyNameRep "a" 0), TyVarRep ('TyNameRep "b" 1))
--        -&gt; TyVarRep ('TyNameRep "a" 0)
--   </pre>
elaborateDebug :: forall a j. ElaborateFromTo DefaultUni 0 j (Term TyName Name DefaultUni DefaultFun ()) a => a -> a
makeBuiltinMeaningDebug :: forall a. MakeBuiltinMeaning a (Term TyName Name DefaultUni DefaultFun ()) => a -> a

-- | The AST of a value with a Plutus type attached to it. The type is for
--   the Plutus type checker to look at. <a>Opaque</a> can appear in the
--   type of the denotation of a builtin.
newtype Opaque val (rep :: Type)
Opaque :: val -> Opaque val (rep :: Type)
[unOpaque] :: Opaque val (rep :: Type) -> val

-- | For unlifting from the <a>Constant</a> constructor when the stored
--   value is of a monomorphic built-in type
--   
--   The <tt>rep</tt> parameter specifies how the type looks on the PLC
--   side (i.e. just like with <tt>Opaque val rep</tt>).
newtype SomeConstant uni (rep :: Type)
SomeConstant :: Some (ValueOf uni) -> SomeConstant uni (rep :: Type)
[unSomeConstant] :: SomeConstant uni (rep :: Type) -> Some (ValueOf uni)

-- | Representation of a type variable: its name and unique and an implicit
--   kind.
data TyNameRep (kind :: Type)
TyNameRep :: Symbol -> Nat -> TyNameRep (kind :: Type)

-- | Representation of an intrinsically-kinded type variable: a name.
data family TyVarRep (name :: TyNameRep kind) :: kind

-- | Representation of an intrinsically-kinded type application: a function
--   and an argument.
data family TyAppRep (fun :: dom -> cod) (arg :: dom) :: cod

-- | Representation of of an intrinsically-kinded universal quantifier: a
--   bound name and a body.
data family TyForallRep (name :: TyNameRep kind) (a :: Type) :: Type

-- | For annotating an uninstantiated built-in type, so that it gets
--   handled by the right instance or type family.
data family BuiltinHead x

-- | Take an iterated application of a built-in type and elaborate every
--   function application inside of it to <a>TyAppRep</a> and annotate the
--   head with <a>BuiltinHead</a>.
--   
--   The idea is that we don't need to process built-in types manually if
--   we simply add some annotations for instance resolution to look for.
--   Think what we'd have to do manually for, say, <tt>ToHoles</tt>:
--   traverse the spine of the application and collect all the holes into a
--   list, which is troubling, because type applications are left-nested
--   and lists are right-nested, so we'd have to use accumulators or an
--   explicit <tt>Reverse</tt> type family. And then we also have
--   <tt>KnownTypeAst</tt> and <tt>ToBinds</tt>, so handling built-in types
--   in a special way for each of those would be a hassle, especially given
--   the fact that type-level Haskell is not exactly good at computing
--   things. With the <a>ElaborateBuiltin</a> approach we get
--   <tt>KnownTypeAst</tt>, <tt>ToHoles</tt> and <tt>ToBinds</tt> for free.
--   
--   We make this an open type family, so that elaboration is customizable
--   for each universe.
type family ElaborateBuiltin uni x

-- | Take a constraint and use it to constrain every argument of a possibly
--   0-ary elaborated application of a built-in type.
type family AllElaboratedArgs constr x

-- | Take a constraint and use it to constrain every argument of a possibly
--   0-ary application of a built-in type.
class AllElaboratedArgs constr (ElaborateBuiltin uni x) => AllBuiltinArgs uni constr x

-- | Turn a list of Haskell types <tt>args</tt> into a functional type
--   ending in <tt>res</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; :kind! FoldArgs [(), Bool] Integer
--   FoldArgs [(), Bool] Integer :: *
--   = () -&gt; Bool -&gt; Integer
--   </pre>
type family FoldArgs args res

-- | The meaning of a built-in function consists of its type represented as
--   a <a>TypeScheme</a>, its Haskell denotation and its uninstantiated
--   runtime denotation.
--   
--   The <a>TypeScheme</a> of a built-in function is used for example for
--   
--   <ol>
--   <li>computing the PLC type of the function to be used during type
--   checking</li>
--   <li>getting arity information</li>
--   <li>generating arbitrary values to apply the function to in tests</li>
--   </ol>
--   
--   The denotation is lazy, so that we don't need to worry about a builtin
--   being bottom (happens in tests). The production path is not affected
--   by that, since only runtime denotations are used for evaluation.
data BuiltinMeaning val cost
BuiltinMeaning :: TypeScheme val args res -> ~FoldArgs args res -> (cost -> BuiltinRuntime val) -> BuiltinMeaning val cost

-- | Constraints available when defining a built-in function.
type HasMeaningIn uni val = (Typeable val, ExMemoryUsage val, HasConstantIn uni val)

-- | A type class for "each function from a set of built-in functions has a
--   <a>BuiltinMeaning</a>".
class (Typeable uni, Typeable fun, Bounded fun, Enum fun, Ix fun, Default (BuiltinSemanticsVariant fun)) => ToBuiltinMeaning uni fun where {
    
    -- | The <tt>cost</tt> part of <a>BuiltinMeaning</a>.
    type CostingPart uni fun;
    
    -- | See Note [Builtin semantics variants]
    data BuiltinSemanticsVariant fun;
}

-- | Get the <a>BuiltinMeaning</a> of a built-in function.
toBuiltinMeaning :: (ToBuiltinMeaning uni fun, HasMeaningIn uni val) => BuiltinSemanticsVariant fun -> fun -> BuiltinMeaning val (CostingPart uni fun)

-- | Feed the <a>TypeScheme</a> of the given built-in function to the
--   continuation.
withTypeSchemeOfBuiltinFunction :: forall val fun r. (ToBuiltinMeaning (UniOf val) fun, ExMemoryUsage val, Typeable val, HasConstant val) => BuiltinSemanticsVariant fun -> fun -> (forall args res. TypeScheme val args res -> r) -> r

-- | Get the type of a built-in function.
typeOfBuiltinFunction :: forall uni fun. ToBuiltinMeaning uni fun => BuiltinSemanticsVariant fun -> fun -> Type TyName uni ()

-- | Chop a function type to get a list of its argument types.
type family GetArgs a

-- | A class that allows us to derive a monotype for a builtin. We could've
--   computed the runtime denotation from the <a>TypeScheme</a> and the
--   denotation of the builtin, but not statically (due to unfolding not
--   working for recursive functions and <a>TypeScheme</a> being recursive,
--   i.e. requiring the conversion function to be recursive), and so it
--   would cause us to retain a lot of evaluation-irrelevant stuff in the
--   constructors of <a>BuiltinRuntime</a>, which has to make evaluation
--   slower (we didn't check) and certainly makes the generated Core much
--   harder to read. Technically speaking, we could get a
--   <tt>RuntimeScheme</tt> from the <a>TypeScheme</a> and the denotation
--   statically if we changed the definition of <a>TypeScheme</a> and made
--   it a singleton, but then the conversion function would have to become
--   a class anyway and we'd just replicate what we have here, except in a
--   much more complicated way.
class KnownMonotype val args res
knownMonotype :: KnownMonotype val args res => TypeScheme val args res

-- | Convert the denotation of a builtin to its runtime counterpart . The
--   argument is in <a>ReadKnownM</a>, because that's what deferred
--   unlifting amounts to: passing the action returning the builtin
--   application around until full saturation, which is when the action
--   actually gets run.
toMonoF :: KnownMonotype val args res => ReadKnownM (FoldArgs args res, FoldArgs args ExBudgetStream) -> BuiltinRuntime val

-- | A class that allows us to derive a polytype for a builtin.
class KnownMonotype val args res => KnownPolytype (binds :: [Some TyNameRep]) val args res
knownPolytype :: KnownPolytype binds val args res => TypeScheme val args res

-- | Convert the denotation of a builtin to its runtime counterpart. The
--   argument is in <a>ReadKnownM</a>, because that's what we need to do:
--   passing the action returning the builtin application around until full
--   saturation, which is when the action actually gets run.
toPolyF :: KnownPolytype binds val args res => ReadKnownM (FoldArgs args res, FoldArgs args ExBudgetStream) -> BuiltinRuntime val

-- | Ensure a built-in function is not nullary and throw a nice error
--   otherwise.
type family ThrowOnBothEmpty binds args isBuiltin a

-- | A function turned into a type class with exactly one fully general
--   instance. We can't package up the constraints of
--   <a>makeBuiltinMeaning</a> (see the instance) into a type or class
--   synonym, because they contain a bunch of variables defined by
--   <tt>~</tt> or determined via functional dependencies and neither class
--   nor type definitions can handle that (see
--   <a>https://gitlab.haskell.org/ghc/ghc/-/issues/7100)</a>. Inlining
--   three lines of constraints whenever we need to call
--   <a>makeBuiltinMeaning</a> over a non-concrete type is a bad option and
--   this abstraction is free anyway, hence its existence.
--   
--   The <tt>a</tt> type variable goes first, because
--   <tt>makeBuiltinMeaning @A</tt> is a common pattern.
class MakeBuiltinMeaning a val

-- | Construct the meaning for a built-in function by automatically
--   deriving its <a>TypeScheme</a>, given
--   
--   <ol>
--   <li>the denotation of the builtin</li>
--   <li>an uninstantiated costing function</li>
--   </ol>
makeBuiltinMeaning :: MakeBuiltinMeaning a val => a -> (cost -> FoldArgs (GetArgs a) ExBudgetStream) -> BuiltinMeaning val cost

-- | Convert a <a>BuiltinMeaning</a> to a <a>BuiltinRuntime</a> given a
--   cost model.
toBuiltinRuntime :: cost -> BuiltinMeaning val cost -> BuiltinRuntime val

-- | Calculate runtime info for all built-in functions given meanings of
--   builtins (as a constraint), the semantics variant of the set of
--   builtins and a cost model.
toBuiltinsRuntime :: (cost ~ CostingPart uni fun, ToBuiltinMeaning uni fun, HasMeaningIn uni val) => BuiltinSemanticsVariant fun -> cost -> BuiltinsRuntime fun val


-- | The internals of the normalizer.
module PlutusCore.Normalize.Internal

-- | The monad transformer that type normalization runs in.
data NormalizeTypeT m tyname uni ann a

-- | The constraints that type normalization requires.
type MonadNormalizeType uni m = (MonadQuote m, HasUniApply uni)

-- | Run a <a>NormalizeTypeT</a> computation.
runNormalizeTypeT :: NormalizeTypeT m tyname uni ann a -> m a

-- | Locally extend a <a>TypeVarEnv</a> in a <a>NormalizeTypeT</a>
--   computation.
withExtendedTypeVarEnv :: (HasUnique tyname TypeUnique, Monad m) => tyname -> Normalized (Type tyname uni ann) -> NormalizeTypeT m tyname uni ann a -> NormalizeTypeT m tyname uni ann a

-- | Normalize a <a>Type</a> in the <a>NormalizeTypeT</a> monad.
normalizeTypeM :: (HasUnique tyname TypeUnique, MonadNormalizeType uni m) => Type tyname uni ann -> NormalizeTypeT m tyname uni ann (Normalized (Type tyname uni ann))

-- | Substitute a type for a variable in a type and normalize in the
--   <a>NormalizeTypeT</a> monad.
substNormalizeTypeM :: (HasUnique tyname TypeUnique, MonadNormalizeType uni m) => Normalized (Type tyname uni ann) -> tyname -> Type tyname uni ann -> NormalizeTypeT m tyname uni ann (Normalized (Type tyname uni ann))

-- | Normalize every <a>Type</a> in a <a>Term</a>.
normalizeTypesInM :: (HasUnique tyname TypeUnique, MonadNormalizeType uni m) => Term tyname name uni fun ann -> NormalizeTypeT m tyname uni ann (Term tyname name uni fun ann)
instance PlutusCore.Quote.MonadQuote m => PlutusCore.Quote.MonadQuote (PlutusCore.Normalize.Internal.NormalizeTypeT m tyname uni ann)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (PlutusCore.Normalize.Internal.NormalizeTypeT m tyname uni ann)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader (PlutusCore.Normalize.Internal.NormalizeTypeEnv tyname uni ann) (PlutusCore.Normalize.Internal.NormalizeTypeT m tyname uni ann)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (PlutusCore.Normalize.Internal.NormalizeTypeT m tyname uni ann)
instance GHC.Base.Monad m => GHC.Base.Monad (PlutusCore.Normalize.Internal.NormalizeTypeT m tyname uni ann)
instance GHC.Base.Alternative m => GHC.Base.Alternative (PlutusCore.Normalize.Internal.NormalizeTypeT m tyname uni ann)
instance GHC.Base.Applicative m => GHC.Base.Applicative (PlutusCore.Normalize.Internal.NormalizeTypeT m tyname uni ann)
instance GHC.Base.Functor m => GHC.Base.Functor (PlutusCore.Normalize.Internal.NormalizeTypeT m tyname uni ann)


-- | The internal module of the type checker that defines the actual
--   algorithms, but not the user-facing API.
module PlutusCore.TypeCheck.Internal

-- | The constraints that are required for kind checking.
type MonadKindCheck err term uni fun ann m = (MonadError err m, AsTypeError err term uni fun ann, ToKind uni)

-- | The general constraints that are required for type checking a Plutus
--   AST.
type MonadTypeCheck err term uni fun ann m = (MonadKindCheck err term uni fun ann m, MonadNormalizeType uni m, GEq uni, Ix fun)

-- | Mapping from <a>Builtin</a>s to their <a>Normalized</a> <a>Kind</a>s.
newtype BuiltinTypes uni fun
BuiltinTypes :: Array fun (Dupable (Normalized (Type TyName uni ()))) -> BuiltinTypes uni fun
[unBuiltinTypes] :: BuiltinTypes uni fun -> Array fun (Dupable (Normalized (Type TyName uni ())))

-- | Configuration of the kind checker.
newtype KindCheckConfig
KindCheckConfig :: HandleNameMismatches -> KindCheckConfig
[_kccHandleNameMismatches] :: KindCheckConfig -> HandleNameMismatches

-- | Configuration of the type checker.
data TypeCheckConfig uni fun
TypeCheckConfig :: KindCheckConfig -> BuiltinTypes uni fun -> TypeCheckConfig uni fun
[_tccKindCheckConfig] :: TypeCheckConfig uni fun -> KindCheckConfig
[_tccBuiltinTypes] :: TypeCheckConfig uni fun -> BuiltinTypes uni fun
type TyVarKinds = UniqueMap TypeUnique (Named (Kind ()))
type VarTypes uni = UniqueMap TermUnique (Named (Dupable (Normalized (Type TyName uni ()))))

-- | Decides what to do upon encountering a variable whose name doesn't
--   match the name of the variable with the same unique that is currently
--   in the scope. Consider for example this type:
--   
--   (a_0 :: *) (b_0 :: *) -&gt; a_0
--   
--   here <tt>b_0</tt> shadows <tt>a_0</tt> and so any variable having the
--   <tt>0</tt>th unique within the body of the lambda references
--   <tt>b_0</tt>, but we have <tt>a_0</tt> there and so there's a name
--   mismatch. Technically, it's not a type error to have a name mismatch,
--   because uniques are the single source of truth, however a name
--   mismatch is deeply suspicious and is likely to be caused by a bug
--   somewhere.
--   
--   We perform the same check for term-level variables too.
data HandleNameMismatches

-- | Throw upon encountering such a name.
DetectNameMismatches :: HandleNameMismatches

-- | Ignore it.
IgnoreNameMismatches :: HandleNameMismatches
class HasKindCheckConfig c_a9I41
kindCheckConfig :: HasKindCheckConfig c_a9I41 => Lens' c_a9I41 KindCheckConfig
kccHandleNameMismatches :: HasKindCheckConfig c_a9I41 => Lens' c_a9I41 HandleNameMismatches

-- | We want <a>HasKindCheckConfig</a> to be a superclass of
--   <a>HasTypeCheckConfig</a> for being able to seamlessly call the kind
--   checker from the type checker, hence we're rolling out our own
--   <a>makeClassy</a> here just to add the constraint.
class HasKindCheckConfig cfg => HasTypeCheckConfig cfg uni fun | cfg -> uni fun
typeCheckConfig :: HasTypeCheckConfig cfg uni fun => Lens' cfg (TypeCheckConfig uni fun)
tccKindCheckConfig :: HasTypeCheckConfig cfg uni fun => Lens' cfg KindCheckConfig
tccBuiltinTypes :: HasTypeCheckConfig cfg uni fun => Lens' cfg (BuiltinTypes uni fun)

-- | The environment that the type checker runs in.
data TypeCheckEnv uni fun cfg
TypeCheckEnv :: cfg -> TyVarKinds -> VarTypes uni -> TypeCheckEnv uni fun cfg
[_tceTypeCheckConfig] :: TypeCheckEnv uni fun cfg -> cfg
[_tceTyVarKinds] :: TypeCheckEnv uni fun cfg -> TyVarKinds
[_tceVarTypes] :: TypeCheckEnv uni fun cfg -> VarTypes uni

-- | The type checking monad that the type checker runs in. In contains a
--   <a>TypeCheckEnv</a> and allows to throw <a>TypeError</a>s.
type TypeCheckT uni fun cfg m = ReaderT (TypeCheckEnv uni fun cfg) m

-- | The constraints that are required for type checking Plutus Core.
type MonadTypeCheckPlc err uni fun ann m = MonadTypeCheck err (Term TyName Name uni fun ()) uni fun ann m

-- | Normalize a <a>Kind</a>.
normalizeTypeM :: MonadNormalizeType uni m => Type TyName uni ann -> TypeCheckT uni fun cfg m (Normalized (Type TyName uni ann))

-- | Substitute a type for a variable in a type and normalize the result.
substNormalizeTypeM :: MonadNormalizeType uni m => Normalized (Type TyName uni ()) -> TyName -> Type TyName uni () -> TypeCheckT uni fun cfg m (Normalized (Type TyName uni ()))

-- | Check a <a>Term</a> against a <tt>NormalizedType</tt>.
checkTypeM :: (MonadTypeCheckPlc err uni fun ann m, HasTypeCheckConfig cfg uni fun) => ann -> Term TyName Name uni fun ann -> Normalized (Type TyName uni ()) -> TypeCheckT uni fun cfg m ()

-- | Run a <tt>TypeCheckM</tt> computation by supplying a
--   <a>TypeCheckConfig</a> to it.
--   
--   Used for both type and kind checking, because we need to do kind
--   checking during type checking and so it makes sense to keep a single
--   monad. However type checking requires a <a>TypeCheckConfig</a>, while
--   kind checking doesn't, hence we keep the kind checker fully
--   polymorphic over the type of config, so that the kinder checker can be
--   run with an empty config (such as <tt>()</tt>) and access to a
--   <a>TypeCheckConfig</a> is not needed.
runTypeCheckM :: cfg -> TypeCheckT uni fun cfg m a -> m a

-- | Extend the context of a <tt>TypeCheckM</tt> computation with a kinded
--   variable.
withTyVar :: TyName -> Kind () -> TypeCheckT uni fun cfg m a -> TypeCheckT uni fun cfg m a
tceTyVarKinds :: forall uni_a9I4j fun_a9I4k cfg_a9I4l fun_a9IbW. Lens (TypeCheckEnv uni_a9I4j fun_a9I4k cfg_a9I4l) (TypeCheckEnv uni_a9I4j fun_a9IbW cfg_a9I4l) TyVarKinds TyVarKinds

-- | Look up the type of a built-in function.
lookupBuiltinM :: (MonadTypeCheck err term uni fun ann m, HasTypeCheckConfig cfg uni fun) => ann -> fun -> TypeCheckT uni fun cfg m (Normalized (Type TyName uni ()))
tceTypeCheckConfig :: forall uni_a9I4j fun_a9I4k cfg_a9I4l fun_a9IbX cfg_a9IbY. Lens (TypeCheckEnv uni_a9I4j fun_a9I4k cfg_a9I4l) (TypeCheckEnv uni_a9I4j fun_a9IbX cfg_a9IbY) cfg_a9I4l cfg_a9IbY

-- | Extend the context of a <tt>TypeCheckM</tt> computation with a typed
--   variable.
withVar :: Name -> Normalized (Type TyName uni ()) -> TypeCheckT uni fun cfg m a -> TypeCheckT uni fun cfg m a
tceVarTypes :: forall uni_a9I4j fun_a9I4k cfg_a9I4l uni_a9IbZ fun_a9Ic0. Lens (TypeCheckEnv uni_a9I4j fun_a9I4k cfg_a9I4l) (TypeCheckEnv uni_a9IbZ fun_a9Ic0 cfg_a9I4l) (VarTypes uni_a9I4j) (VarTypes uni_a9IbZ)

-- | Look up a type variable in the current context.
lookupTyVarM :: (MonadKindCheck err term uni fun ann m, HasKindCheckConfig cfg) => ann -> TyName -> TypeCheckT uni fun cfg m (Kind ())

-- | Look up a term variable in the current context.
lookupVarM :: (MonadTypeCheck err term uni fun ann m, HasTypeCheckConfig cfg uni fun) => ann -> Name -> TypeCheckT uni fun cfg m (Normalized (Type TyName uni ()))

-- | Infer the kind of a type.
inferKindM :: (MonadKindCheck err term uni fun ann m, HasKindCheckConfig cfg) => Type TyName uni ann -> TypeCheckT uni fun cfg m (Kind ())

-- | Check a <a>Kind</a> against a <a>Kind</a>.
checkKindM :: (MonadKindCheck err term uni fun ann m, HasKindCheckConfig cfg) => ann -> Type TyName uni ann -> Kind () -> TypeCheckT uni fun cfg m ()

-- | <pre>
--   unfoldIFixOf pat arg k = NORM (vPat ((a :: k) -&gt; ifix vPat a) arg)
--   </pre>
unfoldIFixOf :: MonadNormalizeType uni m => Normalized (Type TyName uni ()) -> Normalized (Type TyName uni ()) -> Kind () -> TypeCheckT uni fun cfg m (Normalized (Type TyName uni ()))

-- | Synthesize the type of a term, returning a normalized type.
inferTypeM :: (MonadTypeCheckPlc err uni fun ann m, HasTypeCheckConfig cfg uni fun) => Term TyName Name uni fun ann -> TypeCheckT uni fun cfg m (Normalized (Type TyName uni ()))

-- | The constraints that type normalization requires.
type MonadNormalizeType uni m = (MonadQuote m, HasUniApply uni)
instance PlutusCore.TypeCheck.Internal.HasKindCheckConfig (PlutusCore.TypeCheck.Internal.TypeCheckConfig uni fun)
instance PlutusCore.TypeCheck.Internal.HasTypeCheckConfig (PlutusCore.TypeCheck.Internal.TypeCheckConfig uni fun) uni fun
instance PlutusCore.TypeCheck.Internal.HasKindCheckConfig PlutusCore.TypeCheck.Internal.KindCheckConfig
instance GHC.Classes.Eq PlutusCore.TypeCheck.Internal.HandleNameMismatches
instance GHC.Show.Show PlutusCore.TypeCheck.Internal.HandleNameMismatches


-- | The user-facing API of the normalizer.
module PlutusCore.Normalize

-- | Normalize a <a>Kind</a>.
normalizeType :: (HasUnique tyname TypeUnique, MonadNormalizeType uni m) => Type tyname uni ann -> m (Normalized (Type tyname uni ann))

-- | Normalize every <a>Kind</a> in a <a>Term</a>.
normalizeTypesIn :: (HasUnique tyname TypeUnique, HasUnique name TermUnique, MonadNormalizeType uni m) => Term tyname name uni fun ann -> m (Term tyname name uni fun ann)

-- | Normalize every <a>Kind</a> in a <a>Program</a>.
normalizeTypesInProgram :: (HasUnique tyname TypeUnique, HasUnique name TermUnique, MonadNormalizeType uni m) => Program tyname name uni fun ann -> m (Program tyname name uni fun ann)


-- | Kind<i>type inference</i>checking.
module PlutusCore.TypeCheck

-- | For computing the Plutus kind of a built-in type. See
--   <a>kindOfBuiltinType</a>.
class ToKind (uni :: Type -> Type)

-- | The constraints that are required for kind checking.
type MonadKindCheck err term uni fun ann m = (MonadError err m, AsTypeError err term uni fun ann, ToKind uni)

-- | The general constraints that are required for type checking a Plutus
--   AST.
type MonadTypeCheck err term uni fun ann m = (MonadKindCheck err term uni fun ann m, MonadNormalizeType uni m, GEq uni, Ix fun)

-- | The constraint for built-in types/functions are kind/type-checkable.
--   
--   We keep this separate from
--   <a>MonadKindCheck</a>/<a>MonadTypeCheck</a>, because those mainly
--   constrain the monad and <a>Typecheckable</a> constraints only the
--   builtins. In particular useful when the monad gets instantiated and
--   builtins don't. Another reason is that <a>Typecheckable</a> is not
--   required during type checking, since it's only needed for computing
--   <a>BuiltinTypes</a>, which is passed as a regular argument to the
--   worker of the type checker.
type Typecheckable uni fun = (ToKind uni, HasUniApply uni, ToBuiltinMeaning uni fun)

-- | Mapping from <a>Builtin</a>s to their <a>Normalized</a> <a>Kind</a>s.
newtype BuiltinTypes uni fun
BuiltinTypes :: Array fun (Dupable (Normalized (Type TyName uni ()))) -> BuiltinTypes uni fun
[unBuiltinTypes] :: BuiltinTypes uni fun -> Array fun (Dupable (Normalized (Type TyName uni ())))

-- | Configuration of the kind checker.
newtype KindCheckConfig
KindCheckConfig :: HandleNameMismatches -> KindCheckConfig
[_kccHandleNameMismatches] :: KindCheckConfig -> HandleNameMismatches

-- | Configuration of the type checker.
data TypeCheckConfig uni fun
TypeCheckConfig :: KindCheckConfig -> BuiltinTypes uni fun -> TypeCheckConfig uni fun
[_tccKindCheckConfig] :: TypeCheckConfig uni fun -> KindCheckConfig
[_tccBuiltinTypes] :: TypeCheckConfig uni fun -> BuiltinTypes uni fun
tccBuiltinTypes :: HasTypeCheckConfig cfg uni fun => Lens' cfg (BuiltinTypes uni fun)

-- | The default kind checking config.
defKindCheckConfig :: KindCheckConfig

-- | Extract the <a>TypeScheme</a> from a <a>BuiltinMeaning</a> and convert
--   it to the corresponding <a>Kind</a> for each built-in function.
builtinMeaningsToTypes :: (MonadKindCheck err term uni fun ann m, Typecheckable uni fun) => BuiltinSemanticsVariant fun -> ann -> m (BuiltinTypes uni fun)

-- | Get the default type checking config.
getDefTypeCheckConfig :: (MonadKindCheck err term uni fun ann m, Typecheckable uni fun) => ann -> m (TypeCheckConfig uni fun)

-- | Infer the kind of a type.
inferKind :: MonadKindCheck err term uni fun ann m => KindCheckConfig -> Type TyName uni ann -> m (Kind ())

-- | Check a type against a kind. Infers the kind of the type and checks
--   that it's equal to the given kind throwing a <tt>TypeError</tt>
--   (annotated with the value of the <tt>ann</tt> argument) otherwise.
checkKind :: MonadKindCheck err term uni fun ann m => KindCheckConfig -> ann -> Type TyName uni ann -> Kind () -> m ()

-- | Infer the type of a term.
inferType :: MonadTypeCheckPlc err uni fun ann m => TypeCheckConfig uni fun -> Term TyName Name uni fun ann -> m (Normalized (Type TyName uni ()))

-- | Check a term against a type. Infers the type of the term and checks
--   that it's equal to the given type throwing a <tt>TypeError</tt>
--   (annotated with the value of the <tt>ann</tt> argument) otherwise.
checkType :: MonadTypeCheckPlc err uni fun ann m => TypeCheckConfig uni fun -> ann -> Term TyName Name uni fun ann -> Normalized (Type TyName uni ()) -> m ()

-- | Infer the type of a program.
inferTypeOfProgram :: MonadTypeCheckPlc err uni fun ann m => TypeCheckConfig uni fun -> Program TyName Name uni fun ann -> m (Normalized (Type TyName uni ()))

-- | Check a program against a type. Infers the type of the program and
--   checks that it's equal to the given type throwing a <tt>TypeError</tt>
--   (annotated with the value of the <tt>ann</tt> argument) otherwise.
checkTypeOfProgram :: MonadTypeCheckPlc err uni fun ann m => TypeCheckConfig uni fun -> ann -> Program TyName Name uni fun ann -> Normalized (Type TyName uni ()) -> m ()

module PlutusCore.Examples.Data.TreeForest
treeData :: RecursiveType uni fun ()
forestData :: RecursiveType uni fun ()

-- | <pre>
--   /\(a :: *) -&gt; \(x : a) (fr : forest a) -&gt;
--       wrapTree [a] /\(r :: *) -&gt; \(f : a -&gt; forest a -&gt; r) -&gt; f x fr
--   </pre>
treeNode :: HasUniApply uni => Term TyName Name uni fun ()

-- | <pre>
--   /\(a :: *) -&gt;
--       wrapForest [a] /\(r :: *) -&gt; \(z : r) (f : tree a -&gt; forest a -&gt; r) -&gt; z
--   </pre>
forestNil :: HasUniApply uni => Term TyName Name uni fun ()

-- | <pre>
--   /\(a :: *) -&gt; \(tr : tree a) (fr : forest a)
--       wrapForest [a] /\(r :: *) -&gt; \(z : r) (f : tree a -&gt; forest a -&gt; r) -&gt; f tr fr
--   </pre>
forestCons :: HasUniApply uni => Term TyName Name uni fun ()
instance (a GHC.Types.~ ()) => PlutusCore.Examples.Data.TreeForest.HasArrow (PlutusCore.Core.Type.Kind a)
instance (a GHC.Types.~ ()) => PlutusCore.Examples.Data.TreeForest.HasArrow (PlutusCore.Core.Type.Type tyname uni a)

module PlutusCore

-- | Parse a PLC program. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors. This
--   passes "test" to the parser as the name of the input stream; to supply
--   a name explicity, use `parse program <a>name</a> <a>input</a>`.
parseProgram :: (AsParserErrorBundle e, MonadError e m, MonadQuote m) => Text -> m (Program TyName Name DefaultUni DefaultFun SrcSpan)

-- | Parse a PLC term. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors.
parseTerm :: (AsParserErrorBundle e, MonadError e m, MonadQuote m) => Text -> m (Term TyName Name DefaultUni DefaultFun SrcSpan)

-- | Parse a PLC type. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors.
parseType :: (AsParserErrorBundle e, MonadError e m, MonadQuote m) => Text -> m (Type TyName DefaultUni SrcSpan)
data () => SourcePos

-- | The span between two source locations.
--   
--   This corresponds roughly to the <a>SrcSpan</a> used by GHC, but we
--   define our own version so we don't have to depend on <tt>ghc</tt> to
--   use it.
--   
--   The line and column numbers are 1-based, and the unit is Unicode code
--   point (or <a>Char</a>).
data SrcSpan
SrcSpan :: FilePath -> Int -> Int -> Int -> Int -> SrcSpan
[srcSpanFile] :: SrcSpan -> FilePath
[srcSpanSLine] :: SrcSpan -> Int
[srcSpanSCol] :: SrcSpan -> Int
[srcSpanELine] :: SrcSpan -> Int

-- | Same as GHC's <tt>SrcSpan</tt>, <tt>srcSpanECol</tt> is usually one
--   more than the column of the last character of the thing this
--   <tt>SrcSpan</tt> is for (unless the last character is the line break).
[srcSpanECol] :: SrcSpan -> Int
data SrcSpans
data () => Some (tag :: k -> Type)
pattern Some :: forall {k} tag (a :: k). () => tag a -> Some tag

-- | A particular type from a universe.
data SomeTypeIn uni
SomeTypeIn :: !uni (Esc a) -> SomeTypeIn uni
data Kinded uni ta
[Kinded] :: Typeable k => !uni (Esc a) -> Kinded uni (Esc (a :: k))

-- | A value of a particular type from a universe.
data ValueOf uni a
ValueOf :: !uni (Esc a) -> !a -> ValueOf uni a

-- | Wrap a value into <tt>Some (ValueOf uni)</tt>, given its explicit type
--   tag.
someValueOf :: forall a uni. uni (Esc a) -> a -> Some (ValueOf uni)

-- | Wrap a value into <tt>Some (ValueOf uni)</tt>, provided its type is in
--   the universe.
someValue :: forall a uni. uni `Contains` a => a -> Some (ValueOf uni)
someValueType :: Some (ValueOf uni) -> SomeTypeIn uni

-- | "Escapes" a type of an arbitrary kind to fit into <a>Type</a>.
data Esc a

-- | A class for enumerating types and fully instantiated type formers that
--   <tt>uni</tt> contains. For example, a particular <tt>ExampleUni</tt>
--   may have monomorphic types in it:
--   
--   instance ExampleUni <a>Contains</a> Integer where <a>...</a> instance
--   ExampleUni <a>Contains</a> Bool where <a>...</a>
--   
--   as well as polymorphic ones:
--   
--   instance ExampleUni <a>Contains</a> [] where <a>...</a> instance
--   ExampleUni <a>Contains</a> (,) where <a>...</a>
--   
--   as well as their instantiations:
--   
--   instance ExampleUni <a>Contains</a> a =&gt; ExampleUni <a>Contains</a>
--   [a] where <a>...</a> instance (ExampleUni <a>Contains</a> a,
--   ExampleUni <a>Contains</a> b) =&gt; ExampleUni <a>Contains</a> (a, b)
--   where <a>...</a>
--   
--   (a universe can have any subset of the mentioned sorts of types, for
--   example it's fine to have instantiated polymorphic types and not have
--   uninstantiated ones and vice versa)
--   
--   Note that when used as a constraint of a function <a>Contains</a> does
--   not allow you to directly express things like "<tt>uni</tt> has the
--   <tt>Integer</tt>, <tt>Bool</tt> and <tt>[]</tt> types and type
--   formers", because <tt>[]</tt> is not fully instantiated. So you can
--   only say "<tt>uni</tt> has <tt>Integer</tt>, <tt>Bool</tt>,
--   <tt>[Integer]</tt>, <tt>[Bool]</tt>, <tt>[[Integer]]</tt>,
--   <tt>[[Bool]]</tt> etc" and such manual enumeration is annoying, so
--   we'd really like to be able to say that <tt>uni</tt> has lists of
--   arbitrary built-in types (including lists of lists etc).
--   <a>Contains</a> does not allow that, but <a>Includes</a> does. For
--   example, in the body of the following definition:
--   
--   foo :: (uni <a>Includes</a> Integer, uni <a>Includes</a> Bool, uni
--   <a>Includes</a> []) =&gt; <a>...</a> foo = <a>...</a>
--   
--   you can make use of the fact that <tt>uni</tt> has lists of arbitrary
--   included types (integers, booleans and lists).
--   
--   Hence most of the time opt for using the more flexible
--   <a>Includes</a>.
--   
--   <a>Includes</a> is defined in terms of <a>Contains</a>, so you only
--   need to provide a <a>Contains</a> instance per type from the universe
--   and you'll get <a>Includes</a> for free.
class uni `Contains` a
knownUni :: Contains uni a => uni (Esc a)

-- | A universe is <a>Closed</a>, if it's known how to constrain every type
--   from the universe and every type can be encoded to / decoded from a
--   sequence of integer tags. The universe doesn't have to be finite and
--   providing support for infinite universes is the reason why we encode a
--   type as a sequence of integer tags as opposed to a single integer tag.
--   For example, given
--   
--   <pre>
--   data U a where
--       UList :: !(U a) -&gt; U [a]
--       UInt  :: U Int
--   </pre>
--   
--   <tt>UList (UList UInt)</tt> can be encoded to <tt>[0,0,1]</tt> where
--   <tt>0</tt> and <tt>1</tt> are the integer tags of the <tt>UList</tt>
--   and <tt>UInt</tt> constructors, respectively.
class Closed uni where {
    
    -- | A constrant for "<tt>constr a</tt> holds for any <tt>a</tt> from
    --   <tt>uni</tt>".
    type Everywhere uni (constr :: Type -> Constraint) :: Constraint;
}

-- | Encode a type as a sequence of <a>Int</a> tags. The opposite of
--   <tt>decodeUni</tt>.
encodeUni :: Closed uni => uni a -> [Int]

-- | Decode a type and feed it to the continuation.
withDecodedUni :: Closed uni => (forall k (a :: k). Typeable k => uni (Esc a) -> DecodeUniM r) -> DecodeUniM r

-- | Bring a <tt>constr a</tt> instance in scope, provided <tt>a</tt> is a
--   type from the universe and <tt>constr</tt> holds for any type from the
--   universe.
bring :: (Closed uni, uni `Everywhere` constr) => proxy constr -> uni (Esc a) -> (constr a => r) -> r
type family uni `EverywhereAll` constrs

-- | Same as <a>knownUni</a>, but receives a <tt>proxy</tt>.
knownUniOf :: uni `Contains` a => proxy a -> uni (Esc a)
class () => GShow (t :: k -> Type)
gshowsPrec :: forall (a :: k). GShow t => Int -> t a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String
class () => GEq (f :: k -> Type)
geq :: forall (a :: k) (b :: k). GEq f => f a -> f b -> Maybe (a :~: b)

-- | A class for "<tt>uni</tt> has general type application".
class HasUniApply (uni :: Type -> Type)

-- | Apply a type constructor to an argument.
uniApply :: forall k l (f :: k -> l) a. HasUniApply uni => uni (Esc f) -> uni (Esc a) -> uni (Esc (f a))

-- | Deconstruct a type application into the function and the argument and
--   feed them to the continuation. If the type is not an application, then
--   return the default value.
matchUniApply :: HasUniApply uni => uni tb -> r -> (forall k l (f :: k -> l) a. tb ~ Esc (f a) => uni (Esc f) -> uni (Esc a) -> r) -> r

-- | Check if the kind of the given type from the universe is <a>Type</a>.
checkStar :: forall uni a (x :: a). Typeable a => uni (Esc x) -> Maybe (a :~: Type)

-- | Check if one type from the universe can be applied to another (i.e.
--   check that the expected kind of the argument matches the actual one)
--   and call the continuation in the refined context. Fail with
--   <a>mzero</a> otherwise.
withApplicable :: forall (a :: Type) (ab :: Type) f x uni m r. (Typeable ab, Typeable a, MonadPlus m) => uni (Esc (f :: ab)) -> uni (Esc (x :: a)) -> (forall (b :: Type). (Typeable b, ab ~ (a -> b)) => m r) -> m r

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data () => (a :: k) :~: (b :: k)
[Refl] :: forall {k} (a :: k). a :~: a
infix 4 :~:

-- | A constraint for "<tt>uni1</tt> is a subuniverse of <tt>uni2</tt>".
type uni1 <: uni2 = uni1 `Everywhere` Includes uni2

-- | Specifies that the given type is a built-in one and can be embedded
--   into a <a>Kind</a>.
type HasTypeLevel uni x = KnownTypeAst Void uni (ElaborateBuiltin uni x)

-- | Specifies that the given type is a built-in one and its values can be
--   embedded into a <a>Term</a>.
type HasTermLevel uni = Includes uni

-- | The product of <a>HasTypeLevel</a> and <a>HasTermLevel</a>.
type HasTypeAndTermLevel uni x = (uni `HasTypeLevel` x, uni `HasTermLevel` x)

-- | The universe used by default.
data DefaultUni a
[DefaultUniInteger] :: DefaultUni (Esc Integer)
[DefaultUniByteString] :: DefaultUni (Esc ByteString)
[DefaultUniString] :: DefaultUni (Esc Text)
[DefaultUniUnit] :: DefaultUni (Esc ())
[DefaultUniBool] :: DefaultUni (Esc Bool)
[DefaultUniProtoList] :: DefaultUni (Esc [])
[DefaultUniProtoPair] :: DefaultUni (Esc (,))
[DefaultUniApply] :: !DefaultUni (Esc f) -> !DefaultUni (Esc a) -> DefaultUni (Esc (f a))
[DefaultUniData] :: DefaultUni (Esc Data)
[DefaultUniBLS12_381_G1_Element] :: DefaultUni (Esc Element)
[DefaultUniBLS12_381_G2_Element] :: DefaultUni (Esc Element)
[DefaultUniBLS12_381_MlResult] :: DefaultUni (Esc MlResult)
pattern DefaultUniList :: forall {a} {k1} {k2} {f :: k1 -> k2} {a1 :: k1}. () => (a ~ Esc (f a1), Esc f ~ Esc []) => DefaultUni (Esc a1) -> DefaultUni a
pattern DefaultUniPair :: forall {a} {k1} {k2} {f1 :: k1 -> k2} {a1 :: k1} {k3} {k4} {f2 :: k3 -> k4} {a2 :: k3}. () => (a ~ Esc (f1 a1), Esc f1 ~ Esc (f2 a2), Esc f2 ~ Esc (,)) => DefaultUni (Esc a2) -> DefaultUni (Esc a1) -> DefaultUni a

-- | Default built-in functions.
--   
--   When updating these, make sure to add them to the protocol version
--   listing! See Note [New builtins/language versions and protocol
--   versions]
data DefaultFun
AddInteger :: DefaultFun
SubtractInteger :: DefaultFun
MultiplyInteger :: DefaultFun
DivideInteger :: DefaultFun
QuotientInteger :: DefaultFun
RemainderInteger :: DefaultFun
ModInteger :: DefaultFun
EqualsInteger :: DefaultFun
LessThanInteger :: DefaultFun
LessThanEqualsInteger :: DefaultFun
AppendByteString :: DefaultFun
ConsByteString :: DefaultFun
SliceByteString :: DefaultFun
LengthOfByteString :: DefaultFun
IndexByteString :: DefaultFun
EqualsByteString :: DefaultFun
LessThanByteString :: DefaultFun
LessThanEqualsByteString :: DefaultFun
Sha2_256 :: DefaultFun
Sha3_256 :: DefaultFun
Blake2b_256 :: DefaultFun
VerifyEd25519Signature :: DefaultFun
VerifyEcdsaSecp256k1Signature :: DefaultFun
VerifySchnorrSecp256k1Signature :: DefaultFun
AppendString :: DefaultFun
EqualsString :: DefaultFun
EncodeUtf8 :: DefaultFun
DecodeUtf8 :: DefaultFun
IfThenElse :: DefaultFun
ChooseUnit :: DefaultFun
Trace :: DefaultFun
FstPair :: DefaultFun
SndPair :: DefaultFun
ChooseList :: DefaultFun
MkCons :: DefaultFun
HeadList :: DefaultFun
TailList :: DefaultFun
NullList :: DefaultFun
ChooseData :: DefaultFun
ConstrData :: DefaultFun
MapData :: DefaultFun
ListData :: DefaultFun
IData :: DefaultFun
BData :: DefaultFun
UnConstrData :: DefaultFun
UnMapData :: DefaultFun
UnListData :: DefaultFun
UnIData :: DefaultFun
UnBData :: DefaultFun
EqualsData :: DefaultFun
SerialiseData :: DefaultFun
MkPairData :: DefaultFun
MkNilData :: DefaultFun
MkNilPairData :: DefaultFun
Bls12_381_G1_add :: DefaultFun
Bls12_381_G1_neg :: DefaultFun
Bls12_381_G1_scalarMul :: DefaultFun
Bls12_381_G1_equal :: DefaultFun
Bls12_381_G1_hashToGroup :: DefaultFun
Bls12_381_G1_compress :: DefaultFun
Bls12_381_G1_uncompress :: DefaultFun
Bls12_381_G2_add :: DefaultFun
Bls12_381_G2_neg :: DefaultFun
Bls12_381_G2_scalarMul :: DefaultFun
Bls12_381_G2_equal :: DefaultFun
Bls12_381_G2_hashToGroup :: DefaultFun
Bls12_381_G2_compress :: DefaultFun
Bls12_381_G2_uncompress :: DefaultFun
Bls12_381_millerLoop :: DefaultFun
Bls12_381_mulMlResult :: DefaultFun
Bls12_381_finalVerify :: DefaultFun
Keccak_256 :: DefaultFun
Blake2b_224 :: DefaultFun
IntegerToByteString :: DefaultFun
ByteStringToInteger :: DefaultFun
AndByteString :: DefaultFun
OrByteString :: DefaultFun
XorByteString :: DefaultFun
ComplementByteString :: DefaultFun
ReadBit :: DefaultFun
WriteBits :: DefaultFun
ReplicateByte :: DefaultFun
ShiftByteString :: DefaultFun
RotateByteString :: DefaultFun
CountSetBits :: DefaultFun
FindFirstSetBit :: DefaultFun
Ripemd_160 :: DefaultFun
ExpModInteger :: DefaultFun
data Term tyname name uni fun ann

-- | a named variable
Var :: ann -> name -> Term tyname name uni fun ann

-- | lambda abstraction
LamAbs :: ann -> name -> Type tyname uni ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann

-- | application
Apply :: ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann

-- | type abstraction
TyAbs :: ann -> tyname -> Kind ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann

-- | instantiation
TyInst :: ann -> Term tyname name uni fun ann -> Type tyname uni ann -> Term tyname name uni fun ann

-- | wrapping
IWrap :: ann -> Type tyname uni ann -> Type tyname uni ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann

-- | unwrapping See Note [Constr tag type]
Unwrap :: ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann

-- | constructor
Constr :: ann -> Type tyname uni ann -> Word64 -> [Term tyname name uni fun ann] -> Term tyname name uni fun ann

-- | case
Case :: ann -> Type tyname uni ann -> Term tyname name uni fun ann -> [Term tyname name uni fun ann] -> Term tyname name uni fun ann

-- | constants
Constant :: ann -> Some (ValueOf uni) -> Term tyname name uni fun ann

-- | builtin functions
Builtin :: ann -> fun -> Term tyname name uni fun ann

-- | fail with error
Error :: ann -> Type tyname uni ann -> Term tyname name uni fun ann

-- | Get all the direct child <a>Term</a>s of the given <a>Term</a>.
termSubterms :: Traversal' (Term tyname name uni fun ann) (Term tyname name uni fun ann)

-- | Get all the direct child <a>Kind</a>s of the given <a>Term</a>.
termSubtypes :: Traversal' (Term tyname name uni fun ann) (Type tyname uni ann)
termMapNames :: forall tyname tyname' name name' uni fun ann. (tyname -> tyname') -> (name -> name') -> Term tyname name uni fun ann -> Term tyname' name' uni fun ann
programMapNames :: forall tyname tyname' name name' uni fun ann. (tyname -> tyname') -> (name -> name') -> Program tyname name uni fun ann -> Program tyname' name' uni fun ann

-- | Extract the universe from a type.
type family UniOf a :: Type -> Type

-- | A <a>Kind</a> assigned to expressions.
data Type tyname uni ann

-- | Type variable
TyVar :: ann -> tyname -> Type tyname uni ann

-- | Function type
TyFun :: ann -> Type tyname uni ann -> Type tyname uni ann -> Type tyname uni ann

-- | Fix-point type, for constructing self-recursive types
TyIFix :: ann -> Type tyname uni ann -> Type tyname uni ann -> Type tyname uni ann

-- | Polymorphic type
TyForall :: ann -> tyname -> Kind ann -> Type tyname uni ann -> Type tyname uni ann

-- | Builtin type
TyBuiltin :: ann -> SomeTypeIn uni -> Type tyname uni ann

-- | Type lambda
TyLam :: ann -> tyname -> Kind ann -> Type tyname uni ann -> Type tyname uni ann

-- | Type application
TyApp :: ann -> Type tyname uni ann -> Type tyname uni ann -> Type tyname uni ann

-- | Sum-of-products type
TySOP :: ann -> [[Type tyname uni ann]] -> Type tyname uni ann

-- | Get all the direct child <a>Kind</a>s of the given <a>Kind</a>.
typeSubtypes :: Traversal' (Type tyname uni ann) (Type tyname uni ann)
typeMapNames :: forall tyname tyname' uni ann. (tyname -> tyname') -> Type tyname uni ann -> Type tyname' uni ann
data Kind ann
Type :: ann -> Kind ann
KindArrow :: ann -> Kind ann -> Kind ann -> Kind ann

-- | The kind of a pattern functor (the first <a>Kind</a> argument of
--   <a>TyIFix</a>) at a given kind (of the second <a>Kind</a> argument of
--   <a>TyIFix</a>):
--   
--   <pre>
--   toPatFuncKind k = (k -&gt; *) -&gt; k -&gt; *
--   </pre>
toPatFuncKind :: Kind () -> Kind ()
fromPatFuncKind :: Kind () -> Maybe (Kind ())

-- | Extract all <tt>a_i</tt> from <tt>a_0 -&gt; a_1 -&gt; ... -&gt;
--   r</tt>.
argsFunKind :: Kind ann -> [Kind ann]

-- | An error encountered during parsing.
data ParserError
BuiltinTypeNotAStar :: !Text -> !SourcePos -> ParserError
UnknownBuiltinFunction :: !Text -> !SourcePos -> ![Text] -> ParserError
InvalidBuiltinConstant :: !Text -> !Text -> !SourcePos -> ParserError

-- | The version of Plutus Core used by this program.
--   
--   The intention is to convey different levels of backwards compatibility
--   for existing scripts: - Major version changes are
--   backwards-incompatible - Minor version changes are
--   backwards-compatible - Patch version changes should be entirely
--   invisible (and we will likely not use this level)
--   
--   The version used should be changed only when the <i>language
--   itself</i> changes. For example, adding a new kind of term to the
--   language would require a minor version bump; removing a kind of term
--   would require a major version bump.
--   
--   Similarly, changing the semantics of the language will require a
--   version bump, typically a major one. This is the main reason why the
--   version is actually tracked in the AST: we can have two language
--   versions with identical ASTs but different semantics, so we need to
--   track the version explicitly.
--   
--   Compatibility is about compatibility for specific scripts, not about
--   e.g. tools which consume scripts. Adding a new kind of term does not
--   change how existing scripts behave, but does change what tools would
--   need to do to process scripts.
data Version
Version :: Natural -> Natural -> Natural -> Version
[_versionMajor] :: Version -> Natural
[_versionMinor] :: Version -> Natural
[_versionPatch] :: Version -> Natural

-- | A <a>Program</a> is simply a <a>Term</a> coupled with a <a>Version</a>
--   of the core language.
data Program tyname name uni fun ann
Program :: ann -> Version -> Term tyname name uni fun ann -> Program tyname name uni fun ann
[_progAnn] :: Program tyname name uni fun ann -> ann
[_progVer] :: Program tyname name uni fun ann -> Version
[_progTerm] :: Program tyname name uni fun ann -> Term tyname name uni fun ann

-- | A <a>Name</a> represents variables/names in Plutus Core.
data Name
Name :: Text -> Unique -> Name

-- | The identifier name, for use in error messages.
[_nameText] :: Name -> Text

-- | A <a>Unique</a> assigned to the name, allowing for cheap comparisons
--   in the compiler.
[_nameUnique] :: Name -> Unique

-- | We use a <tt>newtype</tt> to enforce separation between names used for
--   types and those used for terms.
newtype TyName
TyName :: Name -> TyName
[unTyName] :: TyName -> Name

-- | A unique identifier
newtype Unique
Unique :: Int -> Unique
[unUnique] :: Unique -> Int

-- | A mapping from <a>Unique</a>s to arbitrary values of type <tt>a</tt>.
--   Since <a>Unique</a> is equivalent to <a>Int</a> (see
--   <a>PlutusCore.Name.Unique</a>), we can use an <tt>IntMap</tt>
--   representation for this type.
newtype UniqueMap unique a
UniqueMap :: IntMap a -> UniqueMap unique a
[unUniqueMap] :: UniqueMap unique a -> IntMap a

-- | A set containing <a>Unique</a>s. Since <a>Unique</a> is equivalent to
--   <a>Int</a> (see <a>PlutusCore.Name.Unique</a>), we can use an
--   <tt>IntSet</tt> representation for this type.
newtype UniqueSet unique
UniqueSet :: IntSet -> UniqueSet unique
[unUniqueSet] :: UniqueSet unique -> IntSet
newtype Normalized a
Normalized :: a -> Normalized a
[unNormalized] :: Normalized a -> a

-- | The latest version of Plutus Core supported by this library.
latestVersion :: Version
termAnn :: Term tyname name uni fun ann -> ann
typeAnn :: Type tyname uni ann -> ann
tyVarDeclAnn :: forall tyname_a7d1z ann_a7d1A. Lens' (TyVarDecl tyname_a7d1z ann_a7d1A) ann_a7d1A
tyVarDeclName :: forall tyname_a7d1z ann_a7d1A tyname_a7dfC. Lens (TyVarDecl tyname_a7d1z ann_a7d1A) (TyVarDecl tyname_a7dfC ann_a7d1A) tyname_a7d1z tyname_a7dfC
tyVarDeclKind :: forall tyname_a7d1z ann_a7d1A. Lens' (TyVarDecl tyname_a7d1z ann_a7d1A) (Kind ann_a7d1A)
varDeclAnn :: forall tyname_a7dg0 name_a7dg1 uni_a7dg2 ann_a7dg3. Lens' (VarDecl tyname_a7dg0 name_a7dg1 uni_a7dg2 ann_a7dg3) ann_a7dg3
varDeclName :: forall tyname_a7dg0 name_a7dg1 uni_a7dg2 ann_a7dg3 name_a7dq7. Lens (VarDecl tyname_a7dg0 name_a7dg1 uni_a7dg2 ann_a7dg3) (VarDecl tyname_a7dg0 name_a7dq7 uni_a7dg2 ann_a7dg3) name_a7dg1 name_a7dq7
varDeclType :: forall tyname_a7dg0 name_a7dg1 uni_a7dg2 ann_a7dg3 tyname_a7dq8 uni_a7dq9. Lens (VarDecl tyname_a7dg0 name_a7dg1 uni_a7dg2 ann_a7dg3) (VarDecl tyname_a7dq8 name_a7dg1 uni_a7dq9 ann_a7dg3) (Type tyname_a7dg0 uni_a7dg2 ann_a7dg3) (Type tyname_a7dq8 uni_a7dq9 ann_a7dg3)
tyDeclAnn :: forall tyname_a7dqx uni_a7dqy ann_a7dqz. Lens' (TyDecl tyname_a7dqx uni_a7dqy ann_a7dqz) ann_a7dqz
tyDeclType :: forall tyname_a7dqx uni_a7dqy ann_a7dqz tyname_a7dAY uni_a7dAZ. Lens (TyDecl tyname_a7dqx uni_a7dqy ann_a7dqz) (TyDecl tyname_a7dAY uni_a7dAZ ann_a7dqz) (Type tyname_a7dqx uni_a7dqy ann_a7dqz) (Type tyname_a7dAY uni_a7dAZ ann_a7dqz)
tyDeclKind :: forall tyname_a7dqx uni_a7dqy ann_a7dqz. Lens' (TyDecl tyname_a7dqx uni_a7dqy ann_a7dqz) (Kind ann_a7dqz)
progAnn :: forall tyname_a7aWk name_a7aWl uni_a7aWm fun_a7aWn ann_a7aWo. Lens' (Program tyname_a7aWk name_a7aWl uni_a7aWm fun_a7aWn ann_a7aWo) ann_a7aWo
progVer :: forall tyname_a7aWk name_a7aWl uni_a7aWm fun_a7aWn ann_a7aWo. Lens' (Program tyname_a7aWk name_a7aWl uni_a7aWm fun_a7aWn ann_a7aWo) Version
progTerm :: forall tyname_a7aWk name_a7aWl uni_a7aWm fun_a7aWn ann_a7aWo tyname_a7d16 name_a7d17 uni_a7d18 fun_a7d19. Lens (Program tyname_a7aWk name_a7aWl uni_a7aWm fun_a7aWn ann_a7aWo) (Program tyname_a7d16 name_a7d17 uni_a7d18 fun_a7d19 ann_a7aWo) (Term tyname_a7aWk name_a7aWl uni_a7aWm fun_a7aWn ann_a7aWo) (Term tyname_a7d16 name_a7d17 uni_a7d18 fun_a7d19 ann_a7aWo)

-- | Map a function over the set of built-in functions.
mapFun :: (fun -> fun') -> Term tyname name uni fun ann -> Term tyname name uni fun' ann

-- | A term name as a de Bruijn index, without the name string.
newtype DeBruijn
DeBruijn :: Index -> DeBruijn
[dbnIndex] :: DeBruijn -> Index

-- | A type name as a de Bruijn index, without the name string.
newtype TyDeBruijn
TyDeBruijn :: DeBruijn -> TyDeBruijn

-- | A term name as a de Bruijn index.
data NamedDeBruijn
NamedDeBruijn :: !Text -> !Index -> NamedDeBruijn
[ndbnString] :: NamedDeBruijn -> !Text
[ndbnIndex] :: NamedDeBruijn -> !Index

-- | A type name as a de Bruijn index.
newtype NamedTyDeBruijn
NamedTyDeBruijn :: NamedDeBruijn -> NamedTyDeBruijn

-- | Convert a <a>Term</a> with <a>TyName</a>s and <a>Name</a>s into a
--   <a>Term</a> with <a>NamedTyDeBruijn</a>s and <a>NamedDeBruijn</a>s.
--   Will throw an error if a free variable is encountered.
deBruijnTerm :: (AsFreeVariableError e, MonadError e m) => Term TyName Name uni fun ann -> m (Term NamedTyDeBruijn NamedDeBruijn uni fun ann)

-- | Convert a <a>Term</a> with <a>NamedTyDeBruijn</a>s and
--   <a>NamedDeBruijn</a>s into a <a>Term</a> with <a>TyName</a>s and
--   <a>Name</a>s. Will throw an error if a free variable is encountered.
unDeBruijnTerm :: (MonadQuote m, AsFreeVariableError e, MonadError e m) => Term NamedTyDeBruijn NamedDeBruijn uni fun ann -> m (Term TyName Name uni fun ann)

-- | All kinds of uniques an entity contains.
type family HasUniques a :: Constraint

-- | The class of things that can be renamed. I.e. things that are capable
--   of satisfying the global uniqueness condition.
class Rename a

-- | Rename <a>Unique</a>s so that they're globally unique. In case there
--   are any free variables, they must be left untouched and bound
--   variables must not get renamed to free ones. Must always assign new
--   names to bound variables, so that <tt>rename</tt> can be used for
--   alpha-renaming as well.
rename :: (Rename a, MonadQuote m) => a -> m a

-- | Normalize every <a>Kind</a> in a <a>Term</a>.
normalizeTypesIn :: (HasUnique tyname TypeUnique, HasUnique name TermUnique, MonadNormalizeType uni m) => Term tyname name uni fun ann -> m (Term tyname name uni fun ann)

-- | Normalize every <a>Kind</a> in a <a>Program</a>.
normalizeTypesInProgram :: (HasUnique tyname TypeUnique, HasUnique name TermUnique, MonadNormalizeType uni m) => Program tyname name uni fun ann -> m (Program tyname name uni fun ann)
class AsTypeError r_a7UN6 term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR | r_a7UN6 -> term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR
_TypeError :: AsTypeError r_a7UN6 term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR => Prism' r_a7UN6 (TypeError term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR)
_KindMismatch :: AsTypeError r_a7UN6 term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR => Prism' r_a7UN6 (ann_a7ScR, Type TyName uni_a7ScP (), ExpectedShapeOr (Kind ()), Kind ())
_TypeMismatch :: AsTypeError r_a7UN6 term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR => Prism' r_a7UN6 (ann_a7ScR, term_a7ScO, ExpectedShapeOr (Type TyName uni_a7ScP ()), Normalized (Type TyName uni_a7ScP ()))
_TyNameMismatch :: AsTypeError r_a7UN6 term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR => Prism' r_a7UN6 (ann_a7ScR, TyName, TyName)
_NameMismatch :: AsTypeError r_a7UN6 term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR => Prism' r_a7UN6 (ann_a7ScR, Name, Name)
_FreeTypeVariableE :: AsTypeError r_a7UN6 term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR => Prism' r_a7UN6 (ann_a7ScR, TyName)
_FreeVariableE :: AsTypeError r_a7UN6 term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR => Prism' r_a7UN6 (ann_a7ScR, Name)
_UnknownBuiltinFunctionE :: AsTypeError r_a7UN6 term_a7ScO uni_a7ScP fun_a7ScQ ann_a7ScR => Prism' r_a7UN6 (ann_a7ScR, fun_a7ScQ)
data TypeError term uni fun ann
data Error uni fun ann
ParseErrorE :: !ParserErrorBundle -> Error uni fun ann
UniqueCoherencyErrorE :: !UniqueError ann -> Error uni fun ann
TypeErrorE :: !TypeError (Term TyName Name uni fun ()) uni fun ann -> Error uni fun ann
NormCheckErrorE :: !NormCheckError TyName Name uni fun ann -> Error uni fun ann
FreeVariableErrorE :: !FreeVariableError -> Error uni fun ann
class AsError r_a7V3b uni_a7ScL fun_a7ScM ann_a7ScN | r_a7V3b -> uni_a7ScL fun_a7ScM ann_a7ScN
_Error :: AsError r_a7V3b uni_a7ScL fun_a7ScM ann_a7ScN => Prism' r_a7V3b (Error uni_a7ScL fun_a7ScM ann_a7ScN)
_ParseErrorE :: AsError r_a7V3b uni_a7ScL fun_a7ScM ann_a7ScN => Prism' r_a7V3b ParserErrorBundle
_UniqueCoherencyErrorE :: AsError r_a7V3b uni_a7ScL fun_a7ScM ann_a7ScN => Prism' r_a7V3b (UniqueError ann_a7ScN)
_TypeErrorE :: AsError r_a7V3b uni_a7ScL fun_a7ScM ann_a7ScN => Prism' r_a7V3b (TypeError (Term TyName Name uni_a7ScL fun_a7ScM ()) uni_a7ScL fun_a7ScM ann_a7ScN)
_NormCheckErrorE :: AsError r_a7V3b uni_a7ScL fun_a7ScM ann_a7ScN => Prism' r_a7V3b (NormCheckError TyName Name uni_a7ScL fun_a7ScM ann_a7ScN)
_FreeVariableErrorE :: AsError r_a7V3b uni_a7ScL fun_a7ScM ann_a7ScN => Prism' r_a7V3b FreeVariableError
data NormCheckError tyname name uni fun ann
BadType :: !ann -> !Type tyname uni ann -> !Text -> NormCheckError tyname name uni fun ann
BadTerm :: !ann -> !Term tyname name uni fun ann -> !Text -> NormCheckError tyname name uni fun ann
class AsNormCheckError r_a7UGI tyname_a7ScT name_a7ScU uni_a7ScV fun_a7ScW ann_a7ScX | r_a7UGI -> tyname_a7ScT name_a7ScU uni_a7ScV fun_a7ScW ann_a7ScX
_NormCheckError :: AsNormCheckError r_a7UGI tyname_a7ScT name_a7ScU uni_a7ScV fun_a7ScW ann_a7ScX => Prism' r_a7UGI (NormCheckError tyname_a7ScT name_a7ScU uni_a7ScV fun_a7ScW ann_a7ScX)
_BadType :: AsNormCheckError r_a7UGI tyname_a7ScT name_a7ScU uni_a7ScV fun_a7ScW ann_a7ScX => Prism' r_a7UGI (ann_a7ScX, Type tyname_a7ScT uni_a7ScV ann_a7ScX, Text)
_BadTerm :: AsNormCheckError r_a7UGI tyname_a7ScT name_a7ScU uni_a7ScV fun_a7ScW ann_a7ScX => Prism' r_a7UGI (ann_a7ScX, Term tyname_a7ScT name_a7ScU uni_a7ScV fun_a7ScW ann_a7ScX, Text)
data UniqueError ann
MultiplyDefined :: !Unique -> !ann -> !ann -> UniqueError ann
IncoherentUsage :: !Unique -> !ann -> !ann -> UniqueError ann
FreeVariable :: !Unique -> !ann -> UniqueError ann
class AsUniqueError r_a7UAM ann_a7ScY | r_a7UAM -> ann_a7ScY
_UniqueError :: AsUniqueError r_a7UAM ann_a7ScY => Prism' r_a7UAM (UniqueError ann_a7ScY)
_MultiplyDefined :: AsUniqueError r_a7UAM ann_a7ScY => Prism' r_a7UAM (Unique, ann_a7ScY, ann_a7ScY)
_IncoherentUsage :: AsUniqueError r_a7UAM ann_a7ScY => Prism' r_a7UAM (Unique, ann_a7ScY, ann_a7ScY)
_FreeVariable :: AsUniqueError r_a7UAM ann_a7ScY => Prism' r_a7UAM (Unique, ann_a7ScY)

-- | We cannot do a correct translation to or from de Bruijn indices if the
--   program is not well-scoped. So we throw an error in such a case.
data FreeVariableError
FreeUnique :: !Unique -> FreeVariableError
FreeIndex :: !Index -> FreeVariableError
class AsFreeVariableError r_a1KDI
_FreeVariableError :: AsFreeVariableError r_a1KDI => Prism' r_a1KDI FreeVariableError
_FreeUnique :: AsFreeVariableError r_a1KDI => Prism' r_a1KDI Unique
_FreeIndex :: AsFreeVariableError r_a1KDI => Prism' r_a1KDI Index

-- | A non-transformer version of <a>QuoteT</a>.
type Quote = QuoteT Identity

-- | See <a>runQuoteT</a>.
runQuote :: Quote a -> a

-- | The "quotation" monad transformer. Within this monad you can do safe
--   construction of PLC terms using quasiquotation, fresh-name generation,
--   and parsing.
data QuoteT m a

-- | Run a quote from an empty identifier state. Note that the resulting
--   term cannot necessarily be safely combined with other terms - that
--   should happen inside <a>QuoteT</a>.
runQuoteT :: Monad m => QuoteT m a -> m a

-- | A monad that allows lifting of quoted expressions.
class Monad m => MonadQuote m
liftQuote :: MonadQuote m => Quote a -> m a

-- | Get a fresh <a>Unique</a>.
freshUnique :: MonadQuote m => m Unique

-- | Get a fresh <a>Name</a>, given the annotation and the <a>Text</a>
--   name.
freshName :: MonadQuote m => Text -> m Name

-- | Get a fresh <a>TyName</a>, given the annotation and the <a>Text</a>
--   name.
freshTyName :: MonadQuote m => Text -> m TyName

-- | The parameterized type of results various evaluation engines return.
--   On the PLC side this becomes (via <tt>makeKnown</tt>) either a call to
--   <tt>Error</tt> or a value of the PLC counterpart of type <tt>a</tt>.
data EvaluationResult a
EvaluationSuccess :: !a -> EvaluationResult a
EvaluationFailure :: EvaluationResult a

-- | Applies one program to another. Fails if the versions do not match and
--   tries to merge annotations.
applyProgram :: (MonadError ApplyProgramError m, Semigroup a) => Program tyname name uni fun a -> Program tyname name uni fun a -> m (Program tyname name uni fun a)

-- | Count the number of AST nodes in a term.
termSize :: Term tyname name uni fun ann -> Size

-- | Count the number of AST nodes in a type.
typeSize :: Type tyname uni ann -> Size

-- | Count the number of AST nodes in a kind.
--   
--   <pre>
--   &gt;&gt;&gt; kindSize $ Type ()
--   Size {unSize = 1}
--   
--   &gt;&gt;&gt; kindSize $ KindArrow () (KindArrow () (Type ()) (Type ())) (Type ())
--   Size {unSize = 5}
--   </pre>
kindSize :: Kind a -> Size

-- | Count the number of AST nodes in a program.
programSize :: Program tyname name uni fun ann -> Size

-- | Compute the size of the serializabled form of a value.
serialisedSize :: Flat a => a -> Integer

module PlutusCore.Examples.Builtins
size :: forall a. (Bounded a, Enum a) => Int
data ExtensionFun
Factorial :: ExtensionFun
ForallFortyTwo :: ExtensionFun
SumInteger :: ExtensionFun
Const :: ExtensionFun
Id :: ExtensionFun
IdAssumeBool :: ExtensionFun
IdAssumeCheckBool :: ExtensionFun
IdSomeConstantBool :: ExtensionFun
IdIntegerAsBool :: ExtensionFun
IdFInteger :: ExtensionFun
IdList :: ExtensionFun
IdRank2 :: ExtensionFun
ScottToMetaUnit :: ExtensionFun
FailingSucc :: ExtensionFun
ExpensiveSucc :: ExtensionFun
FailingPlus :: ExtensionFun
ExpensivePlus :: ExtensionFun
IsConstant :: ExtensionFun
UnsafeCoerce :: ExtensionFun
UnsafeCoerceEl :: ExtensionFun
Undefined :: ExtensionFun
Absurd :: ExtensionFun
ErrorPrime :: ExtensionFun
Comma :: ExtensionFun
BiconstPair :: ExtensionFun
Swap :: ExtensionFun
SwapEls :: ExtensionFun
ExtensionVersion :: ExtensionFun
TrackCosts :: ExtensionFun
IntNoIntegerNoWord :: ExtensionFun

-- | Normally <tt>forall</tt> in the type of a Haskell function gets
--   detected and instantiated automatically, however there's no way of
--   doing that for a <tt>forall</tt> that binds a never referenced type
--   variable. Which is OK, because that would be a pretty weird builtin,
--   however it's definable and for the purpose of testing we do introduce
--   such a builtin, hence this definition allowing us to create an
--   <tt>all</tt> that binds a never referenced type variable in Plutus
--   while still using <a>makeBuiltinMeaning</a>.
newtype MetaForall name a
MetaForall :: a -> MetaForall name a
data PlcListRep (a :: Type)
data BuiltinErrorCall
BuiltinErrorCall :: BuiltinErrorCall

-- | For the most part we don't care about costing functions of example
--   builtins, hence this class for being explicit about not caring.
class Whatever a

-- | The costing function of a builtin whose costing function doesn't
--   matter.
whatever :: Whatever a => a
instance Data.Hashable.Class.Hashable PlutusCore.Examples.Builtins.ExtensionFun
instance GHC.Generics.Generic PlutusCore.Examples.Builtins.ExtensionFun
instance GHC.Ix.Ix PlutusCore.Examples.Builtins.ExtensionFun
instance GHC.Enum.Bounded PlutusCore.Examples.Builtins.ExtensionFun
instance GHC.Enum.Enum PlutusCore.Examples.Builtins.ExtensionFun
instance GHC.Classes.Ord PlutusCore.Examples.Builtins.ExtensionFun
instance GHC.Classes.Eq PlutusCore.Examples.Builtins.ExtensionFun
instance GHC.Show.Show PlutusCore.Examples.Builtins.ExtensionFun
instance GHC.Exception.Type.Exception PlutusCore.Examples.Builtins.BuiltinErrorCall
instance GHC.Classes.Eq PlutusCore.Examples.Builtins.BuiltinErrorCall
instance GHC.Show.Show PlutusCore.Examples.Builtins.BuiltinErrorCall
instance GHC.Show.Show (PlutusCore.Builtin.Meaning.BuiltinSemanticsVariant PlutusCore.Examples.Builtins.ExtensionFun)
instance GHC.Enum.Bounded (PlutusCore.Builtin.Meaning.BuiltinSemanticsVariant PlutusCore.Examples.Builtins.ExtensionFun)
instance GHC.Enum.Enum (PlutusCore.Builtin.Meaning.BuiltinSemanticsVariant PlutusCore.Examples.Builtins.ExtensionFun)
instance GHC.Classes.Ord (PlutusCore.Builtin.Meaning.BuiltinSemanticsVariant PlutusCore.Examples.Builtins.ExtensionFun)
instance GHC.Classes.Eq (PlutusCore.Builtin.Meaning.BuiltinSemanticsVariant PlutusCore.Examples.Builtins.ExtensionFun)
instance PlutusCore.Examples.Builtins.Whatever b => PlutusCore.Examples.Builtins.Whatever (a -> b)
instance PlutusCore.Examples.Builtins.Whatever PlutusCore.Evaluation.Machine.ExBudgetStream.ExBudgetStream
instance (uni GHC.Types.~ PlutusCore.Default.Universe.DefaultUni) => PlutusCore.Builtin.Meaning.ToBuiltinMeaning uni PlutusCore.Examples.Builtins.ExtensionFun
instance (tyname GHC.Types.~ PlutusCore.Name.Unique.TyName, PlutusCore.Builtin.KnownTypeAst.KnownTypeAst tyname uni a) => PlutusCore.Builtin.KnownTypeAst.KnownTypeAst tyname uni (PlutusCore.Examples.Builtins.PlcListRep a)
instance forall kind (name :: PlutusCore.Builtin.Polymorphism.TyNameRep kind) (text :: GHC.Types.Symbol) (uniq :: GHC.TypeNats.Nat) tyname (uni :: * -> *) a. (name GHC.Types.~ 'PlutusCore.Builtin.Polymorphism.TyNameRep text uniq, GHC.TypeLits.KnownSymbol text, GHC.TypeNats.KnownNat uniq, PlutusCore.Builtin.KnownKind.KnownKind kind, PlutusCore.Builtin.KnownTypeAst.KnownTypeAst tyname uni a) => PlutusCore.Builtin.KnownTypeAst.KnownTypeAst tyname uni (PlutusCore.Examples.Builtins.MetaForall name a)
instance forall k term a (name :: k). PlutusCore.Builtin.KnownType.MakeKnownIn PlutusCore.Default.Universe.DefaultUni term a => PlutusCore.Builtin.KnownType.MakeKnownIn PlutusCore.Default.Universe.DefaultUni term (PlutusCore.Examples.Builtins.MetaForall name a)
instance Prettyprinter.Internal.Pretty PlutusCore.Examples.Builtins.ExtensionFun
instance Data.Default.Class.Default (PlutusCore.Builtin.Meaning.BuiltinSemanticsVariant PlutusCore.Examples.Builtins.ExtensionFun)
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b) => GHC.Enum.Bounded (Data.Either.Either a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Enum a, GHC.Enum.Enum b) => GHC.Enum.Enum (Data.Either.Either a b)
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Ix.Ix a, GHC.Ix.Ix b) => GHC.Ix.Ix (Data.Either.Either a b)
instance (PlutusCore.Builtin.Meaning.ToBuiltinMeaning uni fun1, PlutusCore.Builtin.Meaning.ToBuiltinMeaning uni fun2, Data.Default.Class.Default (PlutusCore.Builtin.Meaning.BuiltinSemanticsVariant fun1), Data.Default.Class.Default (PlutusCore.Builtin.Meaning.BuiltinSemanticsVariant fun2)) => PlutusCore.Builtin.Meaning.ToBuiltinMeaning uni (Data.Either.Either fun1 fun2)
instance (Data.Default.Class.Default (PlutusCore.Builtin.Meaning.BuiltinSemanticsVariant fun1), Data.Default.Class.Default (PlutusCore.Builtin.Meaning.BuiltinSemanticsVariant fun2)) => Data.Default.Class.Default (PlutusCore.Builtin.Meaning.BuiltinSemanticsVariant (Data.Either.Either fun1 fun2))
instance (tyname GHC.Types.~ PlutusCore.Name.Unique.TyName) => PlutusCore.Builtin.KnownTypeAst.KnownTypeAst tyname PlutusCore.Default.Universe.DefaultUni GHC.Base.Void
instance (PlutusCore.Core.Type.UniOf term GHC.Types.~ PlutusCore.Default.Universe.DefaultUni) => PlutusCore.Builtin.KnownType.MakeKnownIn PlutusCore.Default.Universe.DefaultUni term GHC.Base.Void
instance (PlutusCore.Core.Type.UniOf term GHC.Types.~ PlutusCore.Default.Universe.DefaultUni) => PlutusCore.Builtin.KnownType.ReadKnownIn PlutusCore.Default.Universe.DefaultUni term GHC.Base.Void

module PlutusCore.Examples.Data.Pair

-- | Apply a monomorphic function to both components of a pair.
--   
--   <pre>
--   /\(a :: *) -&gt; \(f : a -&gt; a) (p : pair a a) -&gt;
--       comma {a} {a} (f (fst {a} {a} p)) (f (snd {a} {a} p))
--   </pre>
obothPair :: TermLike term TyName Name DefaultUni (Either DefaultFun ExtensionFun) => term ()

module PlutusCore.Examples.Data.List

-- | Monomorphic <tt>map</tt> over built-in lists.
--   
--   /(a :: *) -&gt; (f : a -&gt; a) -&gt; fix {list a} {list a} (rec :
--   list a -&gt; list a) (xs : list a) -&gt; caseList {a} xs {list a} xs
--   (x : a) (xs' : list a) -&gt; cons {a} (f x) (rec xs')
omapList :: Term TyName Name DefaultUni (Either DefaultFun ExtensionFun) ()

module PlutusCore.Examples.Data.Data

-- | Right-folding over <a>Data</a> inside PLC currently hardcoded to only
--   ever return <tt>Data</tt> as a result, 'cause we need to be able to
--   map built-in lists and pairs in the definition of the right fold for
--   <a>Data</a> and we can only do that monomorphically (see Note
--   [Representable built-in functions over polymorphic built-in types]),
--   which forces us to always return a <a>Data</a>. Alternatively we could
--   convert built-in lists and pairs to their non-built-in
--   Scott/Church-encoded forms, map polymorphically and convert back at
--   the call site, but we really only use this definition as a test, so
--   it's fine to make it overly specific for the sake of keeping the
--   actual test trivial.
--   
--   <pre>
--   metaTypeLet r = data in
--       \(fConstr : integer -&gt; list r -&gt; r)
--        (fMap : list (pair r r) -&gt; r)
--        (fList : list r -&gt; r)
--        (fI : integer -&gt; r)
--        (fB : bytestring -&gt; r) -&gt;
--            fix {data} {r} \(rec : data -&gt; r) (d : data) -&gt;
--                caseData
--                    d
--                    {r}
--                    (\(i : integer) (ds : list data) -&gt; fConstr i (omapList {data} rec ds)
--                    (\(es : list (pair data data)) -&gt;
--                        fMap (omapList {pair data data} (obothPair {data} rec) es))
--                    (\(ds : list data) -&gt; fList (omapList {data} rec ds))
--                    fI
--                    fB
--   </pre>
ofoldrData :: Term TyName Name DefaultUni (Either DefaultFun ExtensionFun) ()

-- | Just a random <a>Data</a> object.
exampleData :: Term tyname Name DefaultUni (Either DefaultFun ExtensionFun) ()


-- | This module exports all available examples via a data type which
--   allows to test various procedures (pretty-printing, type checking,
--   etc) over the entire set of examples in a convenient way: each time a
--   function / data type is added to examples, none of the tests is
--   required to be adapted, instead you just add the new definition to
--   <a>examples</a> defined below and all the tests see it automatically.
module PlutusCore.Examples.Everything

-- | All examples exported as a single value.
examples :: PlcFolderContents DefaultUni (Either DefaultFun ExtensionFun)
builtins :: PlcFolderContents DefaultUni ExtensionFun

module PlutusCore.Arity

-- | Is the next argument a term or a type?
data Param
TermParam :: Param
TypeParam :: Param

-- | The (syntactic) arity of a term. That is, a record of the arguments
--   that the term expects before it may do some work. Since we have both
--   type and lambda abstractions, this is not a simple argument count, but
--   rather a list of values indicating whether the next argument should be
--   a term or a type.
--   
--   Note that this is the syntactic arity, i.e. it just corresponds to the
--   number of syntactic lambda and type abstractions on the outside of the
--   term. It is thus an under-approximation of how many arguments the term
--   may need. e.g. consider the term <tt>let id = x -&gt; x in id</tt>:
--   the variable <tt>id</tt> has syntactic arity <tt>[]</tt>, but does in
--   fact need an argument before it does any work.
type Arity = [Param]

-- | Get the <a>Arity</a> from a <a>TypeScheme</a>.
typeSchemeArity :: TypeScheme val args res -> Arity

-- | Get the arity of a builtin function from the
--   <a>BuiltinSemanticsVariant</a>.
builtinArity :: forall uni fun. ToBuiltinMeaning uni fun => Proxy uni -> BuiltinSemanticsVariant fun -> fun -> Arity
instance GHC.Classes.Eq PlutusCore.Arity.Param
instance GHC.Show.Show PlutusCore.Arity.Param
instance Prettyprinter.Internal.Pretty PlutusCore.Arity.Param


-- | This module makes sure types are normalized inside programs.
module PlutusCore.Check.Normal

-- | Ensure that all types in the <a>Program</a> are normalized.
checkProgram :: (AsNormCheckError e tyname name uni fun ann, HasUniApply uni, MonadError e m) => Program tyname name uni fun ann -> m ()

-- | Ensure that all types in the <a>Term</a> are normalized.
checkTerm :: (AsNormCheckError e tyname name uni fun ann, HasUniApply uni, MonadError e m) => Term tyname name uni fun ann -> m ()
isNormalType :: HasUniApply uni => Type tyname uni ann -> Bool
data NormCheckError tyname name uni fun ann
BadType :: !ann -> !Type tyname uni ann -> !Text -> NormCheckError tyname name uni fun ann
BadTerm :: !ann -> !Term tyname name uni fun ann -> !Text -> NormCheckError tyname name uni fun ann

module UntypedPlutusCore.Core.Type

-- | Extract the universe from a type.
type family UniOf a :: Type -> Type

-- | The version of Plutus Core used by this program.
--   
--   The intention is to convey different levels of backwards compatibility
--   for existing scripts: - Major version changes are
--   backwards-incompatible - Minor version changes are
--   backwards-compatible - Patch version changes should be entirely
--   invisible (and we will likely not use this level)
--   
--   The version used should be changed only when the <i>language
--   itself</i> changes. For example, adding a new kind of term to the
--   language would require a minor version bump; removing a kind of term
--   would require a major version bump.
--   
--   Similarly, changing the semantics of the language will require a
--   version bump, typically a major one. This is the main reason why the
--   version is actually tracked in the AST: we can have two language
--   versions with identical ASTs but different semantics, so we need to
--   track the version explicitly.
--   
--   Compatibility is about compatibility for specific scripts, not about
--   e.g. tools which consume scripts. Adding a new kind of term does not
--   change how existing scripts behave, but does change what tools would
--   need to do to process scripts.
data Version
Version :: Natural -> Natural -> Natural -> Version
[_versionMajor] :: Version -> Natural
[_versionMinor] :: Version -> Natural
[_versionPatch] :: Version -> Natural

-- | This is a wrapper to mark the place where the binder is introduced
--   (i.e. LamAbs/TyAbs) and not where it is actually used (TyVar/Var..).
--   This marking allows us to skip the (de)serialization of binders at
--   LamAbs/TyAbs positions iff <tt>name</tt> is DeBruijn-encoded (level or
--   index). See for example the instance of <a>Flat</a>
newtype Binder name
Binder :: name -> Binder name
[unBinder] :: Binder name -> name

-- | The type of Untyped Plutus Core terms. Mirrors the type of Typed
--   Plutus Core terms except
--   
--   <ol>
--   <li>all types are removed</li>
--   <li><tt>IWrap</tt> and <tt>Unwrap</tt> are removed</li>
--   <li>type abstractions are replaced with <a>Delay</a></li>
--   <li>type instantiations are replaced with <a>Force</a></li>
--   </ol>
--   
--   The latter two are due to the fact that we don't have value
--   restriction in Typed Plutus Core and hence a computation can be stuck
--   expecting only a single type argument for the computation to become
--   unstuck. Therefore we can't just silently remove type abstractions and
--   instantiations and need to replace them with something else that also
--   blocks evaluation (in order for the semantics of an erased program to
--   match with the semantics of the original typed one). <a>Delay</a> and
--   <a>Force</a> serve exactly this purpose.
data Term name uni fun ann
Var :: !ann -> !name -> Term name uni fun ann
LamAbs :: !ann -> !name -> !Term name uni fun ann -> Term name uni fun ann
Apply :: !ann -> !Term name uni fun ann -> !Term name uni fun ann -> Term name uni fun ann
Force :: !ann -> !Term name uni fun ann -> Term name uni fun ann
Delay :: !ann -> !Term name uni fun ann -> Term name uni fun ann
Constant :: !ann -> !Some (ValueOf uni) -> Term name uni fun ann
Builtin :: !ann -> !fun -> Term name uni fun ann
Error :: !ann -> Term name uni fun ann
Constr :: !ann -> !Word64 -> ![Term name uni fun ann] -> Term name uni fun ann
Case :: !ann -> !Term name uni fun ann -> !Vector (Term name uni fun ann) -> Term name uni fun ann

-- | A <a>Program</a> is simply a <a>Term</a> coupled with a
--   <tt>Version</tt> of the core language.
data Program name uni fun ann
Program :: ann -> Version -> Term name uni fun ann -> Program name uni fun ann
[_progAnn] :: Program name uni fun ann -> ann
[_progVer] :: Program name uni fun ann -> Version
[_progTerm] :: Program name uni fun ann -> Term name uni fun ann
progAnn :: forall name_a9Vbg uni_a9Vbh fun_a9Vbi ann_a9Vbj. Lens' (Program name_a9Vbg uni_a9Vbh fun_a9Vbi ann_a9Vbj) ann_a9Vbj
progVer :: forall name_a9Vbg uni_a9Vbh fun_a9Vbi ann_a9Vbj. Lens' (Program name_a9Vbg uni_a9Vbh fun_a9Vbi ann_a9Vbj) Version
progTerm :: forall name_a9Vbg uni_a9Vbh fun_a9Vbi ann_a9Vbj name_a9VXW uni_a9VXX fun_a9VXY. Lens (Program name_a9Vbg uni_a9Vbh fun_a9Vbi ann_a9Vbj) (Program name_a9VXW uni_a9VXX fun_a9VXY ann_a9Vbj) (Term name_a9Vbg uni_a9Vbh fun_a9Vbi ann_a9Vbj) (Term name_a9VXW uni_a9VXX fun_a9VXY ann_a9Vbj)
bindFunM :: Monad m => (ann -> fun -> m (Term name uni fun' ann)) -> Term name uni fun ann -> m (Term name uni fun' ann)
bindFun :: (ann -> fun -> Term name uni fun' ann) -> Term name uni fun ann -> Term name uni fun' ann
mapFun :: (ann -> fun -> fun') -> Term name uni fun ann -> Term name uni fun' ann

-- | Return the outermost annotation of a <a>Term</a>.
termAnn :: Term name uni fun ann -> ann

-- | An untyped "variable declaration", i.e. a name for a variable.
data UVarDecl name ann
UVarDecl :: ann -> name -> UVarDecl name ann
[_uvarDeclAnn] :: UVarDecl name ann -> ann
[_uvarDeclName] :: UVarDecl name ann -> name
uvarDeclName :: forall name_a9VYl ann_a9VYm name_a9Wfb. Lens (UVarDecl name_a9VYl ann_a9VYm) (UVarDecl name_a9Wfb ann_a9VYm) name_a9VYl name_a9Wfb
uvarDeclAnn :: forall name_a9VYl ann_a9VYm ann_a9Wfa. Lens (UVarDecl name_a9VYl ann_a9VYm) (UVarDecl name_a9VYl ann_a9Wfa) ann_a9VYm ann_a9Wfa
instance GHC.Generics.Generic (UntypedPlutusCore.Core.Type.UVarDecl name ann)
instance (GHC.Show.Show ann, GHC.Show.Show name) => GHC.Show.Show (UntypedPlutusCore.Core.Type.UVarDecl name ann)
instance GHC.Base.Functor (UntypedPlutusCore.Core.Type.UVarDecl name)
instance (GHC.Show.Show name, Data.GADT.Internal.GShow uni, Universe.Core.Everywhere uni GHC.Show.Show, GHC.Show.Show fun, GHC.Show.Show ann, Universe.Core.Closed uni) => GHC.Show.Show (UntypedPlutusCore.Core.Type.Program name uni fun ann)
instance (Control.DeepSeq.NFData name, Universe.Core.Everywhere uni Control.DeepSeq.NFData, Control.DeepSeq.NFData fun, Control.DeepSeq.NFData ann, Universe.Core.Closed uni) => Control.DeepSeq.NFData (UntypedPlutusCore.Core.Type.Program name uni fun ann)
instance PlutusCore.MkPlc.TermLike (UntypedPlutusCore.Core.Type.Term name uni fun) PlutusCore.Name.Unique.TyName name uni fun
instance PlutusCore.Builtin.HasConstant.HasConstant (UntypedPlutusCore.Core.Type.Term name uni fun ())
instance GHC.Generics.Generic (UntypedPlutusCore.Core.Type.Term name uni fun ann)
instance GHC.Base.Functor (UntypedPlutusCore.Core.Type.Term name uni fun)
instance GHC.Generics.Generic (UntypedPlutusCore.Core.Type.Program name uni fun ann)
instance GHC.Base.Functor (UntypedPlutusCore.Core.Type.Program name uni fun)
instance (GHC.Show.Show name, Data.GADT.Internal.GShow uni, Universe.Core.Everywhere uni GHC.Show.Show, GHC.Show.Show fun, GHC.Show.Show ann, Universe.Core.Closed uni) => GHC.Show.Show (UntypedPlutusCore.Core.Type.Term name uni fun ann)
instance (Control.DeepSeq.NFData name, Control.DeepSeq.NFData fun, Control.DeepSeq.NFData ann, Universe.Core.Everywhere uni Control.DeepSeq.NFData, Universe.Core.Closed uni) => Control.DeepSeq.NFData (UntypedPlutusCore.Core.Type.Term name uni fun ann)

module UntypedPlutusCore.Core.Plated

-- | Get all the direct constants of the given <a>Term</a> from
--   <a>Constant</a>s.
termConstants :: Traversal' (Term name uni fun ann) (Some (ValueOf uni))

-- | Get all the direct child 'name a's of the given <a>Term</a> from
--   <a>LamAbs</a>es.
termBinds :: Traversal' (Term name uni fun ann) name

-- | Get all the direct child 'name a's of the given <a>Term</a> from
--   <a>Var</a>s.
termVars :: Traversal' (Term name uni fun ann) name

-- | Get all the direct child <a>Unique</a>s of the given <a>Term</a>.
termUniques :: HasUniques (Term name uni fun ann) => Traversal' (Term name uni fun ann) Unique

-- | Get all the direct child <a>Term</a>s of the given <a>Term</a>.
termSubterms :: Traversal' (Term name uni fun ann) (Term name uni fun ann)

-- | Get all the transitive child <a>Constant</a>s of the given
--   <a>Term</a>.
termConstantsDeep :: Fold (Term name uni fun ann) (Some (ValueOf uni))

-- | Get all the transitive child <a>Term</a>s of the given <a>Term</a>.
termSubtermsDeep :: Fold (Term name uni fun ann) (Term name uni fun ann)

-- | Get all the transitive child <a>Unique</a>s of the given <a>Term</a>.
termUniquesDeep :: HasUniques (Term name uni fun ann) => Fold (Term name uni fun ann) Unique

module UntypedPlutusCore.Core

-- | Using 4 bits to encode term tags.
termTagWidth :: NumBits
encodeTermTag :: Word8 -> Encoding
decodeTermTag :: Get Word8
encodeTerm :: forall name uni fun ann. (Closed uni, uni `Everywhere` Flat, Flat fun, Flat ann, Flat name, Flat (Binder name)) => Term name uni fun ann -> Encoding
decodeTerm :: forall name uni fun ann. (Closed uni, uni `Everywhere` Flat, Flat fun, Flat ann, Flat name, Flat (Binder name)) => Version -> (fun -> Maybe String) -> Get (Term name uni fun ann)
sizeTerm :: forall name uni fun ann. (Closed uni, uni `Everywhere` Flat, Flat fun, Flat ann, Flat name, Flat (Binder name)) => Term name uni fun ann -> NumBits -> NumBits

-- | An encoder for programs.
--   
--   It is not easy to use this correctly with <tt>flat</tt>. The simplest
--   thing is to go via the instance for <a>UnrestrictedProgram</a>, which
--   uses this
encodeProgram :: forall name uni fun ann. (Closed uni, uni `Everywhere` Flat, Flat fun, Flat ann, Flat name, Flat (Binder name)) => Program name uni fun ann -> Encoding
decodeProgram :: forall name uni fun ann. (Closed uni, uni `Everywhere` Flat, Flat fun, Flat ann, Flat name, Flat (Binder name)) => (fun -> Maybe String) -> Get (Program name uni fun ann)
sizeProgram :: forall name uni fun ann. (Closed uni, uni `Everywhere` Flat, Flat fun, Flat ann, Flat name, Flat (Binder name)) => Program name uni fun ann -> NumBits -> NumBits

-- | A program that can be serialized without any restrictions, e.g. on the
--   set of allowable builtins or term constructs. It is generally safe to
--   use this newtype for serializing, but it should only be used for
--   deserializing in tests.
newtype UnrestrictedProgram name uni fun ann
UnrestrictedProgram :: Program name uni fun ann -> UnrestrictedProgram name uni fun ann
[unUnrestrictedProgram] :: UnrestrictedProgram name uni fun ann -> Program name uni fun ann

-- | Strips off lambda binders.
splitParams :: Term name uni fun a -> ([name], Term name uni fun a)

-- | Strip off arguments
splitApplication :: Term name uni fun a -> (Term name uni fun a, [(a, Term name uni fun a)])

module UntypedPlutusCore.Check.Uniques
checkProgram :: (Ord ann, HasUnique name TermUnique, AsUniqueError e ann, MonadError e m) => (UniqueError ann -> Bool) -> Program name uni fun ann -> m ()
checkTerm :: (Ord ann, HasUnique name TermUnique, AsUniqueError e ann, MonadError e m) => (UniqueError ann -> Bool) -> Term name uni fun ann -> m ()
data UniqueError ann
MultiplyDefined :: !Unique -> !ann -> !ann -> UniqueError ann
IncoherentUsage :: !Unique -> !ann -> !ann -> UniqueError ann
FreeVariable :: !Unique -> !ann -> UniqueError ann
class AsUniqueError r_a7UAM ann_a7ScY | r_a7UAM -> ann_a7ScY
_UniqueError :: AsUniqueError r_a7UAM ann_a7ScY => Prism' r_a7UAM (UniqueError ann_a7ScY)
_MultiplyDefined :: AsUniqueError r_a7UAM ann_a7ScY => Prism' r_a7UAM (Unique, ann_a7ScY, ann_a7ScY)
_IncoherentUsage :: AsUniqueError r_a7UAM ann_a7ScY => Prism' r_a7UAM (Unique, ann_a7ScY, ann_a7ScY)
_FreeVariable :: AsUniqueError r_a7UAM ann_a7ScY => Prism' r_a7UAM (Unique, ann_a7ScY)

module PlutusCore.Compiler.Erase

-- | Erase a Typed Plutus Core term to its untyped counterpart.
--   
--   Restricted to Plc terms with <a>Name</a>s, because erasing a
--   (Named-)Debruijn term will mess up its debruijn indexing and thus
--   break scope-checking. -- FIXME: Lift this restriction of
--   <a>eraseTerm</a> for (Named-)DeBruijn terms.
eraseTerm :: HasUnique name TermUnique => Term tyname name uni fun ann -> Term name uni fun ann
eraseProgram :: HasUnique name TermUnique => Program tyname name uni fun ann -> Program name uni fun ann

module PlutusCore.Compiler.Types
newtype UPLCSimplifierTrace name uni fun a
UPLCSimplifierTrace :: [Term name uni fun a] -> UPLCSimplifierTrace name uni fun a
[uplcSimplifierTrace] :: UPLCSimplifierTrace name uni fun a -> [Term name uni fun a]
initUPLCSimplifierTrace :: UPLCSimplifierTrace name uni fun a
type Compiling m uni fun name a = (ToBuiltinMeaning uni fun, MonadQuote m, HasUnique name TermUnique, Ord name, Typeable name, Hashable fun)

module UntypedPlutusCore.Core.Zip

-- | Zip two programs using a combinator function for annotations.
--   
--   Throws an error if the input programs are not "equal" modulo
--   annotations. Note that the function is "left-biased", so in case that
--   the 2 input programs contain <tt>Name</tt>s, the output program will
--   contain just the <tt>Name</tt>s of the first input program.
pzipWith :: forall p name uni fun ann1 ann2 ann3 m. (p ~ Program name uni fun, Eq (Term name uni fun ()), MonadError String m) => (ann1 -> ann2 -> ann3) -> p ann1 -> p ann2 -> m (p ann3)

-- | Zip 2 programs by pairing their annotations
pzip :: (p ~ Program name uni fun, Eq (Term name uni fun ()), MonadError String m) => p ann1 -> p ann2 -> m (p (ann1, ann2))

-- | Zip two terms using a combinator function for annotations.
--   
--   Throws an error if the input terms are not "equal" modulo annotations.
--   Note that the function is "left-biased", so in case that the 2 input
--   terms contain <tt>Name</tt>s, the output term will contain just the
--   <tt>Name</tt>s of the first input term. TODO: this is not an optimal
--   implementation
tzipWith :: forall t name uni fun ann1 ann2 ann3 m. (t ~ Term name uni fun, Eq (t ()), MonadError String m) => (ann1 -> ann2 -> ann3) -> t ann1 -> t ann2 -> m (t ann3)

-- | Zip 2 terms by pairing their annotations
tzip :: (t ~ Term name uni fun, Eq (t ()), MonadError String m) => t ann1 -> t ann2 -> m (t (ann1, ann2))


-- | Support for using de Bruijn indices for term names.
module UntypedPlutusCore.DeBruijn

-- | A relative index used for de Bruijn identifiers.
--   
--   FIXME: downside of using newtype+Num instead of type-synonym is that
--   `-Woverflowed-literals` does not work, e.g.: `DeBruijn (-1)` has no
--   warning. To trigger the warning you have to bypass the Num and write
--   `DeBruijn (Index -1)`. This can be revisited when we implement
--   PLT-1053.
newtype Index
Index :: Word64 -> Index

-- | An absolute level in the program.
newtype Level
Level :: Integer -> Level

-- | During visiting the AST we hold a reader "state" of current level and
--   a current scoping (levelMapping). Invariant-A: the current level is
--   positive and greater than all levels in the levelMapping. Invariant-B:
--   only positive levels are stored in the levelMapping.
data LevelInfo
LevelInfo :: Level -> Bimap Unique Level -> LevelInfo
[currentLevel] :: LevelInfo -> Level
[levelMapping] :: LevelInfo -> Bimap Unique Level
class HasIndex a
index :: HasIndex a => Lens' a Index

-- | A term name as a de Bruijn index, without the name string.
newtype DeBruijn
DeBruijn :: Index -> DeBruijn
[dbnIndex] :: DeBruijn -> Index

-- | A term name as a de Bruijn index.
data NamedDeBruijn
NamedDeBruijn :: !Text -> !Index -> NamedDeBruijn
[ndbnString] :: NamedDeBruijn -> !Text
[ndbnIndex] :: NamedDeBruijn -> !Index

-- | A wrapper around <a>NamedDeBruijn</a> that *must* hold the invariant
--   of name=<a>fakeName</a>.
--   
--   We do not export the <a>FakeNamedDeBruijn</a> constructor: the
--   projection `FND-&gt;ND` is safe but injection `ND-&gt;FND` is unsafe,
--   thus they are not isomorphic.
--   
--   See Note [Why newtype FakeNamedDeBruijn]
data FakeNamedDeBruijn

-- | We cannot do a correct translation to or from de Bruijn indices if the
--   program is not well-scoped. So we throw an error in such a case.
data FreeVariableError
FreeUnique :: !Unique -> FreeVariableError
FreeIndex :: !Index -> FreeVariableError
class AsFreeVariableError r_a1KDI
_FreeVariableError :: AsFreeVariableError r_a1KDI => Prism' r_a1KDI FreeVariableError
_FreeUnique :: AsFreeVariableError r_a1KDI => Prism' r_a1KDI Unique
_FreeIndex :: AsFreeVariableError r_a1KDI => Prism' r_a1KDI Index

-- | Convert a <a>Term</a> with <a>Name</a>s into a <a>Term</a> with
--   <a>DeBruijn</a>s. Will throw an error if a free variable is
--   encountered.
deBruijnTerm :: (AsFreeVariableError e, MonadError e m) => Term Name uni fun ann -> m (Term NamedDeBruijn uni fun ann)

-- | Convert a <a>Term</a> with <a>DeBruijn</a>s into a <a>Term</a> with
--   <a>Name</a>s. Will throw an error if a free variable is encountered.
unDeBruijnTerm :: (MonadQuote m, AsFreeVariableError e, MonadError e m) => Term NamedDeBruijn uni fun ann -> m (Term Name uni fun ann)
unNameDeBruijn :: NamedDeBruijn -> DeBruijn
fakeNameDeBruijn :: DeBruijn -> NamedDeBruijn

-- | Takes a "handler" function to execute when encountering free
--   variables.
deBruijnTermWith :: Monad m => (Unique -> ReaderT LevelInfo m Index) -> Term Name uni fun ann -> m (Term NamedDeBruijn uni fun ann)

-- | Takes a "handler" function to execute when encountering free
--   variables.
unDeBruijnTermWith :: MonadQuote m => (Index -> ReaderT LevelInfo m Unique) -> Term NamedDeBruijn uni fun ann -> m (Term Name uni fun ann)

-- | A different implementation of a handler, where "free" debruijn indices
--   do not throw an error but are instead gracefully converted to fresh
--   uniques. These generated uniques remain free; i.e. if the original
--   term was open, it will remain open after applying this handler. These
--   generated free uniques are consistent across the open term (by using a
--   state cache).
freeIndexAsConsistentLevel :: (MonadReader LevelInfo m, MonadState (Map Level Unique) m, MonadQuote m) => Index -> m Unique

-- | The LamAbs index (for debruijn indices) and the starting level of
--   DeBruijn monad
deBruijnInitIndex :: Index

module UntypedPlutusCore.Check.Scope

-- | A pass to check that the input term: 1) does not contain free
--   variables and 2) that all binders are set to debruijn index 0.
--   
--   Feeding the result of the debruijnification to this function is
--   expected to pass.
--   
--   On the other hand, because of (2), this pass is stricter than the
--   undebruijnification's (indirect) scope-checking, see Note [DeBruijn
--   indices of Binders].
--   
--   Inlining this function makes a big difference, since it will usually
--   be called in a context where all the type variables are known. That
--   then means that GHC can optimize go locally in a completely
--   monomorphic setting, which helps a lot.
checkScope :: forall e m name uni fun a. (HasIndex name, MonadError e m, AsFreeVariableError e) => Term name uni fun a -> m ()

module UntypedPlutusCore.Evaluation.Machine.Cek.CekMachineCosts

-- | Costs for evaluating AST nodes. Times should be specified in
--   picoseconds, memory sizes in bytes.
type CekMachineCosts = CekMachineCostsBase Identity
data CekMachineCostsBase f
CekMachineCostsBase :: f ExBudget -> f ExBudget -> f ExBudget -> f ExBudget -> f ExBudget -> f ExBudget -> f ExBudget -> f ExBudget -> f ExBudget -> f ExBudget -> CekMachineCostsBase f
[cekStartupCost] :: CekMachineCostsBase f -> f ExBudget
[cekVarCost] :: CekMachineCostsBase f -> f ExBudget
[cekConstCost] :: CekMachineCostsBase f -> f ExBudget
[cekLamCost] :: CekMachineCostsBase f -> f ExBudget
[cekDelayCost] :: CekMachineCostsBase f -> f ExBudget
[cekForceCost] :: CekMachineCostsBase f -> f ExBudget
[cekApplyCost] :: CekMachineCostsBase f -> f ExBudget

-- | Just the cost of evaluating a Builtin node, not the builtin itself.
--   There's no entry for Error since we'll be exiting anyway; also, what
--   would happen if calling <tt>Error</tt> caused the budget to be
--   exceeded?
[cekBuiltinCost] :: CekMachineCostsBase f -> f ExBudget
[cekConstrCost] :: CekMachineCostsBase f -> f ExBudget
[cekCaseCost] :: CekMachineCostsBase f -> f ExBudget

-- | The prefix of the field names in the CekMachineCosts type, used for
--   extracting the CekMachineCosts component of the ledger's cost model
--   parameters. See Note [Cost model parameters] in CostModelInterface.
cekMachineCostsPrefix :: Text
unitCekMachineCosts :: CekMachineCosts
instance Barbies.Internal.ConstraintsB.ConstraintsB UntypedPlutusCore.Evaluation.Machine.Cek.CekMachineCosts.CekMachineCostsBase
instance Barbies.Internal.TraversableB.TraversableB UntypedPlutusCore.Evaluation.Machine.Cek.CekMachineCosts.CekMachineCostsBase
instance Barbies.Internal.FunctorB.FunctorB UntypedPlutusCore.Evaluation.Machine.Cek.CekMachineCosts.CekMachineCostsBase
instance GHC.Generics.Generic (UntypedPlutusCore.Evaluation.Machine.Cek.CekMachineCosts.CekMachineCostsBase f)
instance Data.Aeson.Types.ToJSON.ToJSON (UntypedPlutusCore.Evaluation.Machine.Cek.CekMachineCosts.CekMachineCostsBase Data.Functor.Identity.Identity)
instance Data.Aeson.Types.FromJSON.FromJSON (UntypedPlutusCore.Evaluation.Machine.Cek.CekMachineCosts.CekMachineCostsBase Data.Functor.Identity.Identity)
instance Data.Aeson.Types.ToJSON.ToJSON (UntypedPlutusCore.Evaluation.Machine.Cek.CekMachineCosts.CekMachineCostsBase GHC.Maybe.Maybe)
instance Barbies.Internal.ConstraintsB.AllBF GHC.Show.Show f UntypedPlutusCore.Evaluation.Machine.Cek.CekMachineCosts.CekMachineCostsBase => GHC.Show.Show (UntypedPlutusCore.Evaluation.Machine.Cek.CekMachineCosts.CekMachineCostsBase f)
instance Barbies.Internal.ConstraintsB.AllBF GHC.Classes.Eq f UntypedPlutusCore.Evaluation.Machine.Cek.CekMachineCosts.CekMachineCostsBase => GHC.Classes.Eq (UntypedPlutusCore.Evaluation.Machine.Cek.CekMachineCosts.CekMachineCostsBase f)
instance Barbies.Internal.ConstraintsB.AllBF Language.Haskell.TH.Syntax.Lift f UntypedPlutusCore.Evaluation.Machine.Cek.CekMachineCosts.CekMachineCostsBase => Language.Haskell.TH.Syntax.Lift (UntypedPlutusCore.Evaluation.Machine.Cek.CekMachineCosts.CekMachineCostsBase f)
instance Barbies.Internal.ConstraintsB.AllBF Control.DeepSeq.NFData f UntypedPlutusCore.Evaluation.Machine.Cek.CekMachineCosts.CekMachineCostsBase => Control.DeepSeq.NFData (UntypedPlutusCore.Evaluation.Machine.Cek.CekMachineCosts.CekMachineCostsBase f)
instance Barbies.Internal.ConstraintsB.AllBF NoThunks.Class.NoThunks f UntypedPlutusCore.Evaluation.Machine.Cek.CekMachineCosts.CekMachineCostsBase => NoThunks.Class.NoThunks (UntypedPlutusCore.Evaluation.Machine.Cek.CekMachineCosts.CekMachineCostsBase f)

module PlutusCore.Evaluation.Machine.CostModelInterface

-- | A raw representation of the ledger's cost model parameters.
--   
--   The associated keys/names to the parameter values are arbitrarily set
--   by the plutus team; the ledger does not hold any such names.
--   
--   See Note [Cost model parameters]
type CostModelParams = Map Text Int64

-- | Costs for evaluating AST nodes. Times should be specified in
--   picoseconds, memory sizes in bytes.
type CekMachineCosts = CekMachineCostsBase Identity

-- | Given a CostModel, produce a single map containing the parameters from
--   both components
extractCostModelParams :: (ToJSON machinecosts, ToJSON builtincosts) => CostModel machinecosts builtincosts -> Maybe CostModelParams

-- | Update a CostModel for the CEK machine with a given set of parameters.
--   Note that this is costly. See <a>here</a>. Callers are recommended to
--   call this once and cache the results.
applyCostModelParams :: (FromJSON evaluatorcosts, FromJSON builtincosts, ToJSON evaluatorcosts, ToJSON builtincosts, MonadError CostModelApplyError m) => CostModel evaluatorcosts builtincosts -> CostModelParams -> m (CostModel evaluatorcosts builtincosts)

-- | A fatal error when trying to create a cost given some plain costmodel
--   parameters.
data CostModelApplyError

-- | a costmodel parameter with the give name does not exist in the
--   costmodel to be applied upon
CMUnknownParamError :: !Text -> CostModelApplyError

-- | internal error when we are transforming the applyParams' input to json
--   (should not happen)
CMInternalReadError :: CostModelApplyError

-- | internal error when we are transforming the applied params from json
--   with given jsonstring error (should not happen)
CMInternalWriteError :: !String -> CostModelApplyError

-- | A non-fatal warning when trying to create a cost given some plain
--   costmodel parameters.
data CostModelApplyWarn

-- | See Note [Cost model parameters from the ledger's point of view]
CMTooManyParamsWarn :: !Int -> !Int -> CostModelApplyWarn
[cmExpected] :: CostModelApplyWarn -> !Int
[cmActual] :: CostModelApplyWarn -> !Int

-- | See Note [Cost model parameters from the ledger's point of view]
CMTooFewParamsWarn :: !Int -> !Int -> CostModelApplyWarn
[cmExpected] :: CostModelApplyWarn -> !Int
[cmActual] :: CostModelApplyWarn -> !Int
instance NoThunks.Class.NoThunks PlutusCore.Evaluation.Machine.CostModelInterface.CostModelApplyError
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.CostModelInterface.CostModelApplyError
instance GHC.Exception.Type.Exception PlutusCore.Evaluation.Machine.CostModelInterface.CostModelApplyError
instance Data.Data.Data PlutusCore.Evaluation.Machine.CostModelInterface.CostModelApplyError
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.CostModelInterface.CostModelApplyError
instance GHC.Show.Show PlutusCore.Evaluation.Machine.CostModelInterface.CostModelApplyError
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.CostModelInterface.CostModelApplyError
instance Prettyprinter.Internal.Pretty PlutusCore.Evaluation.Machine.CostModelInterface.CostModelApplyWarn
instance Prettyprinter.Internal.Pretty PlutusCore.Evaluation.Machine.CostModelInterface.CostModelApplyError

module UntypedPlutusCore.Evaluation.Machine.Cek.StepCounter

-- | A set of <a>Word8</a> counters that is used in the CEK machine to
--   count steps.
newtype StepCounter (n :: Nat) s
StepCounter :: MutablePrimArray s Word8 -> StepCounter (n :: Nat) s

-- | Make a new <a>StepCounter</a> with the given number of counters.
newCounter :: (KnownNat n, PrimMonad m) => Proxy n -> m (StepCounter n (PrimState m))

-- | Reset all the counters in the given <a>StepCounter</a> to zero.
resetCounter :: forall n m. (KnownNat n, PrimMonad m) => StepCounter n (PrimState m) -> m ()

-- | Read the value of a counter.
readCounter :: forall m n. PrimMonad m => StepCounter n (PrimState m) -> Int -> m Word8

-- | Write to a counter.
writeCounter :: forall m n. PrimMonad m => StepCounter n (PrimState m) -> Int -> Word8 -> m ()

-- | Modify the value of a counter. Returns the modified value.
modifyCounter :: PrimMonad m => Int -> (Word8 -> Word8) -> StepCounter n (PrimState m) -> m Word8

-- | Traverse the counters with an effectful function.
itraverseCounter_ :: forall n m. (KnownNat n, PrimMonad m) => (Int -> Word8 -> m ()) -> StepCounter n (PrimState m) -> m ()

-- | Traverse the counters with an effectful function.
iforCounter_ :: (KnownNat n, PrimMonad m) => StepCounter n (PrimState m) -> (Int -> Word8 -> m ()) -> m ()


-- | The CEK machine.
module UntypedPlutusCore.Evaluation.Machine.Cek.Internal

-- | The parameterized type of results various evaluation engines return.
--   On the PLC side this becomes (via <tt>makeKnown</tt>) either a call to
--   <tt>Error</tt> or a value of the PLC counterpart of type <tt>a</tt>.
data EvaluationResult a
EvaluationSuccess :: !a -> EvaluationResult a
EvaluationFailure :: EvaluationResult a
data CekValue uni fun ann
VCon :: !Some (ValueOf uni) -> CekValue uni fun ann
VDelay :: !NTerm uni fun ann -> !CekValEnv uni fun ann -> CekValue uni fun ann
VLamAbs :: !NamedDeBruijn -> !NTerm uni fun ann -> !CekValEnv uni fun ann -> CekValue uni fun ann

-- | A partial builtin application, accumulating arguments for eventual
--   full application. We don't need a <a>CekValEnv</a> here unlike in the
--   other constructors, because <a>VBuiltin</a> values always store their
--   corresponding <a>Term</a>s fully discharged, see the comments at the
--   call sites (search for <a>VBuiltin</a>).
VBuiltin :: !fun -> NTerm uni fun () -> !BuiltinRuntime (CekValue uni fun ann) -> CekValue uni fun ann
VConstr :: {-# UNPACK #-} !Word64 -> !ArgStack uni fun ann -> CekValue uni fun ann

-- | A LIFO stack of <a>CekValue</a>s, useful for recording multiple
--   arguments which will need to be pushed onto the context in reverse
--   order.
data ArgStack uni fun ann
EmptyStack :: ArgStack uni fun ann
ConsStack :: !CekValue uni fun ann -> !ArgStack uni fun ann -> ArgStack uni fun ann

-- | Transfers an <a>ArgStack</a> to a series of <a>Context</a> frames.
transferArgStack :: ArgStack uni fun ann -> Context uni fun ann -> Context uni fun ann
data CekUserError

-- | The final overspent (i.e. negative) budget.
CekOutOfExError :: !ExRestrictingBudget -> CekUserError

-- | Error has been called or a builtin application has failed
CekEvaluationFailure :: CekUserError

-- | The CEK machine-specific <a>EvaluationException</a>.
type CekEvaluationException name uni fun = EvaluationException (MachineError fun) CekUserError (Term name uni fun ())

-- | The CEK machine is parameterized over a <tt>spendBudget</tt> function.
--   This makes the budgeting machinery extensible and allows us to
--   separate budgeting logic from evaluation logic and avoid branching on
--   the union of all possible budgeting state types during evaluation.
newtype CekBudgetSpender uni fun s
CekBudgetSpender :: (ExBudgetCategory fun -> ExBudget -> CekM uni fun s ()) -> CekBudgetSpender uni fun s
[unCekBudgetSpender] :: CekBudgetSpender uni fun s -> ExBudgetCategory fun -> ExBudget -> CekM uni fun s ()

-- | Runtime budgeting info.
data ExBudgetInfo cost uni fun s
ExBudgetInfo :: !CekBudgetSpender uni fun s -> !ST s cost -> !ST s ExBudget -> ExBudgetInfo cost uni fun s

-- | A spending function.
[_exBudgetModeSpender] :: ExBudgetInfo cost uni fun s -> !CekBudgetSpender uni fun s

-- | For accessing the final state.
[_exBudgetModeGetFinal] :: ExBudgetInfo cost uni fun s -> !ST s cost

-- | For accessing the cumulative budget.
[_exBudgetModeGetCumulative] :: ExBudgetInfo cost uni fun s -> !ST s ExBudget

-- | A budgeting mode to execute the CEK machine in.
newtype ExBudgetMode cost uni fun
ExBudgetMode :: (forall s. ST s (ExBudgetInfo cost uni fun s)) -> ExBudgetMode cost uni fun
[unExBudgetMode] :: ExBudgetMode cost uni fun -> forall s. ST s (ExBudgetInfo cost uni fun s)

-- | The CEK machine is parameterized over an emitter function, similar to
--   <a>CekBudgetSpender</a>.
type CekEmitter uni fun s = DList Text -> CekM uni fun s ()

-- | Runtime emitter info, similar to <a>ExBudgetInfo</a>.
data CekEmitterInfo uni fun s
CekEmitterInfo :: !CekEmitter uni fun s -> !ST s [Text] -> CekEmitterInfo uni fun s
[_cekEmitterInfoEmit] :: CekEmitterInfo uni fun s -> !CekEmitter uni fun s
[_cekEmitterInfoGetFinal] :: CekEmitterInfo uni fun s -> !ST s [Text]

-- | An emitting mode to execute the CEK machine in, similar to
--   <a>ExBudgetMode</a>.
newtype EmitterMode uni fun
EmitterMode :: (forall s. ST s ExBudget -> ST s (CekEmitterInfo uni fun s)) -> EmitterMode uni fun
[unEmitterMode] :: EmitterMode uni fun -> forall s. ST s ExBudget -> ST s (CekEmitterInfo uni fun s)

-- | The monad the CEK machine runs in.
newtype CekM uni fun s a
CekM :: ST s a -> CekM uni fun s a
[unCekM] :: CekM uni fun s a -> ST s a

-- | An error and (optionally) what caused it.
data ErrorWithCause err cause
ErrorWithCause :: !err -> !Maybe cause -> ErrorWithCause err cause
[_ewcError] :: ErrorWithCause err cause -> !err
[_ewcCause] :: ErrorWithCause err cause -> !Maybe cause

-- | The type of errors that can occur during evaluation. There are two
--   kinds of errors:
--   
--   <ol>
--   <li>Structural ones -- these are errors that are indicative of the
--   _structure_ of the program being wrong. For example, a free variable
--   was encountered during evaluation, a non-function was applied to an
--   argument or <tt>tailList</tt> was applied to a non-list.</li>
--   <li>Operational ones -- these are errors that are indicative of the
--   _logic_ of the program being wrong. For example, <a>error</a> was
--   executed, <tt>tailList</tt> was applied to an empty list or evaluation
--   ran out of gas.</li>
--   </ol>
--   
--   On the chain both of these are just regular failures and we don't
--   distinguish between them there: if a script fails, it fails, it
--   doesn't matter what the reason was. However in the tests it does
--   matter why the failure occurred: a structural error may indicate that
--   the test was written incorrectly while an operational error may be
--   entirely expected.
--   
--   In other words, structural errors are "runtime type errors" and
--   operational errors are regular runtime errors. Which means that
--   evaluating an (erased) well-typed program should never produce a
--   structural error, only an operational one. This creates a sort of
--   "runtime type system" for UPLC and it would be great to stick to it
--   and enforce in tests etc, but we currently don't.
data EvaluationError structural operational
StructuralEvaluationError :: !structural -> EvaluationError structural operational
OperationalEvaluationError :: !operational -> EvaluationError structural operational
data ExBudgetCategory fun
BStep :: StepKind -> ExBudgetCategory fun
BBuiltinApp :: fun -> ExBudgetCategory fun
BStartup :: ExBudgetCategory fun
data StepKind
BConst :: StepKind
BVar :: StepKind
BLamAbs :: StepKind
BApply :: StepKind
BDelay :: StepKind
BForce :: StepKind
BBuiltin :: StepKind
BConstr :: StepKind
BCase :: StepKind

-- | The set of constraints we need to be able to throw exceptions with
--   things with built-in types and functions in them.
type ThrowableBuiltins uni fun = (PrettyUni uni, Pretty fun, Typeable uni, Typeable fun)

-- | Preserve the contents of an <a>StructuralEvaluationError</a> as a
--   <a>Left</a> and turn an <a>OperationalEvaluationError</a> into a
--   <tt>Right EvaluationFailure</tt> (thus erasing the content of the
--   error in the latter case).
splitStructuralOperational :: Either (EvaluationException structural operational term) a -> Either (ErrorWithCause structural term) (EvaluationResult a)

-- | Throw on a <a>StructuralEvaluationError</a> and turn an
--   <a>OperationalEvaluationError</a> into an <a>EvaluationFailure</a>
--   (thus erasing the content of the error in the latter case).
unsafeSplitStructuralOperational :: (PrettyPlc structural, PrettyPlc term, Typeable structural, Typeable term) => Either (EvaluationException structural operational term) a -> EvaluationResult a

-- | Evaluate a term using the CEK machine and keep track of costing,
--   logging is optional.
runCekDeBruijn :: ThrowableBuiltins uni fun => MachineParameters CekMachineCosts fun (CekValue uni fun ann) -> ExBudgetMode cost uni fun -> EmitterMode uni fun -> NTerm uni fun ann -> (Either (CekEvaluationException NamedDeBruijn uni fun) (NTerm uni fun ()), cost, [Text])

-- | Convert a <a>CekValue</a> into a <a>Term</a> by replacing all bound
--   variables with the terms they're bound to (which themselves have to be
--   obtain by recursively discharging values).
dischargeCekValue :: CekValue uni fun ann -> NTerm uni fun ()

-- | The context in which the machine operates.
--   
--   Morally, this is a stack of frames, but we use the "intrusive list"
--   representation so that we can match on context and the top frame in a
--   single, strict pattern match.
data Context uni fun ann

-- | <pre>
--   [V _]
--   </pre>
FrameAwaitArg :: !CekValue uni fun ann -> !Context uni fun ann -> Context uni fun ann

-- | <pre>
--   [_ N]
--   </pre>
FrameAwaitFunTerm :: !CekValEnv uni fun ann -> !NTerm uni fun ann -> !Context uni fun ann -> Context uni fun ann

-- | <pre>
--   [_ V]
--   </pre>
FrameAwaitFunValue :: !CekValue uni fun ann -> !Context uni fun ann -> Context uni fun ann

-- | <tt>(force _)</tt> See Note [Accumulators for terms]
FrameForce :: !Context uni fun ann -> Context uni fun ann

-- | <pre>
--   (constr i V0 ... Vj-1 _ Nj ... Nn)
--   </pre>
FrameConstr :: !CekValEnv uni fun ann -> {-# UNPACK #-} !Word64 -> ![NTerm uni fun ann] -> !ArgStack uni fun ann -> !Context uni fun ann -> Context uni fun ann

-- | <pre>
--   (case _ C0 .. Cn)
--   </pre>
FrameCases :: !CekValEnv uni fun ann -> !Vector (NTerm uni fun ann) -> !Context uni fun ann -> Context uni fun ann
NoFrame :: Context uni fun ann
type CekValEnv uni fun ann = RAList (CekValue uni fun ann)

-- | Constraint requiring all of the machine's implicit parameters.
type GivenCekReqs uni fun ann s = (GivenCekRuntime uni fun ann, GivenCekEmitter uni fun s, GivenCekSpender uni fun s, GivenCekSlippage, GivenCekStepCounter s, GivenCekCosts)

-- | Implicit parameter for budget spender.
type GivenCekSpender uni fun s = (?cekBudgetSpender :: (CekBudgetSpender uni fun s))

-- | A set of <a>Word8</a> counters that is used in the CEK machine to
--   count steps.
data StepCounter (n :: Nat) s

-- | The total number of counters that we need, one extra for the total
--   counter. See Note [Structure of the step counter]
type CounterSize = NumberOfStepCounters + 1

-- | The index at which the total step counter is kept. See Note [Structure
--   of the step counter]
type TotalCountIndex = NumberOfStepCounters
type Slippage = Word8

-- | The default number of slippage (in machine steps) to allow.
defaultSlippage :: Slippage

-- | The <a>Term</a>s that CEK can execute must have DeBruijn binders
--   <tt>Name</tt> is not necessary but we leave it here for simplicity and
--   debuggability.
type NTerm uni fun = Term NamedDeBruijn uni fun
runCekM :: forall a cost uni fun ann. ThrowableBuiltins uni fun => MachineParameters CekMachineCosts fun (CekValue uni fun ann) -> ExBudgetMode cost uni fun -> EmitterMode uni fun -> (forall s. GivenCekReqs uni fun ann s => CekM uni fun s a) -> (Either (CekEvaluationException NamedDeBruijn uni fun) a, cost, [Text])
instance Data.Hashable.Class.Hashable UntypedPlutusCore.Evaluation.Machine.Cek.Internal.StepKind
instance Control.DeepSeq.NFData UntypedPlutusCore.Evaluation.Machine.Cek.Internal.StepKind
instance GHC.Enum.Bounded UntypedPlutusCore.Evaluation.Machine.Cek.Internal.StepKind
instance GHC.Enum.Enum UntypedPlutusCore.Evaluation.Machine.Cek.Internal.StepKind
instance GHC.Generics.Generic UntypedPlutusCore.Evaluation.Machine.Cek.Internal.StepKind
instance GHC.Classes.Ord UntypedPlutusCore.Evaluation.Machine.Cek.Internal.StepKind
instance GHC.Classes.Eq UntypedPlutusCore.Evaluation.Machine.Cek.Internal.StepKind
instance GHC.Show.Show UntypedPlutusCore.Evaluation.Machine.Cek.Internal.StepKind
instance Data.Hashable.Class.Hashable fun => Data.Hashable.Class.Hashable (UntypedPlutusCore.Evaluation.Machine.Cek.Internal.ExBudgetCategory fun)
instance Control.DeepSeq.NFData fun => Control.DeepSeq.NFData (UntypedPlutusCore.Evaluation.Machine.Cek.Internal.ExBudgetCategory fun)
instance GHC.Generics.Generic (UntypedPlutusCore.Evaluation.Machine.Cek.Internal.ExBudgetCategory fun)
instance GHC.Classes.Ord fun => GHC.Classes.Ord (UntypedPlutusCore.Evaluation.Machine.Cek.Internal.ExBudgetCategory fun)
instance GHC.Classes.Eq fun => GHC.Classes.Eq (UntypedPlutusCore.Evaluation.Machine.Cek.Internal.ExBudgetCategory fun)
instance GHC.Show.Show fun => GHC.Show.Show (UntypedPlutusCore.Evaluation.Machine.Cek.Internal.ExBudgetCategory fun)
instance Control.DeepSeq.NFData UntypedPlutusCore.Evaluation.Machine.Cek.Internal.CekUserError
instance GHC.Generics.Generic UntypedPlutusCore.Evaluation.Machine.Cek.Internal.CekUserError
instance GHC.Classes.Eq UntypedPlutusCore.Evaluation.Machine.Cek.Internal.CekUserError
instance GHC.Show.Show UntypedPlutusCore.Evaluation.Machine.Cek.Internal.CekUserError
instance Control.Monad.Primitive.PrimMonad (UntypedPlutusCore.Evaluation.Machine.Cek.Internal.CekM uni fun s)
instance GHC.Base.Monad (UntypedPlutusCore.Evaluation.Machine.Cek.Internal.CekM uni fun s)
instance GHC.Base.Applicative (UntypedPlutusCore.Evaluation.Machine.Cek.Internal.CekM uni fun s)
instance GHC.Base.Functor (UntypedPlutusCore.Evaluation.Machine.Cek.Internal.CekM uni fun s)
instance (Data.GADT.Internal.GShow uni, Universe.Core.Everywhere uni GHC.Show.Show, GHC.Show.Show fun, GHC.Show.Show ann, Universe.Core.Closed uni) => GHC.Show.Show (UntypedPlutusCore.Evaluation.Machine.Cek.Internal.ArgStack uni fun ann)
instance (Data.GADT.Internal.GShow uni, Universe.Core.Everywhere uni GHC.Show.Show, GHC.Show.Show fun, GHC.Show.Show ann, Universe.Core.Closed uni) => GHC.Show.Show (UntypedPlutusCore.Evaluation.Machine.Cek.Internal.CekValue uni fun ann)
instance (Data.GADT.Internal.GShow uni, Universe.Core.Everywhere uni GHC.Show.Show, GHC.Show.Show fun, GHC.Show.Show ann, Universe.Core.Closed uni) => GHC.Show.Show (UntypedPlutusCore.Evaluation.Machine.Cek.Internal.Context uni fun ann)
instance PlutusCore.Pretty.PrettyConst.ThrowableBuiltins uni fun => Control.Monad.Error.Class.MonadError (UntypedPlutusCore.Evaluation.Machine.Cek.Internal.CekEvaluationException PlutusCore.DeBruijn.Internal.NamedDeBruijn uni fun) (UntypedPlutusCore.Evaluation.Machine.Cek.Internal.CekM uni fun s)
instance PlutusCore.Evaluation.Result.AsEvaluationFailure UntypedPlutusCore.Evaluation.Machine.Cek.Internal.CekUserError
instance PlutusCore.Builtin.Result.AsUnliftingError UntypedPlutusCore.Evaluation.Machine.Cek.Internal.CekUserError
instance Prettyprinter.Internal.Pretty UntypedPlutusCore.Evaluation.Machine.Cek.Internal.CekUserError
instance GHC.Show.Show (PlutusCore.Builtin.Runtime.BuiltinRuntime (UntypedPlutusCore.Evaluation.Machine.Cek.Internal.CekValue uni fun ann))
instance (PlutusCore.Pretty.PrettyConst.PrettyUni uni, Prettyprinter.Internal.Pretty fun) => Text.PrettyBy.Internal.PrettyBy PlutusCore.Pretty.Plc.PrettyConfigPlc (UntypedPlutusCore.Evaluation.Machine.Cek.Internal.CekValue uni fun ann)
instance PlutusCore.Builtin.HasConstant.HasConstant (UntypedPlutusCore.Evaluation.Machine.Cek.Internal.CekValue uni fun ann)
instance (Universe.Core.Closed uni, Universe.Core.Everywhere uni PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage) => PlutusCore.Evaluation.Machine.ExMemoryUsage.ExMemoryUsage (UntypedPlutusCore.Evaluation.Machine.Cek.Internal.CekValue uni fun ann)
instance GHC.Show.Show fun => Prettyprinter.Internal.Pretty (UntypedPlutusCore.Evaluation.Machine.Cek.Internal.ExBudgetCategory fun)
instance PlutusCore.Evaluation.Machine.ExBudget.ExBudgetBuiltin fun (UntypedPlutusCore.Evaluation.Machine.Cek.Internal.ExBudgetCategory fun)

module PlutusCore.Evaluation.Machine.ExBudgetingDefaults
defaultBuiltinsRuntimeForSemanticsVariant :: HasMeaningIn DefaultUni term => BuiltinSemanticsVariant DefaultFun -> BuiltinsRuntime DefaultFun term
defaultCekParametersForVariant :: Typeable ann => BuiltinSemanticsVariant DefaultFun -> MachineParameters CekMachineCosts DefaultFun (CekValue DefaultUni DefaultFun ann)
defaultCostModelParamsForVariant :: BuiltinSemanticsVariant DefaultFun -> Maybe CostModelParams

-- | Return the <a>CostModel</a> corresponding to the given semantics
--   variant. The dependency on the semantics variant is what makes cost
--   models configurable.
cekCostModelForVariant :: BuiltinSemanticsVariant DefaultFun -> CostModel CekMachineCosts BuiltinCostModel
defaultBuiltinsRuntimeForTesting :: HasMeaningIn DefaultUni term => BuiltinsRuntime DefaultFun term
defaultCekParametersForTesting :: Typeable ann => MachineParameters CekMachineCosts DefaultFun (CekValue DefaultUni DefaultFun ann)
defaultCekMachineCostsForTesting :: CekMachineCosts
defaultCostModelParamsForTesting :: Maybe CostModelParams
defaultBuiltinCostModelForTesting :: BuiltinCostModel
defaultCekCostModelForTesting :: CostModel CekMachineCosts BuiltinCostModel
defaultCekCostModelForTestingB :: CostModel CekMachineCosts BuiltinCostModel
unitCekMachineCosts :: CekMachineCosts
unitCekParameters :: Typeable ann => MachineParameters CekMachineCosts DefaultFun (CekValue DefaultUni DefaultFun ann)


-- | The API to the CEK machine.
module UntypedPlutusCore.Evaluation.Machine.Cek

-- | Evaluate a term using the CEK machine with logging enabled and keep
--   track of costing. A wrapper around the internal runCek to debruijn
--   input and undebruijn output. *THIS FUNCTION IS PARTIAL if the input
--   term contains free variables*
runCek :: ThrowableBuiltins uni fun => MachineParameters CekMachineCosts fun (CekValue uni fun ann) -> ExBudgetMode cost uni fun -> EmitterMode uni fun -> Term Name uni fun ann -> (Either (CekEvaluationException Name uni fun) (Term Name uni fun ()), cost, [Text])

-- | Evaluate a term using the CEK machine and keep track of costing,
--   logging is optional.
runCekDeBruijn :: ThrowableBuiltins uni fun => MachineParameters CekMachineCosts fun (CekValue uni fun ann) -> ExBudgetMode cost uni fun -> EmitterMode uni fun -> NTerm uni fun ann -> (Either (CekEvaluationException NamedDeBruijn uni fun) (NTerm uni fun ()), cost, [Text])

-- | Evaluate a term using the CEK machine with logging disabled and keep
--   track of costing. *THIS FUNCTION IS PARTIAL if the input term contains
--   free variables*
runCekNoEmit :: ThrowableBuiltins uni fun => MachineParameters CekMachineCosts fun (CekValue uni fun ann) -> ExBudgetMode cost uni fun -> Term Name uni fun ann -> (Either (CekEvaluationException Name uni fun) (Term Name uni fun ()), cost)

-- | Evaluate a term using the CEK machine with logging enabled. *THIS
--   FUNCTION IS PARTIAL if the input term contains free variables*
evaluateCek :: ThrowableBuiltins uni fun => EmitterMode uni fun -> MachineParameters CekMachineCosts fun (CekValue uni fun ann) -> Term Name uni fun ann -> (Either (CekEvaluationException Name uni fun) (Term Name uni fun ()), [Text])

-- | Evaluate a term using the CEK machine with logging disabled. *THIS
--   FUNCTION IS PARTIAL if the input term contains free variables*
evaluateCekNoEmit :: ThrowableBuiltins uni fun => MachineParameters CekMachineCosts fun (CekValue uni fun ann) -> Term Name uni fun ann -> Either (CekEvaluationException Name uni fun) (Term Name uni fun ())

-- | The parameterized type of results various evaluation engines return.
--   On the PLC side this becomes (via <tt>makeKnown</tt>) either a call to
--   <tt>Error</tt> or a value of the PLC counterpart of type <tt>a</tt>.
data EvaluationResult a
EvaluationSuccess :: !a -> EvaluationResult a
EvaluationFailure :: EvaluationResult a

-- | Preserve the contents of an <a>StructuralEvaluationError</a> as a
--   <a>Left</a> and turn an <a>OperationalEvaluationError</a> into a
--   <tt>Right EvaluationFailure</tt> (thus erasing the content of the
--   error in the latter case).
splitStructuralOperational :: Either (EvaluationException structural operational term) a -> Either (ErrorWithCause structural term) (EvaluationResult a)

-- | Throw on a <a>StructuralEvaluationError</a> and turn an
--   <a>OperationalEvaluationError</a> into an <a>EvaluationFailure</a>
--   (thus erasing the content of the error in the latter case).
unsafeSplitStructuralOperational :: (PrettyPlc structural, PrettyPlc term, Typeable structural, Typeable term) => Either (EvaluationException structural operational term) a -> EvaluationResult a
data CekUserError

-- | The final overspent (i.e. negative) budget.
CekOutOfExError :: !ExRestrictingBudget -> CekUserError

-- | Error has been called or a builtin application has failed
CekEvaluationFailure :: CekUserError

-- | An error and (optionally) what caused it.
data ErrorWithCause err cause
ErrorWithCause :: !err -> !Maybe cause -> ErrorWithCause err cause
[_ewcError] :: ErrorWithCause err cause -> !err
[_ewcCause] :: ErrorWithCause err cause -> !Maybe cause

-- | The CEK machine-specific <a>EvaluationException</a>.
type CekEvaluationException name uni fun = EvaluationException (MachineError fun) CekUserError (Term name uni fun ())

-- | The type of errors that can occur during evaluation. There are two
--   kinds of errors:
--   
--   <ol>
--   <li>Structural ones -- these are errors that are indicative of the
--   _structure_ of the program being wrong. For example, a free variable
--   was encountered during evaluation, a non-function was applied to an
--   argument or <tt>tailList</tt> was applied to a non-list.</li>
--   <li>Operational ones -- these are errors that are indicative of the
--   _logic_ of the program being wrong. For example, <a>error</a> was
--   executed, <tt>tailList</tt> was applied to an empty list or evaluation
--   ran out of gas.</li>
--   </ol>
--   
--   On the chain both of these are just regular failures and we don't
--   distinguish between them there: if a script fails, it fails, it
--   doesn't matter what the reason was. However in the tests it does
--   matter why the failure occurred: a structural error may indicate that
--   the test was written incorrectly while an operational error may be
--   entirely expected.
--   
--   In other words, structural errors are "runtime type errors" and
--   operational errors are regular runtime errors. Which means that
--   evaluating an (erased) well-typed program should never produce a
--   structural error, only an operational one. This creates a sort of
--   "runtime type system" for UPLC and it would be great to stick to it
--   and enforce in tests etc, but we currently don't.
data EvaluationError structural operational
StructuralEvaluationError :: !structural -> EvaluationError structural operational
OperationalEvaluationError :: !operational -> EvaluationError structural operational
data ExBudgetCategory fun
BStep :: StepKind -> ExBudgetCategory fun
BBuiltinApp :: fun -> ExBudgetCategory fun
BStartup :: ExBudgetCategory fun

-- | The CEK machine is parameterized over a <tt>spendBudget</tt> function.
--   This makes the budgeting machinery extensible and allows us to
--   separate budgeting logic from evaluation logic and avoid branching on
--   the union of all possible budgeting state types during evaluation.
newtype CekBudgetSpender uni fun s
CekBudgetSpender :: (ExBudgetCategory fun -> ExBudget -> CekM uni fun s ()) -> CekBudgetSpender uni fun s
[unCekBudgetSpender] :: CekBudgetSpender uni fun s -> ExBudgetCategory fun -> ExBudget -> CekM uni fun s ()

-- | A budgeting mode to execute the CEK machine in.
newtype ExBudgetMode cost uni fun
ExBudgetMode :: (forall s. ST s (ExBudgetInfo cost uni fun s)) -> ExBudgetMode cost uni fun
[unExBudgetMode] :: ExBudgetMode cost uni fun -> forall s. ST s (ExBudgetInfo cost uni fun s)
data StepKind
BConst :: StepKind
BVar :: StepKind
BLamAbs :: StepKind
BApply :: StepKind
BDelay :: StepKind
BForce :: StepKind
BBuiltin :: StepKind
BConstr :: StepKind
BCase :: StepKind

-- | For a detailed report on what costs how much + the same overall budget
--   that <tt>Counting</tt> gives. The (derived) <a>Monoid</a> instance of
--   <a>CekExTally</a> is the main piece of the machinery.
newtype CekExTally fun
CekExTally :: MonoidalHashMap (ExBudgetCategory fun) ExBudget -> CekExTally fun

-- | For calculating the cost of execution by counting up using the
--   <a>Monoid</a> instance of <a>ExBudget</a>.
newtype CountingSt
CountingSt :: ExBudget -> CountingSt
data TallyingSt fun
TallyingSt :: CekExTally fun -> ExBudget -> TallyingSt fun
newtype RestrictingSt
RestrictingSt :: ExRestrictingBudget -> RestrictingSt

-- | Costs for evaluating AST nodes. Times should be specified in
--   picoseconds, memory sizes in bytes.
type CekMachineCosts = CekMachineCostsBase Identity

-- | Construct an <a>ExBudgetMode</a> out of a function returning a value
--   of the budgeting state type. The value then gets added to the current
--   state via <tt>(&lt;&gt;)</tt>.
monoidalBudgeting :: Monoid cost => (ExBudgetCategory fun -> ExBudget -> cost) -> ExBudgetMode cost uni fun

-- | For calculating the cost of execution.
counting :: ExBudgetMode CountingSt uni fun

-- | For a detailed report on what costs how much + the same overall budget
--   that <tt>Counting</tt> gives.
tallying :: Hashable fun => ExBudgetMode (TallyingSt fun) uni fun

-- | For execution, to avoid overruns.
restricting :: ThrowableBuiltins uni fun => ExRestrictingBudget -> ExBudgetMode RestrictingSt uni fun

-- | <a>restricting</a> instantiated at <a>enormousBudget</a>.
restrictingEnormous :: ThrowableBuiltins uni fun => ExBudgetMode RestrictingSt uni fun

-- | When we want to just evaluate the program we use the
--   <tt>Restricting</tt> mode with an enormous budget, so that evaluation
--   costs of on-chain budgeting are reflected accurately in benchmarks.
enormousBudget :: ExRestrictingBudget

-- | No emitter.
noEmitter :: EmitterMode uni fun

-- | Emits log only.
logEmitter :: EmitterMode uni fun

-- | Emits log with timestamp.
logWithTimeEmitter :: EmitterMode uni fun

-- | Emits log with the budget.
logWithBudgetEmitter :: EmitterMode uni fun

-- | A <tt>data</tt> wrapper around a function returning the
--   <a>BuiltinRuntime</a> of a built-in function. We use <tt>data</tt>
--   rather than <tt>newtype</tt>, because GHC is able to see through
--   <tt>newtype</tt>s and may break carefully set up optimizations, see
--   <a>https://github.com/IntersectMBO/plutus/pull/4914#issuecomment-1396306606</a>
--   
--   Using <tt>data</tt> may make things more expensive, however it was
--   verified at the time of writing that the wrapper is removed before the
--   CEK machine starts, leaving the stored function to be used directly.
--   
--   In order for lookups to be efficient the <a>BuiltinRuntime</a>s need
--   to be cached, i.e. pulled out of the function statically. See
--   <tt>makeBuiltinMeaning</tt> for how we achieve that.
data BuiltinsRuntime fun val
BuiltinsRuntime :: (fun -> BuiltinRuntime val) -> BuiltinsRuntime fun val
[unBuiltinsRuntime] :: BuiltinsRuntime fun val -> fun -> BuiltinRuntime val
data CekValue uni fun ann
VCon :: !Some (ValueOf uni) -> CekValue uni fun ann
VDelay :: !NTerm uni fun ann -> !CekValEnv uni fun ann -> CekValue uni fun ann
VLamAbs :: !NamedDeBruijn -> !NTerm uni fun ann -> !CekValEnv uni fun ann -> CekValue uni fun ann

-- | A partial builtin application, accumulating arguments for eventual
--   full application. We don't need a <a>CekValEnv</a> here unlike in the
--   other constructors, because <a>VBuiltin</a> values always store their
--   corresponding <a>Term</a>s fully discharged, see the comments at the
--   call sites (search for <a>VBuiltin</a>).
VBuiltin :: !fun -> NTerm uni fun () -> !BuiltinRuntime (CekValue uni fun ann) -> CekValue uni fun ann
VConstr :: {-# UNPACK #-} !Word64 -> !ArgStack uni fun ann -> CekValue uni fun ann

-- | Unlift a value using the CEK machine. *THIS FUNCTION IS PARTIAL if the
--   input term contains free variables*
readKnownCek :: (ThrowableBuiltins uni fun, ReadKnown (Term Name uni fun ()) a) => MachineParameters CekMachineCosts fun (CekValue uni fun ann) -> Term Name uni fun ann -> Either (CekEvaluationException Name uni fun) a
class Eq a => Hashable a

-- | The set of constraints we need to be able to throw exceptions with
--   things with built-in types and functions in them.
type ThrowableBuiltins uni fun = (PrettyUni uni, Pretty fun, Typeable uni, Typeable fun)


-- | Defines the type of default machine parameters and a function for
--   creating a value of the type. We keep them separate, because the
--   function unfolds into multiple thousands of lines of Core that we need
--   to be able to visually inspect, hence we dedicate a separate file to
--   it.
module PlutusCore.Evaluation.Machine.MachineParameters.Default

-- | <a>MachineParameters</a> instantiated at CEK-machine-specific types
--   and default builtins. Encompasses everything we need for evaluating a
--   UPLC program with default builtins using the CEK machine.
type DefaultMachineParameters = MachineParameters CekMachineCosts DefaultFun (CekValue DefaultUni DefaultFun ())

-- | Produce a <a>DefaultMachineParameters</a> for each of the given
--   semantics variants. The <a>CostModelParams</a> argument is used to
--   update the costing parameters returned by
--   <a>cekCostModelForVariant</a> for each of the semantics variants.
--   
--   Whenever you need to evaluate UPLC in a performance-sensitive manner
--   (e.g. in the production, for benchmarking, for cost calibration etc),
--   you MUST use this definition for creating a
--   <a>DefaultMachineParameters</a> and not any other. Changing this
--   definition in absolutely any way, however trivial, requires running
--   the benchmarks and making sure that the resulting GHC Core is still
--   sensible. E.g. you switch the order of arguments -- you run the
--   benchmarks and check the Core; you move this definition as-is to a
--   different file -- you run the benchmarks and check the Core; you
--   change how it's exported (implicitly as a part of a whole-module
--   export or explicitly as a single definition) -- you get the idea.
--   
--   This function is very expensive, so its result needs to be cached if
--   it's going to be used multiple times.
mkMachineParametersFor :: MonadError CostModelApplyError m => [BuiltinSemanticsVariant DefaultFun] -> CostModelParams -> m [(BuiltinSemanticsVariant DefaultFun, DefaultMachineParameters)]


-- | The CEK machine. The CEK machine relies on variables having non-equal
--   <tt>Unique</tt>s whenever they have non-equal string names. I.e.
--   <tt>Unique</tt>s are used instead of string names. This is for
--   efficiency reasons. The CEK machines handles name capture by design.
module UntypedPlutusCore.Evaluation.Machine.SteppableCek.Internal
data CekState uni fun ann
Starting :: NTerm uni fun ann -> CekState uni fun ann
Computing :: Context uni fun ann -> CekValEnv uni fun ann -> NTerm uni fun ann -> CekState uni fun ann
Returning :: Context uni fun ann -> CekValue uni fun ann -> CekState uni fun ann
Terminating :: NTerm uni fun () -> CekState uni fun ann

-- | Similar to <a>Context</a>, but augmented with an <tt>ann</tt>
data Context uni fun ann

-- | <pre>
--   [V _]
--   </pre>
FrameAwaitArg :: ann -> !CekValue uni fun ann -> !Context uni fun ann -> Context uni fun ann

-- | <pre>
--   [_ N]
--   </pre>
FrameAwaitFunTerm :: ann -> !CekValEnv uni fun ann -> !NTerm uni fun ann -> !Context uni fun ann -> Context uni fun ann
FrameAwaitFunValue :: ann -> !CekValue uni fun ann -> !Context uni fun ann -> Context uni fun ann

-- | <pre>
--   (force _)
--   </pre>
FrameForce :: ann -> !Context uni fun ann -> Context uni fun ann
FrameConstr :: ann -> !CekValEnv uni fun ann -> {-# UNPACK #-} !Word64 -> ![NTerm uni fun ann] -> !ArgStack uni fun ann -> !Context uni fun ann -> Context uni fun ann
FrameCases :: ann -> !CekValEnv uni fun ann -> !Vector (NTerm uni fun ann) -> !Context uni fun ann -> Context uni fun ann
NoFrame :: Context uni fun ann
contextAnn :: Context uni fun ann -> Maybe ann

-- | Lift a CEK computation to a primitive.PrimMonad m
liftCek :: (PrimMonad m, PrimState m ~ s) => CekM uni fun s a -> m a
class Monad m => PrimMonad (m :: Type -> Type) where {
    type family PrimState (m :: Type -> Type);
}
primitive :: PrimMonad m => (State# (PrimState m) -> (# State# (PrimState m), a #)) -> m a
lenContext :: Context uni fun ann -> Word
cekStateContext :: Traversal' (CekState uni fun ann) (Context uni fun ann)
cekStateAnn :: CekState uni fun ann -> Maybe ann
runCekDeBruijn :: ThrowableBuiltins uni fun => MachineParameters CekMachineCosts fun (CekValue uni fun ann) -> ExBudgetMode cost uni fun -> EmitterMode uni fun -> NTerm uni fun ann -> (Either (CekEvaluationException NamedDeBruijn uni fun) (NTerm uni fun ()), cost, [Text])
computeCek :: forall uni fun ann s. (ThrowableBuiltins uni fun, GivenCekReqs uni fun ann s) => Context uni fun ann -> CekValEnv uni fun ann -> NTerm uni fun ann -> CekM uni fun s (CekState uni fun ann)
returnCek :: forall uni fun ann s. (ThrowableBuiltins uni fun, GivenCekReqs uni fun ann s) => Context uni fun ann -> CekValue uni fun ann -> CekM uni fun s (CekState uni fun ann)

-- | Based on the supplied arguments, initialize the CEK environment and
--   construct a state transition function. Returns the constructed
--   transition function paired with the methods to live access the running
--   budget.
mkCekTrans :: forall cost uni fun ann m s. (ThrowableBuiltins uni fun, PrimMonad m, s ~ PrimState m) => MachineParameters CekMachineCosts fun (CekValue uni fun ann) -> ExBudgetMode cost uni fun -> EmitterMode uni fun -> Slippage -> m (CekTrans uni fun ann s, ExBudgetInfo cost uni fun s)
type CekTrans uni fun ann s = Trans (CekM uni fun s) (CekState uni fun ann)

-- | A CEK parameter that turns the slippage optimization *off*.
--   
--   This is needed in the case of the debugger, where the
--   accounting/budgeting costs must be *live* updated.
nilSlippage :: Slippage

-- | The parameterized type of results various evaluation engines return.
--   On the PLC side this becomes (via <tt>makeKnown</tt>) either a call to
--   <tt>Error</tt> or a value of the PLC counterpart of type <tt>a</tt>.
data EvaluationResult a
EvaluationSuccess :: !a -> EvaluationResult a
EvaluationFailure :: EvaluationResult a

-- | The type of errors that can occur during evaluation. There are two
--   kinds of errors:
--   
--   <ol>
--   <li>Structural ones -- these are errors that are indicative of the
--   _structure_ of the program being wrong. For example, a free variable
--   was encountered during evaluation, a non-function was applied to an
--   argument or <tt>tailList</tt> was applied to a non-list.</li>
--   <li>Operational ones -- these are errors that are indicative of the
--   _logic_ of the program being wrong. For example, <a>error</a> was
--   executed, <tt>tailList</tt> was applied to an empty list or evaluation
--   ran out of gas.</li>
--   </ol>
--   
--   On the chain both of these are just regular failures and we don't
--   distinguish between them there: if a script fails, it fails, it
--   doesn't matter what the reason was. However in the tests it does
--   matter why the failure occurred: a structural error may indicate that
--   the test was written incorrectly while an operational error may be
--   entirely expected.
--   
--   In other words, structural errors are "runtime type errors" and
--   operational errors are regular runtime errors. Which means that
--   evaluating an (erased) well-typed program should never produce a
--   structural error, only an operational one. This creates a sort of
--   "runtime type system" for UPLC and it would be great to stick to it
--   and enforce in tests etc, but we currently don't.
data EvaluationError structural operational
StructuralEvaluationError :: !structural -> EvaluationError structural operational
OperationalEvaluationError :: !operational -> EvaluationError structural operational

-- | An error and (optionally) what caused it.
data ErrorWithCause err cause
ErrorWithCause :: !err -> !Maybe cause -> ErrorWithCause err cause
[_ewcError] :: ErrorWithCause err cause -> !err
[_ewcCause] :: ErrorWithCause err cause -> !Maybe cause

-- | The set of constraints we need to be able to throw exceptions with
--   things with built-in types and functions in them.
type ThrowableBuiltins uni fun = (PrettyUni uni, Pretty fun, Typeable uni, Typeable fun)
data CekUserError

-- | The final overspent (i.e. negative) budget.
CekOutOfExError :: !ExRestrictingBudget -> CekUserError

-- | Error has been called or a builtin application has failed
CekEvaluationFailure :: CekUserError

-- | The CEK machine-specific <a>EvaluationException</a>.
type CekEvaluationException name uni fun = EvaluationException (MachineError fun) CekUserError (Term name uni fun ())
data ExBudgetCategory fun
BStep :: StepKind -> ExBudgetCategory fun
BBuiltinApp :: fun -> ExBudgetCategory fun
BStartup :: ExBudgetCategory fun

-- | The CEK machine is parameterized over a <tt>spendBudget</tt> function.
--   This makes the budgeting machinery extensible and allows us to
--   separate budgeting logic from evaluation logic and avoid branching on
--   the union of all possible budgeting state types during evaluation.
newtype CekBudgetSpender uni fun s
CekBudgetSpender :: (ExBudgetCategory fun -> ExBudget -> CekM uni fun s ()) -> CekBudgetSpender uni fun s
[unCekBudgetSpender] :: CekBudgetSpender uni fun s -> ExBudgetCategory fun -> ExBudget -> CekM uni fun s ()

-- | A budgeting mode to execute the CEK machine in.
newtype ExBudgetMode cost uni fun
ExBudgetMode :: (forall s. ST s (ExBudgetInfo cost uni fun s)) -> ExBudgetMode cost uni fun
[unExBudgetMode] :: ExBudgetMode cost uni fun -> forall s. ST s (ExBudgetInfo cost uni fun s)
data StepKind
BConst :: StepKind
BVar :: StepKind
BLamAbs :: StepKind
BApply :: StepKind
BDelay :: StepKind
BForce :: StepKind
BBuiltin :: StepKind
BConstr :: StepKind
BCase :: StepKind
data CekValue uni fun ann
VCon :: !Some (ValueOf uni) -> CekValue uni fun ann
VDelay :: !NTerm uni fun ann -> !CekValEnv uni fun ann -> CekValue uni fun ann
VLamAbs :: !NamedDeBruijn -> !NTerm uni fun ann -> !CekValEnv uni fun ann -> CekValue uni fun ann

-- | A partial builtin application, accumulating arguments for eventual
--   full application. We don't need a <a>CekValEnv</a> here unlike in the
--   other constructors, because <a>VBuiltin</a> values always store their
--   corresponding <a>Term</a>s fully discharged, see the comments at the
--   call sites (search for <a>VBuiltin</a>).
VBuiltin :: !fun -> NTerm uni fun () -> !BuiltinRuntime (CekValue uni fun ann) -> CekValue uni fun ann
VConstr :: {-# UNPACK #-} !Word64 -> !ArgStack uni fun ann -> CekValue uni fun ann

-- | An emitting mode to execute the CEK machine in, similar to
--   <a>ExBudgetMode</a>.
newtype EmitterMode uni fun
EmitterMode :: (forall s. ST s ExBudget -> ST s (CekEmitterInfo uni fun s)) -> EmitterMode uni fun
[unEmitterMode] :: EmitterMode uni fun -> forall s. ST s ExBudget -> ST s (CekEmitterInfo uni fun s)

-- | A LIFO stack of <a>CekValue</a>s, useful for recording multiple
--   arguments which will need to be pushed onto the context in reverse
--   order.
data ArgStack uni fun ann
EmptyStack :: ArgStack uni fun ann
ConsStack :: !CekValue uni fun ann -> !ArgStack uni fun ann -> ArgStack uni fun ann

-- | Runtime budgeting info.
data ExBudgetInfo cost uni fun s
ExBudgetInfo :: !CekBudgetSpender uni fun s -> !ST s cost -> !ST s ExBudget -> ExBudgetInfo cost uni fun s

-- | A spending function.
[_exBudgetModeSpender] :: ExBudgetInfo cost uni fun s -> !CekBudgetSpender uni fun s

-- | For accessing the final state.
[_exBudgetModeGetFinal] :: ExBudgetInfo cost uni fun s -> !ST s cost

-- | For accessing the cumulative budget.
[_exBudgetModeGetCumulative] :: ExBudgetInfo cost uni fun s -> !ST s ExBudget

-- | The CEK machine is parameterized over an emitter function, similar to
--   <a>CekBudgetSpender</a>.
type CekEmitter uni fun s = DList Text -> CekM uni fun s ()

-- | Runtime emitter info, similar to <a>ExBudgetInfo</a>.
data CekEmitterInfo uni fun s
CekEmitterInfo :: !CekEmitter uni fun s -> !ST s [Text] -> CekEmitterInfo uni fun s
[_cekEmitterInfoEmit] :: CekEmitterInfo uni fun s -> !CekEmitter uni fun s
[_cekEmitterInfoGetFinal] :: CekEmitterInfo uni fun s -> !ST s [Text]

-- | The monad the CEK machine runs in.
newtype CekM uni fun s a
CekM :: ST s a -> CekM uni fun s a
[unCekM] :: CekM uni fun s a -> ST s a
type CekValEnv uni fun ann = RAList (CekValue uni fun ann)

-- | Constraint requiring all of the machine's implicit parameters.
type GivenCekReqs uni fun ann s = (GivenCekRuntime uni fun ann, GivenCekEmitter uni fun s, GivenCekSpender uni fun s, GivenCekSlippage, GivenCekStepCounter s, GivenCekCosts)

-- | Implicit parameter for budget spender.
type GivenCekSpender uni fun s = (?cekBudgetSpender :: (CekBudgetSpender uni fun s))

-- | A set of <a>Word8</a> counters that is used in the CEK machine to
--   count steps.
data StepCounter (n :: Nat) s

-- | The total number of counters that we need, one extra for the total
--   counter. See Note [Structure of the step counter]
type CounterSize = NumberOfStepCounters + 1

-- | The index at which the total step counter is kept. See Note [Structure
--   of the step counter]
type TotalCountIndex = NumberOfStepCounters
type Slippage = Word8

-- | The <a>Term</a>s that CEK can execute must have DeBruijn binders
--   <tt>Name</tt> is not necessary but we leave it here for simplicity and
--   debuggability.
type NTerm uni fun = Term NamedDeBruijn uni fun

-- | Preserve the contents of an <a>StructuralEvaluationError</a> as a
--   <a>Left</a> and turn an <a>OperationalEvaluationError</a> into a
--   <tt>Right EvaluationFailure</tt> (thus erasing the content of the
--   error in the latter case).
splitStructuralOperational :: Either (EvaluationException structural operational term) a -> Either (ErrorWithCause structural term) (EvaluationResult a)

-- | Throw on a <a>StructuralEvaluationError</a> and turn an
--   <a>OperationalEvaluationError</a> into an <a>EvaluationFailure</a>
--   (thus erasing the content of the error in the latter case).
unsafeSplitStructuralOperational :: (PrettyPlc structural, PrettyPlc term, Typeable structural, Typeable term) => Either (EvaluationException structural operational term) a -> EvaluationResult a

-- | Convert a <a>CekValue</a> into a <a>Term</a> by replacing all bound
--   variables with the terms they're bound to (which themselves have to be
--   obtain by recursively discharging values).
dischargeCekValue :: CekValue uni fun ann -> NTerm uni fun ()

-- | The default number of slippage (in machine steps) to allow.
defaultSlippage :: Slippage
runCekM :: forall a cost uni fun ann. ThrowableBuiltins uni fun => MachineParameters CekMachineCosts fun (CekValue uni fun ann) -> ExBudgetMode cost uni fun -> EmitterMode uni fun -> (forall s. GivenCekReqs uni fun ann s => CekM uni fun s a) -> (Either (CekEvaluationException NamedDeBruijn uni fun) a, cost, [Text])
instance (Data.GADT.Internal.GShow uni, Universe.Core.Everywhere uni GHC.Show.Show, GHC.Show.Show fun, GHC.Show.Show ann, Universe.Core.Closed uni) => GHC.Show.Show (UntypedPlutusCore.Evaluation.Machine.SteppableCek.Internal.Context uni fun ann)
instance Prettyprinter.Internal.Pretty (UntypedPlutusCore.Evaluation.Machine.SteppableCek.Internal.CekState uni fun ann)

module UntypedPlutusCore.Evaluation.Machine.SteppableCek.DebugDriver

-- | Leave abstract the types of annotation and breakpoints. The only thing
--   the driver requires is an inclusion relation of breakpoints into the
--   Annotation
class Breakpointable ann bps | ann -> bps
hasBreakpoints :: Breakpointable ann bps => ann -> bps -> Bool
data CekState uni fun ann

-- | The commands that the driver may receive from the client
--   (tui,cli,test,etc)
data Cmd bps

-- | Instruct the driver to a *SINGLE* step. Note: No need to pass
--   breakpoints here because the stepping granularity is *minimal*.
Step :: Cmd bps

-- | Instruct to multi-step until end-of-program or until breakpoint
--   reached
Continue :: bps -> Cmd bps

-- | Instruct to multi-step over the function call at point or until
--   breakpoint reached
Next :: bps -> Cmd bps

-- | Instruct to multi-step to end of current function or until breakpoint
--   reached
Finish :: bps -> Cmd bps

-- | Entrypoint of the driver
runDriverT :: forall uni fun ann bps m. (Breakpointable ann bps, MonadFree (DebugF uni fun ann bps) m) => NTerm uni fun ann -> m ()

-- | The drivers's suspension functor
data DebugF uni fun ann bps a

-- | Await for the client (e.g. TUI) to tell what to do next (Cmd).
InputF :: (Cmd bps -> a) -> DebugF uni fun ann bps a

-- | The debug driver wants to log something
DriverLogF :: Text -> a -> DebugF uni fun ann bps a

-- | An enumeratee of Driver State (generator+iteratee): Yield a state
--   before doing a step, then await for a state to resume after the step.
--   See Note [Stepping the driver].
StepF :: CekState uni fun ann -> (CekState uni fun ann -> a) -> DebugF uni fun ann bps a
UpdateClientF :: CekState uni fun ann -> a -> DebugF uni fun ann bps a

-- | Based on the supplied arguments, initialize the CEK environment and
--   construct a state transition function. Returns the constructed
--   transition function paired with the methods to live access the running
--   budget.
mkCekTrans :: forall cost uni fun ann m s. (ThrowableBuiltins uni fun, PrimMonad m, s ~ PrimState m) => MachineParameters CekMachineCosts fun (CekValue uni fun ann) -> ExBudgetMode cost uni fun -> EmitterMode uni fun -> Slippage -> m (CekTrans uni fun ann s, ExBudgetInfo cost uni fun s)
type CekTrans uni fun ann s = Trans (CekM uni fun s) (CekState uni fun ann)
class Monad m => MonadFree (f :: Type -> Type) (m :: Type -> Type) | m -> f
iterM :: (Functor f, Monad m) => (f (m a) -> m a) -> Free f a -> m a
iterTM :: forall f (m :: Type -> Type) t a. (Functor f, Monad m, MonadTrans t, Monad (t m)) => (f (t m a) -> t m a) -> FreeT f m a -> t m a
partialIterT :: Monad m => Integer -> (forall a. () => f a -> m a) -> FreeT f m b -> FreeT f m b
cutoff :: forall (f :: Type -> Type) (m :: Type -> Type) a. (Functor f, Monad m) => Integer -> FreeT f m a -> FreeT f m (Maybe a)
data () => FreeT (f :: Type -> Type) (m :: Type -> Type) a
instance GHC.Read.Read bps => GHC.Read.Read (UntypedPlutusCore.Evaluation.Machine.SteppableCek.DebugDriver.Cmd bps)
instance GHC.Show.Show bps => GHC.Show.Show (UntypedPlutusCore.Evaluation.Machine.SteppableCek.DebugDriver.Cmd bps)
instance GHC.Base.Functor (UntypedPlutusCore.Evaluation.Machine.SteppableCek.DebugDriver.DebugF uni fun ann bps)


-- | The API to the Steppable CEK machine. Provides the same interface to
--   original CEK machine.
module UntypedPlutusCore.Evaluation.Machine.SteppableCek

-- | Evaluate a term using the Steppable CEK machine with logging enabled
--   and keep track of costing. A wrapper around the internal runCek to
--   debruijn input and undebruijn output. *THIS FUNCTION IS PARTIAL if the
--   input term contains free variables*
runCek :: ThrowableBuiltins uni fun => MachineParameters CekMachineCosts fun (CekValue uni fun ann) -> ExBudgetMode cost uni fun -> EmitterMode uni fun -> Term Name uni fun ann -> (Either (CekEvaluationException Name uni fun) (Term Name uni fun ()), cost, [Text])
runCekDeBruijn :: ThrowableBuiltins uni fun => MachineParameters CekMachineCosts fun (CekValue uni fun ann) -> ExBudgetMode cost uni fun -> EmitterMode uni fun -> NTerm uni fun ann -> (Either (CekEvaluationException NamedDeBruijn uni fun) (NTerm uni fun ()), cost, [Text])

-- | Evaluate a term using the Steppable CEK machine with logging disabled
--   and keep track of costing. *THIS FUNCTION IS PARTIAL if the input term
--   contains free variables*
runCekNoEmit :: ThrowableBuiltins uni fun => MachineParameters CekMachineCosts fun (CekValue uni fun ann) -> ExBudgetMode cost uni fun -> Term Name uni fun ann -> (Either (CekEvaluationException Name uni fun) (Term Name uni fun ()), cost)

-- | Evaluate a term using the Steppable CEK machine with logging enabled.
--   *THIS FUNCTION IS PARTIAL if the input term contains free variables*
evaluateCek :: ThrowableBuiltins uni fun => EmitterMode uni fun -> MachineParameters CekMachineCosts fun (CekValue uni fun ann) -> Term Name uni fun ann -> (Either (CekEvaluationException Name uni fun) (Term Name uni fun ()), [Text])

-- | Evaluate a term using the Steppable CEK machine with logging disabled.
--   *THIS FUNCTION IS PARTIAL if the input term contains free variables*
evaluateCekNoEmit :: ThrowableBuiltins uni fun => MachineParameters CekMachineCosts fun (CekValue uni fun ann) -> Term Name uni fun ann -> Either (CekEvaluationException Name uni fun) (Term Name uni fun ())

-- | The parameterized type of results various evaluation engines return.
--   On the PLC side this becomes (via <tt>makeKnown</tt>) either a call to
--   <tt>Error</tt> or a value of the PLC counterpart of type <tt>a</tt>.
data EvaluationResult a
EvaluationSuccess :: !a -> EvaluationResult a
EvaluationFailure :: EvaluationResult a

-- | Preserve the contents of an <a>StructuralEvaluationError</a> as a
--   <a>Left</a> and turn an <a>OperationalEvaluationError</a> into a
--   <tt>Right EvaluationFailure</tt> (thus erasing the content of the
--   error in the latter case).
splitStructuralOperational :: Either (EvaluationException structural operational term) a -> Either (ErrorWithCause structural term) (EvaluationResult a)

-- | Throw on a <a>StructuralEvaluationError</a> and turn an
--   <a>OperationalEvaluationError</a> into an <a>EvaluationFailure</a>
--   (thus erasing the content of the error in the latter case).
unsafeSplitStructuralOperational :: (PrettyPlc structural, PrettyPlc term, Typeable structural, Typeable term) => Either (EvaluationException structural operational term) a -> EvaluationResult a
data CekUserError

-- | The final overspent (i.e. negative) budget.
CekOutOfExError :: !ExRestrictingBudget -> CekUserError

-- | Error has been called or a builtin application has failed
CekEvaluationFailure :: CekUserError

-- | An error and (optionally) what caused it.
data ErrorWithCause err cause
ErrorWithCause :: !err -> !Maybe cause -> ErrorWithCause err cause
[_ewcError] :: ErrorWithCause err cause -> !err
[_ewcCause] :: ErrorWithCause err cause -> !Maybe cause

-- | The CEK machine-specific <a>EvaluationException</a>.
type CekEvaluationException name uni fun = EvaluationException (MachineError fun) CekUserError (Term name uni fun ())

-- | The type of errors that can occur during evaluation. There are two
--   kinds of errors:
--   
--   <ol>
--   <li>Structural ones -- these are errors that are indicative of the
--   _structure_ of the program being wrong. For example, a free variable
--   was encountered during evaluation, a non-function was applied to an
--   argument or <tt>tailList</tt> was applied to a non-list.</li>
--   <li>Operational ones -- these are errors that are indicative of the
--   _logic_ of the program being wrong. For example, <a>error</a> was
--   executed, <tt>tailList</tt> was applied to an empty list or evaluation
--   ran out of gas.</li>
--   </ol>
--   
--   On the chain both of these are just regular failures and we don't
--   distinguish between them there: if a script fails, it fails, it
--   doesn't matter what the reason was. However in the tests it does
--   matter why the failure occurred: a structural error may indicate that
--   the test was written incorrectly while an operational error may be
--   entirely expected.
--   
--   In other words, structural errors are "runtime type errors" and
--   operational errors are regular runtime errors. Which means that
--   evaluating an (erased) well-typed program should never produce a
--   structural error, only an operational one. This creates a sort of
--   "runtime type system" for UPLC and it would be great to stick to it
--   and enforce in tests etc, but we currently don't.
data EvaluationError structural operational
StructuralEvaluationError :: !structural -> EvaluationError structural operational
OperationalEvaluationError :: !operational -> EvaluationError structural operational
data ExBudgetCategory fun
BStep :: StepKind -> ExBudgetCategory fun
BBuiltinApp :: fun -> ExBudgetCategory fun
BStartup :: ExBudgetCategory fun

-- | The CEK machine is parameterized over a <tt>spendBudget</tt> function.
--   This makes the budgeting machinery extensible and allows us to
--   separate budgeting logic from evaluation logic and avoid branching on
--   the union of all possible budgeting state types during evaluation.
newtype CekBudgetSpender uni fun s
CekBudgetSpender :: (ExBudgetCategory fun -> ExBudget -> CekM uni fun s ()) -> CekBudgetSpender uni fun s
[unCekBudgetSpender] :: CekBudgetSpender uni fun s -> ExBudgetCategory fun -> ExBudget -> CekM uni fun s ()

-- | A budgeting mode to execute the CEK machine in.
newtype ExBudgetMode cost uni fun
ExBudgetMode :: (forall s. ST s (ExBudgetInfo cost uni fun s)) -> ExBudgetMode cost uni fun
[unExBudgetMode] :: ExBudgetMode cost uni fun -> forall s. ST s (ExBudgetInfo cost uni fun s)
data StepKind
BConst :: StepKind
BVar :: StepKind
BLamAbs :: StepKind
BApply :: StepKind
BDelay :: StepKind
BForce :: StepKind
BBuiltin :: StepKind
BConstr :: StepKind
BCase :: StepKind

-- | For a detailed report on what costs how much + the same overall budget
--   that <tt>Counting</tt> gives. The (derived) <a>Monoid</a> instance of
--   <a>CekExTally</a> is the main piece of the machinery.
newtype CekExTally fun
CekExTally :: MonoidalHashMap (ExBudgetCategory fun) ExBudget -> CekExTally fun

-- | For calculating the cost of execution by counting up using the
--   <a>Monoid</a> instance of <a>ExBudget</a>.
newtype CountingSt
CountingSt :: ExBudget -> CountingSt
data TallyingSt fun
TallyingSt :: CekExTally fun -> ExBudget -> TallyingSt fun
newtype RestrictingSt
RestrictingSt :: ExRestrictingBudget -> RestrictingSt

-- | Costs for evaluating AST nodes. Times should be specified in
--   picoseconds, memory sizes in bytes.
type CekMachineCosts = CekMachineCostsBase Identity

-- | For calculating the cost of execution.
counting :: ExBudgetMode CountingSt uni fun

-- | For a detailed report on what costs how much + the same overall budget
--   that <tt>Counting</tt> gives.
tallying :: Hashable fun => ExBudgetMode (TallyingSt fun) uni fun

-- | For execution, to avoid overruns.
restricting :: ThrowableBuiltins uni fun => ExRestrictingBudget -> ExBudgetMode RestrictingSt uni fun

-- | <a>restricting</a> instantiated at <a>enormousBudget</a>.
restrictingEnormous :: ThrowableBuiltins uni fun => ExBudgetMode RestrictingSt uni fun

-- | When we want to just evaluate the program we use the
--   <tt>Restricting</tt> mode with an enormous budget, so that evaluation
--   costs of on-chain budgeting are reflected accurately in benchmarks.
enormousBudget :: ExRestrictingBudget

-- | No emitter.
noEmitter :: EmitterMode uni fun

-- | Emits log only.
logEmitter :: EmitterMode uni fun

-- | Emits log with timestamp.
logWithTimeEmitter :: EmitterMode uni fun

-- | Emits log with the budget.
logWithBudgetEmitter :: EmitterMode uni fun
data CekValue uni fun ann
VCon :: !Some (ValueOf uni) -> CekValue uni fun ann
VDelay :: !NTerm uni fun ann -> !CekValEnv uni fun ann -> CekValue uni fun ann
VLamAbs :: !NamedDeBruijn -> !NTerm uni fun ann -> !CekValEnv uni fun ann -> CekValue uni fun ann

-- | A partial builtin application, accumulating arguments for eventual
--   full application. We don't need a <a>CekValEnv</a> here unlike in the
--   other constructors, because <a>VBuiltin</a> values always store their
--   corresponding <a>Term</a>s fully discharged, see the comments at the
--   call sites (search for <a>VBuiltin</a>).
VBuiltin :: !fun -> NTerm uni fun () -> !BuiltinRuntime (CekValue uni fun ann) -> CekValue uni fun ann
VConstr :: {-# UNPACK #-} !Word64 -> !ArgStack uni fun ann -> CekValue uni fun ann

-- | Unlift a value using the Steppable CEK machine. *THIS FUNCTION IS
--   PARTIAL if the input term contains free variables*
readKnownCek :: (ThrowableBuiltins uni fun, ReadKnown (Term Name uni fun ()) a) => MachineParameters CekMachineCosts fun (CekValue uni fun ann) -> Term Name uni fun ann -> Either (CekEvaluationException Name uni fun) a
class Eq a => Hashable a

-- | The set of constraints we need to be able to throw exceptions with
--   things with built-in types and functions in them.
type ThrowableBuiltins uni fun = (PrettyUni uni, Pretty fun, Typeable uni, Typeable fun)

module UntypedPlutusCore.MkUPlc

-- | An untyped "variable declaration", i.e. a name for a variable.
data UVarDecl name ann
UVarDecl :: ann -> name -> UVarDecl name ann
[_uvarDeclAnn] :: UVarDecl name ann -> ann
[_uvarDeclName] :: UVarDecl name ann -> name
uvarDeclName :: forall name_a9VYl ann_a9VYm name_a9Wfb. Lens (UVarDecl name_a9VYl ann_a9VYm) (UVarDecl name_a9Wfb ann_a9VYm) name_a9VYl name_a9Wfb
uvarDeclAnn :: forall name_a9VYl ann_a9VYm ann_a9Wfa. Lens (UVarDecl name_a9VYl ann_a9VYm) (UVarDecl name_a9VYl ann_a9Wfa) ann_a9VYm ann_a9Wfa

-- | Make a <a>Var</a> referencing the given <tt>VarDecl</tt>.
mkVar :: ann -> UVarDecl name ann -> Term name uni fun ann

-- | Lambda abstract a list of names.
mkIterLamAbs :: [UVarDecl name ann] -> Term name uni fun ann -> Term name uni fun ann

-- | A definition. Pretty much just a pair with more descriptive names.
data Def var val
Def :: var -> val -> Def var val
[defVar] :: Def var val -> var
[defVal] :: Def var val -> val

-- | A term definition as a variable.
type UTermDef name uni fun ann = Def (UVarDecl name ann) (Term name uni fun ann)

module UntypedPlutusCore.Purity

-- | Will evaluating this term have side effects (looping or error)? This
--   is slightly wider than the definition of a value, as it includes
--   applications that are known to be pure, as well as things that can't
--   be returned from the machine (as they'd be ill-scoped).
isPure :: ToBuiltinMeaning uni fun => BuiltinSemanticsVariant fun -> Term name uni fun a -> Bool

-- | Is the given term 'work-free'?
--   
--   Note: The definition of 'work-free' is a little unclear, but the idea
--   is that evaluating this term should do very a trivial amount of work.
isWorkFree :: ToBuiltinMeaning uni fun => BuiltinSemanticsVariant fun -> Term name uni fun a -> Bool

-- | The order in which terms get evaluated, along with their purities.
data EvalOrder name uni fun a

-- | Get the evaluation order as a list of <a>EvalTerm</a>s. Either
--   terminates in a single <a>Unknown</a>, which means that we got to a
--   point where evaluation continues but we don't know where; or
--   terminates normally, in which case we actually got to the end of the
--   evaluation order for the term.
unEvalOrder :: EvalOrder name uni fun a -> [EvalTerm name uni fun a]

-- | Either the "next" term to be evaluated, along with its <a>Purity</a>
--   and <a>WorkFreedom</a>, or we don't know what comes next.
data EvalTerm name uni fun a
Unknown :: EvalTerm name uni fun a
EvalTerm :: Purity -> WorkFreedom -> Term name uni fun a -> EvalTerm name uni fun a

-- | Is this pure? Either yes, or maybe not.
data Purity
MaybeImpure :: Purity
Pure :: Purity

-- | Given a term, return the order in which it and its sub-terms will be
--   evaluated.
--   
--   This aims to be a sound under-approximation: if we don't know, we just
--   say <a>Unknown</a>. Typically there will be a sequence of terms that
--   we do know, which will terminate in <a>Unknown</a> once we do
--   something like call a function.
--   
--   This makes some assumptions about the evaluator, in particular about
--   the order in which we evaluate sub-terms, but these match the current
--   evaluator and we are not planning on changing it.
termEvaluationOrder :: forall name uni fun a. ToBuiltinMeaning uni fun => BuiltinSemanticsVariant fun -> Term name uni fun a -> EvalOrder name uni fun a
instance GHC.Base.Monoid (UntypedPlutusCore.Purity.EvalOrder name uni fun a)
instance GHC.Base.Semigroup (UntypedPlutusCore.Purity.EvalOrder name uni fun a)
instance Text.PrettyBy.Internal.PrettyBy config (UntypedPlutusCore.Core.Type.Term name uni fun a) => Text.PrettyBy.Internal.PrettyBy config (UntypedPlutusCore.Purity.EvalOrder name uni fun a)
instance Text.PrettyBy.Internal.PrettyBy config (UntypedPlutusCore.Core.Type.Term name uni fun a) => Text.PrettyBy.Internal.PrettyBy config (UntypedPlutusCore.Purity.EvalTerm name uni fun a)
instance Prettyprinter.Internal.Pretty UntypedPlutusCore.Purity.WorkFreedom
instance Prettyprinter.Internal.Pretty UntypedPlutusCore.Purity.Purity


-- | The user-facing API of the untyped renamer. See PlutusCore.Rename for
--   details.
module UntypedPlutusCore.Rename

-- | The class of things that can be renamed. I.e. things that are capable
--   of satisfying the global uniqueness condition.
class Rename a

-- | Rename <a>Unique</a>s so that they're globally unique. In case there
--   are any free variables, they must be left untouched and bound
--   variables must not get renamed to free ones. Must always assign new
--   names to bound variables, so that <tt>rename</tt> can be used for
--   alpha-renaming as well.
rename :: (Rename a, MonadQuote m) => a -> m a
instance PlutusCore.Core.Type.HasUniques (UntypedPlutusCore.Core.Type.Term name uni fun ann) => PlutusCore.Rename.Rename (UntypedPlutusCore.Core.Type.Term name uni fun ann)
instance PlutusCore.Core.Type.HasUniques (UntypedPlutusCore.Core.Type.Program name uni fun ann) => PlutusCore.Rename.Rename (UntypedPlutusCore.Core.Type.Program name uni fun ann)

module UntypedPlutusCore.Parser
parse :: (AsParserErrorBundle e, MonadError e m, MonadQuote m) => Parser a -> String -> Text -> m a

-- | Parser for all UPLC terms.
term :: Parser PTerm

-- | Parser for UPLC programs.
program :: Parser (Program Name DefaultUni DefaultFun SrcSpan)

-- | Parse a UPLC term. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors.
parseTerm :: (AsParserErrorBundle e, MonadError e m, MonadQuote m) => Text -> m PTerm

-- | Parse a UPLC program. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors. This
--   passes "test" to the parser as the name of the input stream; to supply
--   a name explicity, use `parse program <a>name</a> <a>input</a><a>.</a>
parseProgram :: (AsParserErrorBundle e, MonadError e m, MonadQuote m) => Text -> m (Program Name DefaultUni DefaultFun SrcSpan)

-- | Parse and rewrite so that names are globally unique, not just unique
--   within their scope.
parseScoped :: (AsParserErrorBundle e, AsUniqueError e SrcSpan, MonadError e m, MonadQuote m) => Text -> m (Program Name DefaultUni DefaultFun SrcSpan)
type Parser = ParsecT ParserError Text (StateT ParserState (ReaderT (Maybe Version) Quote))
data () => SourcePos

module PlutusCore.Compiler.Opts
data CompilationOpts name fun a
CompilationOpts :: SimplifyOpts name a -> BuiltinSemanticsVariant fun -> CompilationOpts name fun a
[_coSimplifyOpts] :: CompilationOpts name fun a -> SimplifyOpts name a
[_coBuiltinSemanticsVariant] :: CompilationOpts name fun a -> BuiltinSemanticsVariant fun
coSimplifyOpts :: forall name_ab0OP fun_ab0OQ a_ab0OR name_ab0PI a_ab0PJ. Lens (CompilationOpts name_ab0OP fun_ab0OQ a_ab0OR) (CompilationOpts name_ab0PI fun_ab0OQ a_ab0PJ) (SimplifyOpts name_ab0OP a_ab0OR) (SimplifyOpts name_ab0PI a_ab0PJ)
coBuiltinSemanticsVariant :: forall name_ab0OP fun_ab0OQ a_ab0OR fun_ab0PH. Lens (CompilationOpts name_ab0OP fun_ab0OQ a_ab0OR) (CompilationOpts name_ab0OP fun_ab0PH a_ab0OR) (BuiltinSemanticsVariant fun_ab0OQ) (BuiltinSemanticsVariant fun_ab0PH)
defaultCompilationOpts :: Default (BuiltinSemanticsVariant fun) => CompilationOpts name fun a

module UntypedPlutusCore.Size
newtype Size
Size :: Integer -> Size
[unSize] :: Size -> Integer

-- | Count the number of AST nodes in a term.
termSize :: Term name uni fun ann -> Size

-- | Count the number of AST nodes in a program.
programSize :: Program name uni fun ann -> Size

-- | Compute the size of the serialized form of a value.
serialisedSize :: Flat a => a -> Integer


-- | A special case of case-of-case optimisation: transforms
--   
--   <pre>
--   case ((force ifThenElse) b (constr t) (constr f)) alts
--   </pre>
--   
--   into
--   
--   <pre>
--   force ifThenElse b (case (constr t) alts) (case (constr f) alts)
--   </pre>
--   
--   This is always an improvement.
module UntypedPlutusCore.Transform.CaseOfCase
caseOfCase :: fun ~ DefaultFun => Term name uni fun a -> Term name uni fun a

module UntypedPlutusCore

-- | Applicatively replace a variable using the given function.
substVarA :: Applicative f => (name -> f (Maybe (Term name uni fun ann))) -> Term name uni fun ann -> f (Term name uni fun ann)

-- | Replace a variable using the given function.
substVar :: (name -> Maybe (Term name uni fun ann)) -> Term name uni fun ann -> Term name uni fun ann

-- | Naively monadically substitute names using the given function (i.e. do
--   not substitute binders).
termSubstNamesM :: Monad m => (name -> m (Maybe (Term name uni fun ann))) -> Term name uni fun ann -> m (Term name uni fun ann)

-- | Naively substitute names using the given function (i.e. do not
--   substitute binders).
termSubstNames :: (name -> Maybe (Term name uni fun ann)) -> Term name uni fun ann -> Term name uni fun ann

-- | Completely replace the names with a new name type.
termMapNames :: forall name name' uni fun ann. (name -> name') -> Term name uni fun ann -> Term name' uni fun ann
programMapNames :: forall name name' uni fun ann. (name -> name') -> Program name uni fun ann -> Program name' uni fun ann

-- | Get all the term variables in a term.
vTerm :: Fold (Term name uni fun ann) name
data SimplifyOpts name a
SimplifyOpts :: Int -> Int -> Bool -> InlineHints name a -> Bool -> SimplifyOpts name a
[_soMaxSimplifierIterations] :: SimplifyOpts name a -> Int
[_soMaxCseIterations] :: SimplifyOpts name a -> Int
[_soConservativeOpts] :: SimplifyOpts name a -> Bool
[_soInlineHints] :: SimplifyOpts name a -> InlineHints name a
[_soInlineConstants] :: SimplifyOpts name a -> Bool
soMaxSimplifierIterations :: forall name_ab06X a_ab06Y. Lens' (SimplifyOpts name_ab06X a_ab06Y) Int
soMaxCseIterations :: forall name_ab06X a_ab06Y. Lens' (SimplifyOpts name_ab06X a_ab06Y) Int
soInlineHints :: forall name_ab06X a_ab06Y name_ab09M a_ab09N. Lens (SimplifyOpts name_ab06X a_ab06Y) (SimplifyOpts name_ab09M a_ab09N) (InlineHints name_ab06X a_ab06Y) (InlineHints name_ab09M a_ab09N)
soConservativeOpts :: forall name_ab06X a_ab06Y. Lens' (SimplifyOpts name_ab06X a_ab06Y) Bool
soInlineConstants :: forall name_ab06X a_ab06Y. Lens' (SimplifyOpts name_ab06X a_ab06Y) Bool
defaultSimplifyOpts :: SimplifyOpts name a
simplifyTerm :: forall name uni fun m a. (Compiling m uni fun name a, MonadState (UPLCSimplifierTrace name uni fun a) m) => SimplifyOpts name a -> BuiltinSemanticsVariant fun -> Term name uni fun a -> m (Term name uni fun a)
simplifyProgram :: forall name uni fun m a. (Compiling m uni fun name a, MonadState (UPLCSimplifierTrace name uni fun a) m) => SimplifyOpts name a -> BuiltinSemanticsVariant fun -> Program name uni fun a -> m (Program name uni fun a)
newtype InlineHints name a
InlineHints :: (a -> name -> Bool) -> InlineHints name a
[shouldInline] :: InlineHints name a -> a -> name -> Bool

-- | The type of Untyped Plutus Core terms. Mirrors the type of Typed
--   Plutus Core terms except
--   
--   <ol>
--   <li>all types are removed</li>
--   <li><tt>IWrap</tt> and <tt>Unwrap</tt> are removed</li>
--   <li>type abstractions are replaced with <a>Delay</a></li>
--   <li>type instantiations are replaced with <a>Force</a></li>
--   </ol>
--   
--   The latter two are due to the fact that we don't have value
--   restriction in Typed Plutus Core and hence a computation can be stuck
--   expecting only a single type argument for the computation to become
--   unstuck. Therefore we can't just silently remove type abstractions and
--   instantiations and need to replace them with something else that also
--   blocks evaluation (in order for the semantics of an erased program to
--   match with the semantics of the original typed one). <a>Delay</a> and
--   <a>Force</a> serve exactly this purpose.
data Term name uni fun ann
Var :: !ann -> !name -> Term name uni fun ann
LamAbs :: !ann -> !name -> !Term name uni fun ann -> Term name uni fun ann
Apply :: !ann -> !Term name uni fun ann -> !Term name uni fun ann -> Term name uni fun ann
Force :: !ann -> !Term name uni fun ann -> Term name uni fun ann
Delay :: !ann -> !Term name uni fun ann -> Term name uni fun ann
Constant :: !ann -> !Some (ValueOf uni) -> Term name uni fun ann
Builtin :: !ann -> !fun -> Term name uni fun ann
Error :: !ann -> Term name uni fun ann
Constr :: !ann -> !Word64 -> ![Term name uni fun ann] -> Term name uni fun ann
Case :: !ann -> !Term name uni fun ann -> !Vector (Term name uni fun ann) -> Term name uni fun ann

-- | A <a>Program</a> is simply a <a>Term</a> coupled with a
--   <tt>Version</tt> of the core language.
data Program name uni fun ann
Program :: ann -> Version -> Term name uni fun ann -> Program name uni fun ann
[_progAnn] :: Program name uni fun ann -> ann
[_progVer] :: Program name uni fun ann -> Version
[_progTerm] :: Program name uni fun ann -> Term name uni fun ann

-- | Applies one program to another. Fails if the versions do not match and
--   tries to merge annotations.
applyProgram :: (MonadError ApplyProgramError m, Semigroup a) => Program name uni fun a -> Program name uni fun a -> m (Program name uni fun a)

-- | Parse and rewrite so that names are globally unique, not just unique
--   within their scope.
parseScoped :: (AsParserErrorBundle e, AsUniqueError e SrcSpan, MonadError e m, MonadQuote m) => Text -> m (Program Name DefaultUni DefaultFun SrcSpan)

-- | The universe used by default.
data DefaultUni a

-- | Default built-in functions.
--   
--   When updating these, make sure to add them to the protocol version
--   listing! See Note [New builtins/language versions and protocol
--   versions]
data DefaultFun

module PlutusCore.Compiler

-- | Compile a PLC term to UPLC, and optimize it.
compileTerm :: (Compiling m uni fun name a, MonadReader (CompilationOpts name fun a) m, MonadState (UPLCSimplifierTrace name uni fun a) m) => Term tyname name uni fun a -> m (Term name uni fun a)

-- | Compile a PLC program to UPLC, and optimize it.
compileProgram :: (Compiling m uni fun name a, MonadReader (CompilationOpts name fun a) m, MonadState (UPLCSimplifierTrace name uni fun a) m) => Program tyname name uni fun a -> m (Program name uni fun a)
runCompile :: CompilationOpts name fun a -> Compile m name uni fun a b -> m (b, UPLCSimplifierTrace name uni fun a)
evalCompile :: Functor m => CompilationOpts name fun a -> Compile m name uni fun a b -> m b
