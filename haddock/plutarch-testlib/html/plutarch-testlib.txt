-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package plutarch-testlib
@version 1.0.0


-- | Plutarch benchmarking tools
--   
--   Interface mirrors the one from <tt>tasty-bench</tt> but <a>bench</a>
--   instead of taking <tt>Benchmarkable</tt> takes <a>ClosedTerm</a>
--   
--   To compare benchmark run against baseline file you need to generate it
--   first with <tt>cabal run bench -- --csv baseline.csv</tt>. Then after
--   making modifications you can rerun the benchmarks to compare with
--   previous values with <tt>cabal run bench -- --baseline
--   baseline.csv</tt>. You can instruct benchmarks to fail if certain
--   values changed by too much using <tt>--fail-if-*</tt> flags. See
--   <tt>cabal run bench -- --help</tt> for all available flags. To
--   regenreate baseline file run with <tt>--csv</tt> flag again.
module Plutarch.Test.Bench

-- | @since WIP
data BenchConfig

-- | Compile with UPLC simplifier pass and no tracing
Optimizing :: BenchConfig

-- | Compile without UPLC simplifier and configurable tracing
NonOptimizing :: Config -> BenchConfig

-- | Use this instead of <a>defaultMain</a> from <tt>Test.Tasty</tt> to run
--   benchmarks to get formatted output
--   
--   @since WIP
defaultMain :: TestTree -> IO ()

-- | Create benchmark from Plutarch term without tracing and no UPLC
--   simplifier
--   
--   @since WIP
bench :: TestName -> ClosedTerm a -> TestTree

-- | Like <a>bench</a> but with customizable compilation config
--   
--   @since WIP
benchWithConfig :: TestName -> BenchConfig -> ClosedTerm a -> TestTree

-- | Compare benchmarks, reporting relative CPU, MEM, and size differences
--   
--   @since WIP
bcompare :: String -> TestTree -> TestTree

-- | Like <a>bcompare</a> but with customizable upper and lower bounds of
--   relative differences
--   
--   @since WIP
bcompareWithin :: (Double, Double) -> (Double, Double) -> (Double, Double) -> String -> TestTree -> TestTree

-- | @since WIP
data BaselinePath

-- | @since WIP
data CsvPath

-- | @since WIP
data FailIfMoreCpu

-- | @since WIP
data FailIfLessCpu

-- | @since WIP
data FailIfMoreMem

-- | @since WIP
data FailIfLessMem

-- | @since WIP
data FailIfBigger

-- | @since WIP
data FailIfSmaller

-- | @since WIP
consoleBenchReporter :: Ingredient

-- | @since WIP
csvReporter :: Ingredient
instance GHC.Real.Fractional Plutarch.Test.Bench.FailIfMoreCpu
instance GHC.Num.Num Plutarch.Test.Bench.FailIfMoreCpu
instance GHC.Read.Read Plutarch.Test.Bench.FailIfMoreCpu
instance GHC.Show.Show Plutarch.Test.Bench.FailIfMoreCpu
instance GHC.Classes.Ord Plutarch.Test.Bench.FailIfMoreCpu
instance GHC.Classes.Eq Plutarch.Test.Bench.FailIfMoreCpu
instance GHC.Real.Fractional Plutarch.Test.Bench.FailIfLessCpu
instance GHC.Num.Num Plutarch.Test.Bench.FailIfLessCpu
instance GHC.Read.Read Plutarch.Test.Bench.FailIfLessCpu
instance GHC.Show.Show Plutarch.Test.Bench.FailIfLessCpu
instance GHC.Classes.Ord Plutarch.Test.Bench.FailIfLessCpu
instance GHC.Classes.Eq Plutarch.Test.Bench.FailIfLessCpu
instance GHC.Real.Fractional Plutarch.Test.Bench.FailIfMoreMem
instance GHC.Num.Num Plutarch.Test.Bench.FailIfMoreMem
instance GHC.Read.Read Plutarch.Test.Bench.FailIfMoreMem
instance GHC.Show.Show Plutarch.Test.Bench.FailIfMoreMem
instance GHC.Classes.Ord Plutarch.Test.Bench.FailIfMoreMem
instance GHC.Classes.Eq Plutarch.Test.Bench.FailIfMoreMem
instance GHC.Real.Fractional Plutarch.Test.Bench.FailIfLessMem
instance GHC.Num.Num Plutarch.Test.Bench.FailIfLessMem
instance GHC.Read.Read Plutarch.Test.Bench.FailIfLessMem
instance GHC.Show.Show Plutarch.Test.Bench.FailIfLessMem
instance GHC.Classes.Ord Plutarch.Test.Bench.FailIfLessMem
instance GHC.Classes.Eq Plutarch.Test.Bench.FailIfLessMem
instance GHC.Real.Fractional Plutarch.Test.Bench.FailIfBigger
instance GHC.Num.Num Plutarch.Test.Bench.FailIfBigger
instance GHC.Read.Read Plutarch.Test.Bench.FailIfBigger
instance GHC.Show.Show Plutarch.Test.Bench.FailIfBigger
instance GHC.Classes.Ord Plutarch.Test.Bench.FailIfBigger
instance GHC.Classes.Eq Plutarch.Test.Bench.FailIfBigger
instance GHC.Real.Fractional Plutarch.Test.Bench.FailIfSmaller
instance GHC.Num.Num Plutarch.Test.Bench.FailIfSmaller
instance GHC.Read.Read Plutarch.Test.Bench.FailIfSmaller
instance GHC.Show.Show Plutarch.Test.Bench.FailIfSmaller
instance GHC.Classes.Ord Plutarch.Test.Bench.FailIfSmaller
instance GHC.Classes.Eq Plutarch.Test.Bench.FailIfSmaller
instance GHC.Classes.Ord Plutarch.Test.Bench.BaselinePath
instance GHC.Classes.Eq Plutarch.Test.Bench.BaselinePath
instance GHC.Classes.Ord Plutarch.Test.Bench.CsvPath
instance GHC.Classes.Eq Plutarch.Test.Bench.CsvPath
instance GHC.Read.Read Plutarch.Test.Bench.ExecutionBudget
instance GHC.Show.Show Plutarch.Test.Bench.ExecutionBudget
instance forall a. GHC.Read.Read a => GHC.Read.Read (Plutarch.Test.Bench.WithLoHi a)
instance forall a. GHC.Show.Show a => GHC.Show.Show (Plutarch.Test.Bench.WithLoHi a)
instance GHC.Base.Functor Plutarch.Test.Bench.Unique
instance forall a. GHC.Base.Semigroup (Plutarch.Test.Bench.Unique a)
instance forall a. GHC.Base.Monoid (Plutarch.Test.Bench.Unique a)
instance Test.Tasty.Core.IsTest Plutarch.Test.Bench.PBenchmarkable
instance Test.Tasty.Options.IsOption (GHC.Maybe.Maybe Plutarch.Test.Bench.CsvPath)
instance Test.Tasty.Options.IsOption (GHC.Maybe.Maybe Plutarch.Test.Bench.BaselinePath)
instance Test.Tasty.Options.IsOption Plutarch.Test.Bench.FailIfSmaller
instance Test.Tasty.Options.IsOption Plutarch.Test.Bench.FailIfBigger
instance Test.Tasty.Options.IsOption Plutarch.Test.Bench.FailIfLessMem
instance Test.Tasty.Options.IsOption Plutarch.Test.Bench.FailIfMoreMem
instance Test.Tasty.Options.IsOption Plutarch.Test.Bench.FailIfLessCpu
instance Test.Tasty.Options.IsOption Plutarch.Test.Bench.FailIfMoreCpu


-- | Utilities for golden testing
--   
--   To regenerate golden tests it is enough to remove <tt>./goldens</tt>
--   directory and rerun tests
module Plutarch.Test.Golden

-- | Opaque type representing tree of golden tests
--   
--   @since WIP
data GoldenTestTree

-- | Convert tree of golden tests into standard Tasty <a>TestTree</a>,
--   capturing results produced by nested golden tests
--   
--   @since WIP
plutarchGolden :: TestName -> FilePath -> [GoldenTestTree] -> TestTree

-- | Like <a>testGroup</a> but for golden tests
--   
--   Goldens in the group will be prefixed by the group name
--   
--   @since WIP
goldenGroup :: TestName -> [GoldenTestTree] -> GoldenTestTree

-- | Like <a>testEval</a> but will append to goldens created by enclosing
--   <a>plutarchGolden</a>
--   
--   @since WIP
goldenEval :: TestName -> ClosedTerm a -> GoldenTestTree

-- | Like <a>testEvalFail</a> but will append to goldens created by
--   enclosing <a>plutarchGolden</a>
--   
--   @since WIP
goldenEvalFail :: TestName -> ClosedTerm a -> GoldenTestTree
instance GHC.Show.Show Plutarch.Test.Golden.Benchmark
instance Data.Aeson.Types.ToJSON.ToJSON Plutarch.Test.Golden.PerfBenchmark


-- | Dummy types used in tests
module Plutarch.Test.SpecTypes

-- | Tuple of three elements of the same type
--   
--   @since WIP
data Triplet a
Triplet :: a -> a -> a -> Triplet a

-- | We can defined a data-type using PDataRecord, with labeled fields.
--   
--   With an appropriate instance of <tt>PIsDataRepr</tt>, we can
--   automatically derive <a>PDataFields</a>.
--   
--   @since WIP
newtype PTriplet (a :: S -> Type) (s :: S)
PTriplet :: Term s (PDataRecord '["x" ':= a, "y" ':= a, "z" ':= a]) -> PTriplet (a :: S -> Type) (s :: S)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (PlutusTx.IsData.Class.ToData (Plutarch.Internal.Lift.AsHaskell a), PlutusTx.IsData.Class.FromData (Plutarch.Internal.Lift.AsHaskell a)) => Plutarch.Internal.Lift.PLiftable (Plutarch.Test.SpecTypes.PTriplet a)
instance forall a. PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (Plutarch.Test.SpecTypes.Triplet a)
instance forall a. PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (Plutarch.Test.SpecTypes.Triplet a)
instance forall a. PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (Plutarch.Test.SpecTypes.Triplet a)
instance forall a. Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Plutarch.Test.SpecTypes.Triplet a)
instance forall a. GHC.Classes.Ord a => GHC.Classes.Ord (Plutarch.Test.SpecTypes.Triplet a)
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Plutarch.Test.SpecTypes.Triplet a)
instance forall a. GHC.Show.Show a => GHC.Show.Show (Plutarch.Test.SpecTypes.Triplet a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.Test.SpecTypes.PTriplet a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Ord.POrd a, Plutarch.Internal.IsData.PIsData a) => Plutarch.Internal.Ord.POrd (Plutarch.Test.SpecTypes.PTriplet a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Eq.PEq (Plutarch.Test.SpecTypes.PTriplet a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.IsData.PIsData (Plutarch.Test.SpecTypes.PTriplet a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Test.SpecTypes.PTriplet a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Test.SpecTypes.PTriplet a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Test.SpecTypes.PTriplet a)
instance forall a. Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Plutarch.Test.SpecTypes.Triplet a)


-- | Utilities for unit testing plutarch terms
module Plutarch.Test.Unit

-- | Assert that term failed to compile
--   
--   @since WIP
testCompileFail :: TestName -> ClosedTerm a -> TestTree

-- | Assert that term compiled and evaluated without errors
--   
--   @since WIP
testEval :: TestName -> ClosedTerm a -> TestTree

-- | Assert that term compiled correctly but evaluated with errors
--   
--   @since WIP
testEvalFail :: TestName -> ClosedTerm a -> TestTree

-- | Assert that term compiled and evaluated without errors and matches the
--   expected value note that comparison is done on AST level, not by
--   <a>Eq</a> or <a>PEq</a>
--   
--   @since WIP
testEvalEqual :: TestName -> ClosedTerm a -> ClosedTerm a -> TestTree

-- | Assert that term compiled (with specified tracing level and
--   <a>DetTracing</a>) and evaluated without errors produced traces that
--   match expected value. Note that this succeeds even if script evaluated
--   to error if traces still match
--   
--   @since WIP
testEvalEqualTraces :: TestName -> ClosedTerm a -> LogLevel -> [Text] -> TestTree

-- | @since WIP
data TermResult
FailedToCompile :: Text -> TermResult
FailedToEvaluate :: EvalError -> [Text] -> TermResult
Evaluated :: String -> [Text] -> TermResult

-- | @since WIP
evalTermResult :: Config -> ClosedTerm a -> TermResult

module Plutarch.Test.Utils

-- | Decrease number of quickcheck tests by specified factor
fewerTests :: QuickCheckTests -> QuickCheckTests -> QuickCheckTests
prettyShow :: forall (a :: Type). Pretty a => a -> String
prettyEquals :: (Eq a, Pretty a) => a -> a -> Property
typeName :: forall k (a :: k). Typeable a => String
instanceOfType :: forall k (a :: k). Typeable a => String -> String
typeName' :: Bool -> TypeRep k -> String

-- | @since WIP
precompileTerm :: forall (p :: S -> Type). ClosedTerm p -> ClosedTerm p

module Plutarch.Test.QuickCheck

-- | Like <a>testEval</a> but generate terms
--   
--   @since WIP
propEval :: (Arbitrary a, Show a) => TestName -> (a -> ClosedTerm b) -> TestTree

-- | Like <a>testEvalFail</a> but generate terms
--   
--   @since WIP
propEvalFail :: (Arbitrary a, Show a) => TestName -> (a -> ClosedTerm b) -> TestTree

-- | Like <a>testCompileFail</a> but generate terms
--   
--   @since WIP
propCompileFail :: (Arbitrary a, Show a) => TestName -> (a -> ClosedTerm b) -> TestTree

-- | Like <a>testEvalEqual</a> but generate terms
--   
--   @since WIP
propEvalEqual :: (Arbitrary a, Show a) => TestName -> (a -> ClosedTerm b) -> (a -> ClosedTerm b) -> TestTree

-- | @since WIP
checkHaskellEquivalent :: forall (plutarchInput :: S -> Type) (plutarchOutput :: S -> Type). (PLiftable plutarchInput, PLiftable plutarchOutput, Pretty (AsHaskell plutarchInput), Arbitrary (AsHaskell plutarchInput), Pretty (AsHaskell plutarchOutput), Eq (AsHaskell plutarchOutput)) => (AsHaskell plutarchInput -> AsHaskell plutarchOutput) -> ClosedTerm (plutarchInput :--> plutarchOutput) -> Property

-- | @since WIP
checkHaskellEquivalent2 :: forall (plutarchInput1 :: S -> Type) (plutarchInput2 :: S -> Type) (plutarchOutput :: S -> Type). (PLiftable plutarchInput1, Pretty (AsHaskell plutarchInput1), Arbitrary (AsHaskell plutarchInput1), PLiftable plutarchInput2, Pretty (AsHaskell plutarchInput2), Arbitrary (AsHaskell plutarchInput2), PLiftable plutarchOutput, Pretty (AsHaskell plutarchOutput), Eq (AsHaskell plutarchOutput)) => (AsHaskell plutarchInput1 -> AsHaskell plutarchInput2 -> AsHaskell plutarchOutput) -> ClosedTerm (plutarchInput1 :--> (plutarchInput2 :--> plutarchOutput)) -> Property
instance forall a. Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Test.QuickCheck.Modifiers.Positive a)
instance forall a. Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Test.QuickCheck.Modifiers.Negative a)
instance forall a. Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Test.QuickCheck.Modifiers.NonZero a)
instance forall a. Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Test.QuickCheck.Modifiers.NonNegative a)
instance forall a. Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Test.QuickCheck.Modifiers.NonPositive a)

module Plutarch.Test.Laws

-- | Like <a>checkLedgerProperties</a> but specialized to <tt>PValue</tt>
--   
--   This is an ugly kludge because PValue doesn't have a direct PData
--   conversion, and bringing one in would break too much other stuff to be
--   worth it.
--   
--   @since WIP
checkLedgerPropertiesValue :: TestTree

-- | Like <a>checkLedgerProperties</a> but specialized to <tt>PMap</tt>
--   
--   Same as above
--   
--   @since WIP
checkLedgerPropertiesAssocMap :: TestTree

-- | @since WIP
checkLedgerProperties :: forall (a :: S -> Type). (Typeable a, PLiftable a, Eq (AsHaskell a), PIsData a, ToData (AsHaskell a), Arbitrary (AsHaskell a), Pretty (AsHaskell a), Show (AsHaskell a)) => TestTree

-- | @since WIP
checkLedgerPropertiesPCountable :: forall (a :: S -> Type). (Typeable a, PCountable a, Arbitrary (AsHaskell a), Pretty (AsHaskell a), Eq (AsHaskell a), Show (AsHaskell a), PLiftable a) => TestTree

-- | @since WIP
checkLedgerPropertiesPEnumerable :: forall (a :: S -> Type). (Typeable a, PEnumerable a, Arbitrary (AsHaskell a), Pretty (AsHaskell a), Eq (AsHaskell a), PLiftable a) => TestTree

-- | @since WIP
checkHaskellOrdEquivalent :: forall (plutarchInput :: S -> Type). (PLiftable plutarchInput, Pretty (AsHaskell plutarchInput), Arbitrary (AsHaskell plutarchInput), Typeable (AsHaskell plutarchInput), Ord (AsHaskell plutarchInput), Typeable plutarchInput, POrd plutarchInput) => TestTree
checkHaskellNumEquivalent :: forall (plutarchInput :: S -> Type). (PLiftable plutarchInput, Pretty (AsHaskell plutarchInput), Arbitrary (AsHaskell plutarchInput), Eq (AsHaskell plutarchInput), Typeable (AsHaskell plutarchInput), Num (AsHaskell plutarchInput), Typeable plutarchInput, PIntegralDomain plutarchInput) => TestTree

-- | Verifies that the specified Plutarch and Haskell types satisfy the
--   laws of <a>PLiftable</a>.
--   
--   @since WIP
checkPLiftableLaws :: forall (a :: S -> Type). (Arbitrary (AsHaskell a), Pretty (AsHaskell a), Eq (AsHaskell a), PLiftable a, Show (AsHaskell a)) => [TestTree]

-- | Verifies that the specified Plutarch type satisfies the <a>POrd</a>
--   laws for mandatory methods.
--   
--   @since WIP
checkPOrdLaws :: forall (a :: S -> Type). (Arbitrary (AsHaskell a), Pretty (AsHaskell a), PLiftable a, POrd a) => [TestTree]

-- | Verifies that the specified Plutarch type satisfies the
--   <a>PAdditiveSemigroup</a> laws for mandatory methods.
--   
--   @since WIP
checkPAdditiveSemigroupLaws :: forall (a :: S -> Type). (Arbitrary (AsHaskell a), Pretty (AsHaskell a), PAdditiveSemigroup a, PEq a, PLiftable a) => TestTree

-- | Verifies that the specified Plutarch type satisfies the
--   <a>PAdditiveMonoid</a> laws for mandatory methods.
--   
--   @since WIP
checkPAdditiveMonoidLaws :: forall (a :: S -> Type). (Arbitrary (AsHaskell a), Pretty (AsHaskell a), PAdditiveMonoid a, PEq a, PLiftable a) => TestTree

-- | Verifies that the specified Plutarch type satisfies the
--   <a>PAdditiveGroup</a> laws for mandatory methods.
--   
--   @since WIP
checkPAdditiveGroupLaws :: forall (a :: S -> Type). (Arbitrary (AsHaskell a), Pretty (AsHaskell a), PAdditiveGroup a, PEq a, PLiftable a) => TestTree

-- | Verifies that the specified Plutarch type satisfies the
--   <a>PSemigroup</a> laws for mandatory methods.
--   
--   @since WIP
checkPSemigroupLaws :: forall (a :: S -> Type). (Arbitrary (AsHaskell a), Pretty (AsHaskell a), PSemigroup a, PEq a, PLiftable a) => TestTree

-- | Verifies that the specified Plutarch type satisfies the <a>PMonoid</a>
--   laws for mandatory methods.
--   
--   @since WIP
checkPMonoidLaws :: forall (a :: S -> Type). (Arbitrary (AsHaskell a), Pretty (AsHaskell a), PMonoid a, PEq a, PLiftable a) => TestTree
instance forall a. GHC.Show.Show a => GHC.Show.Show (Plutarch.Test.Laws.Triplet a)
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Plutarch.Test.Laws.Triplet a)
instance forall a. Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Plutarch.Test.Laws.Triplet a)
instance Test.QuickCheck.Arbitrary.Arbitrary1 Plutarch.Test.Laws.Triplet
instance forall a. Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Plutarch.Test.Laws.Triplet a)
