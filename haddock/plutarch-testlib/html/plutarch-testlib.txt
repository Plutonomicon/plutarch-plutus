-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package plutarch-testlib
@version 1.0.0


-- | Plutarch benchmarking tools
--   
--   Interface mirrors the one from <tt>tasty-bench</tt> but <a>bench</a>
--   instead of taking <tt>Benchmarkable</tt> takes <a>ClosedTerm</a>
--   
--   To compare benchmark run against baseline file you need to generate it
--   first with <tt>cabal run bench -- --csv baseline.csv</tt>. Then after
--   making modifications you can rerun the benchmarks to compare with
--   previous values with <tt>cabal run bench -- --baseline
--   baseline.csv</tt>. You can instruct benchmarks to fail if certain
--   values changed by too much using <tt>--fail-if-*</tt> flags. See
--   <tt>cabal run bench -- --help</tt> for all available flags. To
--   regenreate baseline file run with <tt>--csv</tt> flag again.
module Plutarch.Test.Bench

data BenchConfig

-- | Compile with UPLC simplifier pass and no tracing
Optimizing :: BenchConfig

-- | Compile without UPLC simplifier and configurable tracing
NonOptimizing :: Config -> BenchConfig

-- | Use this instead of <a>defaultMain</a> from <tt>Test.Tasty</tt> to run
--   benchmarks to get formatted output
defaultMain :: TestTree -> IO ()

-- | Create benchmark from Plutarch term without tracing and no UPLC
--   simplifier
bench :: TestName -> ClosedTerm a -> TestTree

-- | Like <a>bench</a> but with customizable compilation config
benchWithConfig :: TestName -> BenchConfig -> ClosedTerm a -> TestTree

-- | Compare benchmarks, reporting relative CPU, MEM, and size differences
bcompare :: String -> TestTree -> TestTree

-- | Like <a>bcompare</a> but with customizable upper and lower bounds of
--   relative differences
bcompareWithin :: (Double, Double) -> (Double, Double) -> (Double, Double) -> String -> TestTree -> TestTree

data BaselinePath

data CsvPath

data FailIfMoreCpu

data FailIfLessCpu

data FailIfMoreMem

data FailIfLessMem

data FailIfBigger

data FailIfSmaller

consoleBenchReporter :: Ingredient

csvReporter :: Ingredient
instance GHC.Real.Fractional Plutarch.Test.Bench.FailIfMoreCpu
instance GHC.Num.Num Plutarch.Test.Bench.FailIfMoreCpu
instance GHC.Read.Read Plutarch.Test.Bench.FailIfMoreCpu
instance GHC.Show.Show Plutarch.Test.Bench.FailIfMoreCpu
instance GHC.Classes.Ord Plutarch.Test.Bench.FailIfMoreCpu
instance GHC.Classes.Eq Plutarch.Test.Bench.FailIfMoreCpu
instance GHC.Real.Fractional Plutarch.Test.Bench.FailIfLessCpu
instance GHC.Num.Num Plutarch.Test.Bench.FailIfLessCpu
instance GHC.Read.Read Plutarch.Test.Bench.FailIfLessCpu
instance GHC.Show.Show Plutarch.Test.Bench.FailIfLessCpu
instance GHC.Classes.Ord Plutarch.Test.Bench.FailIfLessCpu
instance GHC.Classes.Eq Plutarch.Test.Bench.FailIfLessCpu
instance GHC.Real.Fractional Plutarch.Test.Bench.FailIfMoreMem
instance GHC.Num.Num Plutarch.Test.Bench.FailIfMoreMem
instance GHC.Read.Read Plutarch.Test.Bench.FailIfMoreMem
instance GHC.Show.Show Plutarch.Test.Bench.FailIfMoreMem
instance GHC.Classes.Ord Plutarch.Test.Bench.FailIfMoreMem
instance GHC.Classes.Eq Plutarch.Test.Bench.FailIfMoreMem
instance GHC.Real.Fractional Plutarch.Test.Bench.FailIfLessMem
instance GHC.Num.Num Plutarch.Test.Bench.FailIfLessMem
instance GHC.Read.Read Plutarch.Test.Bench.FailIfLessMem
instance GHC.Show.Show Plutarch.Test.Bench.FailIfLessMem
instance GHC.Classes.Ord Plutarch.Test.Bench.FailIfLessMem
instance GHC.Classes.Eq Plutarch.Test.Bench.FailIfLessMem
instance GHC.Real.Fractional Plutarch.Test.Bench.FailIfBigger
instance GHC.Num.Num Plutarch.Test.Bench.FailIfBigger
instance GHC.Read.Read Plutarch.Test.Bench.FailIfBigger
instance GHC.Show.Show Plutarch.Test.Bench.FailIfBigger
instance GHC.Classes.Ord Plutarch.Test.Bench.FailIfBigger
instance GHC.Classes.Eq Plutarch.Test.Bench.FailIfBigger
instance GHC.Real.Fractional Plutarch.Test.Bench.FailIfSmaller
instance GHC.Num.Num Plutarch.Test.Bench.FailIfSmaller
instance GHC.Read.Read Plutarch.Test.Bench.FailIfSmaller
instance GHC.Show.Show Plutarch.Test.Bench.FailIfSmaller
instance GHC.Classes.Ord Plutarch.Test.Bench.FailIfSmaller
instance GHC.Classes.Eq Plutarch.Test.Bench.FailIfSmaller
instance GHC.Classes.Ord Plutarch.Test.Bench.BaselinePath
instance GHC.Classes.Eq Plutarch.Test.Bench.BaselinePath
instance GHC.Classes.Ord Plutarch.Test.Bench.CsvPath
instance GHC.Classes.Eq Plutarch.Test.Bench.CsvPath
instance GHC.Read.Read Plutarch.Test.Bench.ExecutionBudget
instance GHC.Show.Show Plutarch.Test.Bench.ExecutionBudget
instance forall a. GHC.Read.Read a => GHC.Read.Read (Plutarch.Test.Bench.WithLoHi a)
instance forall a. GHC.Show.Show a => GHC.Show.Show (Plutarch.Test.Bench.WithLoHi a)
instance GHC.Base.Functor Plutarch.Test.Bench.Unique
instance forall a. GHC.Base.Semigroup (Plutarch.Test.Bench.Unique a)
instance forall a. GHC.Base.Monoid (Plutarch.Test.Bench.Unique a)
instance Test.Tasty.Core.IsTest Plutarch.Test.Bench.PBenchmarkable
instance Test.Tasty.Options.IsOption (GHC.Maybe.Maybe Plutarch.Test.Bench.CsvPath)
instance Test.Tasty.Options.IsOption (GHC.Maybe.Maybe Plutarch.Test.Bench.BaselinePath)
instance Test.Tasty.Options.IsOption Plutarch.Test.Bench.FailIfSmaller
instance Test.Tasty.Options.IsOption Plutarch.Test.Bench.FailIfBigger
instance Test.Tasty.Options.IsOption Plutarch.Test.Bench.FailIfLessMem
instance Test.Tasty.Options.IsOption Plutarch.Test.Bench.FailIfMoreMem
instance Test.Tasty.Options.IsOption Plutarch.Test.Bench.FailIfLessCpu
instance Test.Tasty.Options.IsOption Plutarch.Test.Bench.FailIfMoreCpu


-- | Utilities for golden testing
--   
--   To regenerate golden tests it is enough to remove <tt>./goldens</tt>
--   directory and rerun tests
module Plutarch.Test.Golden

-- | Opaque type representing tree of golden tests
data GoldenTestTree

-- | Convert tree of golden tests into standard Tasty <a>TestTree</a>,
--   capturing results produced by nested golden tests
plutarchGolden :: TestName -> FilePath -> [GoldenTestTree] -> TestTree

-- | Like <a>testGroup</a> but for golden tests
--   
--   Goldens in the group will be prefixed by the group name
goldenGroup :: TestName -> [GoldenTestTree] -> GoldenTestTree

-- | Like <a>testEval</a> but will append to goldens created by enclosing
--   <a>plutarchGolden</a>
goldenEval :: TestName -> ClosedTerm a -> GoldenTestTree

-- | Like <a>testEvalFail</a> but will append to goldens created by
--   enclosing <a>plutarchGolden</a>
goldenEvalFail :: TestName -> ClosedTerm a -> GoldenTestTree
instance GHC.Show.Show Plutarch.Test.Golden.Benchmark
instance Data.Aeson.Types.ToJSON.ToJSON Plutarch.Test.Golden.PerfBenchmark


-- | Dummy types used in tests
module Plutarch.Test.SpecTypes

-- | Tuple of three elements of the same type
data Triplet a
Triplet :: a -> a -> a -> Triplet a

-- | We can defined a data-type using PDataRecord, with labeled fields.
--   
--   With an appropriate instance of <tt>PIsDataRepr</tt>, we can
--   automatically derive <a>PDataFields</a>.
newtype PTriplet (a :: S -> Type) (s :: S)
PTriplet :: Term s (PDataRecord '["x" ':= a, "y" ':= a, "z" ':= a]) -> PTriplet (a :: S -> Type) (s :: S)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (PlutusTx.IsData.Class.ToData (Plutarch.Internal.Lift.AsHaskell a), PlutusTx.IsData.Class.FromData (Plutarch.Internal.Lift.AsHaskell a)) => Plutarch.Internal.Lift.PLiftable (Plutarch.Test.SpecTypes.PTriplet a)
instance forall a. PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (Plutarch.Test.SpecTypes.Triplet a)
instance forall a. PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (Plutarch.Test.SpecTypes.Triplet a)
instance forall a. PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (Plutarch.Test.SpecTypes.Triplet a)
instance forall a. Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Plutarch.Test.SpecTypes.Triplet a)
instance forall a. GHC.Classes.Ord a => GHC.Classes.Ord (Plutarch.Test.SpecTypes.Triplet a)
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Plutarch.Test.SpecTypes.Triplet a)
instance forall a. GHC.Show.Show a => GHC.Show.Show (Plutarch.Test.SpecTypes.Triplet a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.Test.SpecTypes.PTriplet a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). (Plutarch.Internal.Ord.POrd a, Plutarch.Internal.IsData.PIsData a) => Plutarch.Internal.Ord.POrd (Plutarch.Test.SpecTypes.PTriplet a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.Eq.PEq (Plutarch.Test.SpecTypes.PTriplet a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.IsData.PIsData (Plutarch.Test.SpecTypes.PTriplet a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Test.SpecTypes.PTriplet a)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type) (s :: Plutarch.Internal.Term.S). GHC.Generics.Generic (Plutarch.Test.SpecTypes.PTriplet a s)
instance forall (a :: Plutarch.Internal.Term.S -> GHC.Types.Type). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Test.SpecTypes.PTriplet a)
instance forall a. Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Plutarch.Test.SpecTypes.Triplet a)


-- | Utilities for unit testing plutarch terms
module Plutarch.Test.Unit

-- | Assert that term failed to compile
testCompileFail :: TestName -> ClosedTerm a -> TestTree

-- | Assert that term compiled and evaluated without errors
testEval :: TestName -> ClosedTerm a -> TestTree

-- | Assert that term compiled correctly but evaluated with errors
testEvalFail :: TestName -> ClosedTerm a -> TestTree

-- | Assert that term compiled and evaluated without errors and matches the
--   expected value note that comparison is done on AST level, not by
--   <a>Eq</a> or <a>PEq</a>
testEvalEqual :: TestName -> ClosedTerm a -> ClosedTerm a -> TestTree

-- | Assert that term compiled (with specified tracing level and
--   <a>DetTracing</a>) and evaluated without errors produced traces that
--   match expected value. Note that this succeeds even if script evaluated
--   to error if traces still match
testEvalEqualTraces :: TestName -> ClosedTerm a -> LogLevel -> [Text] -> TestTree

data TermResult
FailedToCompile :: Text -> TermResult
FailedToEvaluate :: EvalError -> [Text] -> TermResult
Evaluated :: String -> [Text] -> TermResult

evalTermResult :: Config -> ClosedTerm a -> TermResult

module Plutarch.Test.Utils

-- | Decrease number of quickcheck tests by specified factor
fewerTests :: QuickCheckTests -> QuickCheckTests -> QuickCheckTests
prettyShow :: forall (a :: Type). Pretty a => a -> String
prettyEquals :: (Eq a, Pretty a) => a -> a -> Property
typeName :: forall k (a :: k). Typeable a => String
instanceOfType :: forall k (a :: k). Typeable a => String -> String
typeName' :: Bool -> TypeRep k -> String

precompileTerm :: forall (p :: S -> Type). ClosedTerm p -> ClosedTerm p

module Plutarch.Test.QuickCheck

-- | Like <a>testEval</a> but generate terms
propEval :: (Arbitrary a, Show a) => TestName -> (a -> ClosedTerm b) -> TestTree

-- | Like <a>testEvalFail</a> but generate terms
propEvalFail :: (Arbitrary a, Show a) => TestName -> (a -> ClosedTerm b) -> TestTree

-- | Like <a>testCompileFail</a> but generate terms
propCompileFail :: (Arbitrary a, Show a) => TestName -> (a -> ClosedTerm b) -> TestTree

-- | Like <a>testEvalEqual</a> but generate terms
propEvalEqual :: (Arbitrary a, Show a) => TestName -> (a -> ClosedTerm b) -> (a -> ClosedTerm b) -> TestTree

checkHaskellEquivalent :: forall (plutarchInput :: S -> Type) (plutarchOutput :: S -> Type). (PLiftable plutarchInput, PLiftable plutarchOutput, Pretty (AsHaskell plutarchInput), Arbitrary (AsHaskell plutarchInput), Pretty (AsHaskell plutarchOutput), Eq (AsHaskell plutarchOutput)) => (AsHaskell plutarchInput -> AsHaskell plutarchOutput) -> ClosedTerm (plutarchInput :--> plutarchOutput) -> Property

checkHaskellEquivalent2 :: forall (plutarchInput1 :: S -> Type) (plutarchInput2 :: S -> Type) (plutarchOutput :: S -> Type). (PLiftable plutarchInput1, Pretty (AsHaskell plutarchInput1), Arbitrary (AsHaskell plutarchInput1), PLiftable plutarchInput2, Pretty (AsHaskell plutarchInput2), Arbitrary (AsHaskell plutarchInput2), PLiftable plutarchOutput, Pretty (AsHaskell plutarchOutput), Eq (AsHaskell plutarchOutput)) => (AsHaskell plutarchInput1 -> AsHaskell plutarchInput2 -> AsHaskell plutarchOutput) -> ClosedTerm (plutarchInput1 :--> (plutarchInput2 :--> plutarchOutput)) -> Property
instance forall a. Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Test.QuickCheck.Modifiers.Positive a)
instance forall a. Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Test.QuickCheck.Modifiers.Negative a)
instance forall a. Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Test.QuickCheck.Modifiers.NonZero a)
instance forall a. Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Test.QuickCheck.Modifiers.NonNegative a)
instance forall a. Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Test.QuickCheck.Modifiers.NonPositive a)

module Plutarch.Test.Laws

-- | Like <a>checkLedgerProperties</a> but specialized to <tt>PValue</tt>
--   
--   This is an ugly kludge because PValue doesn't have a direct PData
--   conversion, and bringing one in would break too much other stuff to be
--   worth it.
checkLedgerPropertiesValue :: TestTree

-- | Like <a>checkLedgerProperties</a> but specialized to <tt>PMap</tt>
--   
--   Same as above
checkLedgerPropertiesAssocMap :: TestTree

checkLedgerProperties :: forall (a :: S -> Type). (Typeable a, PLiftable a, Eq (AsHaskell a), PIsData a, ToData (AsHaskell a), Arbitrary (AsHaskell a), Pretty (AsHaskell a), Show (AsHaskell a)) => TestTree

checkLedgerPropertiesPCountable :: forall (a :: S -> Type). (Typeable a, PCountable a, Arbitrary (AsHaskell a), Pretty (AsHaskell a), Eq (AsHaskell a), Show (AsHaskell a), PLiftable a) => TestTree

checkLedgerPropertiesPEnumerable :: forall (a :: S -> Type). (Typeable a, PEnumerable a, Arbitrary (AsHaskell a), Pretty (AsHaskell a), Eq (AsHaskell a), PLiftable a) => TestTree

checkHaskellOrdEquivalent :: forall (plutarchInput :: S -> Type). (PLiftable plutarchInput, Pretty (AsHaskell plutarchInput), Arbitrary (AsHaskell plutarchInput), Typeable (AsHaskell plutarchInput), Ord (AsHaskell plutarchInput), Typeable plutarchInput, POrd plutarchInput) => TestTree
checkHaskellNumEquivalent :: forall (plutarchInput :: S -> Type). (PLiftable plutarchInput, Pretty (AsHaskell plutarchInput), Arbitrary (AsHaskell plutarchInput), Eq (AsHaskell plutarchInput), Typeable (AsHaskell plutarchInput), Num (AsHaskell plutarchInput), Typeable plutarchInput, PIntegralDomain plutarchInput) => TestTree

-- | Verifies that the specified Plutarch and Haskell types satisfy the
--   laws of <a>PLiftable</a>.
checkPLiftableLaws :: forall (a :: S -> Type). (Arbitrary (AsHaskell a), Pretty (AsHaskell a), Eq (AsHaskell a), PLiftable a, Show (AsHaskell a)) => [TestTree]

-- | Verifies that the specified Plutarch type satisfies the <a>POrd</a>
--   laws for mandatory methods.
checkPOrdLaws :: forall (a :: S -> Type). (Arbitrary (AsHaskell a), Pretty (AsHaskell a), PLiftable a, POrd a) => [TestTree]

-- | Verifies that the specified Plutarch type satisfies the
--   <a>PAdditiveSemigroup</a> laws for mandatory methods.
checkPAdditiveSemigroupLaws :: forall (a :: S -> Type). (Arbitrary (AsHaskell a), Pretty (AsHaskell a), PAdditiveSemigroup a, PEq a, PLiftable a) => TestTree

-- | Verifies that the specified Plutarch type satisfies the
--   <a>PAdditiveMonoid</a> laws for mandatory methods.
checkPAdditiveMonoidLaws :: forall (a :: S -> Type). (Arbitrary (AsHaskell a), Pretty (AsHaskell a), PAdditiveMonoid a, PEq a, PLiftable a) => TestTree

-- | Verifies that the specified Plutarch type satisfies the
--   <a>PAdditiveGroup</a> laws for mandatory methods.
checkPAdditiveGroupLaws :: forall (a :: S -> Type). (Arbitrary (AsHaskell a), Pretty (AsHaskell a), PAdditiveGroup a, PEq a, PLiftable a) => TestTree

-- | Verifies that the specified Plutarch type satisfies the
--   <a>PSemigroup</a> laws for mandatory methods.
checkPSemigroupLaws :: forall (a :: S -> Type). (Arbitrary (AsHaskell a), Pretty (AsHaskell a), PSemigroup a, PEq a, PLiftable a) => TestTree

-- | Verifies that the specified Plutarch type satisfies the <a>PMonoid</a>
--   laws for mandatory methods.
checkPMonoidLaws :: forall (a :: S -> Type). (Arbitrary (AsHaskell a), Pretty (AsHaskell a), PMonoid a, PEq a, PLiftable a) => TestTree
instance forall a. GHC.Show.Show a => GHC.Show.Show (Plutarch.Test.Laws.Triplet a)
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Plutarch.Test.Laws.Triplet a)
instance forall a. Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Plutarch.Test.Laws.Triplet a)
instance Test.QuickCheck.Arbitrary.Arbitrary1 Plutarch.Test.Laws.Triplet
instance forall a. Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Plutarch.Test.Laws.Triplet a)
